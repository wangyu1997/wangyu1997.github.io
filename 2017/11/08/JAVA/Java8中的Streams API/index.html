<!DOCTYPE html>
<html lang="zh">
    <link rel="stylesheet" href="/css iconfont.css"></%->
<head>
    <!--
        © Material Theme
        https://github.com/viosey/hexo-theme-material
        Version: 1.3.3 -->

    <!-- Title -->
    
    <title>
        
            Java8中的streams API详解 | 
        
        人不如故
    </title>

    <!-- Meta & Info -->
    <meta charset="utf-8">

    <!-- dns prefetch -->
    <meta http-equiv="x-dns-prefetch-control" content="on">
    
    
    
    
        <link rel="dns-prefetch" href="https://hm.baidu.com"/>
    
    
        <link rel="dns-prefetch" href="https://www.google-analytics.com"/>
    
    
        <link rel="dns-prefetch" href="https://busuanzi.ibruce.info"/>
    

    <meta http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#000">
    <meta name="author" content="人不如故">
    <meta name="description" content="世间一场大梦，人生几度秋凉。">
    <meta name="keywords" content="null,java8,lambda,steams">

    <!-- Favicons -->
    <link rel="icon shortcut" type="image/ico" href="/img/favicon.png">
    <link rel="icon" sizes="192x192" href="/img/favicon.png">
    <link rel="apple-touch-icon" href="/img/favicon.png">

    <!--iOS -->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-title" content="Title">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="480">

    <!-- Add to homescreen for Chrome on Android -->
    <meta name="mobile-web-app-capable" content="yes">

    <!-- Add to homescreen for Safari on iOS -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="人不如故">

    <!-- The Open Graph protocol -->
    <meta property="og:url" content="https://wangyu1997.github.io">
    <meta property="og:type" content="blog">
    <meta property="og:title" content="Java8中的streams API详解 | 人不如故">
    <meta property="og:description" content="世间一场大梦，人生几度秋凉。">
    <meta property="og:article:tag" content="java8"> <meta property="og:article:tag" content="lambda"> <meta property="og:article:tag" content="steams"> 

    <!--[if lte IE 9]>
        <link rel="stylesheet" href="/css/ie-blocker.css">

        
            <script src="/js/ie-blocker.zhCN.js"></script>
        
    <![endif]-->
    <!-- Import CSS & jQuery -->
    
        <link rel="stylesheet" href="/css/material.min.css">
        <link rel="stylesheet" href="/css/style.min.css">
        <!-- Config CSS -->


<!-- Other Styles -->
<style>
  body, html {
    font-family: Roboto, "Helvetica Neue", Helvetica, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", "微软雅黑", Arial, sans-serif;
  }

  a {
    color: #000;
  }

  .mdl-card__media,
  #search-label,
  #search-form-label:after,
  #scheme-Paradox .hot_tags-count,
  #scheme-Paradox .sidebar_archives-count,
  #scheme-Paradox .sidebar-colored .sidebar-header,
  #scheme-Paradox .sidebar-colored .sidebar-badge{
    background-color: #000 !important;
  }

  /* Sidebar User Drop Down Menu Text Color */
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:hover,
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:focus {
    color: #000 !important;
  }

  #post_entry-right-info,
  .sidebar-colored .sidebar-nav li:hover > a,
  .sidebar-colored .sidebar-nav li:hover > a i,
  .sidebar-colored .sidebar-nav li > a:hover,
  .sidebar-colored .sidebar-nav li > a:hover i,
  .sidebar-colored .sidebar-nav li > a:focus i,
  .sidebar-colored .sidebar-nav > .open > a,
  .sidebar-colored .sidebar-nav > .open > a:hover,
  .sidebar-colored .sidebar-nav > .open > a:focus,
  #ds-reset #ds-ctx .ds-ctx-entry .ds-ctx-head a {
    color: #000 !important;
  }

  .toTop {
    background: #000 !important;
  }

  .material-layout .material-post>.material-nav,
  .material-layout .material-index>.material-nav,
  .material-nav a {
    color: #000;
  }

  #scheme-Paradox .MD-burger-layer {
    background-color: #000;
  }

  #scheme-Paradox #post-toc-trigger-btn {
    color: #000;
  }

  .post-toc a:hover {
    color: #000;
    text-decoration: underline;
  }

</style>


<!-- Theme Background Related-->

    <style>
      body{
        background-image: url(/img/bg.jpg);
      }
    </style>




<!-- Fade Effect -->

    <style>
      .fade {
        transition: all 800ms linear;
        -webkit-transform: translate3d(0,0,0);
        -moz-transform: translate3d(0,0,0);
        -ms-transform: translate3d(0,0,0);
        -o-transform: translate3d(0,0,0);
        transform: translate3d(0,0,0);
        opacity: 1;
      }

      .fade.out{
        opacity: 0;
      }
    </style>


        <script src="/js/jquery.min.js"></script>
        <script src="/js/queue.js"></script>
    

    <!-- UC Browser Compatible -->
    <script>
        var agent = navigator.userAgent.toLowerCase();
        if(agent.indexOf('ucbrowser')>0) {
            document.write("<link rel=\"stylesheet\" href=\"/css/uc.css\">");
            alert('由于 UC 浏览器使用极旧的内核，而本网站使用了一些新的特性。\n为了您能更好的浏览，推荐使用 Chrome 或 Firefox 浏览器。');
        }
    </script>

    
    <!-- Baidu Analytics -->
    <script>
        var _hmt = _hmt || [];
        (function() {var hm = document.createElement('script');
        hm.src = 'https://hm.baidu.com/hm.js?0c1235d6c5795e257894fa96152e0154';
        var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(hm, s);
        })();
    </script>
    

    
    <!-- Google Analytics -->
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-99567775-1', 'auto');ga('send', 'pageview');
    </script>
    


    <!-- Bing Background -->
    

    <!-- Custom Head -->
    
<link rel="stylesheet" href="/css/prism-dark.css" type="text/css"></head>


    
        <body id="scheme-Paradox" class="lazy">
            <div class="material-layout  mdl-js-layout has-drawer is-upgraded">
                

                <!-- Main Container -->
                <main class="material-layout__content" id="main">

                    <!-- Top Anchor -->
                    <div id="top">
                        <!---->
                    </div>

                    
                        <!-- Hamburger Button -->
                        <button class="MD-burger-icon sidebar-toggle">
                            <span class="MD-burger-layer"></span>
                        </button>
                    

                    <!-- Post TOC -->

    
    <!-- Back Button -->
    <!--
    <div class="material-back" id="backhome-div" tabindex="0">
        <a class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon"
           href="#" onclick="window.history.back();return false;"
           target="_self"
           role="button"
           data-upgraded=",MaterialButton,MaterialRipple">
            <i class="material-icons" role="presentation">arrow_back</i>
            <span class="mdl-button__ripple-container">
                <span class="mdl-ripple"></span>
            </span>
        </a>
    </div>
    -->

    <!-- Left aligned menu below button -->
    <button id="post-toc-trigger-btn"
        class="mdl-button mdl-js-button mdl-button--icon">
        <i class="material-icons">format_list_numbered</i>
    </button>

    <ul class="post-toc-wrap mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect" for="post-toc-trigger-btn" style="max-height:80vh; overflow-y:scroll;">
        <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#为什么需要-Stream"><span class="post-toc-number">1.</span> <span class="post-toc-text">为什么需要 Stream</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#什么是聚合操作"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">什么是聚合操作</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#清单-1-Java-7-的排序、取值实现"><span class="post-toc-number">1.1.0.1.</span> <span class="post-toc-text">清单 1. Java 7 的排序、取值实现</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#清单-2-Java-8-的排序、取值实现"><span class="post-toc-number">1.1.0.2.</span> <span class="post-toc-text">清单 2. Java 8 的排序、取值实现</span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Stream-总览"><span class="post-toc-number">2.</span> <span class="post-toc-text">Stream 总览</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#什么是流"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">什么是流</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#流的构成"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">流的构成</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#图-1-流管道-Stream-Pipeline-的构成"><span class="post-toc-number">2.2.0.1.</span> <span class="post-toc-text">图 1. 流管道 (Stream Pipeline) 的构成</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#清单-3-一个流操作的示例"><span class="post-toc-number">2.2.0.2.</span> <span class="post-toc-text">清单 3. 一个流操作的示例</span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#流的使用详解"><span class="post-toc-number">3.</span> <span class="post-toc-text">流的使用详解</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#流的构造与转换"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">流的构造与转换</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#清单-4-构造流的几种常见方法"><span class="post-toc-number">3.1.0.1.</span> <span class="post-toc-text">清单 4. 构造流的几种常见方法</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#清单-5-数值流的构造"><span class="post-toc-number">3.1.0.2.</span> <span class="post-toc-text">清单 5. 数值流的构造</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#清单-6-流转换为其它数据结构"><span class="post-toc-number">3.1.0.3.</span> <span class="post-toc-text">清单 6. 流转换为其它数据结构</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#流的操作"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">流的操作</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#清单-7-转换大写"><span class="post-toc-number">3.2.0.1.</span> <span class="post-toc-text">清单 7. 转换大写</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#清单-8-平方数"><span class="post-toc-number">3.2.0.2.</span> <span class="post-toc-text">清单 8. 平方数</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#清单-9-一对多"><span class="post-toc-number">3.2.0.3.</span> <span class="post-toc-text">清单 9. 一对多</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#清单-10-留下偶数"><span class="post-toc-number">3.2.0.4.</span> <span class="post-toc-text">清单 10. 留下偶数</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#清单-11-把单词挑出来"><span class="post-toc-number">3.2.0.5.</span> <span class="post-toc-text">清单 11. 把单词挑出来</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#清单-12-打印姓名（forEach-和-pre-java8-的对比）"><span class="post-toc-number">3.2.0.6.</span> <span class="post-toc-text">清单 12. 打印姓名（forEach 和 pre-java8 的对比）</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#清单-13-peek-对每个元素执行操作并返回一个新的-Stream"><span class="post-toc-number">3.2.0.7.</span> <span class="post-toc-text">清单 13. peek 对每个元素执行操作并返回一个新的 Stream</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#清单-14-Optional-的两个用例"><span class="post-toc-number">3.2.0.8.</span> <span class="post-toc-text">清单 14. Optional 的两个用例</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#清单-15-reduce-的用例"><span class="post-toc-number">3.2.0.9.</span> <span class="post-toc-text">清单 15. reduce 的用例</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#清单-16-limit-和-skip-对运行次数的影响"><span class="post-toc-number">3.2.0.10.</span> <span class="post-toc-text">清单 16. limit 和 skip 对运行次数的影响</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#清单-17-limit-和-skip-对-sorted-后的运行次数无影响"><span class="post-toc-number">3.2.0.11.</span> <span class="post-toc-text">清单 17. limit 和 skip 对 sorted 后的运行次数无影响</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#清单-18-优化：排序前进行-limit-和-skip"><span class="post-toc-number">3.2.0.12.</span> <span class="post-toc-text">清单 18. 优化：排序前进行 limit 和 skip</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#清单-19-找出最长一行的长度"><span class="post-toc-number">3.2.0.13.</span> <span class="post-toc-text">清单 19. 找出最长一行的长度</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#清单-20-找出全文的单词，转小写，并排序"><span class="post-toc-number">3.2.0.14.</span> <span class="post-toc-text">清单 20. 找出全文的单词，转小写，并排序</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#清单-21-使用-Match"><span class="post-toc-number">3.2.0.15.</span> <span class="post-toc-text">清单 21. 使用 Match</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#进阶：自己生成流"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">进阶：自己生成流</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#清单-22-生成-10-个随机整数"><span class="post-toc-number">3.3.0.1.</span> <span class="post-toc-text">清单 22. 生成 10 个随机整数</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#清单-23-自实现-Supplier"><span class="post-toc-number">3.3.0.2.</span> <span class="post-toc-text">清单 23. 自实现 Supplier</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#进阶：用-Collectors-来进行-reduction-操作"><span class="post-toc-number">3.4.</span> <span class="post-toc-text">进阶：用 Collectors 来进行 reduction 操作</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#清单-25-按照年龄归组"><span class="post-toc-number">3.4.0.1.</span> <span class="post-toc-text">清单 25. 按照年龄归组</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#清单-26-按照未成年人和成年人归组"><span class="post-toc-number">3.4.0.2.</span> <span class="post-toc-text">清单 26. 按照未成年人和成年人归组</span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#结束语"><span class="post-toc-number">4.</span> <span class="post-toc-text">结束语</span></a></li></ol>

        <!--
        <li class="mdl-menu__item">
            Some Action
        </li>
        -->
    </ul>




<!-- Layouts -->

    <!-- Post Module -->
    <div class="material-post_container">

        <div class="material-post mdl-grid">
            <div class="mdl-card mdl-shadow--4dp mdl-cell mdl-cell--12-col">

                <!-- Post Header(Thumbnail & Title) -->
                
    <!-- Paradox Post Header -->
    
        <!-- Custom Thumbnail -->
        <div class="post_thumbnail-custom mdl-card__media mdl-color-text--grey-50" style="background-image:url(http://oq5d32gij.bkt.clouddn.com/15101490251625.png)">
    
            <p class="article-headline-p">
                Java8中的streams API详解
            </p>
        </div>





                
                    <!-- Paradox Post Info -->
                    <div class="mdl-color-text--grey-700 mdl-card__supporting-text meta">

    <!-- Author Avatar -->
    <div id="author-avatar">
        <img src="/img/avatar.png" width="44px" height="44px" alt="Author Avatar"/>
    </div>
    <!-- Author Name & Date -->
    <div>
        <strong>人不如故</strong>
        <span>11月 08, 2017</span>
    </div>

    <div class="section-spacer"></div>

    <!-- Favorite -->
    <!--
        <button id="article-functions-like-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon btn-like">
            <i class="material-icons" role="presentation">favorite</i>
            <span class="visuallyhidden">favorites</span>
        </button>
    -->

    <!-- Qrcode -->
    
        <button id="article-functions-qrcode-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon">
            <i class="material-icons" role="presentation">devices other</i>
            <span class="visuallyhidden">devices other</span>
        </button>
        <ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-functions-qrcode-button">
            <li class="mdl-menu__item">在其它设备中阅读本文章</li>
            <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPYAAAD2CAAAAADAeSUUAAACzElEQVR42u3a0W4bMQwEQP//T7evBYo6u+ShsKW5JyN2LI0ChCBXr19XPi9sbGxsbGxsbGzsj2S/4ufPz//9+v27+Tfn6+Z7xsbGxr6B/cO//rfU/JP/2vr7n7xfJdkJNjY29j3spHjsDyL//oRdfCc2NjY29qj9SBjJ6nlbgo2NjY29KWA/jHWS0U/5E2xsbGzs4YDmoWKTID9iloaNjY398ex90Pv/X39Evo2NjY39Aez2aY9m1qLkharYOTY2Nvah7PwazbOwPDDIW6P3UQQ2Njb2qew8cM1D37ZQtWOsFoyNjY19A/tVPvlhPRX6tutiY2Nj38Ouh+wjXv6Z/a6wsbGxb2PvR/9JyZnFCZsouhgqYWNjY385Ox/KtIfV4vdHgI2NjY3dlqJ8o5vYuN1bfWUHGxsb+8vZ7bgnLzaz+DY/pnbAhI2NjX0qOylOmzFQe7lndt0niqKxsbGxj2ZHQWkcFSRjqZadX+UpChg2Njb2Qex2kDQLGPLWZRYh/PBb2NjY2New8+F73hg8cHVyUdKwsbGxz2bvo9yk/MyoDxdLbGxs7EPZs8HQpj14asV6P9jY2NhHs9uIdxYVbK7UtxHCMOjFxsbG/kL2viDl7yZrPXWVp+7AsLGxsY9gt03Cs9d32og3L67Y2NjYN7Bz5KYtaZucJFQYXr7ExsbGPo69GffkAe3+gNqGBBsbG/sG9ixAfbYJyQ9i82BjY2Ofys6D1dn4fhP9JmVsFQ9gY2NjH8eeNRWb8DWPBPKIoujAsLGxsY9g7wtDHv3uSbMSiI2NjX0Du20e8sX2kcPsOtFqloaNjY39texiQFNSZ41KO1rCxsbGxk42lDBmQ6Jk3U3MjI2NjY2dj+M3wUCOT/4k2NjY2Lexk6HSZkCfHFZ7HHlDgo2NjX02exb0ttdo9iWtbYSwsbGxb2Df82BjY2NjY2NjY2N/zPMbfYAqXDQdupMAAAAASUVORK5CYII=">
        </ul>
    

    <!-- Tags (bookmark) -->
    
    <button id="article-functions-viewtags-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon">
        <i class="material-icons" role="presentation">bookmark</i>
        <span class="visuallyhidden">bookmark</span>
    </button>
    <ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-functions-viewtags-button">
        <li class="mdl-menu__item">
        <a class="post_tag-link" href="/tags/java8/">java8</a></li><li class="mdl-menu__item"><a class="post_tag-link" href="/tags/lambda/">lambda</a></li><li class="mdl-menu__item"><a class="post_tag-link" href="/tags/steams/">steams</a>
    </ul>
    

    <!-- Share -->
    <button id="article-fuctions-share-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon">
    <i class="material-icons" role="presentation">share</i>
    <span class="visuallyhidden">share</span>
</button>
<ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-fuctions-share-button">
    

    
        
            <!-- Busuanzi Views -->
            <a class="post_share-link" href="#">
                <li class="mdl-menu__item">
                    <span id="busuanzi_container_page_pv">
                        <span id="busuanzi_value_page_pv"></span>&nbsp;浏览量
                    </span>
                </li>
            </a>
        
    

    <!-- Share Weibo -->
    
        <a class="post_share-link" href="http://service.weibo.com/share/share.php?appkey=&title=Java8中的streams API详解&url=https://wangyu1997.github.io//2017/11/08/JAVA/Java8中的Streams API/index.html&pic=&searchPic=false&style=simple" target="_blank">
            <li class="mdl-menu__item">
                分享到微博
            </li>
        </a>
    

    <!-- Share Twitter -->
    
        <a class="post_share-link" href="https://twitter.com/intent/tweet?text=Java8中的streams API详解&url=https://wangyu1997.github.io//2017/11/08/JAVA/Java8中的Streams API/index.html&via=人不如故" target="_blank">
            <li class="mdl-menu__item">
                分享到 Twitter
            </li>
        </a>
    

    <!-- Share Facebook -->
    
        <a class="post_share-link" href="https://www.facebook.com/sharer/sharer.php?u=https://wangyu1997.github.io//2017/11/08/JAVA/Java8中的Streams API/index.html" target="_blank">
            <li class="mdl-menu__item">
                分享到 Facebook
            </li>
        </a>
    

    <!-- Share Google+ -->
    
        <a class="post_share-link" href="https://plus.google.com/share?url=https://wangyu1997.github.io//2017/11/08/JAVA/Java8中的Streams API/index.html" target="_blank">
            <li class="mdl-menu__item">
                分享到 Google+
            </li>
        </a>
    

    <!-- Share LinkedIn -->
    

    <!-- Share QQ -->
    
        <a class="post_share-link" href="http://connect.qq.com/widget/shareqq/index.html?site=人不如故&title=Java8中的streams API详解&summary=世间一场大梦，人生几度秋凉。&pics=https://wangyu1997.github.io/img/favicon.png&url=https://wangyu1997.github.io/2017/11/08/JAVA/Java8中的Streams API/index.html" target="_blank">
            <li class="mdl-menu__item">
                分享到 QQ
            </li>
        </a>
    

    <!-- Share Telegram -->
    
</ul>

</div>

                

                <!-- Post Content -->
                <div id="post-content" class="mdl-color-text--grey-700 mdl-card__supporting-text fade out">
   
    
            <link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p>Streams 的背景，以及 Java 8 中的使用详解 </p>
<h2 id="为什么需要-Stream"><a href="#为什么需要-Stream" class="headerlink" title="为什么需要 Stream"></a>为什么需要 Stream</h2><p>Stream 作为 Java 8 的一大亮点，它与 java.io 包里的 InputStream 和 OutputStream 是完全不同的概念。它也不同于 StAX 对 XML 解析的 Stream，也不是 Amazon Kinesis 对大数据实时处理的 Stream。Java 8 中的 Stream 是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation），或者大批量数据操作 (bulk data operation)。Stream API 借助于同样新出现的 Lambda 表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork/join 并行方式来拆分任务和加速处理过程。通常编写并行代码很难而且容易出错, 但使用 Stream API 无需编写一行多线程的代码，就可以很方便地写出高性能的并发程序。所以说，Java 8 中首次出现的 java.util.stream 是一个函数式语言+多核时代综合影响的产物。 </p>
<h3 id="什么是聚合操作"><a href="#什么是聚合操作" class="headerlink" title="什么是聚合操作"></a>什么是聚合操作</h3><p>在传统的 J2EE 应用中，Java 代码经常不得不依赖于关系型数据库的聚合操作来完成诸如： </p>
<ul>
<li>客户每月平均消费金额</li>
<li>最昂贵的在售商品</li>
<li>本周完成的有效订单（排除了无效的）</li>
<li>取十个数据样本作为首页推荐</li>
</ul>
<p>这类的操作。 </p>
<p>但在当今这个数据大爆炸的时代，在数据来源多样化、数据海量化的今天，很多时候不得不脱离 RDBMS，或者以底层返回的数据为基础进行更上层的数据统计。而 Java 的集合 API 中，仅仅有极少量的辅助型方法，更多的时候是程序员需要用 Iterator 来遍历集合，完成相关的聚合应用逻辑。这是一种远不够高效、笨拙的方法。在 Java 7 中，如果要发现 type 为 grocery 的所有交易，然后返回以交易值降序排序好的交易 ID 集合，我们需要这样写： </p>
<h5 id="清单-1-Java-7-的排序、取值实现"><a href="#清单-1-Java-7-的排序、取值实现" class="headerlink" title="清单 1. Java 7 的排序、取值实现"></a>清单 1. Java 7 的排序、取值实现</h5><pre><code>List&lt;Transaction&gt; groceryTransactions = new Arraylist&lt;&gt;();
for(Transaction t: transactions){
 if(t.getType() == Transaction.GROCERY){
 groceryTransactions.add(t);
 }
}
Collections.sort(groceryTransactions, new Comparator(){
 public int compare(Transaction t1, Transaction t2){
 return t2.getValue().compareTo(t1.getValue());
 }
});
List&lt;Integer&gt; transactionIds = new ArrayList&lt;&gt;();
for(Transaction t: groceryTransactions){
 transactionsIds.add(t.getId());
}
</code></pre><p>而在 Java 8 使用 Stream，代码更加简洁易读；而且使用并发模式，程序执行速度更快。 </p>
<h5 id="清单-2-Java-8-的排序、取值实现"><a href="#清单-2-Java-8-的排序、取值实现" class="headerlink" title="清单 2. Java 8 的排序、取值实现"></a>清单 2. Java 8 的排序、取值实现</h5><pre><code>List&lt;Integer&gt; transactionsIds = transactions.parallelStream().
 filter(t -&gt; t.getType() == Transaction.GROCERY).
 sorted(comparing(Transaction::getValue).reversed()).
 map(Transaction::getId).
 collect(toList());
</code></pre><h2 id="Stream-总览"><a href="#Stream-总览" class="headerlink" title="Stream 总览"></a>Stream 总览</h2><h3 id="什么是流"><a href="#什么是流" class="headerlink" title="什么是流"></a>什么是流</h3><p>Stream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的 Iterator。原始版本的 Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的 Stream，用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。 </p>
<p>Stream 就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。 </p>
<p>而和迭代器又不同的是，Stream 可以并行化操作，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方式去遍历时，每个 item 读完后再读下一个 item。而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。Stream 的并行操作依赖于 Java7 中引入的 Fork/Join 框架（JSR166y）来拆分任务和加速处理过程。Java 的并行 API 演变历程基本如下： </p>
<ol>
<li>1.0-1.4 中的 java.lang.Thread</li>
<li>5.0 中的 java.util.concurrent</li>
<li>6.0 中的 Phasers 等</li>
<li>7.0 中的 Fork/Join 框架</li>
<li>8.0 中的 Lambda</li>
</ol>
<p>Stream 的另外一大特点是，数据源本身可以是无限的。 </p>
<h3 id="流的构成"><a href="#流的构成" class="headerlink" title="流的构成"></a>流的构成</h3><p>当我们使用一个流的时候，通常包括三个基本步骤： </p>
<p>获取一个数据源（source）→ 数据转换→执行操作获取想要的结果，每次转换原有 Stream 对象不改变，返回一个新的 Stream 对象（可以有多次转换），这就允许对其操作可以像链条一样排列，变成一个管道，如下图所示。 </p>
<h5 id="图-1-流管道-Stream-Pipeline-的构成"><a href="#图-1-流管道-Stream-Pipeline-的构成" class="headerlink" title="图 1. 流管道 (Stream Pipeline) 的构成"></a>图 1. 流管道 (Stream Pipeline) 的构成</h5><p><img src="http://oq5d32gij.bkt.clouddn.com/15101508417650.png" alt=""></p>
<p>有多种方式生成 Stream Source： </p>
<ul>
<li>从 Collection 和数组</li>
<li><ul>
<li>Collection.stream()</li>
<li>Collection.parallelStream()</li>
<li>Arrays.stream(T array) or Stream.of()<br>从 BufferedReader</li>
<li>java.io.BufferedReader.lines()</li>
</ul>
</li>
<li>静态工厂</li>
<li>java.util.stream.IntStream.range()</li>
<li>java.nio.file.Files.walk()</li>
<li>自己构建</li>
<li><ul>
<li>java.util.Spliterator<br>其它</li>
<li>Random.ints()</li>
<li>BitSet.stream()</li>
<li>Pattern.splitAsStream(java.lang.CharSequence)</li>
<li>JarFile.stream()</li>
</ul>
</li>
</ul>
<p>流的操作类型分为两种： </p>
<ul>
<li><strong>Intermediate</strong>：一个流可以后面跟随零个或多个 intermediate 操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历。</li>
<li><strong>Terminal</strong>：一个流只能有一个 terminal 操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。Terminal 操作的执行，才会真正开始流的遍历，并且会生成一个结果，或者一个 side effect。</li>
</ul>
<p>在对于一个 Stream 进行多次转换操作 (Intermediate 操作)，每次都对 Stream 的每个元素进行转换，而且是执行多次，这样时间复杂度就是 N（转换次数）个 for 循环里把所有操作都做掉的总和吗？其实不是这样的，转换操作都是 lazy 的，多个转换操作只会在 Terminal 操作的时候融合起来，一次循环完成。我们可以这样简单的理解，Stream 里有个操作函数的集合，每次转换操作就是把转换函数放入这个集合中，在 Terminal 操作的时候循环 Stream 对应的集合，然后对每个元素执行所有的函数。 </p>
<p>还有一种操作被称为 <strong>short-circuiting</strong>。用以指： </p>
<ul>
<li>对于一个 intermediate 操作，如果它接受的是一个无限大（infinite/unbounded）的 Stream，但返回一个有限的新 Stream。</li>
<li>对于一个 terminal 操作，如果它接受的是一个无限大的 Stream，但能在有限的时间计算出结果。</li>
</ul>
<p>当操作一个无限大的 Stream，而又希望在有限时间内完成操作，则在管道内拥有一个 short-circuiting 操作是必要非充分条件。 </p>
<h5 id="清单-3-一个流操作的示例"><a href="#清单-3-一个流操作的示例" class="headerlink" title="清单 3. 一个流操作的示例"></a>清单 3. 一个流操作的示例</h5><pre><code>int sum = widgets.stream()
.filter(w -&gt; w.getColor() == RED)
 .mapToInt(w -&gt; w.getWeight())
 .sum();
</code></pre><p>stream() 获取当前小物件的 source，filter 和 mapToInt 为 intermediate 操作，进行数据筛选和转换，最后一个 sum() 为 terminal 操作，对符合条件的全部小物件作重量求和。 </p>
<h2 id="流的使用详解"><a href="#流的使用详解" class="headerlink" title="流的使用详解"></a>流的使用详解</h2><p>简单说，对 Stream 的使用就是实现一个 filter-map-reduce 过程，产生一个最终结果，或者导致一个副作用（side effect）。 </p>
<h3 id="流的构造与转换"><a href="#流的构造与转换" class="headerlink" title="流的构造与转换"></a>流的构造与转换</h3><p>下面提供最常见的几种构造 Stream 的样例。 </p>
<h5 id="清单-4-构造流的几种常见方法"><a href="#清单-4-构造流的几种常见方法" class="headerlink" title="清单 4. 构造流的几种常见方法"></a>清单 4. 构造流的几种常见方法</h5><pre><code>// 1. Individual values
Stream stream = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);
// 2. Arrays
String [] strArray = new String[] {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;};
stream = Stream.of(strArray);
stream = Arrays.stream(strArray);
// 3. Collections
List&lt;String&gt; list = Arrays.asList(strArray);
stream = list.stream();
</code></pre><p>需要注意的是，对于基本数值型，目前有三种对应的包装类型 Stream： </p>
<p>IntStream、LongStream、DoubleStream。当然我们也可以用 Stream<integer>、Stream<long> &gt;、Stream<double>，但是 boxing 和 unboxing 会很耗时，所以特别为这三种基本数值型提供了对应的 Stream。 </double></long></integer></p>
<p>Java 8 中还没有提供其它数值型 Stream，因为这将导致扩增的内容较多。而常规的数值型聚合运算可以通过上面三种 Stream 进行。 </p>
<h5 id="清单-5-数值流的构造"><a href="#清单-5-数值流的构造" class="headerlink" title="清单 5. 数值流的构造"></a>清单 5. 数值流的构造</h5><pre><code>IntStream.of(new int[]{1, 2, 3}).forEach(System.out::println);
IntStream.range(1, 3).forEach(System.out::println);
IntStream.rangeClosed(1, 3).forEach(System.out::println);
</code></pre><h5 id="清单-6-流转换为其它数据结构"><a href="#清单-6-流转换为其它数据结构" class="headerlink" title="清单 6. 流转换为其它数据结构"></a>清单 6. 流转换为其它数据结构</h5><pre><code>// 1. Array
String[] strArray1 = stream.toArray(String[]::new);
// 2. Collection
List&lt;String&gt; list1 = stream.collect(Collectors.toList());
List&lt;String&gt; list2 = stream.collect(Collectors.toCollection(ArrayList::new));
Set set1 = stream.collect(Collectors.toSet());
Stack stack1 = stream.collect(Collectors.toCollection(Stack::new));
// 3. String
String str = stream.collect(Collectors.joining()).toString();
</code></pre><p>一个 Stream 只可以使用一次，上面的代码为了简洁而重复使用了数次。 </p>
<h3 id="流的操作"><a href="#流的操作" class="headerlink" title="流的操作"></a>流的操作</h3><p>接下来，当把一个数据结构包装成 Stream 后，就要开始对里面的元素进行各类操作了。常见的操作可以归类如下。 </p>
<ul>
<li>Intermediate：</li>
</ul>
<p>map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、 skip、 parallel、 sequential、 unordered </p>
<ul>
<li>Terminal：</li>
</ul>
<p>forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、 anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 iterator </p>
<ul>
<li>Short-circuiting：</li>
</ul>
<p>anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 limit </p>
<p>我们下面看一下 Stream 的比较典型用法。 </p>
<p><strong>map/flatMap</strong></p>
<p>我们先来看 map。如果你熟悉 scala 这类函数式语言，对这个方法应该很了解，它的作用就是把 input Stream 的每一个元素，映射成 output Stream 的另外一个元素。 </p>
<h5 id="清单-7-转换大写"><a href="#清单-7-转换大写" class="headerlink" title="清单 7. 转换大写"></a>清单 7. 转换大写</h5><pre><code>List&lt;String&gt; output = wordList.stream().
map(String::toUpperCase).
collect(Collectors.toList());
</code></pre><p>这段代码把所有的单词转换为大写。 </p>
<h5 id="清单-8-平方数"><a href="#清单-8-平方数" class="headerlink" title="清单 8. 平方数"></a>清单 8. 平方数</h5><pre><code>List&lt;Integer&gt; nums = Arrays.asList(1, 2, 3, 4);
List&lt;Integer&gt; squareNums = nums.stream().
map(n -&gt; n * n).
collect(Collectors.toList());
</code></pre><p>这段代码生成一个整数 list 的平方数 {1, 4, 9, 16}。 </p>
<p>从上面例子可以看出，map 生成的是个 1:1 映射，每个输入元素，都按照规则转换成为另外一个元素。还有一些场景，是一对多映射关系的，这时需要 flatMap。 </p>
<h5 id="清单-9-一对多"><a href="#清单-9-一对多" class="headerlink" title="清单 9. 一对多"></a>清单 9. 一对多</h5><pre><code>Stream&lt;List&lt;Integer&gt;&gt; inputStream = Stream.of(
 Arrays.asList(1),
 Arrays.asList(2, 3),
 Arrays.asList(4, 5, 6)
 );
Stream&lt;Integer&gt; outputStream = inputStream.
flatMap((childList) -&gt; childList.stream());
</code></pre><p>flatMap 把 input Stream 中的层级结构扁平化，就是将最底层元素抽出来放到一起，最终 output 的新 Stream 里面已经没有 List 了，都是直接的数字。 </p>
<p><strong>filter</strong></p>
<p>filter 对原始 Stream 进行某项测试，通过测试的元素被留下来生成一个新 Stream。 </p>
<h5 id="清单-10-留下偶数"><a href="#清单-10-留下偶数" class="headerlink" title="清单 10. 留下偶数"></a>清单 10. 留下偶数</h5><pre><code>Integer[] sixNums = {1, 2, 3, 4, 5, 6};
Integer[] evens =
Stream.of(sixNums).filter(n -&gt; n%2 == 0).toArray(Integer[]::new);
</code></pre><p>经过条件“被 2 整除”的 filter，剩下的数字为 {2, 4, 6}。 </p>
<h5 id="清单-11-把单词挑出来"><a href="#清单-11-把单词挑出来" class="headerlink" title="清单 11. 把单词挑出来"></a>清单 11. 把单词挑出来</h5><pre><code>List&lt;String&gt; output = reader.lines().
 flatMap(line -&gt; Stream.of(line.split(REGEXP))).
 filter(word -&gt; word.length() &gt; 0).
 collect(Collectors.toList());
</code></pre><p>这段代码首先把每行的单词用 flatMap 整理到新的 Stream，然后保留长度不为 0 的，就是整篇文章中的全部单词了。 </p>
<p><strong>forEach</strong></p>
<p>forEach 方法接收一个 Lambda 表达式，然后在 Stream 的每一个元素上执行该表达式。 </p>
<h5 id="清单-12-打印姓名（forEach-和-pre-java8-的对比）"><a href="#清单-12-打印姓名（forEach-和-pre-java8-的对比）" class="headerlink" title="清单 12. 打印姓名（forEach 和 pre-java8 的对比）"></a>清单 12. 打印姓名（forEach 和 pre-java8 的对比）</h5><pre><code>// Java 8
roster.stream()
 .filter(p -&gt; p.getGender() == Person.Sex.MALE)
 .forEach(p -&gt; System.out.println(p.getName()));
// Pre-Java 8
for (Person p : roster) {
 if (p.getGender() == Person.Sex.MALE) {
 System.out.println(p.getName());
 }
}
</code></pre><p>对一个人员集合遍历，找出男性并打印姓名。可以看出来，forEach 是为 Lambda 而设计的，保持了最紧凑的风格。而且 Lambda 表达式本身是可以重用的，非常方便。当需要为多核系统优化时，可以 parallelStream().forEach()，只是此时原有元素的次序没法保证，并行的情况下将改变串行时操作的行为，此时 forEach 本身的实现不需要调整，而 Java8 以前的 for 循环 code 可能需要加入额外的多线程逻辑。 </p>
<p>但一般认为，forEach 和常规 for 循环的差异不涉及到性能，它们仅仅是函数式风格与传统 Java 风格的差别。 </p>
<p>另外一点需要注意，forEach 是 terminal 操作，因此它执行后，Stream 的元素就被“消费”掉了，你无法对一个 Stream 进行两次 terminal 运算。下面的代码是错误的： </p>
<pre><code>     stream.forEach(element -&gt; doOneThing(element));
     stream.forEach(element -&gt; doAnotherThing(element));
</code></pre><p>相反，具有相似功能的 intermediate 操作 peek 可以达到上述目的。如下是出现在该 api javadoc 上的一个示例。 </p>
<h5 id="清单-13-peek-对每个元素执行操作并返回一个新的-Stream"><a href="#清单-13-peek-对每个元素执行操作并返回一个新的-Stream" class="headerlink" title="清单 13. peek 对每个元素执行操作并返回一个新的 Stream"></a>清单 13. peek 对每个元素执行操作并返回一个新的 Stream</h5><pre><code>Stream.of(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;)
 .filter(e -&gt; e.length() &gt; 3)
 .peek(e -&gt; System.out.println(&quot;Filtered value: &quot; + e))
 .map(String::toUpperCase)
 .peek(e -&gt; System.out.println(&quot;Mapped value: &quot; + e))
 .collect(Collectors.toList());
</code></pre><p>forEach 不能修改自己包含的本地变量值，也不能用 break/return 之类的关键字提前结束循环。 </p>
<p><strong>findFirst</strong></p>
<p>这是一个 termimal 兼 short-circuiting 操作，它总是返回 Stream 的第一个元素，或者空。 </p>
<p>这里比较重点的是它的返回值类型：Optional。这也是一个模仿 Scala 语言中的概念，作为一个容器，它可能含有某值，或者不包含。使用它的目的是尽可能避免 NullPointerException。 </p>
<h5 id="清单-14-Optional-的两个用例"><a href="#清单-14-Optional-的两个用例" class="headerlink" title="清单 14. Optional 的两个用例"></a>清单 14. Optional 的两个用例</h5><pre><code>String strA = &quot; abcd &quot;, strB = null;
print(strA);
print(&quot;&quot;);
print(strB);
getLength(strA);
getLength(&quot;&quot;);
getLength(strB);
public static void print(String text) {
 // Java 8
 Optional.ofNullable(text).ifPresent(System.out::println);
 // Pre-Java 8
 if (text != null) {
 System.out.println(text);
 }
 }
public static int getLength(String text) {
 // Java 8
return Optional.ofNullable(text).map(String::length).orElse(-1);
 // Pre-Java 8
// return if (text != null) ? text.length() : -1;
 };
</code></pre><p>在更复杂的 if (xx != null) 的情况中，使用 Optional 代码的可读性更好，而且它提供的是编译时检查，能极大的降低 NPE 这种 Runtime Exception 对程序的影响，或者迫使程序员更早的在编码阶段处理空值问题，而不是留到运行时再发现和调试。 </p>
<p>Stream 中的 findAny、max/min、reduce 等方法等返回 Optional 值。还有例如 IntStream.average() 返回 OptionalDouble 等等。 </p>
<p><strong>reduce</strong></p>
<p>这个方法的主要作用是把 Stream 元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合。从这个意义上说，字符串拼接、数值的 sum、min、max、average 都是特殊的 reduce。例如 Stream 的 sum 就相当于 </p>
<p>Integer sum = integers.reduce(0, (a, b) -&gt; a+b); 或 </p>
<p>Integer sum = integers.reduce(0, Integer::sum); </p>
<p>也有没有起始值的情况，这时会把 Stream 的前面两个元素组合起来，返回的是 Optional。 </p>
<h5 id="清单-15-reduce-的用例"><a href="#清单-15-reduce-的用例" class="headerlink" title="清单 15. reduce 的用例"></a>清单 15. reduce 的用例</h5><pre><code>// 字符串连接，concat = &quot;ABCD&quot;
String concat = Stream.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;).reduce(&quot;&quot;, String::concat); 
// 求最小值，minValue = -3.0
double minValue = Stream.of(-1.5, 1.0, -3.0, -2.0).reduce(Double.MAX_VALUE, Double::min); 
// 求和，sumValue = 10, 有起始值
int sumValue = Stream.of(1, 2, 3, 4).reduce(0, Integer::sum);
// 求和，sumValue = 10, 无起始值
sumValue = Stream.of(1, 2, 3, 4).reduce(Integer::sum).get();
// 过滤，字符串连接，concat = &quot;ace&quot;
concat = Stream.of(&quot;a&quot;, &quot;B&quot;, &quot;c&quot;, &quot;D&quot;, &quot;e&quot;, &quot;F&quot;).
 filter(x -&gt; x.compareTo(&quot;Z&quot;) &gt; 0).
 reduce(&quot;&quot;, String::concat);
</code></pre><p>上面代码例如第一个示例的 reduce()，第一个参数（空白字符）即为起始值，第二个参数（String::concat）为 BinaryOperator。这类有起始值的 reduce() 都返回具体的对象。而对于第四个示例没有起始值的 reduce()，由于可能没有足够的元素，返回的是 Optional，请留意这个区别。 </p>
<p><strong>limit/skip</strong></p>
<p>limit 返回 Stream 的前面 n 个元素；skip 则是扔掉前 n 个元素（它是由一个叫 subStream 的方法改名而来）。 </p>
<h5 id="清单-16-limit-和-skip-对运行次数的影响"><a href="#清单-16-limit-和-skip-对运行次数的影响" class="headerlink" title="清单 16. limit 和 skip 对运行次数的影响"></a>清单 16. limit 和 skip 对运行次数的影响</h5><pre><code>public void testLimitAndSkip() {
 List&lt;Person&gt; persons = new ArrayList();
 for (int i = 1; i &lt;= 10000; i++) {
 Person person = new Person(i, &quot;name&quot; + i);
 persons.add(person);
 }
List&lt;String&gt; personList2 = persons.stream().
map(Person::getName).limit(10).skip(3).collect(Collectors.toList());
 System.out.println(personList2);
}
private class Person {
 public int no;
 private String name;
 public Person (int no, String name) {
 this.no = no;
 this.name = name;
 }
 public String getName() {
 System.out.println(name);
 return name;
 }
}
</code></pre><p>输出结果为： </p>
<pre><code>name1
name2
name3
name4
name5
name6
name7
name8
name9
name10
[name4, name5, name6, name7, name8, name9, name10]
</code></pre><p>这是一个有 10，000 个元素的 Stream，但在 short-circuiting 操作 limit 和 skip 的作用下，管道中 map 操作指定的 getName() 方法的执行次数为 limit 所限定的 10 次，而最终返回结果在跳过前 3 个元素后只有后面 7 个返回。 </p>
<p>有一种情况是 limit/skip 无法达到 short-circuiting 目的的，就是把它们放在 Stream 的排序操作后，原因跟 sorted 这个 intermediate 操作有关：此时系统并不知道 Stream 排序后的次序如何，所以 sorted 中的操作看上去就像完全没有被 limit 或者 skip 一样。 </p>
<h5 id="清单-17-limit-和-skip-对-sorted-后的运行次数无影响"><a href="#清单-17-limit-和-skip-对-sorted-后的运行次数无影响" class="headerlink" title="清单 17. limit 和 skip 对 sorted 后的运行次数无影响"></a>清单 17. limit 和 skip 对 sorted 后的运行次数无影响</h5><pre><code>List&lt;Person&gt; persons = new ArrayList();
 for (int i = 1; i &lt;= 5; i++) {
 Person person = new Person(i, &quot;name&quot; + i);
 persons.add(person);
 }
List&lt;Person&gt; personList2 = persons.stream().sorted((p1, p2) -&gt; 
p1.getName().compareTo(p2.getName())).limit(2).collect(Collectors.toList());
System.out.println(personList2);
</code></pre><p>上面的示例对清单 13 做了微调，首先对 5 个元素的 Stream 排序，然后进行 limit 操作。输出结果为： </p>
<pre><code> name2
name1
name3
name2
name4
name3
name5
name4
[stream.StreamDW$Person@816f27d, stream.StreamDW$Person@87aac27]
</code></pre><p>即虽然最后的返回元素数量是 2，但整个管道中的 sorted 表达式执行次数没有像前面例子相应减少。 </p>
<p>最后有一点需要注意的是，对一个 parallel 的 Steam 管道来说，如果其元素是有序的，那么 limit 操作的成本会比较大，因为它的返回对象必须是前 n 个也有一样次序的元素。取而代之的策略是取消元素间的次序，或者不要用 parallel Stream。 </p>
<p><strong>sorted</strong></p>
<p>对 Stream 的排序通过 sorted 进行，它比数组的排序更强之处在于你可以首先对 Stream 进行各类 map、filter、limit、skip 甚至 distinct 来减少元素数量后，再排序，这能帮助程序明显缩短执行时间。我们对清单 14 进行优化： </p>
<h5 id="清单-18-优化：排序前进行-limit-和-skip"><a href="#清单-18-优化：排序前进行-limit-和-skip" class="headerlink" title="清单 18. 优化：排序前进行 limit 和 skip"></a>清单 18. 优化：排序前进行 limit 和 skip</h5><pre><code>List&lt;Person&gt; persons = new ArrayList();
 for (int i = 1; i &lt;= 5; i++) {
 Person person = new Person(i, &quot;name&quot; + i);
 persons.add(person);
 }
List&lt;Person&gt; personList2 = persons.stream().limit(2).sorted((p1, p2) -&gt; p1.getName().compareTo(p2.getName())).collect(Collectors.toList());
System.out.println(personList2);
</code></pre><p>结果会简单很多： </p>
<pre><code>name2
name1
[stream.StreamDW$Person@6ce253f1, stream.StreamDW$Person@53d8d10a]
</code></pre><p>当然，这种优化是有 business logic 上的局限性的：即不要求排序后再取值。 </p>
<p><strong>min/max/distinct</strong></p>
<p>min 和 max 的功能也可以通过对 Stream 元素先排序，再 findFirst 来实现，但前者的性能会更好，为 O(n)，而 sorted 的成本是 O(n log n)。同时它们作为特殊的 reduce 方法被独立出来也是因为求最大最小值是很常见的操作。 </p>
<h5 id="清单-19-找出最长一行的长度"><a href="#清单-19-找出最长一行的长度" class="headerlink" title="清单 19. 找出最长一行的长度"></a>清单 19. 找出最长一行的长度</h5><pre><code>BufferedReader br = new BufferedReader(new FileReader(&quot;c:\\SUService.log&quot;));
int longest = br.lines().
 mapToInt(String::length).
 max().
 getAsInt();
br.close();
System.out.println(longest);
</code></pre><p>下面的例子则使用 distinct 来找出不重复的单词。 </p>
<h5 id="清单-20-找出全文的单词，转小写，并排序"><a href="#清单-20-找出全文的单词，转小写，并排序" class="headerlink" title="清单 20. 找出全文的单词，转小写，并排序"></a>清单 20. 找出全文的单词，转小写，并排序</h5><pre><code>List&lt;String&gt; words = br.lines().
 flatMap(line -&gt; Stream.of(line.split(&quot; &quot;))).
 filter(word -&gt; word.length() &gt; 0).
 map(String::toLowerCase).
 distinct().
 sorted().
 collect(Collectors.toList());
br.close();
System.out.println(words);
</code></pre><p><strong>Match</strong></p>
<p>Stream 有三个 match 方法，从语义上说： </p>
<ul>
<li>allMatch：Stream 中全部元素符合传入的 predicate，返回 true</li>
<li>anyMatch：Stream 中只要有一个元素符合传入的 predicate，返回 true</li>
<li>noneMatch：Stream 中没有一个元素符合传入的 predicate，返回 true</li>
</ul>
<p>它们都不是要遍历全部元素才能返回结果。例如 allMatch 只要一个元素不满足条件，就 skip 剩下的所有元素，返回 false。对清单 13 中的 Person 类稍做修改，加入一个 age 属性和 getAge 方法。 </p>
<h5 id="清单-21-使用-Match"><a href="#清单-21-使用-Match" class="headerlink" title="清单 21. 使用 Match"></a>清单 21. 使用 Match</h5><pre><code>List&lt;Person&gt; persons = new ArrayList();
persons.add(new Person(1, &quot;name&quot; + 1, 10));
persons.add(new Person(2, &quot;name&quot; + 2, 21));
persons.add(new Person(3, &quot;name&quot; + 3, 34));
persons.add(new Person(4, &quot;name&quot; + 4, 6));
persons.add(new Person(5, &quot;name&quot; + 5, 55));
boolean isAllAdult = persons.stream().
 allMatch(p -&gt; p.getAge() &gt; 18);
System.out.println(&quot;All are adult? &quot; + isAllAdult);
boolean isThereAnyChild = persons.stream().
 anyMatch(p -&gt; p.getAge() &lt; 12);
System.out.println(&quot;Any child? &quot; + isThereAnyChild);
</code></pre><p>输出结果： </p>
<pre><code> All are adult? false
 Any child? true
</code></pre><h3 id="进阶：自己生成流"><a href="#进阶：自己生成流" class="headerlink" title="进阶：自己生成流"></a>进阶：自己生成流</h3><p><strong>Stream.generate</strong></p>
<p>通过实现 Supplier 接口，你可以自己来控制流的生成。这种情形通常用于随机数、常量的 Stream，或者需要前后元素间维持着某种状态信息的 Stream。把 Supplier 实例传递给 Stream.generate() 生成的 Stream，默认是串行（相对 parallel 而言）但无序的（相对 ordered 而言）。由于它是无限的，在管道中，必须利用 limit 之类的操作限制 Stream 大小。 </p>
<h5 id="清单-22-生成-10-个随机整数"><a href="#清单-22-生成-10-个随机整数" class="headerlink" title="清单 22. 生成 10 个随机整数"></a>清单 22. 生成 10 个随机整数</h5><pre><code>Random seed = new Random();
Supplier&lt;Integer&gt; random = seed::nextInt;
Stream.generate(random).limit(10).forEach(System.out::println);
//Another way
IntStream.generate(() -&gt; (int) (System.nanoTime() % 100)).
limit(10).forEach(System.out::println);
</code></pre><p>Stream.generate() 还接受自己实现的 Supplier。例如在构造海量测试数据的时候，用某种自动的规则给每一个变量赋值；或者依据公式计算 Stream 的每个元素值。这些都是维持状态信息的情形。 </p>
<h5 id="清单-23-自实现-Supplier"><a href="#清单-23-自实现-Supplier" class="headerlink" title="清单 23. 自实现 Supplier"></a>清单 23. 自实现 Supplier</h5><pre><code>Stream.generate(new PersonSupplier()).
limit(10).
forEach(p -&gt; System.out.println(p.getName() + &quot;, &quot; + p.getAge()));
private class PersonSupplier implements Supplier&lt;Person&gt; {
 private int index = 0;
 private Random random = new Random();
 @Override
 public Person get() {
 return new Person(index++, &quot;StormTestUser&quot; + index, random.nextInt(100));
 }
}
</code></pre><p>输出结果： </p>
<pre><code> StormTestUser1, 9
StormTestUser2, 12
StormTestUser3, 88
StormTestUser4, 51
StormTestUser5, 22
StormTestUser6, 28
StormTestUser7, 81
StormTestUser8, 51
StormTestUser9, 4
StormTestUser10, 76
</code></pre><p><strong>Stream.iterate</strong></p>
<p>iterate 跟 reduce 操作很像，接受一个种子值，和一个 UnaryOperator（例如 f）。然后种子值成为 Stream 的第一个元素，f(seed) 为第二个，f(f(seed)) 第三个，以此类推。 </p>
<p><strong>清单 24. 生成一个等差数列</strong></p>
<pre><code>     Stream.iterate(0, n -&gt; n + 3).limit(10). forEach(x -&gt; System.out.print(x + &quot; &quot;));.
</code></pre><p>输出结果： </p>
<pre><code>     0 3 6 9 12 15 18 21 24 27
</code></pre><p>与 Stream.generate 相仿，在 iterate 时候管道必须有 limit 这样的操作来限制 Stream 大小。 </p>
<h3 id="进阶：用-Collectors-来进行-reduction-操作"><a href="#进阶：用-Collectors-来进行-reduction-操作" class="headerlink" title="进阶：用 Collectors 来进行 reduction 操作"></a>进阶：用 Collectors 来进行 reduction 操作</h3><p>java.util.stream.Collectors 类的主要作用就是辅助进行各类有用的 reduction 操作，例如转变输出为 Collection，把 Stream 元素进行归组。 </p>
<p><strong>groupingBy/partitioningBy</strong></p>
<h5 id="清单-25-按照年龄归组"><a href="#清单-25-按照年龄归组" class="headerlink" title="清单 25. 按照年龄归组"></a>清单 25. 按照年龄归组</h5><pre><code>Map&lt;Integer, List&lt;Person&gt;&gt; personGroups = Stream.generate(new PersonSupplier()).
 limit(100).
 collect(Collectors.groupingBy(Person::getAge));
Iterator it = personGroups.entrySet().iterator();
while (it.hasNext()) {
 Map.Entry&lt;Integer, List&lt;Person&gt;&gt; persons = (Map.Entry) it.next();
 System.out.println(&quot;Age &quot; + persons.getKey() + &quot; = &quot; + persons.getValue().size());
}
</code></pre><p>上面的 code，首先生成 100 人的信息，然后按照年龄归组，相同年龄的人放到同一个 list 中，可以看到如下的输出： </p>
<pre><code>Age 0 = 2
Age 1 = 2
Age 5 = 2
Age 8 = 1
Age 9 = 1
Age 11 = 2
……
</code></pre><h5 id="清单-26-按照未成年人和成年人归组"><a href="#清单-26-按照未成年人和成年人归组" class="headerlink" title="清单 26. 按照未成年人和成年人归组"></a>清单 26. 按照未成年人和成年人归组</h5><pre><code>Map&lt;Boolean, List&lt;Person&gt;&gt; children = Stream.generate(new PersonSupplier()).
 limit(100).
 collect(Collectors.partitioningBy(p -&gt; p.getAge() &lt; 18));
System.out.println(&quot;Children number: &quot; + children.get(true).size());
System.out.println(&quot;Adult number: &quot; + children.get(false).size());
</code></pre><p>输出结果： </p>
<pre><code>     Children number: 23 
     Adult number: 77
</code></pre><p>在使用条件“年龄小于 18”进行分组后可以看到，不到 18 岁的未成年人是一组，成年人是另外一组。partitioningBy 其实是一种特殊的 groupingBy，它依照条件测试的是否两种结果来构造返回的数据结构，get(true) 和 get(false) 能即为全部的元素对象。 </p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>总之，Stream 的特性可以归纳为： </p>
<ul>
<li>不是数据结构</li>
<li>它没有内部存储，它只是用操作管道从 source（数据结构、数组、generator function、IO channel）抓取数据。</li>
<li>它也绝不修改自己所封装的底层数据结构的数据。例如 Stream 的 filter 操作会产生一个不包含被过滤元素的新 Stream，而不是从 source 删除那些元素。</li>
<li>所有 Stream 的操作必须以 lambda 表达式为参数</li>
<li>不支持索引访问</li>
<li>你可以请求第一个元素，但无法请求第二个，第三个，或最后一个。不过请参阅下一项。</li>
<li>很容易生成数组或者 List</li>
<li>惰性化</li>
<li>很多 Stream 操作是向后延迟的，一直到它弄清楚了最后需要多少数据才会开始。</li>
<li>Intermediate 操作永远是惰性化的。</li>
<li>并行能力</li>
<li>当一个 Stream 是并行化的，就不需要再写多线程代码，所有对它的操作会自动并行进行的。</li>
<li>可以是无限的<ul>
<li>集合有固定大小，Stream 则不必。limit(n) 和 findFirst() 这类的 short-circuiting 操作可以对无限的 Stream 进行运算并很快完成。</li>
</ul>
</li>
</ul>

           
         <style type="text/css">
.hljs-comment,
.hljs-quote {
  color: #999999;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
  color: #f2777a;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
  color: #f99157;
}

/* Tomorrow Yellow */
.hljs-attribute {
  color: #ffcc66;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
  color: #99cc99;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
  color: #6699cc;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
  color: #cc99cc;
}

.hljs {
  display: block;
  overflow-x: auto;
  background: #2d2d2d !important;
  color: #cccccc !important;
  padding: 1em !important;
}

pre{
    background: #2d2d2d !important;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}
</style>
<script type="text/javascript">
// $(function(){
// 	//代码高亮自定义
// 	$("code").each(function(){
// 		$(this).html("<ul><li>" + $(this).html().replace(/\n/g,"\n</li><li>") +"\n</li></ul>");
// 	});
// });
</script>

<style type="text/css">
/*.hljs {
	border: 0;
	font-family: "Consulas", "Courier New", Courier, mono, serif;
	font-size: 12px;
	background: #eee !important;
	display: block;
	padding: 1px;
	margin: 0;
	width: 100%;
	font-weight: 200;
	color: #333;
	white-space: pre-wrap
}*/
/*.hljs ul {
	list-style: decimal;
	background-color: #fff;
	margin: 0px 0px 0 0px !important;
	padding: 0px;
}*/
/*.hljs ul li {
	list-style: decimal-leading-zero;
	border-left: 1px solid #ddd !important;
	background: #fff;
	padding: 5px!important;
	margin: 0 !important;
  width: 20px !important;
	line-height: 14px;
	word-break: break-all;
	word-wrap: break-word;
}*/
/*.hljs ul li:nth-of-type(even) {
	background-color: #fcfcfc;
	color: inherit;
}*/
</style>
<script src="https://cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>
       <script >hljs.initHighlightingOnLoad();</script>  
         
    
             
           <style type="text/css">
           #rewardButton {
    cursor: pointer;
    border: 0;
    outline: 0;
    border-radius: 100%;
    padding: 0;
    margin: 0;
    letter-spacing: normal;
    text-transform: none;
    text-indent: 0px;
    text-shadow: none;
}
#rewardButton span {
    display: inline-block;
    width: 80px;
    height: 35px;
    border-radius: 5px;
    padding-top: 5px;
    color: #fff;
    font-weight: 400;
    font-style: normal;
    font-variant: normal;
    font-stretch: normal;
    font-size: 18px;
    font-family: "Microsoft Yahei";
    background: #F44336;
}
#rewardButton span:hover{
    background: #F7877F;
}
#QR{
    padding-top:20px;
}
#QR a{
    border:0;
}
#QR img{
    width: 180px;
    max-width: 100%;
    display: inline-block;
    margin: 0.8em 2em 0 2em;
}
#wechat:hover p{
    animation: roll 0.1s infinite linear;
    -webkit-animation: roll 0.1s infinite linear;
    -moz-animation: roll 0.1s infinite linear;
}
#alipay:hover p{
    animation: roll 0.1s infinite linear;
    -webkit-animation: roll 0.1s infinite linear;
    -moz-animation: roll 0.1s infinite linear;
}
@keyframes roll {
    from {
      transform(rotateZ(30deg));
    }
    to {
      transform(rotateZ(-30deg));
    }
}

           </style>
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/uploads/wechat.JPG" alt="人不如故 WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/uploads/ali.JPG" alt="人不如故 Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>
           


     
    
    
</div>


                

                <!-- Post Comments -->
                
                    




    <!-- 使用 DISQUS -->
    <div id="disqus-comment">
        <div id="disqus_thread"></div>
<script>
    var disqus_config = function () {
        this.page.url = 'https://wangyu1997.github.io/2017/11/08/JAVA/Java8中的Streams API/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'https://wangyu1997.github.io/2017/11/08/JAVA/Java8中的Streams API/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    queue.offer(function() {
            (function() { // DON'T EDIT BELOW THIS LINE
                var d = document;
                var s = d.createElement('script');
                s.src = '//https-wangyu1997-github-io.disqus.com/embed.js';
                s.setAttribute('data-timestamp', + new Date());
                (d.head || d.body).appendChild(s);
            })();
        });
</script>

    </div>
    <style>
        #disqus-comment{
            background-color: #eee;
            padding: 2pc;
        }
    </style>




                
            </div>

            <!-- Post Prev & Next Nav -->
            <nav class="material-nav mdl-color-text--grey-50 mdl-cell mdl-cell--12-col">
    <!-- Prev Nav -->
    

    <!-- Section Spacer -->
    <div class="section-spacer"></div>

    <!-- Next Nav -->
    
        <a href="/2017/11/08/JAVA/java8 方法引用/" id="post_nav-older" class="next-content">
            旧篇
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation">
                <i class="material-icons">arrow_forward</i>
            </button>
        </a>
    
</nav>

        </div>
    </div>



                    
                        <!-- Overlay For Active Sidebar -->
<div class="sidebar-overlay"></div>

<!-- Material sidebar -->
<aside id="sidebar" class="sidebar sidebar-colored sidebar-fixed-left" role="navigation">
    <div id="sidebar-main">
        <!-- Sidebar Header -->
        <div class="sidebar-header header-cover" style="background-image: url(/img/sidebar_header.png);">
    <!-- Top bar -->
    <div class="top-bar"></div>

    <!-- Sidebar toggle button -->
    <button type="button" class="sidebar-toggle mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon" style="display: initial;" data-upgraded=",MaterialButton,MaterialRipple">
        <i class="material-icons">clear_all</i>
        <span class="mdl-button__ripple-container">
            <span class="mdl-ripple">
            </span>
        </span>
    </button>

    <!-- Sidebar Avatar -->
    <div class="sidebar-image">
        <img src="/img/avatar.png" alt="人不如故's avatar">
    </div>

    <!-- Sidebar Email -->
    <a data-toggle="dropdown" class="sidebar-brand" href="#settings-dropdown">
        wangyu19970819@gmail.com
        <b class="caret"></b>
    </a>
</div>


        <!-- Sidebar Navigation  -->
        <ul class="nav sidebar-nav">
    <!-- User dropdown  -->
    <li class="dropdown">
        <ul id="settings-dropdown" class="dropdown-menu">
            
                <li>
             
                    <a href="mailto:wangyu19970819@gmail.com" target="_blank" title="Email Me">
               
                        
                            <i class="material-icons sidebar-material-icons sidebar-indent-left1pc-element">email</i>
                        
                        Email Me
                    </a>
                </li>
            
                <li>
             
                    <a href="/about" target="_self" title="关于">
              
                        
                            <i class="material-icons sidebar-material-icons sidebar-indent-left1pc-element">person</i>
                        
                        关于
                    </a>
                </li>
            
        </ul>
    </li>

    <!-- Homepage -->
    
        <li id="sidebar-first-li">
            <a href="/" target="_self">
                
                    <i class="material-icons sidebar-material-icons">home</i>
                
                主页
            </a>
        </li>
        
    


    <!-- Categories  -->
    
        <li class="dropdown">
            <a href="#" class="ripple-effect dropdown-toggle" data-toggle="dropdown">
                
                    <i class="material-icons sidebar-material-icons">chrome_reader_mode</i>
                
                分类
                <b class="caret"></b>
            </a>
            <ul class="dropdown-menu">
                <li>
                <a class="sidebar_archives-link" href="/categories/Android/">Android<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/categories/Java/">Java<span class="sidebar_archives-count">2</span></a></li><li><a class="sidebar_archives-link" href="/categories/JavaWeb/">JavaWeb<span class="sidebar_archives-count">7</span></a></li><li><a class="sidebar_archives-link" href="/categories/Python/">Python<span class="sidebar_archives-count">5</span></a></li><li><a class="sidebar_archives-link" href="/categories/Spring/">Spring<span class="sidebar_archives-count">8</span></a></li><li><a class="sidebar_archives-link" href="/categories/VueJs/">VueJs<span class="sidebar_archives-count">5</span></a></li><li><a class="sidebar_archives-link" href="/categories/iOS/">iOS<span class="sidebar_archives-count">6</span></a></li><li><a class="sidebar_archives-link" href="/categories/machine-learning/">machine learning<span class="sidebar_archives-count">2</span></a></li><li><a class="sidebar_archives-link" href="/categories/操作系统/">操作系统<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/categories/杂记/">杂记<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/categories/组成原理/">组成原理<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/categories/计算机网络/">计算机网络<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/categories/那些年倒腾过的服务器/">那些年倒腾过的服务器<span class="sidebar_archives-count">3</span></a>
            </ul>
        </li>
        
    

    <!-- Pages  -->
    
        <li>
            <a href="/links" title="小伙伴们">
                
                    <i class="material-icons sidebar-material-icons">group</i>
                
                小伙伴们
            </a>
        </li>
        
    
        <li>
            <a href="/tags" title="标签">
                
                    <i class="material-icons sidebar-material-icons">loyalty</i>
                
                标签
            </a>
        </li>
        
    

            <!-- Archives  -->
    
        <li class="dropdown">
            <a href="#" class="ripple-effect dropdown-toggle" data-toggle="dropdown">
                
                    <i class="material-icons sidebar-material-icons">inbox</i>
                
                    归档
                <b class="caret"></b>
            </a>
            <ul class="dropdown-menu">
            <li>
                <a class="sidebar_archives-link" href="/archives/2017/11/">十一月 2017<span class="sidebar_archives-count">4</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/10/">十月 2017<span class="sidebar_archives-count">17</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/09/">九月 2017<span class="sidebar_archives-count">3</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/08/">八月 2017<span class="sidebar_archives-count">2</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/07/">七月 2017<span class="sidebar_archives-count">7</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/06/">六月 2017<span class="sidebar_archives-count">7</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/05/">五月 2017<span class="sidebar_archives-count">3</span></a>
            </ul>
        </li>
        
    

          <!-- rss -->
    
        <li id="sidebar-first-li">
            <a href="/gallery" target="_self">
                
                    <i class="material-icons sidebar-material-icons">favorite</i>
                
                情愫
            </a>
        </li>
        
    

      <!-- board -->
    
        <li id="sidebar-first-li">
            <a href="/board" target="_self">
                
                    <i class="material-icons sidebar-material-icons">question_answer</i>
                
                留言板
            </a>
        </li>
        
    

      <!-- rss -->
    
        <li id="sidebar-first-li">
            <a href="/atom.xml" target="_blank">
                
                    <i class="material-icons sidebar-material-icons">cast_connected</i>
                
                RSS订阅
            </a>
        </li>
        
            <li class="divider"></li>
        
    

    <!-- Article Number  -->
    
        <li>
            <a href="/archives">
                文章总数
                <span class="sidebar-badge">43</span>
            </a>
        </li>
        
    
</ul>


        <!-- Sidebar Footer -->
        <!--
I'm glad you use this theme, the development is no so easy, I hope you can keep the copyright, I will thank you so much.
If you still want to delete the copyrights, could you still retain the first one? Which namely "Theme Material"
It will not impact the appearance and can give developers a lot of support :)

很高兴您使用并喜欢该主题，开发不易 十分谢谢与希望您可以保留一下版权声明。
如果您仍然想删除的话 能否只保留第一项呢？即 "Theme Material"
它不会影响美观并可以给开发者很大的支持和动力。 :)
-->

<!-- Sidebar Divider -->


<!-- Theme Material -->


<!-- Help & Support -->
<!--

-->

<!-- Feedback -->
<!--

-->

<!-- About Theme -->
<!--

-->

    </div>

    <!-- Sidebar Image -->
    

</aside>

                    

                    
                        <!-- Footer Top Button -->
                        <div class="toTop-wrap">
    <a href="#top" class="toTop">
        <i class="material-icons footer_top-i">expand_less</i>
    </a>
</div>

                    

                    
 
  <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
   <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  
 


                    <!--Footer-->
<footer class="mdl-mini-footer" id="bottom">
    
        <!-- Paradox Footer Left Section -->
        <div class="mdl-mini-footer--left-section sns-list">
    <!-- Twitter -->
    

    <!-- Facebook -->
    
        <a href="https://www.facebook.com/renburugu" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn" style="background-image: url(/img/footer/footer_ico-facebook.svg);">
                <span class="visuallyhidden">Facebook</span>
            </button><!--
     --></a>
    

    <!-- Google + -->
    

    <!-- Weibo -->
    

    <!-- Instagram -->
    

    <!-- Tumblr -->
    

    <!-- Github -->
    
        <a href="https://github.com/wangyu1997" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn" style="background-image: url(/img/footer/footer_ico-github.svg);">
                <span class="visuallyhidden">Github</span>
            </button><!--
     --></a>
    

    <!-- LinkedIn -->
    

    <!-- Zhihu -->
    

    <!-- Bilibili -->
    

    <!-- Telegram -->
    
</div>


        <!--Copyright-->
        <div id="copyright">
            Copyright&nbsp;©&nbsp;
            <script type="text/javascript">
                var fd = new Date();
                document.write(fd.getFullYear());
            </script>
            &nbsp;人不如故
        </div>

        <!-- Paradox Footer Right Section -->

        <!--
        I am glad you use this theme, the development is no so easy, I hope you can keep the copyright.
        It will not impact the appearance and can give developers a lot of support :)

        很高兴您使用该主题，开发不易，希望您可以保留一下版权声明。
        它不会影响美观并可以给开发者很大的支持。 :)
        -->

        <div class="mdl-mini-footer--right-section">
            <div>
                <div class="footer-develop-div">Follow me on - <a href="https://www.facebook.com/renburugu" target="_blank" class="footer-develop-a">FaceTime</a></div>
                <div class="footer-develop-div">Fork me on - <a href="https://github.com/wangyu1997" target="_blank" class="footer-develop-a">GitHub</a></div>
            </div>
        </div>
    
</footer>


                    <!-- Import File -->

    <script src="/js/lazyload.min.js"></script>
    <script src="/js/js.min.js"></script>



    <script src="/js/nprogress.js"></script>


<script type="text/javascript">
    NProgress.configure({
        showSpinner: true
    });
    NProgress.start();
    $('#nprogress .bar').css({
        'background': '#29d'
    });
    $('#nprogress .peg').css({
        'box-shadow': '0 0 10px #29d, 0 0 15px #29d'
    });
    $('#nprogress .spinner-icon').css({
        'border-top-color': '#29d',
        'border-left-color': '#29d'
    });
    setTimeout(function() {
        NProgress.done();
        $('.fade').removeClass('out');
    }, 800);
</script>



    
        <script src="/js/smoothscroll.js"></script>
    





    <!-- Busuanzi -->
    <script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>







    <!-- 使用 DISQUS js 代码 -->
    <script id="dsq-count-scr" src="//https-wangyu1997-github-io.disqus.com/count.js" async></script>





<!-- Window Load-->
<script>
    $(window).load(function() {
        // Post_Toc parent position fixed
        $('.post-toc-wrap').parent('.mdl-menu__container').css('position', 'fixed');
    });
</script>

<!-- MathJax Load-->

<script>
    <!-- Offer LazyLoad -->
    queue.offer(function(){
        $('.lazy').lazyload({
            effect : 'show'
        });
    });

    <!-- Start Queue -->
    $(document).ready(function(){
        setTimeout(function(){
            setInterval(function(){
                queue.execNext();
            },200);
        },3000);
    });
</script>

                </main>
            </div>
        </body>
    
</html>
