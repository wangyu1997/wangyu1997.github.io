<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>人不如故</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wangyu1997.github.io/"/>
  <updated>2017-11-08T14:22:38.000Z</updated>
  <id>https://wangyu1997.github.io/</id>
  
  <author>
    <name>人不如故</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java8中的streams API详解</title>
    <link href="https://wangyu1997.github.io/2017/11/08/JAVA/Java8%E4%B8%AD%E7%9A%84Streams%20API/"/>
    <id>https://wangyu1997.github.io/2017/11/08/JAVA/Java8中的Streams API/</id>
    <published>2017-11-08T14:38:11.000Z</published>
    <updated>2017-11-08T14:22:38.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p>Streams 的背景，以及 Java 8 中的使用详解 </p>
<h2 id="为什么需要-Stream"><a href="#为什么需要-Stream" class="headerlink" title="为什么需要 Stream"></a>为什么需要 Stream</h2><p>Stream 作为 Java 8 的一大亮点，它与 java.io 包里的 InputStream 和 OutputStream 是完全不同的概念。它也不同于 StAX 对 XML 解析的 Stream，也不是 Amazon Kinesis 对大数据实时处理的 Stream。Java 8 中的 Stream 是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation），或者大批量数据操作 (bulk data operation)。Stream API 借助于同样新出现的 Lambda 表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork/join 并行方式来拆分任务和加速处理过程。通常编写并行代码很难而且容易出错, 但使用 Stream API 无需编写一行多线程的代码，就可以很方便地写出高性能的并发程序。所以说，Java 8 中首次出现的 java.util.stream 是一个函数式语言+多核时代综合影响的产物。 </p>
<h3 id="什么是聚合操作"><a href="#什么是聚合操作" class="headerlink" title="什么是聚合操作"></a>什么是聚合操作</h3><p>在传统的 J2EE 应用中，Java 代码经常不得不依赖于关系型数据库的聚合操作来完成诸如： </p>
<ul>
<li>客户每月平均消费金额</li>
<li>最昂贵的在售商品</li>
<li>本周完成的有效订单（排除了无效的）</li>
<li>取十个数据样本作为首页推荐</li>
</ul>
<p>这类的操作。 </p>
<p>但在当今这个数据大爆炸的时代，在数据来源多样化、数据海量化的今天，很多时候不得不脱离 RDBMS，或者以底层返回的数据为基础进行更上层的数据统计。而 Java 的集合 API 中，仅仅有极少量的辅助型方法，更多的时候是程序员需要用 Iterator 来遍历集合，完成相关的聚合应用逻辑。这是一种远不够高效、笨拙的方法。在 Java 7 中，如果要发现 type 为 grocery 的所有交易，然后返回以交易值降序排序好的交易 ID 集合，我们需要这样写： </p>
<h5 id="清单-1-Java-7-的排序、取值实现"><a href="#清单-1-Java-7-的排序、取值实现" class="headerlink" title="清单 1. Java 7 的排序、取值实现"></a>清单 1. Java 7 的排序、取值实现</h5><pre><code>List&lt;Transaction&gt; groceryTransactions = new Arraylist&lt;&gt;();
for(Transaction t: transactions){
 if(t.getType() == Transaction.GROCERY){
 groceryTransactions.add(t);
 }
}
Collections.sort(groceryTransactions, new Comparator(){
 public int compare(Transaction t1, Transaction t2){
 return t2.getValue().compareTo(t1.getValue());
 }
});
List&lt;Integer&gt; transactionIds = new ArrayList&lt;&gt;();
for(Transaction t: groceryTransactions){
 transactionsIds.add(t.getId());
}
</code></pre><p>而在 Java 8 使用 Stream，代码更加简洁易读；而且使用并发模式，程序执行速度更快。 </p>
<h5 id="清单-2-Java-8-的排序、取值实现"><a href="#清单-2-Java-8-的排序、取值实现" class="headerlink" title="清单 2. Java 8 的排序、取值实现"></a>清单 2. Java 8 的排序、取值实现</h5><pre><code>List&lt;Integer&gt; transactionsIds = transactions.parallelStream().
 filter(t -&gt; t.getType() == Transaction.GROCERY).
 sorted(comparing(Transaction::getValue).reversed()).
 map(Transaction::getId).
 collect(toList());
</code></pre><h2 id="Stream-总览"><a href="#Stream-总览" class="headerlink" title="Stream 总览"></a>Stream 总览</h2><h3 id="什么是流"><a href="#什么是流" class="headerlink" title="什么是流"></a>什么是流</h3><p>Stream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的 Iterator。原始版本的 Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的 Stream，用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。 </p>
<p>Stream 就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。 </p>
<p>而和迭代器又不同的是，Stream 可以并行化操作，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方式去遍历时，每个 item 读完后再读下一个 item。而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。Stream 的并行操作依赖于 Java7 中引入的 Fork/Join 框架（JSR166y）来拆分任务和加速处理过程。Java 的并行 API 演变历程基本如下： </p>
<ol>
<li>1.0-1.4 中的 java.lang.Thread</li>
<li>5.0 中的 java.util.concurrent</li>
<li>6.0 中的 Phasers 等</li>
<li>7.0 中的 Fork/Join 框架</li>
<li>8.0 中的 Lambda</li>
</ol>
<p>Stream 的另外一大特点是，数据源本身可以是无限的。 </p>
<h3 id="流的构成"><a href="#流的构成" class="headerlink" title="流的构成"></a>流的构成</h3><p>当我们使用一个流的时候，通常包括三个基本步骤： </p>
<p>获取一个数据源（source）→ 数据转换→执行操作获取想要的结果，每次转换原有 Stream 对象不改变，返回一个新的 Stream 对象（可以有多次转换），这就允许对其操作可以像链条一样排列，变成一个管道，如下图所示。 </p>
<h5 id="图-1-流管道-Stream-Pipeline-的构成"><a href="#图-1-流管道-Stream-Pipeline-的构成" class="headerlink" title="图 1. 流管道 (Stream Pipeline) 的构成"></a>图 1. 流管道 (Stream Pipeline) 的构成</h5><p><img src="http://oq5d32gij.bkt.clouddn.com/15101508417650.png" alt=""></p>
<p>有多种方式生成 Stream Source： </p>
<ul>
<li>从 Collection 和数组</li>
<li><ul>
<li>Collection.stream()</li>
<li>Collection.parallelStream()</li>
<li>Arrays.stream(T array) or Stream.of()<br>从 BufferedReader</li>
<li>java.io.BufferedReader.lines()</li>
</ul>
</li>
<li>静态工厂</li>
<li>java.util.stream.IntStream.range()</li>
<li>java.nio.file.Files.walk()</li>
<li>自己构建</li>
<li><ul>
<li>java.util.Spliterator<br>其它</li>
<li>Random.ints()</li>
<li>BitSet.stream()</li>
<li>Pattern.splitAsStream(java.lang.CharSequence)</li>
<li>JarFile.stream()</li>
</ul>
</li>
</ul>
<p>流的操作类型分为两种： </p>
<ul>
<li><strong>Intermediate</strong>：一个流可以后面跟随零个或多个 intermediate 操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历。</li>
<li><strong>Terminal</strong>：一个流只能有一个 terminal 操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。Terminal 操作的执行，才会真正开始流的遍历，并且会生成一个结果，或者一个 side effect。</li>
</ul>
<p>在对于一个 Stream 进行多次转换操作 (Intermediate 操作)，每次都对 Stream 的每个元素进行转换，而且是执行多次，这样时间复杂度就是 N（转换次数）个 for 循环里把所有操作都做掉的总和吗？其实不是这样的，转换操作都是 lazy 的，多个转换操作只会在 Terminal 操作的时候融合起来，一次循环完成。我们可以这样简单的理解，Stream 里有个操作函数的集合，每次转换操作就是把转换函数放入这个集合中，在 Terminal 操作的时候循环 Stream 对应的集合，然后对每个元素执行所有的函数。 </p>
<p>还有一种操作被称为 <strong>short-circuiting</strong>。用以指： </p>
<ul>
<li>对于一个 intermediate 操作，如果它接受的是一个无限大（infinite/unbounded）的 Stream，但返回一个有限的新 Stream。</li>
<li>对于一个 terminal 操作，如果它接受的是一个无限大的 Stream，但能在有限的时间计算出结果。</li>
</ul>
<p>当操作一个无限大的 Stream，而又希望在有限时间内完成操作，则在管道内拥有一个 short-circuiting 操作是必要非充分条件。 </p>
<h5 id="清单-3-一个流操作的示例"><a href="#清单-3-一个流操作的示例" class="headerlink" title="清单 3. 一个流操作的示例"></a>清单 3. 一个流操作的示例</h5><pre><code>int sum = widgets.stream()
.filter(w -&gt; w.getColor() == RED)
 .mapToInt(w -&gt; w.getWeight())
 .sum();
</code></pre><p>stream() 获取当前小物件的 source，filter 和 mapToInt 为 intermediate 操作，进行数据筛选和转换，最后一个 sum() 为 terminal 操作，对符合条件的全部小物件作重量求和。 </p>
<h2 id="流的使用详解"><a href="#流的使用详解" class="headerlink" title="流的使用详解"></a>流的使用详解</h2><p>简单说，对 Stream 的使用就是实现一个 filter-map-reduce 过程，产生一个最终结果，或者导致一个副作用（side effect）。 </p>
<h3 id="流的构造与转换"><a href="#流的构造与转换" class="headerlink" title="流的构造与转换"></a>流的构造与转换</h3><p>下面提供最常见的几种构造 Stream 的样例。 </p>
<h5 id="清单-4-构造流的几种常见方法"><a href="#清单-4-构造流的几种常见方法" class="headerlink" title="清单 4. 构造流的几种常见方法"></a>清单 4. 构造流的几种常见方法</h5><pre><code>// 1. Individual values
Stream stream = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);
// 2. Arrays
String [] strArray = new String[] {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;};
stream = Stream.of(strArray);
stream = Arrays.stream(strArray);
// 3. Collections
List&lt;String&gt; list = Arrays.asList(strArray);
stream = list.stream();
</code></pre><p>需要注意的是，对于基本数值型，目前有三种对应的包装类型 Stream： </p>
<p>IntStream、LongStream、DoubleStream。当然我们也可以用 Stream<integer>、Stream<long> &gt;、Stream<double>，但是 boxing 和 unboxing 会很耗时，所以特别为这三种基本数值型提供了对应的 Stream。 </double></long></integer></p>
<p>Java 8 中还没有提供其它数值型 Stream，因为这将导致扩增的内容较多。而常规的数值型聚合运算可以通过上面三种 Stream 进行。 </p>
<h5 id="清单-5-数值流的构造"><a href="#清单-5-数值流的构造" class="headerlink" title="清单 5. 数值流的构造"></a>清单 5. 数值流的构造</h5><pre><code>IntStream.of(new int[]{1, 2, 3}).forEach(System.out::println);
IntStream.range(1, 3).forEach(System.out::println);
IntStream.rangeClosed(1, 3).forEach(System.out::println);
</code></pre><h5 id="清单-6-流转换为其它数据结构"><a href="#清单-6-流转换为其它数据结构" class="headerlink" title="清单 6. 流转换为其它数据结构"></a>清单 6. 流转换为其它数据结构</h5><pre><code>// 1. Array
String[] strArray1 = stream.toArray(String[]::new);
// 2. Collection
List&lt;String&gt; list1 = stream.collect(Collectors.toList());
List&lt;String&gt; list2 = stream.collect(Collectors.toCollection(ArrayList::new));
Set set1 = stream.collect(Collectors.toSet());
Stack stack1 = stream.collect(Collectors.toCollection(Stack::new));
// 3. String
String str = stream.collect(Collectors.joining()).toString();
</code></pre><p>一个 Stream 只可以使用一次，上面的代码为了简洁而重复使用了数次。 </p>
<h3 id="流的操作"><a href="#流的操作" class="headerlink" title="流的操作"></a>流的操作</h3><p>接下来，当把一个数据结构包装成 Stream 后，就要开始对里面的元素进行各类操作了。常见的操作可以归类如下。 </p>
<ul>
<li>Intermediate：</li>
</ul>
<p>map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、 skip、 parallel、 sequential、 unordered </p>
<ul>
<li>Terminal：</li>
</ul>
<p>forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、 anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 iterator </p>
<ul>
<li>Short-circuiting：</li>
</ul>
<p>anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 limit </p>
<p>我们下面看一下 Stream 的比较典型用法。 </p>
<p><strong>map/flatMap</strong></p>
<p>我们先来看 map。如果你熟悉 scala 这类函数式语言，对这个方法应该很了解，它的作用就是把 input Stream 的每一个元素，映射成 output Stream 的另外一个元素。 </p>
<h5 id="清单-7-转换大写"><a href="#清单-7-转换大写" class="headerlink" title="清单 7. 转换大写"></a>清单 7. 转换大写</h5><pre><code>List&lt;String&gt; output = wordList.stream().
map(String::toUpperCase).
collect(Collectors.toList());
</code></pre><p>这段代码把所有的单词转换为大写。 </p>
<h5 id="清单-8-平方数"><a href="#清单-8-平方数" class="headerlink" title="清单 8. 平方数"></a>清单 8. 平方数</h5><pre><code>List&lt;Integer&gt; nums = Arrays.asList(1, 2, 3, 4);
List&lt;Integer&gt; squareNums = nums.stream().
map(n -&gt; n * n).
collect(Collectors.toList());
</code></pre><p>这段代码生成一个整数 list 的平方数 {1, 4, 9, 16}。 </p>
<p>从上面例子可以看出，map 生成的是个 1:1 映射，每个输入元素，都按照规则转换成为另外一个元素。还有一些场景，是一对多映射关系的，这时需要 flatMap。 </p>
<h5 id="清单-9-一对多"><a href="#清单-9-一对多" class="headerlink" title="清单 9. 一对多"></a>清单 9. 一对多</h5><pre><code>Stream&lt;List&lt;Integer&gt;&gt; inputStream = Stream.of(
 Arrays.asList(1),
 Arrays.asList(2, 3),
 Arrays.asList(4, 5, 6)
 );
Stream&lt;Integer&gt; outputStream = inputStream.
flatMap((childList) -&gt; childList.stream());
</code></pre><p>flatMap 把 input Stream 中的层级结构扁平化，就是将最底层元素抽出来放到一起，最终 output 的新 Stream 里面已经没有 List 了，都是直接的数字。 </p>
<p><strong>filter</strong></p>
<p>filter 对原始 Stream 进行某项测试，通过测试的元素被留下来生成一个新 Stream。 </p>
<h5 id="清单-10-留下偶数"><a href="#清单-10-留下偶数" class="headerlink" title="清单 10. 留下偶数"></a>清单 10. 留下偶数</h5><pre><code>Integer[] sixNums = {1, 2, 3, 4, 5, 6};
Integer[] evens =
Stream.of(sixNums).filter(n -&gt; n%2 == 0).toArray(Integer[]::new);
</code></pre><p>经过条件“被 2 整除”的 filter，剩下的数字为 {2, 4, 6}。 </p>
<h5 id="清单-11-把单词挑出来"><a href="#清单-11-把单词挑出来" class="headerlink" title="清单 11. 把单词挑出来"></a>清单 11. 把单词挑出来</h5><pre><code>List&lt;String&gt; output = reader.lines().
 flatMap(line -&gt; Stream.of(line.split(REGEXP))).
 filter(word -&gt; word.length() &gt; 0).
 collect(Collectors.toList());
</code></pre><p>这段代码首先把每行的单词用 flatMap 整理到新的 Stream，然后保留长度不为 0 的，就是整篇文章中的全部单词了。 </p>
<p><strong>forEach</strong></p>
<p>forEach 方法接收一个 Lambda 表达式，然后在 Stream 的每一个元素上执行该表达式。 </p>
<h5 id="清单-12-打印姓名（forEach-和-pre-java8-的对比）"><a href="#清单-12-打印姓名（forEach-和-pre-java8-的对比）" class="headerlink" title="清单 12. 打印姓名（forEach 和 pre-java8 的对比）"></a>清单 12. 打印姓名（forEach 和 pre-java8 的对比）</h5><pre><code>// Java 8
roster.stream()
 .filter(p -&gt; p.getGender() == Person.Sex.MALE)
 .forEach(p -&gt; System.out.println(p.getName()));
// Pre-Java 8
for (Person p : roster) {
 if (p.getGender() == Person.Sex.MALE) {
 System.out.println(p.getName());
 }
}
</code></pre><p>对一个人员集合遍历，找出男性并打印姓名。可以看出来，forEach 是为 Lambda 而设计的，保持了最紧凑的风格。而且 Lambda 表达式本身是可以重用的，非常方便。当需要为多核系统优化时，可以 parallelStream().forEach()，只是此时原有元素的次序没法保证，并行的情况下将改变串行时操作的行为，此时 forEach 本身的实现不需要调整，而 Java8 以前的 for 循环 code 可能需要加入额外的多线程逻辑。 </p>
<p>但一般认为，forEach 和常规 for 循环的差异不涉及到性能，它们仅仅是函数式风格与传统 Java 风格的差别。 </p>
<p>另外一点需要注意，forEach 是 terminal 操作，因此它执行后，Stream 的元素就被“消费”掉了，你无法对一个 Stream 进行两次 terminal 运算。下面的代码是错误的： </p>
<pre><code>     stream.forEach(element -&gt; doOneThing(element));
     stream.forEach(element -&gt; doAnotherThing(element));
</code></pre><p>相反，具有相似功能的 intermediate 操作 peek 可以达到上述目的。如下是出现在该 api javadoc 上的一个示例。 </p>
<h5 id="清单-13-peek-对每个元素执行操作并返回一个新的-Stream"><a href="#清单-13-peek-对每个元素执行操作并返回一个新的-Stream" class="headerlink" title="清单 13. peek 对每个元素执行操作并返回一个新的 Stream"></a>清单 13. peek 对每个元素执行操作并返回一个新的 Stream</h5><pre><code>Stream.of(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;)
 .filter(e -&gt; e.length() &gt; 3)
 .peek(e -&gt; System.out.println(&quot;Filtered value: &quot; + e))
 .map(String::toUpperCase)
 .peek(e -&gt; System.out.println(&quot;Mapped value: &quot; + e))
 .collect(Collectors.toList());
</code></pre><p>forEach 不能修改自己包含的本地变量值，也不能用 break/return 之类的关键字提前结束循环。 </p>
<p><strong>findFirst</strong></p>
<p>这是一个 termimal 兼 short-circuiting 操作，它总是返回 Stream 的第一个元素，或者空。 </p>
<p>这里比较重点的是它的返回值类型：Optional。这也是一个模仿 Scala 语言中的概念，作为一个容器，它可能含有某值，或者不包含。使用它的目的是尽可能避免 NullPointerException。 </p>
<h5 id="清单-14-Optional-的两个用例"><a href="#清单-14-Optional-的两个用例" class="headerlink" title="清单 14. Optional 的两个用例"></a>清单 14. Optional 的两个用例</h5><pre><code>String strA = &quot; abcd &quot;, strB = null;
print(strA);
print(&quot;&quot;);
print(strB);
getLength(strA);
getLength(&quot;&quot;);
getLength(strB);
public static void print(String text) {
 // Java 8
 Optional.ofNullable(text).ifPresent(System.out::println);
 // Pre-Java 8
 if (text != null) {
 System.out.println(text);
 }
 }
public static int getLength(String text) {
 // Java 8
return Optional.ofNullable(text).map(String::length).orElse(-1);
 // Pre-Java 8
// return if (text != null) ? text.length() : -1;
 };
</code></pre><p>在更复杂的 if (xx != null) 的情况中，使用 Optional 代码的可读性更好，而且它提供的是编译时检查，能极大的降低 NPE 这种 Runtime Exception 对程序的影响，或者迫使程序员更早的在编码阶段处理空值问题，而不是留到运行时再发现和调试。 </p>
<p>Stream 中的 findAny、max/min、reduce 等方法等返回 Optional 值。还有例如 IntStream.average() 返回 OptionalDouble 等等。 </p>
<p><strong>reduce</strong></p>
<p>这个方法的主要作用是把 Stream 元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合。从这个意义上说，字符串拼接、数值的 sum、min、max、average 都是特殊的 reduce。例如 Stream 的 sum 就相当于 </p>
<p>Integer sum = integers.reduce(0, (a, b) -&gt; a+b); 或 </p>
<p>Integer sum = integers.reduce(0, Integer::sum); </p>
<p>也有没有起始值的情况，这时会把 Stream 的前面两个元素组合起来，返回的是 Optional。 </p>
<h5 id="清单-15-reduce-的用例"><a href="#清单-15-reduce-的用例" class="headerlink" title="清单 15. reduce 的用例"></a>清单 15. reduce 的用例</h5><pre><code>// 字符串连接，concat = &quot;ABCD&quot;
String concat = Stream.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;).reduce(&quot;&quot;, String::concat); 
// 求最小值，minValue = -3.0
double minValue = Stream.of(-1.5, 1.0, -3.0, -2.0).reduce(Double.MAX_VALUE, Double::min); 
// 求和，sumValue = 10, 有起始值
int sumValue = Stream.of(1, 2, 3, 4).reduce(0, Integer::sum);
// 求和，sumValue = 10, 无起始值
sumValue = Stream.of(1, 2, 3, 4).reduce(Integer::sum).get();
// 过滤，字符串连接，concat = &quot;ace&quot;
concat = Stream.of(&quot;a&quot;, &quot;B&quot;, &quot;c&quot;, &quot;D&quot;, &quot;e&quot;, &quot;F&quot;).
 filter(x -&gt; x.compareTo(&quot;Z&quot;) &gt; 0).
 reduce(&quot;&quot;, String::concat);
</code></pre><p>上面代码例如第一个示例的 reduce()，第一个参数（空白字符）即为起始值，第二个参数（String::concat）为 BinaryOperator。这类有起始值的 reduce() 都返回具体的对象。而对于第四个示例没有起始值的 reduce()，由于可能没有足够的元素，返回的是 Optional，请留意这个区别。 </p>
<p><strong>limit/skip</strong></p>
<p>limit 返回 Stream 的前面 n 个元素；skip 则是扔掉前 n 个元素（它是由一个叫 subStream 的方法改名而来）。 </p>
<h5 id="清单-16-limit-和-skip-对运行次数的影响"><a href="#清单-16-limit-和-skip-对运行次数的影响" class="headerlink" title="清单 16. limit 和 skip 对运行次数的影响"></a>清单 16. limit 和 skip 对运行次数的影响</h5><pre><code>public void testLimitAndSkip() {
 List&lt;Person&gt; persons = new ArrayList();
 for (int i = 1; i &lt;= 10000; i++) {
 Person person = new Person(i, &quot;name&quot; + i);
 persons.add(person);
 }
List&lt;String&gt; personList2 = persons.stream().
map(Person::getName).limit(10).skip(3).collect(Collectors.toList());
 System.out.println(personList2);
}
private class Person {
 public int no;
 private String name;
 public Person (int no, String name) {
 this.no = no;
 this.name = name;
 }
 public String getName() {
 System.out.println(name);
 return name;
 }
}
</code></pre><p>输出结果为： </p>
<pre><code>name1
name2
name3
name4
name5
name6
name7
name8
name9
name10
[name4, name5, name6, name7, name8, name9, name10]
</code></pre><p>这是一个有 10，000 个元素的 Stream，但在 short-circuiting 操作 limit 和 skip 的作用下，管道中 map 操作指定的 getName() 方法的执行次数为 limit 所限定的 10 次，而最终返回结果在跳过前 3 个元素后只有后面 7 个返回。 </p>
<p>有一种情况是 limit/skip 无法达到 short-circuiting 目的的，就是把它们放在 Stream 的排序操作后，原因跟 sorted 这个 intermediate 操作有关：此时系统并不知道 Stream 排序后的次序如何，所以 sorted 中的操作看上去就像完全没有被 limit 或者 skip 一样。 </p>
<h5 id="清单-17-limit-和-skip-对-sorted-后的运行次数无影响"><a href="#清单-17-limit-和-skip-对-sorted-后的运行次数无影响" class="headerlink" title="清单 17. limit 和 skip 对 sorted 后的运行次数无影响"></a>清单 17. limit 和 skip 对 sorted 后的运行次数无影响</h5><pre><code>List&lt;Person&gt; persons = new ArrayList();
 for (int i = 1; i &lt;= 5; i++) {
 Person person = new Person(i, &quot;name&quot; + i);
 persons.add(person);
 }
List&lt;Person&gt; personList2 = persons.stream().sorted((p1, p2) -&gt; 
p1.getName().compareTo(p2.getName())).limit(2).collect(Collectors.toList());
System.out.println(personList2);
</code></pre><p>上面的示例对清单 13 做了微调，首先对 5 个元素的 Stream 排序，然后进行 limit 操作。输出结果为： </p>
<pre><code> name2
name1
name3
name2
name4
name3
name5
name4
[stream.StreamDW$Person@816f27d, stream.StreamDW$Person@87aac27]
</code></pre><p>即虽然最后的返回元素数量是 2，但整个管道中的 sorted 表达式执行次数没有像前面例子相应减少。 </p>
<p>最后有一点需要注意的是，对一个 parallel 的 Steam 管道来说，如果其元素是有序的，那么 limit 操作的成本会比较大，因为它的返回对象必须是前 n 个也有一样次序的元素。取而代之的策略是取消元素间的次序，或者不要用 parallel Stream。 </p>
<p><strong>sorted</strong></p>
<p>对 Stream 的排序通过 sorted 进行，它比数组的排序更强之处在于你可以首先对 Stream 进行各类 map、filter、limit、skip 甚至 distinct 来减少元素数量后，再排序，这能帮助程序明显缩短执行时间。我们对清单 14 进行优化： </p>
<h5 id="清单-18-优化：排序前进行-limit-和-skip"><a href="#清单-18-优化：排序前进行-limit-和-skip" class="headerlink" title="清单 18. 优化：排序前进行 limit 和 skip"></a>清单 18. 优化：排序前进行 limit 和 skip</h5><pre><code>List&lt;Person&gt; persons = new ArrayList();
 for (int i = 1; i &lt;= 5; i++) {
 Person person = new Person(i, &quot;name&quot; + i);
 persons.add(person);
 }
List&lt;Person&gt; personList2 = persons.stream().limit(2).sorted((p1, p2) -&gt; p1.getName().compareTo(p2.getName())).collect(Collectors.toList());
System.out.println(personList2);
</code></pre><p>结果会简单很多： </p>
<pre><code>name2
name1
[stream.StreamDW$Person@6ce253f1, stream.StreamDW$Person@53d8d10a]
</code></pre><p>当然，这种优化是有 business logic 上的局限性的：即不要求排序后再取值。 </p>
<p><strong>min/max/distinct</strong></p>
<p>min 和 max 的功能也可以通过对 Stream 元素先排序，再 findFirst 来实现，但前者的性能会更好，为 O(n)，而 sorted 的成本是 O(n log n)。同时它们作为特殊的 reduce 方法被独立出来也是因为求最大最小值是很常见的操作。 </p>
<h5 id="清单-19-找出最长一行的长度"><a href="#清单-19-找出最长一行的长度" class="headerlink" title="清单 19. 找出最长一行的长度"></a>清单 19. 找出最长一行的长度</h5><pre><code>BufferedReader br = new BufferedReader(new FileReader(&quot;c:\\SUService.log&quot;));
int longest = br.lines().
 mapToInt(String::length).
 max().
 getAsInt();
br.close();
System.out.println(longest);
</code></pre><p>下面的例子则使用 distinct 来找出不重复的单词。 </p>
<h5 id="清单-20-找出全文的单词，转小写，并排序"><a href="#清单-20-找出全文的单词，转小写，并排序" class="headerlink" title="清单 20. 找出全文的单词，转小写，并排序"></a>清单 20. 找出全文的单词，转小写，并排序</h5><pre><code>List&lt;String&gt; words = br.lines().
 flatMap(line -&gt; Stream.of(line.split(&quot; &quot;))).
 filter(word -&gt; word.length() &gt; 0).
 map(String::toLowerCase).
 distinct().
 sorted().
 collect(Collectors.toList());
br.close();
System.out.println(words);
</code></pre><p><strong>Match</strong></p>
<p>Stream 有三个 match 方法，从语义上说： </p>
<ul>
<li>allMatch：Stream 中全部元素符合传入的 predicate，返回 true</li>
<li>anyMatch：Stream 中只要有一个元素符合传入的 predicate，返回 true</li>
<li>noneMatch：Stream 中没有一个元素符合传入的 predicate，返回 true</li>
</ul>
<p>它们都不是要遍历全部元素才能返回结果。例如 allMatch 只要一个元素不满足条件，就 skip 剩下的所有元素，返回 false。对清单 13 中的 Person 类稍做修改，加入一个 age 属性和 getAge 方法。 </p>
<h5 id="清单-21-使用-Match"><a href="#清单-21-使用-Match" class="headerlink" title="清单 21. 使用 Match"></a>清单 21. 使用 Match</h5><pre><code>List&lt;Person&gt; persons = new ArrayList();
persons.add(new Person(1, &quot;name&quot; + 1, 10));
persons.add(new Person(2, &quot;name&quot; + 2, 21));
persons.add(new Person(3, &quot;name&quot; + 3, 34));
persons.add(new Person(4, &quot;name&quot; + 4, 6));
persons.add(new Person(5, &quot;name&quot; + 5, 55));
boolean isAllAdult = persons.stream().
 allMatch(p -&gt; p.getAge() &gt; 18);
System.out.println(&quot;All are adult? &quot; + isAllAdult);
boolean isThereAnyChild = persons.stream().
 anyMatch(p -&gt; p.getAge() &lt; 12);
System.out.println(&quot;Any child? &quot; + isThereAnyChild);
</code></pre><p>输出结果： </p>
<pre><code> All are adult? false
 Any child? true
</code></pre><h3 id="进阶：自己生成流"><a href="#进阶：自己生成流" class="headerlink" title="进阶：自己生成流"></a>进阶：自己生成流</h3><p><strong>Stream.generate</strong></p>
<p>通过实现 Supplier 接口，你可以自己来控制流的生成。这种情形通常用于随机数、常量的 Stream，或者需要前后元素间维持着某种状态信息的 Stream。把 Supplier 实例传递给 Stream.generate() 生成的 Stream，默认是串行（相对 parallel 而言）但无序的（相对 ordered 而言）。由于它是无限的，在管道中，必须利用 limit 之类的操作限制 Stream 大小。 </p>
<h5 id="清单-22-生成-10-个随机整数"><a href="#清单-22-生成-10-个随机整数" class="headerlink" title="清单 22. 生成 10 个随机整数"></a>清单 22. 生成 10 个随机整数</h5><pre><code>Random seed = new Random();
Supplier&lt;Integer&gt; random = seed::nextInt;
Stream.generate(random).limit(10).forEach(System.out::println);
//Another way
IntStream.generate(() -&gt; (int) (System.nanoTime() % 100)).
limit(10).forEach(System.out::println);
</code></pre><p>Stream.generate() 还接受自己实现的 Supplier。例如在构造海量测试数据的时候，用某种自动的规则给每一个变量赋值；或者依据公式计算 Stream 的每个元素值。这些都是维持状态信息的情形。 </p>
<h5 id="清单-23-自实现-Supplier"><a href="#清单-23-自实现-Supplier" class="headerlink" title="清单 23. 自实现 Supplier"></a>清单 23. 自实现 Supplier</h5><pre><code>Stream.generate(new PersonSupplier()).
limit(10).
forEach(p -&gt; System.out.println(p.getName() + &quot;, &quot; + p.getAge()));
private class PersonSupplier implements Supplier&lt;Person&gt; {
 private int index = 0;
 private Random random = new Random();
 @Override
 public Person get() {
 return new Person(index++, &quot;StormTestUser&quot; + index, random.nextInt(100));
 }
}
</code></pre><p>输出结果： </p>
<pre><code> StormTestUser1, 9
StormTestUser2, 12
StormTestUser3, 88
StormTestUser4, 51
StormTestUser5, 22
StormTestUser6, 28
StormTestUser7, 81
StormTestUser8, 51
StormTestUser9, 4
StormTestUser10, 76
</code></pre><p><strong>Stream.iterate</strong></p>
<p>iterate 跟 reduce 操作很像，接受一个种子值，和一个 UnaryOperator（例如 f）。然后种子值成为 Stream 的第一个元素，f(seed) 为第二个，f(f(seed)) 第三个，以此类推。 </p>
<p><strong>清单 24. 生成一个等差数列</strong></p>
<pre><code>     Stream.iterate(0, n -&gt; n + 3).limit(10). forEach(x -&gt; System.out.print(x + &quot; &quot;));.
</code></pre><p>输出结果： </p>
<pre><code>     0 3 6 9 12 15 18 21 24 27
</code></pre><p>与 Stream.generate 相仿，在 iterate 时候管道必须有 limit 这样的操作来限制 Stream 大小。 </p>
<h3 id="进阶：用-Collectors-来进行-reduction-操作"><a href="#进阶：用-Collectors-来进行-reduction-操作" class="headerlink" title="进阶：用 Collectors 来进行 reduction 操作"></a>进阶：用 Collectors 来进行 reduction 操作</h3><p>java.util.stream.Collectors 类的主要作用就是辅助进行各类有用的 reduction 操作，例如转变输出为 Collection，把 Stream 元素进行归组。 </p>
<p><strong>groupingBy/partitioningBy</strong></p>
<h5 id="清单-25-按照年龄归组"><a href="#清单-25-按照年龄归组" class="headerlink" title="清单 25. 按照年龄归组"></a>清单 25. 按照年龄归组</h5><pre><code>Map&lt;Integer, List&lt;Person&gt;&gt; personGroups = Stream.generate(new PersonSupplier()).
 limit(100).
 collect(Collectors.groupingBy(Person::getAge));
Iterator it = personGroups.entrySet().iterator();
while (it.hasNext()) {
 Map.Entry&lt;Integer, List&lt;Person&gt;&gt; persons = (Map.Entry) it.next();
 System.out.println(&quot;Age &quot; + persons.getKey() + &quot; = &quot; + persons.getValue().size());
}
</code></pre><p>上面的 code，首先生成 100 人的信息，然后按照年龄归组，相同年龄的人放到同一个 list 中，可以看到如下的输出： </p>
<pre><code>Age 0 = 2
Age 1 = 2
Age 5 = 2
Age 8 = 1
Age 9 = 1
Age 11 = 2
……
</code></pre><h5 id="清单-26-按照未成年人和成年人归组"><a href="#清单-26-按照未成年人和成年人归组" class="headerlink" title="清单 26. 按照未成年人和成年人归组"></a>清单 26. 按照未成年人和成年人归组</h5><pre><code>Map&lt;Boolean, List&lt;Person&gt;&gt; children = Stream.generate(new PersonSupplier()).
 limit(100).
 collect(Collectors.partitioningBy(p -&gt; p.getAge() &lt; 18));
System.out.println(&quot;Children number: &quot; + children.get(true).size());
System.out.println(&quot;Adult number: &quot; + children.get(false).size());
</code></pre><p>输出结果： </p>
<pre><code>     Children number: 23 
     Adult number: 77
</code></pre><p>在使用条件“年龄小于 18”进行分组后可以看到，不到 18 岁的未成年人是一组，成年人是另外一组。partitioningBy 其实是一种特殊的 groupingBy，它依照条件测试的是否两种结果来构造返回的数据结构，get(true) 和 get(false) 能即为全部的元素对象。 </p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>总之，Stream 的特性可以归纳为： </p>
<ul>
<li>不是数据结构</li>
<li>它没有内部存储，它只是用操作管道从 source（数据结构、数组、generator function、IO channel）抓取数据。</li>
<li>它也绝不修改自己所封装的底层数据结构的数据。例如 Stream 的 filter 操作会产生一个不包含被过滤元素的新 Stream，而不是从 source 删除那些元素。</li>
<li>所有 Stream 的操作必须以 lambda 表达式为参数</li>
<li>不支持索引访问</li>
<li>你可以请求第一个元素，但无法请求第二个，第三个，或最后一个。不过请参阅下一项。</li>
<li>很容易生成数组或者 List</li>
<li>惰性化</li>
<li>很多 Stream 操作是向后延迟的，一直到它弄清楚了最后需要多少数据才会开始。</li>
<li>Intermediate 操作永远是惰性化的。</li>
<li>并行能力</li>
<li>当一个 Stream 是并行化的，就不需要再写多线程代码，所有对它的操作会自动并行进行的。</li>
<li>可以是无限的<ul>
<li>集合有固定大小，Stream 则不必。limit(n) 和 findFirst() 这类的 short-circuiting 操作可以对无限的 Stream 进行运算并很快完成。</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
    
    </summary>
    
      <category term="Java" scheme="https://wangyu1997.github.io/categories/Java/"/>
    
    
      <category term="java8" scheme="https://wangyu1997.github.io/tags/java8/"/>
    
      <category term="lambda" scheme="https://wangyu1997.github.io/tags/lambda/"/>
    
      <category term="steams" scheme="https://wangyu1997.github.io/tags/steams/"/>
    
  </entry>
  
  <entry>
    <title>java8方法引用</title>
    <link href="https://wangyu1997.github.io/2017/11/08/JAVA/java8%20%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/"/>
    <id>https://wangyu1997.github.io/2017/11/08/JAVA/java8 方法引用/</id>
    <published>2017-11-08T13:38:11.000Z</published>
    <updated>2017-11-08T13:52:02.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p>形如 <code>ClassName::methodName</code> 或者 <code>objectName::methodName</code> 的表达式，我们把它叫做方法引用（Method Reference）。可能你现在还理解不了，但是编译器足够聪明，或许你可以看看编译器是如何根据 “晦涩难懂” 的 Method Reference 来推断你的意图的。 </p>
<h2 id="方法引用的种类"><a href="#方法引用的种类" class="headerlink" title="方法引用的种类"></a>方法引用的种类</h2><p>方法引用有四种，分别是： </p>
<ul>
<li>指向静态方法的引用</li>
<li>指向某个对象的实例方法的引用</li>
<li>指向某个类型的实例方法的引用</li>
<li>指向构造方法的引用</li>
</ul>
<p>下面通过一些代码示例来和大家分享一下这四种引用使用场景，先定义一个 <code>Person</code> 类，后面我们会用到它： </p>
<pre><code>public class Person {
    private String name;

    private String getName() {
        return name;
    }

    public static int compareName(Person a, Person b) {
        return a.getName().compareTo(b.name);
    }
}
</code></pre><h3 id="指向静态方法的引用"><a href="#指向静态方法的引用" class="headerlink" title="指向静态方法的引用"></a>指向静态方法的引用</h3><p>形式：<code>ContainingClass:staticMethodName</code></p>
<p>如果要想实现一群人按名字排序，一般你会这么做： </p>
<pre><code>Arrays.sort(personArray, new Comparator() {
    @Override
    public int compare(Person a, Person b) {
        return a.getName().compareTo(b.getName());
    }
});
</code></pre><p>第二个参数很复杂，但是目的却很简单：实现 <code>Comparator</code> 的一个比较方法。我们自然会想——相信很多程序员都会这么想：有没有一种方法能够既简单明了又能无歧义的表达我们的意图？当然有，Java 8 引入的 lambda 表达式便很好的简化了我们的代码，瞧： </p>
<pre><code>Array.sort(personArray, (a, b) -&gt; {
    return a.getName().compareTo(b.getName());
});
</code></pre><p><code>(a, b)</code> 是 lambda 表达式的参数列表，箭头后的是方法体。编译器已经被训练得足够聪明：它知道 <code>(a, b)</code> 就是代表着要比较的两个 <code>Person</code> 对象。它在脑海里构想出了这个 lambda 表达式的 “原型”： </p>
<pre><code>new Comparator() {
    @Override
    public int compare(Person a, Person b) {
        return a.getName().compareTo(b.getName());
    }
}
</code></pre><p>机智的编译器从简化的代码中推断出了 <code>Comparator</code> 对象的 “原型”。但是程序员并不满足：还能不能进一步简化？当然可以，在不造成歧义的前提下可以无限地简化一个语法。我们注意到，<code>Person</code> 类有一个静态方法可以用来实现两个对象的比较，于是引入 <strong>指向静态方法的引用</strong>： </p>
<pre><code>Arrays.sort(personArray, Person::compareName);
</code></pre><p><code>Person.compareName()</code> 方法有两个 <code>Person</code> 类型的参数，一个 <code>int</code> 类型的返回值，所以 <code>Person::compareName</code> 这个方法引用拥有两个 <code>Person</code> 类型的不确定量（在这里指的就是 <code>compareName()</code> 的两个参数；文章末尾有关于不确定量的具体解释）和一个 <code>int</code> 类型的返回值。而 <code>Comparator</code> 中待实现的方法 <code>compare()</code> 也有两个 <code>Person</code> 类型的参数和一个 <code>int</code> 的返回值。方法引用和 <code>Comparator</code> 中要实现的方法有足够的相似度，因此编译器将 <code>Person::compareName</code> 的不确定量和返回值与 <code>compare()</code> 的参数和返回值对应了起来，由此推断出我们的意图是： </p>
<pre><code>Arrays.sort(personArray, new Comparator() {
    @Override
    public int compare(Person a, Person b) {
        return Person.compareName(a, b);
    }
})
</code></pre><p>编译器成功地识别了程序员的意图。但是编译器的聪明程度也是有限的，假如方法引用所对应的静态方法返回值不是 <code>int</code> 而是 <code>boolean</code>，那么编译器无法将该方法引用还原为一个 <code>Comparator</code> 对象，因为它并不知道该返回什么 <code>int</code> 值。幸亏我们提供的静态方法引用有 <code>int</code> 类型的返回值，编译器还原时就可以把它返回。 </p>
<h3 id="指向某个对象的实例方法的引用"><a href="#指向某个对象的实例方法的引用" class="headerlink" title="指向某个对象的实例方法的引用"></a>指向某个对象的实例方法的引用</h3><p>形式：<code>containingObject::instanceMethodName</code></p>
<p>有一个比较器，它可以比较多种对象： </p>
<pre><code>public class Comparator() {
    public int comarePerson(Person a, Person b) {
        return a.getName().compareTo(b.getName());
    }

    public int compareDog(Dog a, Dog b) {
        return a.getName().compareTo(b.getName());
    }

    ......
}
</code></pre><p>上面的 <code>Dog</code> 类和 <code>Person</code> 类结构相似，所以代码就省略了。现在我们要根据一群狗的名字给它们排序，我们同样使用方法引用（当然，你依旧可以用 lambda 表达式），但是这次是 <strong>指向某个对象的实例方法的引用</strong>： </p>
<pre><code>Comparator aComparator = new Comparator(); // 实例化一个比较器
// aComparator::compareDog 是指向实例对象 aComparetor 的实例方法
// compareDog() 的方法引用
Arrays.sort(dogs, aComparator::compareDog); 
</code></pre><p><code>compareDog()</code> 方法的两个参数是 <code>Dog</code> 类型，返回值为 <code>int</code>，也就是说 <code>aComparator::compareDog</code> 有两个 <code>Dog</code> 类型的不确定量和一个 int 类型的返回值。而 <code>Comparator</code> 中的 <code>compare()</code> 方法也是接受两个 <code>Dog</code> 对象，返回一个 <code>int</code> 值。根据这些线索编译器足够推断出我们的意图： </p>
<pre><code>Arrays.sort(dogs, new Comparator() {
    @Override
    public int compare(Dog a, Dog b) {
        return aComparator.compareDog(a, b);
    }
});
</code></pre><h3 id="指向某个类型的实例方法的引用"><a href="#指向某个类型的实例方法的引用" class="headerlink" title="指向某个类型的实例方法的引用"></a>指向某个类型的实例方法的引用</h3><p>形式：<code>ContainingClass::instanceMethodName</code></p>
<pre><code>Stream.of(&quot;A&quot;, &quot;is&quot;, &quot;a&quot;, &quot;dog&quot;).reduce(&quot;&quot;, new BinaryOperator() {
    @Override
    public String apply(String a, String b) {
        return a.toUpperCase() + b.toUpperCase();
    }
});
</code></pre><p><code>reduce()</code> 方法是把某类型对象的集合降解为一个对象，过程是两两合并。它的第一个参数为初始值，第二个参数是一个接口，用来定义两两合并的具体策略。如果你暂时不懂 <code>Stream</code> 以及它的 <code>reduce()</code> 方法也没关系，我们只关注它的第二个参数。我们实现 <code>BinaryOperator</code> 接口的方法是把两个字符串变成大写后连接起来。代码看起来很臃肿，但是没有办法，我们没有合适的方法引用来将它简化（现有方法中没有能够将两个字符串先转换成大写然后连接的，当然你可以自己实现一个这样的方法，但没必要，因为这样会使得代码更加复杂），顶多可以转化成 lambda 表达式： </p>
<pre><code>Stream.of(&quot;A&quot;, &quot;is&quot;, &quot;a&quot;, &quot;dog&quot;).reduce(&quot;&quot;, (a, b) -&gt; {
        return a.toUpperCase() + b.toUpperCase();
    }
});
</code></pre><p>但是如果两两合并的方式是直接将两个字符串连接的话，情况就不同了。我们可以用 <code>String::concat</code> 这个 <strong>指向某个类型的实例方法的引用</strong> 来使代码更简洁： </p>
<pre><code>Stream.of(&quot;A&quot;, &quot;is&quot;, &quot;a&quot;, &quot;dog&quot;).reduce(&quot;&quot;, String::concat);
</code></pre><p>编译器看看这行代码，愣了一下，不知道如何转化。还好，我们的编译器足够聪明，眼珠一转分析了下：我们要实现的方法有两个 <code>String</code> 的参数，一个 <code>String</code> 类型的返回值，而 <code>String::concat</code> 也有两个 <code>String</code> 类型的不确定量和一个 <code>String</code> 类型的返回值，其中一个不确定量是由于 <code>concat()</code> 这个方法是实例方法导致的，因为它必须通过一个 <code>String</code> 实例来调用；另一个不确定量为 <code>concat()</code> 方法的参数，它接受一个 <code>String</code> 类型的参数。以上信息足够编译器来推断我们的意图：程序员一定是想把两个参数和 <code>String::concat</code> 的两个不确定量对应起来，一个作为 <code>concat()</code> 方法调用的接收者，一个作为 <code>concat()</code> 方法的参数。这样一来上面的代码就转化成这样了： </p>
<pre><code>Stream.of(&quot;A&quot;, &quot;is&quot;, &quot;a&quot;, &quot;dog&quot;).reduce(&quot;&quot;, new BinaryOperator() {
    @Override
    public String apply(String a, String b) {
        return a.concat(b);
    }
});
</code></pre><p>Wonderful ！程序员正是这么想的。有心的程序员可能会发出疑问：根据编译器的推断思路，对于任意一个方法引用，是不是只要它有两个 <code>String</code> 类型的不确定量和一个 <code>String</code> 类型返回值（当然类型要为 <code>String</code>）就可以作为参数传入 <code>reduce()</code> 了呢？于是程序员想了个方法来测试： </p>
<pre><code>Stream.of(&quot;A&quot;, &quot;is&quot;, &quot;a&quot;, &quot;dog&quot;).reduce(&quot;&quot;, Test::test);

public class Test {
    public static String test(String a, String b) {
        return a.concat(b);
    }
}
</code></pre><p>程序员在 IDE 中写下上面的代码后，编译器没有错误提示 =&gt; 编译后通过 =&gt; 猜想正确。原因是 <code>Test</code> 的 <code>test()</code> 是一个静态方法，它有两个 <code>String</code> 类型的参数，一个 <code>String</code> 类型的返回值，也就是说 <code>Test::test</code> 有两个 <code>String</code> 类型的不确定量和一个 <code>String</code> 类型的返回值，因此编译器推断出程序员的意图是： </p>
<pre><code>Stream.of(&quot;A&quot;, &quot;is&quot;, &quot;a&quot;, &quot;dog&quot;).reduce(&quot;&quot;, new BinaryOperator() {
    @Override
    public String apply(String a, String b) {
        return Test.test(a, b);
    }
});
</code></pre><h3 id="指向构造方法的引用"><a href="#指向构造方法的引用" class="headerlink" title="指向构造方法的引用"></a>指向构造方法的引用</h3><p>形式：<code>ClassName::new</code></p>
<pre><code>Stream.of(&quot;A&quot;, &quot;is&quot;, &quot;a&quot;, &quot;dog&quot;).toArray(new IntFunction&lt;String[]&gt;() {
     @Override
     public String[] apply(int value) {
         return null; 
     }
});
</code></pre><p><code>toArray()</code> 方法的作用是把数据流转换成一个数组，它接收的参数是一个 <code>IntFunction</code> 的接口实现对象。该接口有一个待实现的方法 <code>apply()</code>，它有一个 <code>int</code> 型的参数和一个 <code>String[]</code> 类型的返回值。我们依旧可以用方法引用来代替它，但这次我们用的是 <strong>指向构造方法的引用</strong>： </p>
<pre><code>Stream.of(&quot;A&quot;, &quot;is&quot;, &quot;a&quot;, &quot;dog&quot;).toArray(String[]::new);
</code></pre><p>指向构造方法的引用可能较其他方法引用难理解一点，但是编译器却很机智的猜测到了程序员的意图：<code>String[]::new</code> 这个 指向构造方法的引用 有一个 <code>int</code> 类型的不确定量，即数组的长度；有一个 String[] 类型的返回值（构造方法不会有返回值，但是指向构造方法的引用却返回了一个该类型的实例）。因此编译器这样还原此方法引用： </p>
<pre><code>Stream.of(&quot;A&quot;, &quot;is&quot;, &quot;a&quot;, &quot;dog&quot;).toArray(new IntFunction&lt;String[]&gt;() {
    @Override
    public String[] apply(int value) {
        return new String[value];
    }
})
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实，JVM 本身并不支持指向方法引用，过去不支持，现在也不支持。Java 8 对方法引用的支持知识编译器层面的支持，虚拟机执行引擎并不了解方法引用。编译器遇到方法引用的时候，会像上面那样自动推断出程序员的意图，将方法引用还原成 <strong>接口实现对象</strong>，或者更形象地说，就是把方法引用设法包装成一个接口实现对象，这样虚拟机就可以无差别地执行字节码文件而不需要管什么是方法引用了。 </p>
<p>需要注意的是，方法引用是用来简化接口实现代码的，并且凡是能够用方法引用来简化的接口，都有这样的特征：有且只有一个待实现的方法。这种接口在 Java 中有个专门的名称： <strong>函数式接口</strong>。当你用试图用方法引用替代一个非函数式接口时，会有这样的错误提示： xxx is not a functional interface。 </p>
<p>文章中很多地方提到过 <strong>不确定量</strong> 这个名词，这个名词并非官方的，而是我为了更好地说明问题而引入的，它的意思是： <strong>方法引用在转换成接口实现对象的过程中需要确定的变量</strong>。如 <strong>方法引用所对应方法的接受者</strong>（ <strong>指向静态方法的引用</strong> 和 <strong>指向某个对象的实例方法的引用</strong> 没有该不确定量，因为前者不需要接受者，而后者接受者已经确定），以及 <strong>方法引用所对应方法的参数</strong> 都属于 <strong>不确定量</strong>。方法引用的 <strong>不确定量</strong> 以及返回值需要和接口中的待实现方法的参数和返回值对应起来，这样编译器才能成功将其还原。 </p>
<h2 id="感谢阅读"><a href="#感谢阅读" class="headerlink" title="感谢阅读"></a>感谢阅读</h2><p>写这篇文章的目的是让大家对方法引用有一个更好的理解，同时也作为个人的学习记录，但由于理解和水平有限，差错在所难免，还请大家不吝赐教。最后，感谢大家的阅读。 </p>
<p><strong>参考文章:</strong><br><a href="http://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html" target="_blank" rel="external">Method References</a><br><a href="http://stackoverflow.com/questions/20001427/double-colon-operator-in-java-8" target="_blank" rel="external">:: (double colon) operator in Java 8</a></p>
<hr>
<ul>
<li><a href="http://liwenkun.me/2017/03/09/android-hot-fix/" title="动态加载应用之简单热更新" target="_blank" rel="external">Previous<br>动态加载应用之简单热更新</a></li>
<li><a href="http://liwenkun.me/2017/05/30/operating-system-conclusion/" title="操作系统原理总结" target="_blank" rel="external">Next<br>操作系统原理总结</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
    
    </summary>
    
      <category term="Java" scheme="https://wangyu1997.github.io/categories/Java/"/>
    
    
      <category term="java8" scheme="https://wangyu1997.github.io/tags/java8/"/>
    
      <category term="lambda" scheme="https://wangyu1997.github.io/tags/lambda/"/>
    
      <category term="reference" scheme="https://wangyu1997.github.io/tags/reference/"/>
    
  </entry>
  
  <entry>
    <title>hibernat中使用二级缓存</title>
    <link href="https://wangyu1997.github.io/2017/11/03/Spring/Hibernate%E4%BD%BF%E7%94%A8%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98/"/>
    <id>https://wangyu1997.github.io/2017/11/03/Spring/Hibernate使用二级缓存/</id>
    <published>2017-11-03T10:38:11.000Z</published>
    <updated>2017-11-03T10:51:33.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h2 id="hibernate使用二级缓存"><a href="#hibernate使用二级缓存" class="headerlink" title="hibernate使用二级缓存"></a>hibernate使用二级缓存</h2>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
    
    </summary>
    
      <category term="Spring" scheme="https://wangyu1997.github.io/categories/Spring/"/>
    
    
      <category term="Hibernate" scheme="https://wangyu1997.github.io/tags/Hibernate/"/>
    
      <category term="cache" scheme="https://wangyu1997.github.io/tags/cache/"/>
    
  </entry>
  
  <entry>
    <title>Web应用中使用hibernate</title>
    <link href="https://wangyu1997.github.io/2017/11/02/Spring/web%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8hibernate/"/>
    <id>https://wangyu1997.github.io/2017/11/02/Spring/web项目中使用hibernate/</id>
    <published>2017-11-02T08:51:11.000Z</published>
    <updated>2017-11-03T10:37:38.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h2 id="web项目中使用Hibernate"><a href="#web项目中使用Hibernate" class="headerlink" title="web项目中使用Hibernate"></a>web项目中使用Hibernate</h2><blockquote>
<p>首先创建一个gradle项目 web-application-with-hibernate, 导入依赖</p>
</blockquote>
<pre><code>testCompile group: &#39;junit&#39;, name: &#39;junit&#39;, version: &#39;4.12&#39;
// https://mvnrepository.com/artifact/org.hibernate/hibernate-core
compile group: &#39;org.hibernate&#39;, name: &#39;hibernate-core&#39;, version: &#39;5.2.12.Final&#39;
// https://mvnrepository.com/artifact/mysql/mysql-connector-java
compile group: &#39;mysql&#39;, name: &#39;mysql-connector-java&#39;, version: &#39;8.0.8-dmr&#39;
</code></pre><blockquote>
<p>创建一个用户注册的静态页面 index.jsp</p>
</blockquote>
<pre><code>&lt;form action=&quot;&quot; method=&quot;post&quot;&gt;
    &lt;h2&gt;用户注册表&lt;/h2&gt;
    &lt;hr&gt;
    Name:&lt;input type=&quot;text&quot; name=&quot;name&quot;/&gt;&lt;br&gt;
    &lt;br&gt;Password: &lt;input type=&quot;password&quot; name=&quot;password&quot;/&gt;&lt;br&gt;
    &lt;br&gt;Email: &lt;input type=&quot;email&quot; name=&quot;email&quot;/&gt;&lt;br&gt;
    &lt;br&gt;&lt;input type=&quot;submit&quot; value=&quot;注册&quot;/&gt;
&lt;/form&gt;
</code></pre><blockquote>
<p>创建一个User实体类用来存储信息</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>Model<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>
    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> String password<span class="token punctuation">;</span>
    <span class="token keyword">private</span> String email<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">//GETTER AND SETTER</span>
    <span class="token comment" spellcheck="true">//...</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>然后创建hibernate映射文件User.hbm.xml</p>
</blockquote>
<pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version='1.0' encoding='UTF-8'?></span>
<span class="token doctype">&lt;!DOCTYPE hibernate-mapping PUBLIC
        "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
        "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hibernate-mapping</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>class</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.demo.Model.User<span class="token punctuation">"</span></span> <span class="token attr-name">table</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tb_user<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>generator</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>increment<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>email<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>class</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>hibernate-mapping</span><span class="token punctuation">></span></span>
</code></pre>
<blockquote>
<p>我们创建操作持久化层测试类UserDao</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>Dao<span class="token punctuation">;</span>

<span class="token keyword">import</span> com<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>Model<span class="token punctuation">.</span>User<span class="token punctuation">;</span>
<span class="token keyword">import</span> org<span class="token punctuation">.</span>hibernate<span class="token punctuation">.</span>Session<span class="token punctuation">;</span>
<span class="token keyword">import</span> org<span class="token punctuation">.</span>hibernate<span class="token punctuation">.</span>SessionFactory<span class="token punctuation">;</span>
<span class="token keyword">import</span> org<span class="token punctuation">.</span>hibernate<span class="token punctuation">.</span>Transaction<span class="token punctuation">;</span>
<span class="token keyword">import</span> org<span class="token punctuation">.</span>hibernate<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>MetadataSources<span class="token punctuation">;</span>
<span class="token keyword">import</span> org<span class="token punctuation">.</span>hibernate<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>registry<span class="token punctuation">.</span>StandardServiceRegistry<span class="token punctuation">;</span>
<span class="token keyword">import</span> org<span class="token punctuation">.</span>hibernate<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>registry<span class="token punctuation">.</span>StandardServiceRegistryBuilder<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserDao</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">save</span><span class="token punctuation">(</span>User u<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

        <span class="token keyword">final</span> StandardServiceRegistry registry <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StandardServiceRegistryBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">configure</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 2. 根据服务注册类创建一个元数据资源集，同时构建元数据并生成应用一般唯一的的session工厂</span>
        SessionFactory factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MetadataSources</span><span class="token punctuation">(</span>registry<span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">buildMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">buildSessionFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Session session <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">openSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Transaction t <span class="token operator">=</span> session<span class="token punctuation">.</span><span class="token function">beginTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        i <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> session<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>
        t<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        session<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>u<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>创建数据库</p>
</blockquote>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>tb_user<span class="token punctuation">`</span> <span class="token punctuation">(</span>
  <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> unsigned <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>
  <span class="token punctuation">`</span>name<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">''</span><span class="token punctuation">,</span>
  <span class="token punctuation">`</span>password<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">''</span><span class="token punctuation">,</span>
  <span class="token punctuation">`</span>email<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">''</span><span class="token punctuation">,</span>
  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span>
</code></pre>
<blockquote>
<p>hibernate配置文件</p>
</blockquote>
<pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version='1.0' encoding='utf-8'?></span>
<span class="token doctype">&lt;!DOCTYPE hibernate-configuration PUBLIC
        "-//Hibernate/Hibernate Configuration DTD//EN"
        "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hibernate-configuration</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>session-factory</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>connection.url<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>jdbc:mysql://localhost:3306/Spring<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>connection.driver_class<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>com.mysql.cj.jdbc.Driver<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>connection.username<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>root<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>connection.password<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>19970819wy<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>

        <span class="token comment" spellcheck="true">&lt;!-- DB schema will be updated if needed --></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dialect<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>org.hibernate.dialect.MySQL5Dialect<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>hbm2ddl.auto<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>update<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapping</span> <span class="token attr-name">resource</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mapping/User.hbm.xml<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>session-factory</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>hibernate-configuration</span><span class="token punctuation">></span></span>
</code></pre>
<blockquote>
<p>修改持久化层configuration</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> StandardServiceRegistry registry <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StandardServiceRegistryBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">configure</span><span class="token punctuation">(</span><span class="token string">"hibernate/hibernate.cfg.xml"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<blockquote>
<p>展示用户信息的jsp页面</p>
</blockquote>
<pre class=" language-jsp"><code class="language-jsp"><%@ page import="com.demo.Dao.UserDao" %><%--
  Created by IntelliJ IDEA.
  User: wangyu
  Date: 02/11/2017
  Time: 5:00 PM
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<jsp:useBean id="obj" class="com.demo.Model.User"/>
<jsp:setProperty name="obj" property="*"/>

<%
    int i = UserDao.save(obj);
    if (i > 0) {
        out.print("You are successfully registered");
    }
%>
</code></pre>
<blockquote>
<p>修改index页面的action </p>
</blockquote>
<pre class=" language-jsp"><code class="language-jsp"><form action="register.jsp" method="post">
</code></pre>
<blockquote>
<p>运行结果</p>
</blockquote>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15097043584807.jpg" alt=""></p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15097043681445.jpg" alt=""></p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15097043810482.jpg" alt=""></p>
<h2 id="hibernate生成器类"><a href="#hibernate生成器类" class="headerlink" title="hibernate生成器类"></a>hibernate生成器类</h2><p>id元素的<code>&lt;generator&gt;</code>子元素用于生成持久化类的对象的唯一标识符。 Hibernate框架中定义了许多生成器类。</p>
<ul>
<li>assigned</li>
<li>increment</li>
<li>sequence</li>
<li>hilo</li>
<li>native</li>
<li>identity</li>
<li>seqhilo</li>
<li>uuid</li>
<li>guid</li>
<li>select</li>
<li>foreign</li>
<li>sequence-identity</li>
</ul>
<blockquote>
<p>assigned</p>
</blockquote>
<p>默认的生成策略，由应用程序为对象分配ID</p>
<pre class=" language-xml"><code class="language-xml"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hibernate-mapping</span><span class="token punctuation">></span></span>  
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>class</span> <span class="token attr-name">...</span><span class="token punctuation">></span></span>  
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">...</span><span class="token punctuation">></span></span>  
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>generator</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>assigned<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>generator</span><span class="token punctuation">></span></span>  
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>  
    .....  
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>class</span><span class="token punctuation">></span></span>  
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>hibernate-mapping</span><span class="token punctuation">></span></span>
</code></pre>
<blockquote>
<p>increment</p>
</blockquote>
<p>当没有其他进程讲数据插入此表时，才会生成唯一的ID，它生成short、int或long类型的数据<br>第一个生成的数据通常为1，然后每次递增为1</p>
<pre class=" language-xml"><code class="language-xml"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hibernate-mapping</span><span class="token punctuation">></span></span>  
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>class</span> <span class="token attr-name">...</span><span class="token punctuation">></span></span>  
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">...</span><span class="token punctuation">></span></span>  
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>generator</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>increment<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>generator</span><span class="token punctuation">></span></span>  
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>  
    .....  
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>class</span><span class="token punctuation">></span></span>  
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>hibernate-mapping</span><span class="token punctuation">></span></span>
</code></pre>
<blockquote>
<p>sequence</p>
</blockquote>
<p>它使用数据库的顺序序列。如果没有定义序列，它会自动创建一个序列。 在Oracle数据库的情况下，它将创建一个名为HIBERNATE_SEQUENCE的序列。 在Oracle，DB2，SAP DB，Postgre SQL或McKoi的情况下，它使用序列(sequence)，但在interbase中使用生成器。</p>
<pre class=" language-xml"><code class="language-xml"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">...</span><span class="token punctuation">></span></span>  
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>generator</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sequence<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>generator</span><span class="token punctuation">></span></span>  
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>
</code></pre>
<p>要定义自己的序列，使用param的name</p>
<pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">...</span><span class="token punctuation">></span></span>  
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>generator</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sequence<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sequence<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>your_sequence_name<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param</span><span class="token punctuation">></span></span>  
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>generator</span><span class="token punctuation">></span></span>  
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>
</code></pre>
<blockquote>
<p>hilo<br>使用高低算法来生成short、int和long类型的数据</p>
</blockquote>
<pre class=" language-xml"><code class="language-xml"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">...</span><span class="token punctuation">></span></span>  
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>generator</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>hilo<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>generator</span><span class="token punctuation">></span></span>  
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>
</code></pre>
<blockquote>
<p>native</p>
</blockquote>
<p>它使用标识，序列或希洛取决于数据库供应商</p>
<pre class=" language-xml"><code class="language-xml"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">...</span><span class="token punctuation">></span></span>  
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>generator</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>native<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>generator</span><span class="token punctuation">></span></span>  
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>
</code></pre>
<blockquote>
<p>identity</p>
</blockquote>
<p>它用于Sybase，Mysql，MS SQL Server，DB2和Hypersonic SQL以支持id列。 返回的ID类型为short，int或long。</p>
<blockquote>
<p>seqhilo</p>
</blockquote>
<p>它在指定的序列名称上使用高低算法。 返回的ID类型为short，int或long。</p>
<blockquote>
<p>uuid</p>
</blockquote>
<p>它使用128位UUID算法生成id。 返回的ID是String类型，在网络中是唯一的(因为使用了IP)。 UUID以十六进制数字表示，长度为32。</p>
<blockquote>
<p>guid</p>
</blockquote>
<p>它使用由字符串类型的数据库生成的GUID。 它适用于MS SQL Server和MySQL。</p>
<blockquote>
<p>select</p>
</blockquote>
<p>它使用数据库触发器返回主键。</p>
<blockquote>
<p>foreign</p>
</blockquote>
<p>它使用另一个关联对象的id，主要用于&lt;一对一&gt;关联。</p>
<blockquote>
<p>sequence-identity</p>
</blockquote>
<p>它使用特殊的序列生成策略。 仅在Oracle 10g驱动程序中支持。</p>
]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
    
    </summary>
    
      <category term="Spring" scheme="https://wangyu1997.github.io/categories/Spring/"/>
    
    
      <category term="Hibernate" scheme="https://wangyu1997.github.io/tags/Hibernate/"/>
    
      <category term="Java Web" scheme="https://wangyu1997.github.io/tags/Java-Web/"/>
    
      <category term="Hibernate生成器" scheme="https://wangyu1997.github.io/tags/Hibernate%E7%94%9F%E6%88%90%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>学习Spring第六天</title>
    <link href="https://wangyu1997.github.io/2017/10/25/Spring/Hibernate/"/>
    <id>https://wangyu1997.github.io/2017/10/25/Spring/Hibernate/</id>
    <published>2017-10-25T13:43:11.000Z</published>
    <updated>2017-11-03T10:33:28.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h2 id="hibernate框架使用"><a href="#hibernate框架使用" class="headerlink" title="hibernate框架使用"></a>hibernate框架使用</h2><blockquote>
<p>首先引入gradle依赖:</p>
</blockquote>
<pre><code>testCompile group: &#39;junit&#39;, name: &#39;junit&#39;, version: &#39;4.12&#39;
// https://mvnrepository.com/artifact/org.hibernate/hibernate-core
compile group: &#39;org.hibernate&#39;, name: &#39;hibernate-core&#39;, version: &#39;5.2.12.Final&#39;
// https://mvnrepository.com/artifact/mysql/mysql-connector-java
compile group: &#39;mysql&#39;, name: &#39;mysql-connector-java&#39;, version: &#39;8.0.8-dmr&#39;
</code></pre><blockquote>
<p>然后创建一个实体类 Employee:</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>Model<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>
    <span class="token keyword">private</span> String firstName<span class="token punctuation">;</span>
    <span class="token keyword">private</span> String lastName<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> id<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setId</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> String <span class="token function">getFirstName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> firstName<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setFirstName</span><span class="token punctuation">(</span>String firstName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>firstName <span class="token operator">=</span> firstName<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> String <span class="token function">getLastName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> lastName<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setLastName</span><span class="token punctuation">(</span>String lastName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>lastName <span class="token operator">=</span> lastName<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>然后创建持久化类 employee.hbm.xml</p>
</blockquote>
<pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version='1.0' encoding='UTF-8'?></span>
<span class="token doctype">&lt;!DOCTYPE hibernate-mapping PUBLIC
        "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
        "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hibernate-mapping</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>class</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.demo.Model.Employee<span class="token punctuation">"</span></span> <span class="token attr-name">table</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>employee<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ID<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>generator</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>assigned<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>firstName<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>FIRST_NAME<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>lastName<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>LAST_NAME<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>class</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>hibernate-mapping</span><span class="token punctuation">></span></span>
</code></pre>
<blockquote>
<p>创建hibernate配置文件 hibernate.cfg.xml</p>
</blockquote>
<pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version='1.0' encoding='UTF-8'?></span>
<span class="token doctype">&lt;!DOCTYPE hibernate-configuration PUBLIC
        "-//Hibernate/Hibernate Configuration DTD 3.0//EN"
        "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hibernate-configuration</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>session-factory</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>connection.driver_class<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>com.mysql.cj.jdbc.Driver<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>connection.url<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>jdbc:mysql://localhost:3306/hibernate<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>connection.username<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>root<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>connection.password<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>19970819wy<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dialect<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>org.hibernate.dialect.MySQL5Dialect<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>show_sql<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>hibernate.hbm2ddl.auto<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>create<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapping</span> <span class="token attr-name">resource</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>hibernate/employee.hbm.xml<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>session-factory</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>hibernate-configuration</span><span class="token punctuation">></span></span>
</code></pre>
<blockquote>
<p>编写测试类 StoreData</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>demo<span class="token punctuation">;</span>


<span class="token keyword">import</span> com<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>Model<span class="token punctuation">.</span>Employee<span class="token punctuation">;</span>
<span class="token keyword">import</span> org<span class="token punctuation">.</span>hibernate<span class="token punctuation">.</span>Session<span class="token punctuation">;</span>
<span class="token keyword">import</span> org<span class="token punctuation">.</span>hibernate<span class="token punctuation">.</span>SessionFactory<span class="token punctuation">;</span>
<span class="token keyword">import</span> org<span class="token punctuation">.</span>hibernate<span class="token punctuation">.</span>Transaction<span class="token punctuation">;</span>
<span class="token keyword">import</span> org<span class="token punctuation">.</span>hibernate<span class="token punctuation">.</span>cfg<span class="token punctuation">.</span>Configuration<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StoreData</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Configuration cfg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Configuration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        cfg<span class="token punctuation">.</span><span class="token function">configure</span><span class="token punctuation">(</span><span class="token string">"hibernate/hibernate.cfg.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        SessionFactory factory <span class="token operator">=</span> cfg<span class="token punctuation">.</span><span class="token function">buildSessionFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        Session session <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">openSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        Transaction transaction <span class="token operator">=</span> session<span class="token punctuation">.</span><span class="token function">beginTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        Employee employee <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        employee<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        employee<span class="token punctuation">.</span><span class="token function">setFirstName</span><span class="token punctuation">(</span><span class="token string">"Wang"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        employee<span class="token punctuation">.</span><span class="token function">setLastName</span><span class="token punctuation">(</span><span class="token string">"Yu"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        session<span class="token punctuation">.</span><span class="token function">persist</span><span class="token punctuation">(</span>employee<span class="token punctuation">)</span><span class="token punctuation">;</span>

        transaction<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        session<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"successful saved"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>运行结果如下：</p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15096117112127.jpg" alt=""></p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15096117282494.jpg" alt=""></p>
<h3 id="使用注解的形式来创建持久化实体类"><a href="#使用注解的形式来创建持久化实体类" class="headerlink" title="使用注解的形式来创建持久化实体类"></a>使用注解的形式来创建持久化实体类</h3><p>我们首先用注解的形式来修改上面的Employee实体类</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>Model<span class="token punctuation">;</span>

<span class="token keyword">import</span> javax<span class="token punctuation">.</span>persistence<span class="token punctuation">.</span>Column<span class="token punctuation">;</span>
<span class="token keyword">import</span> javax<span class="token punctuation">.</span>persistence<span class="token punctuation">.</span>Entity<span class="token punctuation">;</span>
<span class="token keyword">import</span> javax<span class="token punctuation">.</span>persistence<span class="token punctuation">.</span>Id<span class="token punctuation">;</span>
<span class="token keyword">import</span> javax<span class="token punctuation">.</span>persistence<span class="token punctuation">.</span>Table<span class="token punctuation">;</span>

<span class="token annotation punctuation">@Entity</span>
<span class="token annotation punctuation">@Table</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"tb_employee"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Id</span>
    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"Em_ID"</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"Em_FirstName"</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> String firstName<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"Em_LastName"</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> String lastName<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> id<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setId</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> String <span class="token function">getFirstName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> firstName<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setFirstName</span><span class="token punctuation">(</span>String firstName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>firstName <span class="token operator">=</span> firstName<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> String <span class="token function">getLastName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> lastName<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setLastName</span><span class="token punctuation">(</span>String lastName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>lastName <span class="token operator">=</span> lastName<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>@Id表示主键<br>@Column表示对应数据表的列名称<br>@Entity是必须的，把Employee注册成实体类<br>@Table指定对应的数据表的名称</p>
<blockquote>
<p>在hibernate.cfg.xml中修改一下mapping</p>
</blockquote>
<pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapping</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.demo.Model.Employee<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
</code></pre>
<p>运行结果一致</p>
]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
    
    </summary>
    
      <category term="Spring" scheme="https://wangyu1997.github.io/categories/Spring/"/>
    
    
      <category term="Hibernate" scheme="https://wangyu1997.github.io/tags/Hibernate/"/>
    
  </entry>
  
  <entry>
    <title>计算机系统概论</title>
    <link href="https://wangyu1997.github.io/2017/10/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/"/>
    <id>https://wangyu1997.github.io/2017/10/24/计算机组成原理/计算机系统概论/</id>
    <published>2017-10-24T14:43:11.000Z</published>
    <updated>2017-10-24T15:39:57.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p>物联网：把感应器嵌入和装备到电网、铁路、桥梁、隧道、公路、建筑、供水系统、大坝、油气管道等各种物体中，并且被普遍连接，形成所谓的“物联网”，然后将“物联网”与现有的互联网整合起来，实现人类社会与无力系统的整合，形成智慧地球</p>
<a id="more"></a>      
<h2 id="计算机系统简介"><a href="#计算机系统简介" class="headerlink" title="计算机系统简介"></a>计算机系统简介</h2><p>计算机系统分为硬件和软件</p>
<p>硬件：计算机的实体，如主机、外设等</p>
<p>软件：由具有各类特殊功能的信息（程序）组成</p>
<ul>
<li><p>分类：系统软件、应用软件</p>
<p> 系统软件： 用来管理整个计算机系统</p>
<pre><code> e.g. : 语言处理程序、操作系统、服务性程序、数据库管理系统、网络软件
</code></pre><p> 应用软件： 按任务需要编织成的各种程序</p>
</li>
</ul>
<h2 id="计算机系统的层次结构"><a href="#计算机系统的层次结构" class="headerlink" title="计算机系统的层次结构"></a>计算机系统的层次结构</h2><p>层次结构：</p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15088579483898.jpg" alt=""></p>
<p>系统复杂性管理的方法：</p>
<blockquote>
<p>抽象：隐藏系统中不重要的细节</p>
</blockquote>
<p>从语言的角度划分层次</p>
<pre><code>微指令系统  微程序机器M0
              |
              |
机器语言    实际机器M1
              |
              |
操作系统    虚拟机器
              |
              |
汇编语言    虚拟机器M2
              |
              |
高级语言    虚拟机器M3
</code></pre><p>高级语言执行的过程</p>
<pre><code>虚拟机器M4      用编译程序翻译成汇编语言程序
    |
    |
虚拟机器M3      用汇编语言程序翻译成机器语言程序
    |
    |
虚拟机器M2      用机器语言解释操作系统
    |
==============软硬件分界线=========
    |
实际机器M1      用微指令解释机器指令
    |
    |
微程序机器M0     由硬件直接执行微指令
</code></pre><p>软硬件对于功能的实现逻辑上等价</p>
<ul>
<li><p>硬件实现：造价贵</p>
</li>
<li><p>软件实现：软件体系庞大 实现复杂</p>
</li>
</ul>
<p>计算机组成与计算机体系结构从研究内容上的区别：</p>
<blockquote>
<p>计算机体系结构：程序员所见到的计算机系统的属性概念性的结构与功能特性(机器语言程序员)=&gt;有无乘法指令</p>
<p>计算机组成：实现计算机体系结构所体现的属性(具体指令的实现)=&gt;如何实现乘法指令</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;物联网：把感应器嵌入和装备到电网、铁路、桥梁、隧道、公路、建筑、供水系统、大坝、油气管道等各种物体中，并且被普遍连接，形成所谓的“物联网”，然后将“物联网”与现有的互联网整合起来，实现人类社会与无力系统的整合，形成智慧地球&lt;/p&gt;
    
    </summary>
    
      <category term="组成原理" scheme="https://wangyu1997.github.io/categories/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="概论" scheme="https://wangyu1997.github.io/tags/%E6%A6%82%E8%AE%BA/"/>
    
      <category term="计算机体系结构" scheme="https://wangyu1997.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
      <category term="计算机组成" scheme="https://wangyu1997.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络基本概念</title>
    <link href="https://wangyu1997.github.io/2017/10/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>https://wangyu1997.github.io/2017/10/24/计算机网路/基本概念/</id>
    <published>2017-10-24T14:43:11.000Z</published>
    <updated>2017-10-24T23:21:40.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p>计算机网络是通信技术和计算机技术紧密结合的产物</p>
<a id="more"></a>    
<p>通信系统模型：</p>
<p><img src="media/15088842118439.jpg" alt=""></p>
<ul>
<li>计算机网络就是一种通信网络</li>
</ul>
<p>定义：计算机网络就是互连的、自治的计算机集合</p>
<ul>
<li>自治：无主从关系</li>
<li>互连：互联互通<br>  通信链路</li>
</ul>
<p><img src="media/15088843816499.jpg" alt=""></p>
<p>当两台主机距离过远时，直接使用物理链路连接不可行。通过交换网络互连主机</p>
<p><img src="media/15088844808106.jpg" alt=""></p>
<p>Internet：</p>
<p>组成细节角度</p>
<pre><code>全球最大的互联网络
 * ISP（Internet Service Provider）网络互连的“网络之网络”
    数以百万计的互连的计算设备集合
     * 主机=端系统
     * 运行各种网络应用
* 通信链路
    光纤、铜缆、无线电、卫星...
分组交换：转发分组（数据包）
    * 路由器和交换机
</code></pre><p>服务角度</p>
<pre><code>为网络应用提供通信服务的通信基础设施
    * Web、VoIP、email、网络游戏、电子商务、社交网络...
为网络应用提供应用编程接口(API)
    * 支持应用程序“连接”Internet，发送／接收数据
    * 提供类似于邮政系统的数据传输服务
</code></pre><p><img src="media/15088846455227.jpg" alt=""></p>
<p>硬件（主机、路由器、通信链路等）是计算机网络的基础<br>计算机网络中的数据必须交换遵守事先预定好的规则</p>
<blockquote>
<p>任何通信和信息交换过程都需要规则</p>
</blockquote>
<p>网络通信：</p>
<pre><code>* 通信主体是“机器”不是人
* 交换”电子化“或”数字化“消息
* 计算机网络的所有通信过程都必须遵守某种／些规则---协议
</code></pre><blockquote>
<p>网络协议，简称协议，是为进行网络中的数据交换而建立的规则、标准或约定<br>协议规定了通信实体之间所交换的消息的格式、意义、顺序以及针对收到消息或发生的事件所采取的动作（action）</p>
</blockquote>
<p>协议三要素：<br>语法（Syntax）</p>
<pre><code>* 数据与控制信息的结构或格式
* 信号电平
</code></pre><p>语意（Semantics）</p>
<pre><code>* 需要发出何种控制信息
* 完成何种动作以及作出何种响应
* 差错控制
</code></pre><p>时序（Timing）</p>
<pre><code>* 事件顺序
* 速度匹配
</code></pre><ul>
<li>协议规范了网络中所有信息发送和接收过程</li>
<li>学习网络的重要内容之一</li>
<li>网络创新的表现形式之一</li>
<li>Internet协议标准<br>  RFC：Request for Comments<br>  IETF：互联网工程任务组</li>
</ul>
<p>网络边缘：</p>
<pre><code>* 主机
* 网络应用
</code></pre><p>接入网络、物理介质</p>
<pre><code>* 有线或无线通信链路
</code></pre><p>网络核心（核心网络）</p>
<pre><code>* 互联的路由器（或分组转发设备）
* 网络之网络
</code></pre><p>主机（端系统）</p>
<pre><code>* 位于“网络边缘”
* 运行网络应用程序
    Web、email
</code></pre><p>客户／服务器（client／server）应用模型<br>    客户端发送请求，接收服务器响应（Web，FTP）<br>对等（peer-peer，P2P）应用模型<br>    无专用服务器<br>    通信在对等实体之间直接进行</p>
<blockquote>
<p>接入网络</p>
</blockquote>
<p><img src="media/15088866522095.jpg" alt=""></p>
<p>数字用户线路（DSL）（独占）<br>    利用已有的电话线连接中心局的DSLAM<br>    语音通过DSL电话线接入电话网<br>上行低，下行快</p>
<p><img src="media/15088866356085.jpg" alt=""></p>
<p>电缆网络：有线电视网络（共享）</p>
<p><img src="media/15088868501997.jpg" alt=""></p>
<p>频分多路复用：在不同频带（载波）上传输不同的频道<br>HFC：混合光纤同轴电缆（共享）<br>    非对称</p>
<p>典型家庭网络的接入：</p>
<p><img src="media/15088869044970.jpg" alt=""></p>
<p>机构接入：</p>
<p><img src="media/15088869559608.jpg" alt=""></p>
<p>无线接入：<br>通过共享的无线接入网络连接端系统与路由器<br>    通过基站（base station）或称为“接入点”（access point）</p>
<p>无线局域网络（LANs）<br>广域无线接入（蜂窝网）</p>
<p>网络核心的关键功能：路由+转发<br>    路由：确定分组从源到目的传输路径<br>    转发：将分组从路由器的输入端口交换至正确的输出端口</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;计算机网络是通信技术和计算机技术紧密结合的产物&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="https://wangyu1997.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://wangyu1997.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="基本概念" scheme="https://wangyu1997.github.io/tags/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    
      <category term="网络协议" scheme="https://wangyu1997.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>学习Spring第五天</title>
    <link href="https://wangyu1997.github.io/2017/10/24/Spring/AOP/"/>
    <id>https://wangyu1997.github.io/2017/10/24/Spring/AOP/</id>
    <published>2017-10-24T13:43:11.000Z</published>
    <updated>2017-10-25T10:38:07.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a>  
<h2 id="BeanNameAutoProxyCreator"><a href="#BeanNameAutoProxyCreator" class="headerlink" title="BeanNameAutoProxyCreator"></a>BeanNameAutoProxyCreator</h2><p>生产中会有会多bean需要代理，为了节约时间和减少工作量，我们可以使用自动代理来创建代理Bean</p>
<p>个人感觉十分简单</p>
<p>首先创建一个BeanNameAutoProxyCreator的Bean，然后把Advisor和需要代理的Bean丢进去(支持正则匹配)</p>
<pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span>bean <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator"</span><span class="token operator">></span>
    <span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">"beanNames"</span><span class="token operator">></span>
        <span class="token operator">&lt;</span>list<span class="token operator">></span>
            <span class="token operator">&lt;</span>value<span class="token operator">></span><span class="token operator">*</span>Service<span class="token operator">&lt;</span><span class="token operator">/</span>value<span class="token operator">></span>
        <span class="token operator">&lt;</span><span class="token operator">/</span>list<span class="token operator">></span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>property<span class="token operator">></span>
    <span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">"interceptorNames"</span><span class="token operator">></span>
        <span class="token operator">&lt;</span>list<span class="token operator">></span>
            <span class="token operator">&lt;</span>value<span class="token operator">></span>customerPointCut<span class="token operator">&lt;</span><span class="token operator">/</span>value<span class="token operator">></span>
            <span class="token operator">&lt;</span>value<span class="token operator">></span>customerAdvisor<span class="token operator">&lt;</span><span class="token operator">/</span>value<span class="token operator">></span>
        <span class="token operator">&lt;</span><span class="token operator">/</span>list<span class="token operator">></span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>property<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>bean<span class="token operator">></span>
</code></pre>
<p>然后测试类不需要在调用Proxy的名字，直接使用，Spring会自动创建代理</p>
<h2 id="DefaultAdvisorAutoProxyCreator"><a href="#DefaultAdvisorAutoProxyCreator" class="headerlink" title="DefaultAdvisorAutoProxyCreator"></a>DefaultAdvisorAutoProxyCreator</h2><p>听说十分强大，如果有Bean相关联，会自动创建相应的代理</p>
<p><code>&lt;bean class=&quot;org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator&quot;/&gt;</code></p>
<p>一行代码即可，感觉是有点方便，运行结果不变</p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15088497883546.jpg" alt=""></p>
<ul>
<li>拦截器的序列会影响结果，我们需要自己调整顺序如果是使用BeanNameAutoProxyCreator</li>
</ul>
<h2 id="AOP-AspectJ-面向切面编程"><a href="#AOP-AspectJ-面向切面编程" class="headerlink" title="AOP+AspectJ 面向切面编程"></a>AOP+AspectJ 面向切面编程</h2><p>AspectJ常见的注解</p>
<pre><code>@Before – 方法执行前运行
@After – 运行在方法返回结果后
@AfterReturning – 运行在方法返回一个结果后，在拦截器返回结果。
@AfterThrowing – 运行方法在抛出异常后，
@Around – 围绕方法执行运行，结合以上这三个通知。
</code></pre><blockquote>
<p>创建一个Dao</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>Dao<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">CustomerBo</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">addCustomer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    String <span class="token function">addCustomerReturnValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">void</span> <span class="token function">addCustomerThrowException</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">;</span>

    <span class="token keyword">void</span> <span class="token function">addCustomerAround</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>实现类CustomerBoImpl</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>Dao<span class="token punctuation">.</span>Impl<span class="token punctuation">;</span>

<span class="token keyword">import</span> com<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>Dao<span class="token punctuation">.</span>CustomerBo<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CustomerBoImpl</span> <span class="token keyword">implements</span> <span class="token class-name">CustomerBo</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addCustomer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"addCustomer() is running"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> String <span class="token function">addCustomerReturnValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"addCustomerReturnValue() is running"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token string">"abc"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addCustomerThrowException</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"addCustomerThrowException() is running"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Exception</span><span class="token punctuation">(</span><span class="token string">"Generic Error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addCustomerAround</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"addCustomerAround(String name) is running, args: "</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>然后定义一个AspectJ用来输出日志信息</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>AspectJ<span class="token punctuation">;</span>

<span class="token keyword">import</span> org<span class="token punctuation">.</span>aspectj<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>JoinPoint<span class="token punctuation">;</span>
<span class="token keyword">import</span> org<span class="token punctuation">.</span>aspectj<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Aspect<span class="token punctuation">;</span>
<span class="token keyword">import</span> org<span class="token punctuation">.</span>aspectj<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Before<span class="token punctuation">;</span>

<span class="token annotation punctuation">@Aspect</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LoggingAspect</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Before</span><span class="token punctuation">(</span><span class="token string">"execution(* com.demo.Dao.CustomerBo.addCustomer(..))"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">logBefore</span><span class="token punctuation">(</span>JoinPoint joinPoint<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"logBefore() is running"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Method "</span> <span class="token operator">+</span> joinPoint<span class="token punctuation">.</span><span class="token function">getSignature</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"**********"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>在applicationContext.xml中声明Beans</p>
</blockquote>
<pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">xmlns:</span>aop</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/aop<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-4.0.xsd
    http://www.springframework.org/schema/aop
    http://www.springframework.org/schema/aop/spring-aop-4.0.xsd <span class="token punctuation">"</span></span><span class="token punctuation">></span></span>

    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>aspectj-autoproxy</span><span class="token punctuation">/></span></span>

    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>customerBo<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.demo.Dao.Impl.CustomerBoImpl<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>

    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>logAspect<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.demo.AspectJ.LoggingAspect<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">></span></span>
</code></pre>
<p>这里用到了<code>&lt;aop:aspectj-autoproxy/&gt;</code>开启切片自动拦截</p>
<p>然后在xml中注册了这个日志拦截切片</p>
<p>运行结果如下:</p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15088527301527.jpg" alt=""></p>
<blockquote>
<p>下面把其余的几个注解一起使用</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>AspectJ<span class="token punctuation">;</span>

<span class="token keyword">import</span> org<span class="token punctuation">.</span>aspectj<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>JoinPoint<span class="token punctuation">;</span>
<span class="token keyword">import</span> org<span class="token punctuation">.</span>aspectj<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>ProceedingJoinPoint<span class="token punctuation">;</span>
<span class="token keyword">import</span> org<span class="token punctuation">.</span>aspectj<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>*<span class="token punctuation">;</span>

<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span>

<span class="token annotation punctuation">@Aspect</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LoggingAspect</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Before</span><span class="token punctuation">(</span><span class="token string">"execution(* com.demo.Dao.CustomerBo.addCustomer(..))"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">logBefore</span><span class="token punctuation">(</span>JoinPoint joinPoint<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"logBefore() is running"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Method "</span> <span class="token operator">+</span> joinPoint<span class="token punctuation">.</span><span class="token function">getSignature</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"**********"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@After</span><span class="token punctuation">(</span><span class="token string">"execution(* com.demo.Dao.CustomerBo.addCustomer(..))"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">logAfter</span><span class="token punctuation">(</span>JoinPoint joinPoint<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"logAfter() is running"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Method "</span> <span class="token operator">+</span> joinPoint<span class="token punctuation">.</span><span class="token function">getSignature</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"**********"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@AfterReturning</span><span class="token punctuation">(</span><span class="token string">"execution(* com.demo.Dao.CustomerBo.addCustomerReturnValue(..))"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">logAfterReturn</span><span class="token punctuation">(</span>JoinPoint joinPoint<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"logAfterReturn() is running"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Method "</span> <span class="token operator">+</span> joinPoint<span class="token punctuation">.</span><span class="token function">getSignature</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"**********"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@AfterThrowing</span><span class="token punctuation">(</span>pointcut <span class="token operator">=</span> <span class="token string">"execution(* com.demo.Dao.CustomerBo.addCustomerThrowException(..))"</span><span class="token punctuation">,</span> throwing <span class="token operator">=</span> <span class="token string">"error"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">logAfterThrowing</span><span class="token punctuation">(</span>JoinPoint joinPoint<span class="token punctuation">,</span> Throwable error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"logAfterThrowing() is running"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Method : "</span> <span class="token operator">+</span> joinPoint<span class="token punctuation">.</span><span class="token function">getSignature</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Error : "</span> <span class="token operator">+</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"**********"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Around</span><span class="token punctuation">(</span><span class="token string">"execution(* com.demo.Dao.CustomerBo.addCustomerAround(..))"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">logAround</span><span class="token punctuation">(</span>ProceedingJoinPoint joinPoint<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"logAround() is running"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Method : "</span> <span class="token operator">+</span> joinPoint<span class="token punctuation">.</span><span class="token function">getSignature</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Method Parameters : "</span> <span class="token operator">+</span> Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>joinPoint<span class="token punctuation">.</span><span class="token function">getArgs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Around Before is running"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        joinPoint<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Around After is running"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"**********"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre>
<p>感觉跟写Advice差不多</p>
<p>流程就是这样: DaoImpl-&gt;AspectJ-&gt;xml开启aspect自动代理-&gt;xml注入-&gt;调用</p>
<ul>
<li>注解可以用xml代替</li>
</ul>
<pre><code>&lt;aop:before&gt; = @Before
&lt;aop:after&gt; = @After
&lt;aop:after-returning&gt; = @AfterReturning
&lt;aop:after-throwing&gt; = @AfterThrowing
&lt;aop:after-around&gt; = @Around
</code></pre><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">xmlns:</span>aop</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/aop<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-4.0.xsd
    http://www.springframework.org/schema/aop
    http://www.springframework.org/schema/aop/spring-aop-4.0.xsd <span class="token punctuation">"</span></span><span class="token punctuation">></span></span>

    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>aspectj-autoproxy</span><span class="token punctuation">/></span></span>

    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>customerBo<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.demo.Dao.Impl.CustomerBoImpl<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>

    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>logAspect<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.demo.AspectJ.LoggingAspect<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>config</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>aspect</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aspectLogging<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>logAspect<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>pointcut</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>pointCutBefore<span class="token punctuation">"</span></span> <span class="token attr-name">expression</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>execution(* com.demo.Dao.CustomerBo.addCustomer(..))<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>before</span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>logBefore<span class="token punctuation">"</span></span> <span class="token attr-name">pointcut-ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>pointCutBefore<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>

            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>pointcut</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>pointCutAfter<span class="token punctuation">"</span></span> <span class="token attr-name">expression</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>execution(* com.demo.Dao.CustomerBo.addCustomer(..))<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>after</span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>logAfter<span class="token punctuation">"</span></span> <span class="token attr-name">pointcut-ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>pointCutAfter<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">aop:</span>aspect</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">aop:</span>config</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">></span></span>
</code></pre>
<p>在xml中注册<code>&lt;aop:config&gt;</code>在内层用<code>&lt;aop:aspect&gt;</code>包裹，内部每声明一个pointcut就有一个响应的<code>&lt;aop:xxx&gt;</code>与之对应，我理解为一个切片，一个执行</p>
]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
    
    </summary>
    
      <category term="Spring" scheme="https://wangyu1997.github.io/categories/Spring/"/>
    
    
      <category term="AOP" scheme="https://wangyu1997.github.io/tags/AOP/"/>
    
      <category term="AutoProxyCreator" scheme="https://wangyu1997.github.io/tags/AutoProxyCreator/"/>
    
  </entry>
  
  <entry>
    <title>学习Spring第四天</title>
    <link href="https://wangyu1997.github.io/2017/10/22/Spring/AspectJ/"/>
    <id>https://wangyu1997.github.io/2017/10/22/Spring/AspectJ/</id>
    <published>2017-10-22T13:43:11.000Z</published>
    <updated>2017-10-24T06:52:10.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a>  
<h2 id="Spring-PropertyPlaceholderConfigurer的使用"><a href="#Spring-PropertyPlaceholderConfigurer的使用" class="headerlink" title="Spring PropertyPlaceholderConfigurer的使用"></a>Spring PropertyPlaceholderConfigurer的使用</h2><blockquote>
<p>对于一些隐秘的或者是全局变量的操作我们希望可以统一的管理他，我们可以把这些配置写在properties或者yaml文件里，然后在xml配置文件里获取相应的值，PropertyPlaceholderConfigurer就可以帮助我们实现这个功能 </p>
</blockquote>
<p>我们还是从简单的jdbc开始，项目结构如下： </p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15086031216749.jpg" alt=""></p>
<blockquote>
<p>gradle依赖 </p>
</blockquote>
<pre><code>testCompile group: &#39;junit&#39;, name: &#39;junit&#39;, version: &#39;4.12&#39;

compile group: &#39;org.springframework&#39;, name: &#39;spring-context&#39;, version: &#39;5.0.0.RELEASE&#39;

compile group: &#39;mysql&#39;, name: &#39;mysql-connector-java&#39;, version: &#39;8.0.8-dmr&#39;

compile group: &#39;org.springframework&#39;, name: &#39;spring-jdbc&#39;, version: &#39;5.0.0.RELEASE&#39;

compile group: &#39;org.springframework&#39;, name: &#39;spring-core&#39;, version: &#39;5.0.0.RELEASE&#39;
</code></pre><p>数据表如下: </p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15086032783308.jpg" alt=""></p>
<blockquote>
<p>首先我们新建一个Entity </p>
</blockquote>
<pre><code>Customer.java

package com.demo.Model;

public class Customer {
    private int custId;
    private String name;
    private int age;

    public void setCustId(int custId) {
        this.custId = custId;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public int getCustId() {
        return custId;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    @Override
    public String toString() {
        return &quot;Cust_Id: &quot; + custId + &quot;\nName: &quot; + name + &quot;\nAge: &quot; + age;
    }
}
</code></pre><blockquote>
<p>Dao层接口实现 </p>
</blockquote>
<pre><code>CustomerDao.java

package com.demo.Dao;

import com.demo.Model.Customer;

public interface CustomerDao {
    void insert(Customer customer);

    Customer findById(int custId);
}
</code></pre><blockquote>
<p>Impl实现接口方法 </p>
</blockquote>
<pre><code>CustomerDaoImpl.java

package com.demo.Impl;

import com.demo.Dao.CustomerDao;
import com.demo.Model.Customer;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.support.JdbcDaoSupport;

import java.util.List;

public class CustomerDaoImpl extends JdbcDaoSupport implements CustomerDao {
    @Override
    public void insert(Customer customer) {

        String sql = &quot;INSERT INTO customer VALUES (? ,? ,?)&quot;;
        getJdbcTemplate().update(sql, customer.getCustId(), customer.getName(), customer.getAge());
    }

    @Override
    public Customer findById(int custId) {
        String sql = &quot;SELECT * FROM customer WHERE CUST_ID = ?&quot;;

        List&lt;Customer&gt; customers = getJdbcTemplate().query(sql, new Object[]{custId}, new BeanPropertyRowMapper&lt;&gt;(Customer.class));

        return customers.get(0);
    }
}
</code></pre><p>上面都是很基本的Jdbc操作，通过增删改查来测试代码 </p>
<blockquote>
<p>不同于之前，我们把数据库的变量写在properties里 </p>
</blockquote>
<pre><code>data-config.properties

jdbc.driverClassName=com.mysql.cj.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/Spring
jdbc.username=root
jdbc.password=19970819wy
</code></pre><blockquote>
<p>Spring-Beans中配置dataSource和beans </p>
</blockquote>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-4.0.xsd&quot;&gt;

    &lt;bean class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt;
        &lt;property name=&quot;location&quot; value=&quot;database-config.properties&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driverClassName}&quot;/&gt;
        &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;customer&quot; class=&quot;com.demo.Impl.CustomerDaoImpl&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre><p>这里我们首先通过PropertyPlaceholderConfigurer来导入properties里的变量(location属性定位properties文件)<br>然后我们就可以在dataSource里通过${}来获取对应的值 </p>
<blockquote>
<p>测试类 </p>
</blockquote>
<pre><code>App.java

package com.demo;

import com.demo.Impl.CustomerDaoImpl;
import com.demo.Model.Customer;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class App {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;Spring-Beans.xml&quot;);

        Customer customer = new Customer();
        customer.setCustId(1);
        customer.setName(&quot;RenBuRuGu&quot;);
        customer.setAge(20);

        CustomerDaoImpl impl = context.getBean(CustomerDaoImpl.class);

        impl.insert(customer);

        System.out.println(impl.findById(1));
    }
}
</code></pre><h2 id="Bean的继承"><a href="#Bean的继承" class="headerlink" title="Bean的继承"></a>Bean的继承</h2><p>继承的方式有两种 直接继承和抽象继承<br>子类可以继承父类的一系列属性 </p>
<blockquote>
<p>直接继承 </p>
</blockquote>
<p>我个人认为有两种 一种是class由父类指定，子类不指定class，那么父类和子类都会共享同一个实体类，子类可以省略父类既定的字段或者重写。第二种是父类子类都指定class，这里的class不一定要存在继承关系，只要相应的class有共享的字段即可(我感觉这样不是很好) </p>
<blockquote>
<p>创建一个entity </p>
</blockquote>
<pre><code>package com.demo.Model;

public class Customer {
    private int type;
    private String action;
    private String country;

    public int getType() {
        return type;
    }

    public void setType(int type) {
        this.type = type;
    }

    public String getAction() {
        return action;
    }

    public void setAction(String action) {
        this.action = action;
    }

    public String getCountry() {
        return country;
    }

    public void setCountry(String country) {
        this.country = country;
    }

    @Override
    public String toString() {
        return &quot;type: &quot; + type + &quot;\naction: &quot; + action + &quot;\ncountry: &quot; + country;
        }
    }
</code></pre><blockquote>
<p>xml配置文件 </p>
</blockquote>
<pre><code>&lt;bean id=&quot;baseBean&quot; class=&quot;com.demo.Model.Customer&quot;&gt;
    &lt;property name=&quot;country&quot; value=&quot;China&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;customerBean&quot; parent=&quot;baseBean&quot;&gt;
    &lt;property name=&quot;action&quot; value=&quot;buy&quot;/&gt;
    &lt;property name=&quot;type&quot; value=&quot;1&quot;/&gt;
&lt;/bean&gt;
</code></pre><blockquote>
<p>这样子类的country字段就变成China了 运行结果如下: </p>
</blockquote>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15086384239944.jpg" alt=""></p>
<blockquote>
<p>抽象继承 </p>
</blockquote>
<p>抽象继承也分为两种，一般抽象继承和纯抽象继承 </p>
<p>抽象继承的目的是为了父类只提供属性模板而不可被实例化，直接抽象继承很简单，只需要在父类后面加一个<code>abstract=&quot;true&quot;</code>即可 </p>
<pre><code>&lt;bean id=&quot;baseBean&quot; class=&quot;com.demo.Model.Customer&quot; abstract=&quot;true&quot;&gt;
    &lt;property name=&quot;country&quot; value=&quot;China&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;customerBean&quot; parent=&quot;baseBean&quot;&gt;
    &lt;property name=&quot;action&quot; value=&quot;buy&quot;/&gt;
    &lt;property name=&quot;type&quot; value=&quot;1&quot;/&gt;
&lt;/bean&gt;
</code></pre><p>纯抽象继承允许父类不设置class，只是为了共享字段使用 </p>
<pre><code>&lt;bean id=&quot;baseBean&quot; abstract=&quot;true&quot;&gt;
    &lt;property name=&quot;country&quot; value=&quot;China&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;customerBean&quot; parent=&quot;baseBean&quot; class=&quot;com.demo.Model.Customer&quot;&gt;
    &lt;property name=&quot;action&quot; value=&quot;buy&quot;/&gt;
    &lt;property name=&quot;type&quot; value=&quot;1&quot;/&gt;
&lt;/bean&gt;
</code></pre><ul>
<li>父类的属性值在子类中可以被覆盖</li>
</ul>
<p>##依赖检查(感觉4.x这个功能不被支持，更多的使用注解完成(如@Required字段)) </p>
<blockquote>
<p>当我们在xml配置文件中没有对属性值进行赋值时，一般不会报错，如果我们需要它报错，就要用到依赖检查这个功能(<code>dependency-check</code>)<br>依赖检查分为四种 none(默认) simple objects all </p>
</blockquote>
<p>默认方式为none，即他不会检查是否赋值 </p>
<p>simple方式只检查基本数据类型(int, long,double…)和集合类型(map, list..)，如果以上任何属性都没有设置，UnsatisfiedDependencyException将被抛出 </p>
<p>objects方式检查对象类型的数据 </p>
<p>all检查任何类型的数据 </p>
<blockquote>
<p>举一个objects的例子 </p>
</blockquote>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-2.5.xsd&quot;&gt;

    &lt;bean id=&quot;CustomerBean&quot; class=&quot;com.demo.Model.Customer&quot; 
            dependency-check=&quot;objects&quot;&gt;
        &lt;property name=&quot;action&quot; value=&quot;buy&quot; /&gt;
        &lt;property name=&quot;type&quot; value=&quot;1&quot; /&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;PersonBean&quot; class=&quot;com.demo.Model.Person&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;RenBuRuGu&quot; /&gt;
        &lt;property name=&quot;address&quot; value=&quot;address ABC&quot; /&gt;
        &lt;property name=&quot;age&quot; value=&quot;20&quot; /&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre><p>这里我们漏掉了person的注入，由于使用objects的依赖检查方式，将会收到UnsatisfiedDependencyException报错 </p>
<h2 id="Required注解"><a href="#Required注解" class="headerlink" title="@Required注解"></a>@Required注解</h2><blockquote>
<p>对于必须的字段我们可以采用@Required注解的方式 </p>
</blockquote>
<pre><code>public class Customer 
{
    private Person person;
    private int type;
    private String action;

    public Person getPerson() {
        return person;
    }

    @Required
    public void setPerson(Person person) {
        this.person = person;
    }
}
</code></pre><p>还要在xml配置文件中打开annotation注解，像以前一样，有两种方式 </p>
<p><code>&lt;context:annotation-config/&gt;</code>和<code>&lt;bean class=&quot;org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor&quot;/&gt;</code></p>
<h2 id="自定义required注解-个人感觉没什么用…"><a href="#自定义required注解-个人感觉没什么用…" class="headerlink" title="自定义required注解(个人感觉没什么用…)"></a>自定义required注解(个人感觉没什么用…)</h2><blockquote>
<p>首先自定义一个注解 </p>
</blockquote>
<pre><code>import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Mandatory {
}
</code></pre><blockquote>
<p>现在我们可以在业务逻辑中使用它 </p>
</blockquote>
<pre><code>public class Customer 
{
    private Person person;
    private int type;
    private String action;

    @Mandatory
    public void setPerson(Person person) {
        this.person = person;
    }

}
</code></pre><blockquote>
<p>最后需要在xml中去注册它 </p>
</blockquote>
<pre><code>&lt;bean class=&quot;org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor&quot;&gt;
    &lt;property name=&quot;requiredAnnotationType&quot; value=&quot;com.demo.Annotation.Mandatory&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;CustomerBean&quot; class=&quot;com.demo.Model.Customer&quot;&gt;
    &lt;property name=&quot;action&quot; value=&quot;buy&quot; /&gt;
    &lt;property name=&quot;type&quot; value=&quot;1&quot; /&gt;
&lt;/bean&gt;
</code></pre><h2 id="InitializingBean和DisposableBean接口"><a href="#InitializingBean和DisposableBean接口" class="headerlink" title="InitializingBean和DisposableBean接口"></a>InitializingBean和DisposableBean接口</h2><p>这两个接口在我理解中是两个钩子，分别用在bean初始化完成和即将被销毁时调用<br>InitializingBean中的afterPropertiesSet()用于执行初始化方法<br>DisposableBean中的destroy()用于执行bean被容器销毁之前的操作 </p>
<pre><code>Person.java

package com.demo.Model;

import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.InitializingBean;

public class Person implements InitializingBean,DisposableBean {
    private int age;
    private String name;
    private String address;

    @Override
    public void destroy() throws Exception {
        System.out.println(&quot;Destroy&quot;);
    }

    @Override
    public void afterPropertiesSet() throws Exception {
        System.out.println(&quot;Init&quot;);
    }
}

App.java

public class App {
    public static void main(String[] args) {
        ConfigurableApplicationContext context = new ClassPathXmlApplicationContext(&quot;Spring-Beans.xml&quot;);

        Person person = context.getBean(Person.class);

        context.close();
    }
}
</code></pre><p>运行结果如下: </p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15086423947200.jpg" alt=""></p>
<p>官方不推荐这么做，我也不推荐，因为如果钩子方法都写在业务代码中，就违反了Spring的低耦合机制，业务代码和Spring容器的耦合度大大加强。 </p>
<h2 id="init-method和destroy-method"><a href="#init-method和destroy-method" class="headerlink" title="init-method和destroy-method"></a>init-method和destroy-method</h2><blockquote>
<p>不继承接口，我们单纯的写两个方法，然后在xml配置文件中将他们指定为初始化和销毁之前执行的方法 </p>
</blockquote>
<pre><code>package com.demo.Model;

import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.InitializingBean;

public class Person{
    private int age;
    private String name;
    private String address;

    public void destroy() throws Exception {
        System.out.println(&quot;Destroy&quot;);
    }

    public void init() throws Exception {
        System.out.println(&quot;Init&quot;);
    }
}
</code></pre><blockquote>
<p>我们在xml中手动管理 </p>
</blockquote>
<pre><code>&lt;bean id=&quot;person&quot; class=&quot;com.demo.Model.Person&quot;
        init-method=&quot;init&quot;
        destroy-method=&quot;destroy&quot;
        p:name=&quot;RenBuRuGu&quot;
        p:age=&quot;20&quot;
        p:address=&quot;JiangSu NanJing&quot;/&gt;
</code></pre><ul>
<li><p>@PostConstruct 和 @PreDestroy可以帮我们达到同样的目的 当然前提是需要在xml中开启注解</p>
<p>package com.demo.Model;</p>
<p>import org.springframework.beans.factory.DisposableBean;<br>import org.springframework.beans.factory.InitializingBean;</p>
<p>import javax.annotation.PostConstruct;<br>import javax.annotation.PreDestroy;</p>
<p>public class Person{</p>
<pre><code>private int age;
private String name;
private String address;

@PreDestroy
public void destroy() throws Exception {
    System.out.println(&quot;Destroy&quot;);
}

@PostConstruct
public void init() throws Exception {
    System.out.println(&quot;Init&quot;);
}
</code></pre><p>}</p>
</li>
</ul>
<p>xml中不需要写init和destroy方法 </p>
<h2 id="Spring中的EL表达式"><a href="#Spring中的EL表达式" class="headerlink" title="Spring中的EL表达式"></a>Spring中的EL表达式</h2><p>el表达式可以简化代码量，我觉得还是很有必要了解的 </p>
<p>1、在使用PropertyPlaceholderConfigurer从properties文件引入配置信息时，使用<code>${SpEL expression}</code>来引用<br>2、引用同一xml中的其他bean的属性,使用<code>#{SpEL expression}</code></p>
<pre><code>&lt;bean id=&quot;itemBean&quot; class=&quot;com.demo.Model.Item&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;RenBuRuGu&quot;/&gt;
    &lt;property name=&quot;qty&quot; value=&quot;10&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;customer&quot; class=&quot;com.demo.Model.Customer&quot;&gt;
    &lt;property name=&quot;item&quot; value=&quot;#{itemBean}&quot;/&gt;
    &lt;property name=&quot;itemName&quot; value=&quot;#{itemBean.name}&quot;/&gt;
&lt;/bean&gt;
</code></pre><p>Spring EL也可以使用纯注解的方式完成，但是有几个前提<br>1、每一个bean使用Component注解(个人理解相当于xml中配置bean)<br>2、相应的字段增加@Value注解，Spring EL表达式写在注解中<br>3、xml配置文件中开启自动扫描Components </p>
<blockquote>
<p>item.java </p>
</blockquote>
<pre><code>package com.demo.Model;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component(&quot;itemBean&quot;)
public class Item {
    @Value(&quot;RenBuRuGu&quot;)
    private String name;

    @Value(&quot;10&quot;)
    private int qty;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getQty() {
        return qty;
    }

    public void setQty(int qty) {
        this.qty = qty;
    }

    @Override
    public String toString() {
        return name + &quot;  &quot; + qty;
    }
}
</code></pre><blockquote>
<p>Customer.java </p>
</blockquote>
<pre><code>package com.demo.Model;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component(&quot;customerBean&quot;)
public class Customer {

    @Value(&quot;#{itemBean}&quot;)
    private Item item;

    @Value(&quot;#{itemBean.name}&quot;)
    private String itemName;

    public Item getItem() {
        return item;
    }

    public void setItem(Item item) {
        this.item = item;
    }

    public String getItemName() {
        return itemName;
    }

    public void setItemName(String itemName) {
        this.itemName = itemName;
    }

    @Override
    public String toString() {
        return item + &quot;  &quot; + itemName;
    }
}
</code></pre><blockquote>
<p>Spring-Beans.xml </p>
</blockquote>
<pre><code>&lt;context:component-scan base-package=&quot;com.demo.Model&quot;/&gt;
</code></pre><ul>
<li>EL表达式可以直接引用Entity实例、属性和方法，也可以执行java内置的方法，运算符和三元表达式</li>
<li><p>EL表达式中的正则匹配 可以简单的使用<code>matches</code>关键字</p>
<p>@Component(“customerBean”)<br>public class Customer {</p>
</li>
</ul>
<pre><code>    String emailRegEx = &quot;^[_A-Za-z0-9-]+(\\.[_A-Za-z0-9-]+)&quot; +
                &quot;*@[A-Za-z0-9]+(\\.[A-Za-z0-9]+)*(\\.[A-Za-z]{2,})$&quot;;


    @Value(&quot;#{&#39;100&#39; matches &#39;\\d+&#39; }&quot;)
    private boolean validDigit;


    @Value(&quot;#{ (&#39;100&#39; matches &#39;\\d+&#39;) == true ? &quot; +
                &quot;&#39;yes this is digit&#39; : &#39;No this is not a digit&#39;  }&quot;)
    private String msg;


    @Value(&quot;#{emailBean.emailAddress matches customerBean.emailRegEx}&quot;)
    private boolean validEmail;


}
</code></pre><h3 id="ExpressionParser-不知道有什么用…"><a href="#ExpressionParser-不知道有什么用…" class="headerlink" title="ExpressionParser(不知道有什么用…)"></a>ExpressionParser(不知道有什么用…)</h3><p>看意思好像大概也许是提取字符并转化成相应的数据类型 </p>
<pre><code>ExpressionParser parser = new SpelExpressionParser();
Expression exp = parser.parseExpression(&quot;&#39;put spel expression here&#39;&quot;);
String msg = exp.getValue(String.class);
</code></pre><p>下面给个例子自己感受一下 </p>
<pre><code>import org.springframework.expression.Expression;
import org.springframework.expression.ExpressionParser;
import org.springframework.expression.spel.standard.SpelExpressionParser;
import org.springframework.expression.spel.support.StandardEvaluationContext;

public class App {
    public static void main(String[] args) {

        ExpressionParser parser = new SpelExpressionParser();

        Expression exp = parser.parseExpression(&quot;&#39;Hello World&#39;&quot;);
        String msg1 = exp.getValue(String.class);
        System.out.println(msg1);

        Expression exp2 = parser.parseExpression(&quot;&#39;Hello World&#39;.length()&quot;);  
        int msg2 = (Integer) exp2.getValue();
        System.out.println(msg2);

        Expression exp3 = parser.parseExpression(&quot;100 * 2&quot;);  
        int msg3 = (Integer) exp3.getValue();
        System.out.println(msg3);

        Item item = new Item(&quot;RenBuRuGu&quot;, 100);

        StandardEvaluationContext itemContext = new StandardEvaluationContext(item);


        Expression exp4 = parser.parseExpression(&quot;name&quot;);
        String msg4 = exp4.getValue(itemContext, String.class);
        System.out.println(msg4);

        Expression exp5 = parser.parseExpression(&quot;name == &#39;RenBuRuGu&#39;&quot;);
        boolean msg5 = exp5.getValue(itemContext, Boolean.class);
        System.out.println(msg5);

    }
}
</code></pre><h2 id="Spring自动扫描组件"><a href="#Spring自动扫描组件" class="headerlink" title="Spring自动扫描组件"></a>Spring自动扫描组件</h2><p>Spring的业务逻辑分为好多层(DAO,Service,Controller,Views)，主要目的还是为了解耦 </p>
<blockquote>
<p>一般我们都会通过xml的方式来注册组件<br>Dao层<br>首先创建一个CustomerDao </p>
</blockquote>
<pre><code>package com.demo.Dao;

public class CustomerDao {
    @Override
    public String toString() {
        return &quot;Hello, This is CustomerDao&quot;;
    }
}
</code></pre><blockquote>
<p>Service层实现业务逻辑 </p>
</blockquote>
<pre><code>package com.demo.Service;

import com.demo.Dao.CustomerDao;

public class CustomerService {
    CustomerDao customerDao;

    public void setCustomerDao(CustomerDao customerDao) {
        this.customerDao = customerDao;
    }

    @Override
    public String toString() {
        return &quot;CustomerService [ customerDao = &quot; +  customerDao + &quot; ]&quot;;
    }
}
</code></pre><blockquote>
<p>xml注册bean </p>
</blockquote>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-4.0.xsd&quot;&gt;
    &lt;bean id=&quot;customerDao&quot; class=&quot;com.demo.Dao.CustomerDao&quot;/&gt;

    &lt;bean id=&quot;customerService&quot; class=&quot;com.demo.Service.CustomerService&quot;&gt;
        &lt;property name=&quot;customerDao&quot; ref=&quot;customerDao&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre><blockquote>
<p>测试函数 </p>
</blockquote>
<pre><code>package com.demo;

import com.demo.Service.CustomerService;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class App {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;Spring-Beans.xml&quot;);

        CustomerService service = context.getBean(CustomerService.class);

        System.out.println(service);
    }
}
</code></pre><p>运行结果如下: </p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15086548386608.jpg" alt=""></p>
<p>这是一般做法 </p>
<blockquote>
<p>我们还可以通过自动扫描组件来完成相同的工作 </p>
</blockquote>
<p>像之前所说，给所有的实体类加上@Components注解，通过注解的方式注册实体类 </p>
<pre><code>CustomerDao.java

package com.demo.Dao;

import org.springframework.stereotype.Component;

@Component
public class CustomerDao {
    @Override
    public String toString() {
        return &quot;Hello, This is CustomerDao&quot;;
    }
}

CustomerService.java

package com.demo.Service;

import com.demo.Dao.CustomerDao;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class CustomerService {
    private CustomerDao customerDao;

    @Autowired
    public void setCustomerDao(CustomerDao customerDao) {
        this.customerDao = customerDao;
    }

    @Override
    public String toString() {
        return &quot;CustomerService [ customerDao = &quot; +  customerDao + &quot; ]&quot;;
    }
}
</code></pre><blockquote>
<p>然后在xml中开启自动扫描beans </p>
</blockquote>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;context:component-scan base-package=&quot;com.demo&quot;/&gt;
&lt;/beans&gt;
</code></pre><p>运行结果相同 </p>
<p>为了区分开功能不同的各个模块，Spring官方给出了四种注解 </p>
<pre><code>@Component – 指示自动扫描组件。
@Repository – 表示在持久层DAO组件。
@Service – 表示在业务层服务组件。
@Controller – 表示在表示层控制器组件。
</code></pre><p>所有的注解最后都会被编译为Components，但是这样就可以很好的区分业务层和持久层的组件 </p>
<blockquote>
<p>附上代码 </p>
</blockquote>
<pre><code>CustomerDao.java

package com.demo.Dao;

import org.springframework.stereotype.Repository;

@Repository
public class CustomerDao {
    @Override
    public String toString() {
        return &quot;Hello, This is CustomerDao&quot;;
    }
}

CustomerService.java

package com.demo.Service;

import com.demo.Dao.CustomerDao;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class CustomerService {
    private CustomerDao customerDao;

    @Autowired
    public void setCustomerDao(CustomerDao customerDao) {
        this.customerDao = customerDao;
    }

    @Override
    public String toString() {
        return &quot;CustomerService [ customerDao = &quot; +  customerDao + &quot; ]&quot;;
    }
}
</code></pre><h3 id="component-scan过滤器的使用"><a href="#component-scan过滤器的使用" class="headerlink" title="component-scan过滤器的使用"></a>component-scan过滤器的使用</h3><p>过滤器有两种(include-filter和exclude-filter)，顾名思义，一个是包含的过滤器另一个则是排除的过滤器.<br>filter可以通过很多种方式进行过滤,有以下几种类型: </p>
<pre><code>annotation  注解方式
regix       正则表达式
custom      自定义方式
assignable  未知.....
aspectj     切片方式(面向切片编程)
</code></pre><blockquote>
<p>通过正则过滤 </p>
</blockquote>
<pre><code>&lt;context:component-scan base-package=&quot;com.yiibai&quot; &gt;

    &lt;context:include-filter type=&quot;regex&quot; 
                    expression=&quot;com.demo.Dao.*DAO.*&quot; /&gt;

    &lt;context:include-filter type=&quot;regex&quot; 
                    expression=&quot;com.demo.Services.*Service.*&quot; /&gt;

&lt;/context:component-scan&gt;
</code></pre><p>通过include的方式，Spring只会扫描在com.demo.Dao和com.demo.Service包下面名为_Dao._和_Service._的文件 </p>
<blockquote>
<p>通过annotation注解的方式 </p>
</blockquote>
<pre><code>&lt;context:component-scan base-package=&quot;com.demo&quot;&gt;
    &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Service&quot;/&gt;
&lt;/context:component-scan&gt;
</code></pre><p>通过exclude-filter方式，所有@Service注解的entity将会被Spring忽略 </p>
<h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><ul>
<li>面向接口编程</li>
</ul>
<p>我们首先来创建一个简单的小例子 </p>
<blockquote>
<p>创建Service层 </p>
</blockquote>
<pre><code>CustomerService.java

package com.demo.Service;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

@Service
public class CustomerService {

    @Value(&quot;RenBuRuGu&quot;)
    private String name;

    @Value(&quot;https://wangyu1997.github.io/&quot;)
    private String url;

    public void printName() {
        System.out.println(&quot;Customer name: &quot; + this.name);
    }

    public void printUrl() {
        System.out.println(&quot;Customer url: &quot; + this.url);
    }

    public void printThrowException() {
        throw new IllegalArgumentException();
    }
}
</code></pre><blockquote>
<p>创建入口测试函数 </p>
</blockquote>
<pre><code>package com.demo;

import com.demo.Service.CustomerService;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

@Configuration
@ComponentScan({&quot;com.demo.Service&quot;})
public class App {
    public static void main(String[] args) {
        ApplicationContext context = new AnnotationConfigApplicationContext(App.class);

        CustomerService customerService = context.getBean(CustomerService.class);

        customerService.printName();
        customerService.printUrl();
        customerService.printThrowException();
    }
}
</code></pre><p>运行结果如下: </p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15086575392576.jpg" alt=""></p>
<blockquote>
<p>通过注解的方式加入AOP </p>
</blockquote>
<p>1、之前通知 </p>
<p>首先实现MethodBeforeAdvice方法 </p>
<pre><code>@Component(&quot;heiBeforeMethod&quot;)
public class HiBeforeMethod implements MethodBeforeAdvice {
    @Override
    public void before(Method method, Object[] args, @Nullable Object target) throws Throwable {
        System.out.println(&quot;Method Before:  Hey Spring AOP !&quot;);
    }
}
</code></pre><p>在配置文件中注册一个代理bean </p>
<pre><code>@Configuration
public class CustomerServiceProxy {

    @Bean(&quot;customerServiceProxy&quot;)
    public ProxyFactoryBean proxyFactoryBean() {
        ProxyFactoryBean bean = new ProxyFactoryBean();
        bean.setTargetName(&quot;customerService&quot;);
        bean.setInterceptorNames(&quot;heiBeforeMethod&quot;);

        return bean;
    }

}
</code></pre><p>测试类中调用 </p>
<pre><code>@Configuration
@ComponentScan({&quot;com.demo.Service&quot;,&quot;com.demo.Impl&quot;})
@Import({CustomerServiceProxy.class})
public class App {
    public static void main(String[] args) {
        ApplicationContext context = new AnnotationConfigApplicationContext(App.class);
        CustomerService customerService = (CustomerService) context.getBean(&quot;customerServiceProxy&quot;);

        customerService.printName();
        customerService.printUrl();
        try {
            customerService.printThrowException();
        }catch (IllegalArgumentException e){
            System.out.println(&quot;Throw exception...&quot;);
        }
    }
}
</code></pre><p>注意这里的引用不再是<code>customerService</code>而是<code>customerServiceProxy</code></p>
<p>运行结果如下: </p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15086609643673.jpg" alt=""></p>
<p>2、返回后通知 </p>
<p>通过重写AfterReturningAdvice的afterReturning方法来实现功能 </p>
<blockquote>
<p>接着上面再加一个类 </p>
</blockquote>
<pre><code>package com.demo.Impl;

import org.springframework.aop.AfterReturningAdvice;
import org.springframework.lang.Nullable;
import org.springframework.stereotype.Component;

import java.lang.reflect.Method;

@Component(&quot;afterReturn&quot;)
public class AfterReturn implements AfterReturningAdvice {
    @Override
    public void afterReturning(@Nullable Object returnValue, Method method, Object[] args, @Nullable Object target) throws Throwable {
        System.out.println(&quot;Spring after returning: Spring AOP!&quot;);
    }
}
</code></pre><blockquote>
<p>CustomerServiceProxy中InterceptorNames加入该类 </p>
</blockquote>
<p><code>bean.setInterceptorNames(&quot;afterReturn&quot;,&quot;heiBeforeMethod&quot;);</code></p>
<p>运行结果如下: </p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15086613289318.jpg" alt=""></p>
<p>3、抛出后通知，即方法抛出异常后调用 </p>
<p>同上，新建一个类实现ThrowsAdvice的afterThrowing方法即可 </p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15086615601291.jpg" alt=""></p>
<p>不过，我感觉，可能是在新版本中被删除了吧… </p>
<p>4、环绕通知 </p>
<p>我感觉这种方式十分强大，首先实现MethodInterceptor的invoke方法，这里用到了反射 </p>
<pre><code>package com.demo.Impl;

import org.aopalliance.intercept.MethodInterceptor;
import org.aopalliance.intercept.MethodInvocation;
import org.springframework.stereotype.Component;

import java.util.Arrays;

@Component(&quot;aroundMethod&quot;)
public class AroundMethod implements MethodInterceptor {
    @Override
    public Object invoke(MethodInvocation invocation) throws Throwable {
        System.out.println(&quot;Method name : &quot; + invocation.getMethod().getName());
        System.out.println(&quot;Method arguments : &quot; + Arrays.toString(invocation.getArguments()));

        System.out.println(&quot;Around: Method Before&quot;);
        try {
            Object result = invocation.proceed();

            System.out.println(&quot;Around: Method After&quot;);

            return result;
        } catch (Exception ignored) {
            System.out.println(&quot;Around: Method Exception&quot;);

            throw ignored;
        }
    }
}
</code></pre><p>运行结果如下: </p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15086622863646.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
    
    </summary>
    
      <category term="Spring" scheme="https://wangyu1997.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="https://wangyu1997.github.io/tags/Spring/"/>
    
      <category term="AspectJ" scheme="https://wangyu1997.github.io/tags/AspectJ/"/>
    
      <category term="PropertyPlaceholderConfigurer" scheme="https://wangyu1997.github.io/tags/PropertyPlaceholderConfigurer/"/>
    
      <category term="Spring AOP" scheme="https://wangyu1997.github.io/tags/Spring-AOP/"/>
    
      <category term="dependency" scheme="https://wangyu1997.github.io/tags/dependency/"/>
    
      <category term="inheritance" scheme="https://wangyu1997.github.io/tags/inheritance/"/>
    
  </entry>
  
  <entry>
    <title>学习Spring第三天</title>
    <link href="https://wangyu1997.github.io/2017/10/21/Spring/JdbcTemplate/"/>
    <id>https://wangyu1997.github.io/2017/10/21/Spring/JdbcTemplate/</id>
    <published>2017-10-21T13:43:11.000Z</published>
    <updated>2017-10-24T06:49:48.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a>  
<h2 id="JdbcTemplate"><a href="#JdbcTemplate" class="headerlink" title="JdbcTemplate"></a>JdbcTemplate</h2><hr>
<blockquote>
<p>原始的jdbc </p>
</blockquote>
<pre><code>public void insert(Customer customer) {
    String sql = &quot;INSERT INTO customer(CUST_ID,NAME,AGE) VALUES(?,?,?)&quot;;
    Connection conn = null;

    try {
        conn = dataSource.getConnection();
        PreparedStatement ps = conn.prepareStatement(sql);
        ps.setInt(1, customer.getCusId());
        ps.setString(2, customer.getName());
        ps.setInt(3, customer.getAge());
        ps.executeUpdate();
        ps.close();
    } catch (SQLException e) {
        e.printStackTrace();
    } finally {
        if (conn != null) {
            try {
                conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }
}
</code></pre><blockquote>
<p>改用JdbcTemplate方法 </p>
</blockquote>
<pre><code>private DataSource dataSource;
private JdbcTemplate jdbcTemplate;

public void setDataSource(DataSource dataSource) {
    this.dataSource = dataSource;
}

@Override
public void insert(Customer customer) {
    String sql = &quot;INSERT INTO customer(CUST_ID,NAME,AGE) VALUES(?,?,?)&quot;;

    jdbcTemplate = new JdbcTemplate(dataSource);
    jdbcTemplate.update(sql,customer.getCusId(),customer.getName(),customer.getAge());
}
</code></pre><p>瞬间感觉代码量少了很多，对比之前复杂的原生操作，jdbctemplate还是很容易理解的 </p>
<blockquote>
<p>JdbcDaoSupport </p>
</blockquote>
<pre><code>public class JdbcCustomerDao extends JdbcDaoSupport implements CustomerDao {


    @Override
    public void insert(Customer customer) {
        String sql = &quot;INSERT INTO customer(CUST_ID,NAME,AGE) VALUES(?,?,?)&quot;;

        getJdbcTemplate().update(sql, customer.getCusId(), customer.getName(), customer.getAge());
    }

    @Override
    public Customer findByCustomerId(int cusId) {
        String sql = &quot;SELECT * FROM customer WHERE CUST_ID = ?&quot;;
        List&lt;Customer&gt; customers = new ArrayList&lt;&gt;();
        getJdbcTemplate().query(sql, new Object[]{cusId}, new RowCallbackHandler() {
            Customer customer;

            @Override
            public void processRow(ResultSet rs) throws SQLException {
                customer = new Customer(rs.getInt(&quot;CUST_ID&quot;), rs.getString(&quot;NAME&quot;), rs.getInt(&quot;AGE&quot;));
                customers.add(customer);
            }
        });
        return customers.get(0);
    }
}
</code></pre><hr>
<h2 id="自定义RowMapper"><a href="#自定义RowMapper" class="headerlink" title="自定义RowMapper"></a>自定义RowMapper</h2><p>JdbcTemplate推荐使用自定义的RowMapper进行字段的映射 </p>
<blockquote>
<p>我们自定义一个Mapper </p>
</blockquote>
<pre><code>package com.demo.Mapper;

import com.demo.Model.Customer;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.lang.Nullable;

import java.sql.ResultSet;
import java.sql.SQLException;

public class CustomerRowMapper implements RowMapper&lt;Customer&gt; {
    @Nullable
    @Override
    public Customer mapRow(ResultSet rs, int rowNum) throws SQLException {
        Customer customer = new Customer();
        customer.setCusId(rs.getInt(&quot;CUST_ID&quot;));
        customer.setName(rs.getString(&quot;NAME&quot;));
        customer.setAge(rs.getInt(&quot;AGE&quot;));

        return customer;
    }
}
</code></pre><blockquote>
<p>FindByCustomerId方法可以重写了 </p>
</blockquote>
<pre><code>@Override
public Customer findByCustomerId(int cusId) {
    String sql = &quot;SELECT * FROM customer WHERE CUST_ID = ?&quot;;
    List&lt;Customer&gt; customers = new ArrayList&lt;&gt;();
    customers = getJdbcTemplate().query(sql, new Object[]{cusId}, new RowMapperResultSetExtractor&lt;&gt;(new CustomerRowMapper()));
    return customers.get(0);
}
</code></pre><p>运行结果也是不变的.<br>如果我们想限制数量可以在RowMapperResultSetExtractor加上第二的参数，表示查询的数量，为1时则为单个实体类，其他的情况下是该实体类的List集合 </p>
<blockquote>
<p>Example </p>
</blockquote>
<pre><code>JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);  
RowMapper rowMapper = new UserRowMapper();  

List allUsers = (List) jdbcTemplate.query(
        &quot;select * from user&quot;,
        new RowMapperResultSetExtractor(rowMapper, 10));

User user = (User) jdbcTemplate.queryForObject(
        &quot;select * from user where id=?&quot;, new Object[] {id},
        new RowMapperResultSetExtractor(rowMapper, 1));
</code></pre><blockquote>
<p>BeanPropertyRowMapper </p>
</blockquote>
<p>当Entity属性的名称和数据表的字段名称一致的时候可以用BeanPropertyRowMapper来进行映射 </p>
<pre><code>customers = getJdbcTemplate().query(sql, new Object[]{cusId}, new BeanPropertyRowMapper&lt;&gt;(Customer.class));
</code></pre><blockquote>
<p>batchUpdate的用法 </p>
</blockquote>
<p>当我们需要批量操作(同时插入多个值),重复调用相同的方法会显得相当麻烦,这时我们可以使用batchUpdate方法 </p>
<p>我们写一个批量插入的方法 </p>
<pre><code>public void insertBatch(List&lt;Customer&gt; customers) {
    String sql = &quot;INSERT INTO customer(CUST_ID,NAME,AGE) VALUES(?,?,?)&quot;;

    getJdbcTemplate().batchUpdate(sql, new BatchPreparedStatementSetter() {
        @Override
        public void setValues(PreparedStatement ps, int i) throws SQLException      {
            Customer customer = customers.get(i);
            ps.setInt(1, customer.getCustId());
            ps.setString(2, customer.getName());
            ps.setInt(3, customer.getAge());
        }

        @Override
        public int getBatchSize() {
            return customers.size();
        }
    });
}
</code></pre><p>这里使用了jdbcTemplate的batchUpdate方法,通过第二个参数设置字段映射.当你的字段与数据库字段一致时可以省略 </p>
<p>记录一下JdbcDaoSupport的用法 </p>
<blockquote>
<p>原生sql语句执行 </p>
</blockquote>
<pre><code>jdbcTemplate.execute(&quot;CREATE TABLE USER (user_id integer, name varchar(100))&quot;);
</code></pre><blockquote>
<p>如果是UPDATE或INSERT,可以用update()方法 </p>
</blockquote>
<pre><code>jdbcTemplate.update(&quot;INSERT INTO USER VALUES(&#39;&quot;  
        + user.getId() + &quot;&#39;, &#39;&quot;  
        + user.getName() + &quot;&#39;, &#39;&quot;  
        + user.getSex() + &quot;&#39;, &#39;&quot;  
        + user.getAge() + &quot;&#39;)&quot;);
</code></pre><blockquote>
<p>带参数的更新 </p>
</blockquote>
<pre><code>jdbcTemplate.update(&quot;UPDATE USER SET name = ? WHERE user_id = ?&quot;, new Object[] {name, id});

jdbcTemplate.update(&quot;INSERT INTO USER VALUES(?, ?, ?, ?)&quot;, new Object[] {user.getId(), user.getName(), user.getSex(), user.getAge()});
</code></pre><blockquote>
<p>使用JdbcTemplate进行查询时，使用queryForXXX()等方法 </p>
</blockquote>
<pre><code>int count = jdbcTemplate.queryForInt(&quot;SELECT COUNT(*) FROM USER&quot;);

String name = (String) jdbcTemplate.queryForObject(&quot;SELECT name FROM USER WHERE user_id = ?&quot;, new Object[] {id}, java.lang.String.class);
</code></pre><blockquote>
<p>使用iterator迭代器查询 </p>
</blockquote>
<pre><code>List rows = jdbcTemplate.queryForList(&quot;SELECT * FROM USER&quot;);  

List rows = jdbcTemplate.queryForList(&quot;SELECT * FROM USER&quot;);  
Iterator it = rows.iterator();  
while(it.hasNext()) {  
    Map userMap = (Map) it.next();  
    System.out.print(userMap.get(&quot;user_id&quot;) + &quot;\t&quot;);  
    System.out.print(userMap.get(&quot;name&quot;) + &quot;\t&quot;);  
    System.out.print(userMap.get(&quot;sex&quot;) + &quot;\t&quot;);  
    System.out.println(userMap.get(&quot;age&quot;) + &quot;\t&quot;);  
}
</code></pre><blockquote>
<p>在update或者query时还可以通过callback回调设置你的字段 </p>
</blockquote>
<pre><code>final String id = user.getId();  
final String name = user.getName();  
final String sex = user.getSex() + &quot;&quot;;  
final int age = user.getAge();  

jdbcTemplate.update(&quot;INSERT INTO USER VALUES(?, ?, ?, ?)&quot;,  
                    new PreparedStatementSetter() {  
                        public void setValues(PreparedStatement ps) throws SQLException {  
                                ps.setString(1, id);  
                                ps.setString(2, name);            
                                ps.setString(3, sex);  
                                ps.setInt(4, age);  
                                }  
                        });


final User user = new User();  
jdbcTemplate.query(&quot;SELECT * FROM USER WHERE user_id = ?&quot;,  
                    new Object[] {id},  
                    new RowCallbackHandler() {  
                        public void processRow(ResultSet rs) throws SQLException {  
                                user.setId(rs.getString(&quot;user_id&quot;));  
                                user.setName(rs.getString(&quot;name&quot;));  
                                user.setSex(rs.getString(&quot;sex&quot;).charAt(0));  
                                user.setAge(rs.getInt(&quot;age&quot;));  
                        }  
                    });
</code></pre><blockquote>
<p>RowMapper </p>
</blockquote>
<pre><code>class UserRowMapper implements RowMapper {  
    public Object mapRow(ResultSet rs, int index) throws SQLException {  
        User user = new User();  

        user.setId(rs.getString(&quot;user_id&quot;));  
        user.setName(rs.getString(&quot;name&quot;));  
        user.setSex(rs.getString(&quot;sex&quot;).charAt(0));  
        user.setAge(rs.getInt(&quot;age&quot;));  

        return user;  
    }  
}  

public List findAllByRowMapperResultReader() {  
    String sql = &quot;SELECT * FROM USER&quot;;  
    return jdbcTemplate.query(sql, new RowMapperResultReader(new UserRowMapper()));  
}



public User getUser(final String id) throws DataAccessException {  
    String sql = &quot;SELECT * FROM USER WHERE user_id=?&quot;;  
    final Object[] params = new Object[] { id };  
    List list = jdbcTemplate.query(sql, params, new RowMapperResultReader(new UserRowMapper()));  

    return (User) list.get(0);  
}
</code></pre><hr>
<h2 id="Spring自动装配Beans"><a href="#Spring自动装配Beans" class="headerlink" title="Spring自动装配Beans"></a>Spring自动装配Beans</h2><p>Spring对于Bean采用自动装配(AueoWire)机制<br>分为五种： </p>
<pre><code>1、no 省缺情况下，通过ref属性绑定     
2、byName 根据属性名自动装配 如果一个property的name和另一个bean的id相同，Spring将会自动装配  
3、byType 根据属性数据类型自动装配 如果一个property的属性和另一个bean的数据类型相同，Spring将会自动装配   
4、construtor 对于构造函数的属性使用byType方式    
5、autodetect 如果找到默认的构造函数采用“自动装配使用构造”，否则使用“按类型装配”
</code></pre><p>这里演示使用constructor的方式 </p>
<blockquote>
<p>Person Model </p>
</blockquote>
<pre><code>package com.demo.Model;

public class Person {
    private String name;
    private int age;
    private String address;

    public Person() {
    }

    public Person(String name, int age, String address) {
        this.name = name;
        this.age = age;
        this.address = address;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }
}
</code></pre><blockquote>
<p>Customer Model </p>
</blockquote>
<pre><code>package com.demo.Model;

public class Customer {
    private Person person;

    public Customer(Person person) {
        this.person = person;
    }

    public Person getPerson() {
        return person;
    }

    public void setPerson(Person person) {
        this.person = person;
    }
}
</code></pre><blockquote>
<p>在resources中加入配置文件Spring-Beans.xml </p>
</blockquote>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-4.0.xsd&quot;&gt;

    &lt;bean id=&quot;customer&quot; class=&quot;com.demo.Model.Customer&quot; autowire=&quot;constructor&quot;/&gt;

    &lt;bean id=&quot;person&quot; class=&quot;com.demo.Model.Person&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;RenBuRuGu&quot;/&gt;
        &lt;property name=&quot;age&quot; value=&quot;20&quot;/&gt;
        &lt;property name=&quot;address&quot; value=&quot;JiangSu NanJing&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre><blockquote>
<p>测试类App </p>
</blockquote>
<pre><code>package com.demo;

import com.demo.Model.Customer;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class App {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;Spring-Beans.xml&quot;);

        Customer customer = context.getBean(Customer.class);

        System.out.println(customer.getPerson().getAddress());
        System.out.println(customer.getPerson().getAge());
        System.out.println(customer.getPerson().getName());
    }
}
</code></pre><blockquote>
<p>运行结果如下: </p>
</blockquote>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15085762440587.jpg" alt=""></p>
<h3 id="AutoWired字段"><a href="#AutoWired字段" class="headerlink" title="@AutoWired字段"></a>@AutoWired字段</h3><blockquote>
<p>首先在beans中加入 </p>
<pre><code>&lt;context:annotation-config /&gt;
</code></pre></blockquote>
<p>或者 </p>
<pre><code>&lt;bean class=&quot;org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor&quot;/&gt;
</code></pre><blockquote>
<p>@AutoWired注解可以在属性、setter方法、或者构造方法中使用 </p>
</blockquote>
<p>Spring-Beans.xml </p>
<pre><code>&lt;context:annotation-config/&gt;

&lt;bean id=&quot;customer&quot; class=&quot;com.demo.Model.Customer&quot;/&gt;

&lt;bean id=&quot;person&quot; class=&quot;com.demo.Model.Person&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;RenBuRuGu&quot;/&gt;
    &lt;property name=&quot;age&quot; value=&quot;20&quot;/&gt;
    &lt;property name=&quot;address&quot; value=&quot;JiangSu NanJing&quot;/&gt;
&lt;/bean&gt;
</code></pre><blockquote>
<p>setter方法 </p>
</blockquote>
<pre><code>public class Customer {
    private Person person;

    public Person getPerson() {
            return person;
    }

    @Autowired
    public void setPerson(Person person) {
        this.person = person;
    }
}
</code></pre><blockquote>
<p>属性 </p>
</blockquote>
<pre><code>public class Customer {
    @Autowired
    private Person person;

    public Person getPerson() {
            return person;
    }
}
</code></pre><blockquote>
<p>构造方法 </p>
</blockquote>
<pre><code>public class Customer {

    private Person person;

    @Autowired
    public Customer(Person person) {
        this.person = person;
    }

    public Person getPerson() {
        return person;
    }
}
</code></pre><h3 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h3><blockquote>
<p>当自动装载的bean有冲突时，就可以用@Qualifier属性 </p>
</blockquote>
<pre><code>import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;

public class Customer {

    @Autowired
    @Qualifier(&quot;personA&quot;)
    private Person person;

}
</code></pre><h2 id="JavaConfig"><a href="#JavaConfig" class="headerlink" title="JavaConfig"></a>JavaConfig</h2><blockquote>
<p>我们之前注册bean都是通过xml注册的,形式如下: </p>
</blockquote>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-4.0.xsd&quot;&gt;

    &lt;bean id=&quot;helloBean&quot; class=&quot;com.demo.Model.HelloBean&quot;&gt;
        &lt;property name=&quot;id&quot; value=&quot;1&quot;/&gt;
        &lt;property name=&quot;content&quot; value=&quot;Hello Spring&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre><p>实体类代码如下: </p>
<pre><code>package com.demo.Model;

public class HelloBean {
    private int id;
    private String content;

    public void setId(int id) {
        this.id = id;
    }

    public void setContent(String content) {
        this.content = content;
    }

    public void print() {
        System.out.println(&quot;HelloBean:[ &quot; + id + &quot; &quot; + content + &quot; ]&quot;);
    }
}
</code></pre><p>我们写一个测试类来测试一下: </p>
<pre><code>package com.demo;

import com.demo.Model.HelloBean;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class App {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;Spring-Beans.xml&quot;);
        HelloBean helloBean = context.getBean(HelloBean.class);

        helloBean.print();
    }
}
</code></pre><p>输出结果如下: </p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15085829234470.jpg" alt=""></p>
<blockquote>
<p>我们也可以通过Spring注解的方式来用java代码完成配置 </p>
</blockquote>
<pre><code>package com.demo;

import com.demo.Model.HelloBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class AppConfig {
    @Bean(name = &quot;helloBean&quot;)
    public HelloBean helloBean(){
        HelloBean bean = new HelloBean();
        bean.setContent(&quot;Hello Spring&quot;);
        bean.setId(1);
        return bean;
    }
}
</code></pre><p>在Spring中，配置文件必须用configuration注解，相应的bean用@Bean注入 </p>
<p>相应的修改一下App测试类 </p>
<pre><code>import com.demo.Model.HelloBean;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class App {
    public static void main(String[] args) {

        ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);

        HelloBean helloBean = context.getBean(HelloBean.class);

        helloBean.print();
    }
}
</code></pre><p>输出结果完全一致 </p>
<h3 id="Import的使用"><a href="#Import的使用" class="headerlink" title="@Import的使用"></a>@Import的使用</h3><p>通常我们会把不同功能的配置文件分开到不同的xml中书写，然后统一在一个xml中导入进来，就像下面: </p>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-2.5.xsd&quot;&gt;

    &lt;import resource=&quot;config/customer.xml&quot;/&gt;
    &lt;import resource=&quot;config/scheduler.xml&quot;/&gt;

&lt;/beans&gt;
</code></pre><blockquote>
<p>我们可以使用Import注解来完成相同的功能 </p>
</blockquote>
<pre><code>import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;

@Configuration
@Import({ CustomerConfig.class, SchedulerConfig.class })
public class AppConfig {

}
</code></pre><blockquote>
<p>我们分别创建两个实体类CustomerBo和SchedulerBo </p>
</blockquote>
<pre><code>package com.demo.Model;

public class CustomerBo {
    public void printMsg(String msg) {
        System.out.println(&quot;CustomerBo: &quot; + msg);
    }
}

package com.demo.Model;

public class SchedulerBo {

    public void printMsg(String msg) {
        System.out.println(&quot;SchedulerBo: &quot; + msg);
    }
}
</code></pre><blockquote>
<p>接着创建相应的配置文件 </p>
</blockquote>
<pre><code>package com.demo.Config;

import com.demo.Model.CustomerBo;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class CustomerConfig {
    @Bean(name = &quot;customer&quot;)
    public CustomerBo customerBo(){
        return new CustomerBo();
    }
}

package com.demo.Config;

import com.demo.Model.SchedulerBo;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class SchedulerConfig {
    @Bean(name = &quot;scheduler&quot;)
    public SchedulerBo schedulerBo() {
        return new SchedulerBo();
    }
}
</code></pre><blockquote>
<p>然后在AppConfig中引用 </p>
</blockquote>
<pre><code>package com.demo;

import com.demo.Config.CustomerConfig;
import com.demo.Config.SchedulerConfig;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;

@Configuration
@Import({CustomerConfig.class, SchedulerConfig.class})
public class AppConfig {

}
</code></pre><blockquote>
<p>我们在测试类中就可以正常获取到这两个实体类了 </p>
</blockquote>
<pre><code>public class App {
    public static void main(String[] args) {
        ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);

        CustomerBo customerBo = context.getBean(CustomerBo.class);

        SchedulerBo schedulerBo = context.getBean(SchedulerBo.class);

        customerBo.printMsg(&quot;hello Spring&quot;);

        schedulerBo.printMsg(&quot;hello Spring&quot;);
    }
}
</code></pre><p>运行结果如下: </p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15085854585356.jpg" alt=""></p>
<h2 id="DI注入的小问题"><a href="#DI注入的小问题" class="headerlink" title="DI注入的小问题"></a>DI注入的小问题</h2><blockquote>
<p>我们通过在xml中书写配置文件进行DI注入,有两种方式:setter函数注入和构造函数注入 </p>
</blockquote>
<p>setter函数注入：用ref引用相应的bean<br>构造函数注入：用<code>&lt;constructor-arg&gt;</code>标签<br>如果存在多个构造函数，为了避免歧义，需要手动指定数据类型 </p>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-2.5.xsd&quot;&gt;

    &lt;bean id=&quot;CustomerBean&quot; class=&quot;com.yiibai.common.Customer&quot;&gt;

        &lt;constructor-arg type=&quot;java.lang.String&quot;&gt;
            &lt;value&gt;yiibai&lt;/value&gt;
        &lt;/constructor-arg&gt;

        &lt;constructor-arg type=&quot;java.lang.String&quot;&gt;
            &lt;value&gt;188&lt;/value&gt;
        &lt;/constructor-arg&gt;

        &lt;constructor-arg type=&quot;int&quot;&gt;
            &lt;value&gt;28&lt;/value&gt;
        &lt;/constructor-arg&gt;

    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre><h2 id="Spring中对Bean的引用"><a href="#Spring中对Bean的引用" class="headerlink" title="Spring中对Bean的引用"></a>Spring中对Bean的引用</h2><p>有两种方式bean和local </p>
<p><code>&lt;ref&gt;</code> 提供了如下几方面的属性 :<br>1)bean: 在当前 Spring XML 配置文件中，或者在同一 BeanFactory(ApplicationContext) 中的其他 JavaBean 中 .<br>2)local: 在当前 Spring XML 配置文件中 . 其依赖的 JavaBean 必须存在于当前 Spring XML配置文件中 . 如果借助于 Spring IDE, 则在编译期可以对其依赖的 JavaBean 进行验证。基于 local 方式，开发者能够使用到 XML 本身提供 的优势，而进行验证。<br>3)parent: 用于指定其依赖的父 JavaBean 定义。 </p>
<p>local属性在Spring 4.x中被废弃 </p>
<pre><code>&lt;bean id=&quot;OutputHelper&quot; class=&quot;com.yiibai.output.OutputHelper&quot;&gt;
    &lt;property name=&quot;outputGenerator&quot; &gt;
            &lt;ref local=&quot;CsvOutputGenerator&quot;/&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id=&quot;OutputHelper&quot; class=&quot;com.yiibai.output.OutputHelper&quot;&gt;
    &lt;property name=&quot;outputGenerator&quot; &gt;
        &lt;ref bean=&quot;CsvOutputGenerator&quot;/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre><blockquote>
<p>在xml中注入属性有三种方式 正常模式、快捷方式和P模式 </p>
</blockquote>
<p>正常模式(4.x不推荐使用) </p>
<pre><code>&lt;bean id=&quot;helloBean&quot; class=&quot;com.demo.Model.CustomerBo&quot;&gt;
    &lt;property name=&quot;content&quot;&gt;
        &lt;value&gt;Hello World&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre><p>快捷方式(value属性) </p>
<pre><code>&lt;bean id=&quot;helloBean&quot; class=&quot;com.demo.Model.CustomerBo&quot;&gt;
    &lt;property name=&quot;content&quot; value=&quot;Hello World&quot;/&gt;
&lt;/bean&gt;
</code></pre><p>P模式(value和value-ref两种模式 分别表示直接赋值和引用) </p>
<pre><code>&lt;bean id=&quot;helloBean&quot; class=&quot;com.demo.Model.CustomerBo&quot; p:content=&quot;hello world&quot;/&gt;
</code></pre><h2 id="Spring-Bean的作用域"><a href="#Spring-Bean的作用域" class="headerlink" title="Spring Bean的作用域"></a>Spring Bean的作用域</h2><p>Spring中Bean的作用域有两种 singleton(默认)单例模式和prototype 原型模式<br>生命作用域的方式很简单，至于要在xml的bean中使用<code>scope</code>属性即可 </p>
<p>我们还可以通过@Scope注解的方式来实现相同的效果 </p>
<pre><code>@Service
@Scope(&quot;prototype&quot;)
public class CustomerService 
{
    String message;

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }
}
</code></pre><p>需要在xml中开启自动扫描组件功能 </p>
<pre><code>&lt;context:component-scan base-package=&quot;com.yiibai.customer&quot; /&gt;
</code></pre><h2 id="Spring中注册List-Map-Set-Properties等集合"><a href="#Spring中注册List-Map-Set-Properties等集合" class="headerlink" title="Spring中注册List Map Set Properties等集合"></a>Spring中注册List Map Set Properties等集合</h2><blockquote>
<p>Spring中支持对这些集合类的注册和使用，下面是例子 </p>
</blockquote>
<p>创建两个实体类Person和Customer </p>
<pre><code>Person.java

package com.demo.Model;

public class Person {
    private String name;
    private String address;
    private int age;

    public void setName(String name) {
        this.name = name;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return &quot;[ name: &quot; + name + &quot;address: &quot; + address + &quot;age: &quot; + age + &quot; ]&quot;;
    }
}

Customer.java

package com.demo.Model;

import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;

public class Customer {
    private List&lt;Object&gt; lists;
    private Set&lt;Object&gt; sets;
    private Map&lt;Object, Object&gt; maps;
    private Properties props;

    public void setLists(List&lt;Object&gt; lists) {
        this.lists = lists;
    }

    public void setSets(Set&lt;Object&gt; sets) {
        this.sets = sets;
    }

    public void setMaps(Map&lt;Object, Object&gt; maps) {
        this.maps = maps;
    }

    public void setProps(Properties props) {
        this.props = props;
    }

    @Override
    public String toString() {
        StringBuffer buffer = new StringBuffer();
        buffer.append(&quot;list:\n&quot;);
        for (Object o : lists) {
            buffer.append(o.toString() + &quot;\n&quot;);
        }
        buffer.append(&quot;set:\n&quot;);
        for (Object o : sets) {
            buffer.append(o.toString() + &quot;\n&quot;);
        }
        buffer.append(&quot;map:\n&quot;);
        for (Object o : maps.keySet()) {
            buffer.append(&quot;key: &quot; + o.toString() + &quot;  value: &quot; + maps.get(o).toString() + &quot;\n&quot;);
        }
        buffer.append(&quot;properties:\n&quot;);
        for (Object o : props.keySet()) {
            buffer.append(&quot;key: &quot; + o.toString() + &quot;  value: &quot; + props.get(o).toString() + &quot;\n&quot;);
        }
        return buffer.toString();
    }
}
</code></pre><p>我们可以在xml中去注册这些属性值 </p>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-4.0.xsd&quot;&gt;

    &lt;bean id=&quot;customer&quot; class=&quot;com.demo.Model.Customer&quot;&gt;
        &lt;property name=&quot;lists&quot;&gt;
            &lt;list&gt;
                &lt;value&gt;1&lt;/value&gt;
                &lt;ref bean=&quot;person&quot;/&gt;
                &lt;bean class=&quot;com.demo.Model.Person&quot;
                        p:name=&quot;RenBuRuGu123&quot;
                        p:address=&quot;JiangSu NanJing&quot;
                        p:age=&quot;22&quot;/&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;property name=&quot;maps&quot;&gt;
            &lt;map&gt;
                &lt;entry key=&quot;1&quot; value=&quot;1&quot;/&gt;
                &lt;entry key=&quot;2&quot; value-ref=&quot;person&quot;/&gt;
                &lt;entry key=&quot;hello&quot;&gt;
                    &lt;bean class=&quot;com.demo.Model.Person&quot;
                            p:name=&quot;RenBuRuGu&quot;
                            p:address=&quot;JiangSu NanJing&quot;
                            p:age=&quot;20&quot;/&gt;
                &lt;/entry&gt;
            &lt;/map&gt;
        &lt;/property&gt;
        &lt;property name=&quot;props&quot;&gt;
            &lt;props&gt;
                &lt;prop key=&quot;admin&quot;&gt;Admin@123&lt;/prop&gt;
                &lt;prop key=&quot;support&quot;&gt;support@gmail.com&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
        &lt;property name=&quot;sets&quot;&gt;
            &lt;set&gt;
                &lt;set&gt;
                    &lt;value&gt;1&lt;/value&gt;
                    &lt;ref bean=&quot;person&quot;/&gt;
                    &lt;bean class=&quot;com.demo.Model.Person&quot;&gt;
                        &lt;property name=&quot;name&quot; value=&quot;Test Set&quot;/&gt;
                        &lt;property name=&quot;address&quot; value=&quot;Hainan Haikou&quot;/&gt;
                        &lt;property name=&quot;age&quot; value=&quot;28&quot;/&gt;
                    &lt;/bean&gt;
                &lt;/set&gt;
            &lt;/set&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;person&quot; class=&quot;com.demo.Model.Person&quot;
            p:name=&quot;RenBuRuGu&quot;
            p:address=&quot;JiangSu NanJing&quot;
            p:age=&quot;20&quot;/&gt;
&lt;/beans&gt;
</code></pre><p>测试类: </p>
<pre><code>public class App {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;Spring-Beans.xml&quot;);
        Customer customer = context.getBean(Customer.class);

        System.out.println(customer);
    }
}
</code></pre><p>运行结果如下: </p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15085930603056.jpg" alt=""></p>
<blockquote>
<p>自定义List类型 </p>
</blockquote>
<p>如果想要返回的List是ArrayList数据类型的 你有两种方式去实现它 ListFactoryBean 和 util:list<br>分别举个例子 </p>
<blockquote>
<p>ListFactoryBean方式 </p>
</blockquote>
<pre><code>&lt;property name=&quot;lists&quot;&gt;
    &lt;bean class=&quot;org.springframework.beans.factory.config.ListFactoryBean&quot;&gt;
        &lt;property name=&quot;targetListClass&quot; value=&quot;java.util.ArrayList&quot;/&gt;
        &lt;property name=&quot;sourceList&quot;&gt;
            &lt;list&gt;
                &lt;value&gt;1&lt;/value&gt;
                &lt;ref bean=&quot;person&quot;/&gt;
                &lt;bean class=&quot;com.demo.Model.Person&quot;
                        p:name=&quot;RenBuRuGu123&quot;
                        p:address=&quot;JiangSu NanJing&quot;
                        p:age=&quot;22&quot;/&gt;
            &lt;/list&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/property&gt;
</code></pre><p>通过targetListClass指定List的数据类型，sourceList包裹原list数据 </p>
<blockquote>
<p>util:list方式 </p>
</blockquote>
<pre><code>&lt;util:list list-class=&quot;java.util.ArrayList&quot;&gt;
    &lt;value&gt;1&lt;/value&gt;
    &lt;ref bean=&quot;person&quot;/&gt;
    &lt;bean class=&quot;com.demo.Model.Person&quot;
            p:name=&quot;RenBuRuGu123&quot;
            p:address=&quot;JiangSu NanJing&quot;
            p:age=&quot;22&quot;/&gt;
&lt;/util:list&gt;
</code></pre><p>效果完全一样，个人觉得这种方式比较简便 </p>
<ul>
<li>MapFactoryBean和SetFactoryBean用法完全相同,不做过多介绍…</li>
</ul>
<h2 id="Spring注入日期类型的数据"><a href="#Spring注入日期类型的数据" class="headerlink" title="Spring注入日期类型的数据"></a>Spring注入日期类型的数据</h2><p>1、通过factoryBean的方式 </p>
<pre><code>&lt;bean id=&quot;dateFormat&quot; class=&quot;java.text.SimpleDateFormat&quot;&gt;
    &lt;constructor-arg value=&quot;yyyy-MM-dd&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;customer&quot; class=&quot;com.demo.Model.Customer&quot;&gt;
    &lt;property name=&quot;date&quot;&gt;
        &lt;bean factory-bean=&quot;dateFormat&quot; factory-method=&quot;parse&quot;&gt;
            &lt;constructor-arg value=&quot;2015-12-31&quot;/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre><p>我们创建一个SimpleDateFormat的Bean然后通过Factory-bean和Factory-method方法调用SimpleDataFormat的prase方法来初始化我们的日期 </p>
<p>2、通过CustomDateEditor的方式(反正我不会用，一直报错) </p>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-2.5.xsd&quot;&gt;

    &lt;bean id=&quot;dateEditor&quot;
        class=&quot;org.springframework.beans.propertyeditors.CustomDateEditor&quot;&gt;

        &lt;constructor-arg&gt;
            &lt;bean class=&quot;java.text.SimpleDateFormat&quot;&gt;
                &lt;constructor-arg value=&quot;yyyy-MM-dd&quot; /&gt;
            &lt;/bean&gt;
        &lt;/constructor-arg&gt;
        &lt;constructor-arg value=&quot;true&quot; /&gt;

    &lt;/bean&gt;

    &lt;bean class=&quot;org.springframework.beans.factory.config.CustomEditorConfigurer&quot;&gt;
        &lt;property name=&quot;customEditors&quot;&gt;
            &lt;map&gt;
                &lt;entry key=&quot;java.util.Date&quot;&gt;
                    &lt;ref local=&quot;dateEditor&quot; /&gt;
                &lt;/entry&gt;
            &lt;/map&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;customer&quot; class=&quot;com.yiibai.common.Customer&quot;&gt;
        &lt;property name=&quot;date&quot; value=&quot;2015-12-31&quot; /&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre><ul>
<li><code>&lt;ref local=&quot;&quot;&gt;</code>用法好像在4.x中被删除了</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
    
    </summary>
    
      <category term="Spring" scheme="https://wangyu1997.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="https://wangyu1997.github.io/tags/Spring/"/>
    
      <category term="AutoWire" scheme="https://wangyu1997.github.io/tags/AutoWire/"/>
    
      <category term="Beans" scheme="https://wangyu1997.github.io/tags/Beans/"/>
    
      <category term="JdbcTemplate" scheme="https://wangyu1997.github.io/tags/JdbcTemplate/"/>
    
      <category term="SimpleJdbcTemplate" scheme="https://wangyu1997.github.io/tags/SimpleJdbcTemplate/"/>
    
  </entry>
  
  <entry>
    <title>学习Spring第二天</title>
    <link href="https://wangyu1997.github.io/2017/10/20/Spring/Spring%E4%BD%BF%E7%94%A8jdbc/"/>
    <id>https://wangyu1997.github.io/2017/10/20/Spring/Spring使用jdbc/</id>
    <published>2017-10-20T13:43:11.000Z</published>
    <updated>2017-10-24T06:48:11.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a>  
<h2 id="在Spring中使用jdbc"><a href="#在Spring中使用jdbc" class="headerlink" title="在Spring中使用jdbc"></a>在Spring中使用jdbc</h2><hr>
<blockquote>
<p>添加gradle依赖 </p>
</blockquote>
<pre><code>dependencies {

testCompile group: &#39;junit&#39;, name: &#39;junit&#39;, version: &#39;4.12&#39;

compile group: &#39;org.springframework&#39;, name: &#39;spring-context&#39;, version: &#39;5.0.0.RELEASE&#39;

compile group: &#39;org.springframework&#39;, name: &#39;spring-jdbc&#39;, version: &#39;5.0.0.RELEASE&#39;

compile group: &#39;mysql&#39;, name: &#39;mysql-connector-java&#39;, version: &#39;8.0.8-dmr&#39;

}
</code></pre><blockquote>
<p>首先创建数据表 </p>
</blockquote>
<pre><code>CREATE TABLE `customer` (
    `CUST_ID` int(10) unsigned NOT NULL AUTO_INCREMENT,
    `NAME` varchar(100) NOT NULL,
    `AGE` int(10) unsigned NOT NULL,
        PRIMARY KEY (`CUST_ID`)
) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;
</code></pre><p>下面实现业务代码 </p>
<blockquote>
<p>创建一个Customer实体类 </p>
</blockquote>
<pre><code>package com.demo.Model;

public class Customer {
    private int cusId;
    private String name;
    private int age;

    public Customer(int cusId, String name, int age) {
        this.cusId = cusId;
        this.name = name;
        this.age = age;
    }

    public int getCusId() {
        return cusId;
    }

    public void setCusId(int cusId) {
        this.cusId = cusId;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return &quot;id: &quot; + cusId + &quot;\nname: &quot; + name + &quot;\nage: &quot; + age;
    }
}
</code></pre><blockquote>
<p>下面创建一个DAO </p>
</blockquote>
<pre><code>public interface CustomerDao {
    void insert(Customer customer);

    Customer findByCustomerId(int cusId);
}
</code></pre><blockquote>
<p>创建一个DAO的实现层 </p>
</blockquote>
<pre><code>public class JdbcCustomerDao implements CustomerDao {
    private DataSource dataSource;

    public void setDataSource(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    @Override
    public void insert(Customer customer) {
        String sql = &quot;INSERT INTO customer(CUST_ID,NAME,AGE) VALUES(?,?,?)&quot;;
        Connection conn = null;

        try {
            conn = dataSource.getConnection();
            PreparedStatement ps = conn.prepareStatement(sql);
            ps.setInt(1, customer.getCusId());
            ps.setString(2, customer.getName());
            ps.setInt(3, customer.getAge());
            ps.executeUpdate();
            ps.close();
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            if (conn != null) {
                try {
                    conn.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
</code></pre><p>这里采用最原始的jdbc对数据库进行操作，通过dataSource的方式获取connection.dataSource通过Spring-DataSource.xml获取 </p>
<blockquote>
<p>下面创建Spring-Dataource.xml </p>
</blockquote>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-4.0.xsd&quot;&gt;

    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/Spring&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;19970819wy&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre><p>这里使用Spring-JDBC，配置好jdbc的一系列信息 </p>
<blockquote>
<p>Spring-Customer.xml </p>
</blockquote>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-4.0.xsd&quot;&gt;

    &lt;bean id=&quot;customerDAO&quot; class=&quot;com.demo.DaoImpl.JdbcCustomerDao&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre><blockquote>
<p>Spring-Moudle.xml </p>
</blockquote>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-4.0.xsd&quot;&gt;

    &lt;import resource=&quot;Spring-DataSource.xml&quot;/&gt;
    &lt;import resource=&quot;Spring-Customer.xml&quot;/&gt;
&lt;/beans&gt;
</code></pre><p>到此为止xml配置文件已经写完了，最后写个测试类测试一下 </p>
<blockquote>
<p>App.java </p>
</blockquote>
<pre><code>package com.demo;

import com.demo.Dao.CustomerDao;
import com.demo.Model.Customer;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class App
{
    public static void main( String[] args )
    {
        ApplicationContext context =
                new ClassPathXmlApplicationContext(&quot;Spring-Moudle.xml&quot;);

        CustomerDao customerDAO = (CustomerDao) context.getBean(&quot;customerDAO&quot;);
        Customer customer = new Customer(1, &quot;RenBuRuGu&quot;,20);
        customerDAO.insert(customer);

        Customer customer1 = customerDAO.findByCustomerId(1);
        System.out.println(customer1);

    }
}
</code></pre><p>运行结果如下: </p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15085578276768.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
    
    </summary>
    
      <category term="Spring" scheme="https://wangyu1997.github.io/categories/Spring/"/>
    
    
      <category term="spring" scheme="https://wangyu1997.github.io/tags/spring/"/>
    
      <category term="jdbc" scheme="https://wangyu1997.github.io/tags/jdbc/"/>
    
      <category term="mysql" scheme="https://wangyu1997.github.io/tags/mysql/"/>
    
      <category term="spring-jdbc" scheme="https://wangyu1997.github.io/tags/spring-jdbc/"/>
    
  </entry>
  
  <entry>
    <title>学习Spring第一天</title>
    <link href="https://wangyu1997.github.io/2017/10/19/Spring/xml%E8%8E%B7%E5%8F%96Bean/"/>
    <id>https://wangyu1997.github.io/2017/10/19/Spring/xml获取Bean/</id>
    <published>2017-10-19T13:43:11.000Z</published>
    <updated>2017-10-24T06:47:02.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a>  
<h2 id="在xml中装载Bean实体"><a href="#在xml中装载Bean实体" class="headerlink" title="在xml中装载Bean实体"></a>在xml中装载Bean实体</h2><hr>
<blockquote>
<p>首先新建一个实体类 HelloWorld.java </p>
</blockquote>
<pre><code>public class HelloWorld{
    private String name;

    public void setName(String name){
        this.name = name;
    }

    public void printHello(){
        System.out.println(&quot;Spring 4: Hello!&quot; + name);
    }  
}
</code></pre><p>一个实体类就创建完成了，接下来我们在xml中注册这个实体类. </p>
<blockquote>
<p>在resources文件夹下创建applicationContext.xml </p>
</blockquote>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15084257704294.jpg" alt=""></p>
<p>代码结构如上，我们在xml中配置beans. </p>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-4.0.xsd&quot;&gt;

    &lt;bean id=&quot;helloBean&quot; class=&quot;com.demo.Entity.HelloWorld&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;RenBuRuGu&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre><p>其中id为bean的唯一编号，每一个实体类都需要注册成一个bean。class为对应的entity，property为属性值，对应着HelloWorld里的name，spring会根据setName函数自动为name赋值.<br>完成了这一步之后，下面我们来编写一个测试函数调用一下. </p>
<blockquote>
<p>在com.demo根目录下创建App.java. </p>
</blockquote>
<pre><code>public class App {
    public static void main(String[] args){

        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;application.xml&quot;);

        HelloWorld helloWorld = context.getBean(&quot;helloBean&quot;);

        helloWorld.printHello();
    }

}
</code></pre><p>我们通过ClassPathXmlApplicationContext获取xml的bean实体，然后通过Spring的IOC从容器中获取HelloWorld. </p>
<blockquote>
<p>运行结果如下. </p>
</blockquote>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15084265313737.jpg" alt=""></p>
<hr>
<h2 id="Spring的松耦合机制"><a href="#Spring的松耦合机制" class="headerlink" title="Spring的松耦合机制"></a>Spring的松耦合机制</h2><blockquote>
<p>下面为大家介绍一下Spring的松耦合机制. </p>
</blockquote>
<p>项目结构如下:<br><img src="http://oq5d32gij.bkt.clouddn.com/15084583360437.jpg" alt=""><br>如果我们想实现一个可以用Csv和Json格式输出的功能，稍微有点经验的java程序员可能会把输出功能抽象成一个接口然后分别实现. </p>
<blockquote>
<p>先创建一个输出功能的interface </p>
</blockquote>
<pre><code>public interface IOutputGenerator{
    void generateOutput();
}
</code></pre><blockquote>
<p>然后我们创建两个类分别去实现这个接口.<br>CsvOutputGenerator </p>
</blockquote>
<pre><code>public class CsvOutputGenerator implements IOutputGenerator {

    @Override
    public void generateOutput(){
        System.out.println(&quot;Csv Output Generator&quot;);
    }
}
</code></pre><blockquote>
<p>JsonOutputGenerator </p>
</blockquote>
<pre><code>public class JsonOutputGenerator implements IOutputGenerator {

    @Override
    public void generateOutput(){
        System.out.println(&quot;Json Output Generator&quot;);
    }
}
</code></pre><p>如果我们想要在业务逻辑代码中使用输出功能，有如下三个方法: </p>
<pre><code>IoutputGenerator output = new CsvOutputGenerator();

output.generateOutput();
</code></pre><p>这种方式肯定是不好的，如果需求变了或者需要使用新的Generator，必须在所有引用到的地方都手动修改，这种方式的工作量是巨大的. </p>
<pre><code>public class OutputHelper{
    private IOutputGenerator output;

    public OutputHelper(){
        this.output = new CsvOutputGenerator();
    }

    public generateOutput(){
        output.generateOutput();
    }

}
</code></pre><p>当我们需要使用的时候直接调用OutputHelper就可以了. </p>
<pre><code>OutputHelper helper = new OutputHelper();

helper.generateOutput();
</code></pre><p>这种方法比第一种好，当需求改变时(比如从csv变成json)，我们只需要在OutputHelper里手动修改就好了. </p>
<p>第三种方法是用Spring的松耦合机制.<br>我们先在xml中配置bean. </p>
<blockquote>
<p>Spring-common.xml </p>
</blockquote>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-4.0.xsd&quot;&gt;
    &lt;bean id=&quot;outputHelper&quot; class=&quot;com.demo.Helper.OutputHelper&quot;&gt;
        &lt;property name=&quot;outputGenerator&quot; ref=&quot;csvOutputGenerator&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;csvOutputGenerator&quot; class=&quot;com.demo.Generator.CsvOutputGenerator&quot;/&gt;
    &lt;bean id=&quot;jsonOutputGenerator&quot; class=&quot;com.demo.Generator.JsonOutputGenerator&quot;/&gt;
&lt;/beans&gt;
</code></pre><blockquote>
<p>OutputHelper </p>
</blockquote>
<pre><code>public class OutputHelper {

    private IOutputGenerator outputGenerator;

    public void setOutputGenerator(IOutputGenerator outputGenerator) {
        this.outputGenerator = outputGenerator;
    }

    public void generatorOutput() {
        outputGenerator.generateOutput();
    }
}
</code></pre><p>我们现在可以这么使用它: </p>
<pre><code>public class App {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;Spring-common.xml&quot;);
        OutputHelper outputHelper = (OutputHelper) context.getBean(&quot;outputHelper&quot;);

        outputHelper.generatorOutput();
    }
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
    
    </summary>
    
      <category term="Spring" scheme="https://wangyu1997.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="https://wangyu1997.github.io/tags/Spring/"/>
    
      <category term="ClassPathXmlApplicationCOntext" scheme="https://wangyu1997.github.io/tags/ClassPathXmlApplicationCOntext/"/>
    
      <category term="Hello World" scheme="https://wangyu1997.github.io/tags/Hello-World/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis最详细配置</title>
    <link href="https://wangyu1997.github.io/2017/10/10/JavaWeb/MyBatis%E6%9C%80%E8%AF%A6%E7%BB%86%E9%85%8D%E7%BD%AE/"/>
    <id>https://wangyu1997.github.io/2017/10/10/JavaWeb/MyBatis最详细配置/</id>
    <published>2017-10-10T02:43:11.000Z</published>
    <updated>2017-10-24T06:34:07.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a> 
<p>同学们有福了，花了一些时间，重新整理了一个最完整的Mybatis Generator（简称MBG）的最完整配置文件，带详解，再也不用去看EN的User Guide了；  </p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE generatorConfiguration
  PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;
&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;
&lt;!-- 配置生成器 --&gt;
&lt;generatorConfiguration&gt;
&lt;!-- 可以用于加载配置项或者配置文件，在整个配置文件中就可以使用${propertyKey}的方式来引用配置项
    resource：配置资源加载地址，使用resource，MBG从classpath开始找，比如com/myproject/generatorConfig.properties        
    url：配置资源加载地质，使用URL的方式，比如file:///C:/myfolder/generatorConfig.properties.
    注意，两个属性只能选址一个;

    另外，如果使用了mybatis-generator-maven-plugin，那么在pom.xml中定义的properties都可以直接在generatorConfig.xml中使用
&lt;properties resource=&quot;&quot; url=&quot;&quot; /&gt;
 --&gt;

 &lt;!-- 在MBG工作的时候，需要额外加载的依赖包
     location属性指明加载jar/zip包的全路径
&lt;classPathEntry location=&quot;/Program Files/IBM/SQLLIB/java/db2java.zip&quot; /&gt;
  --&gt;

&lt;!-- 
    context:生成一组对象的环境 
    id:必选，上下文id，用于在生成错误时提示
    defaultModelType:指定生成对象的样式
        1，conditional：类似hierarchical；
        2，flat：所有内容（主键，blob）等全部生成在一个对象中；
        3，hierarchical：主键生成一个XXKey对象(key class)，Blob等单独生成一个对象，其他简单属性在一个对象中(record class)
    targetRuntime:
        1，MyBatis3：默认的值，生成基于MyBatis3.x以上版本的内容，包括XXXBySample；
        2，MyBatis3Simple：类似MyBatis3，只是不生成XXXBySample；
    introspectedColumnImpl：类全限定名，用于扩展MBG
--&gt;
&lt;context id=&quot;mysql&quot; defaultModelType=&quot;hierarchical&quot; targetRuntime=&quot;MyBatis3Simple&quot; &gt;

    &lt;!-- 自动识别数据库关键字，默认false，如果设置为true，根据SqlReservedWords中定义的关键字列表；
        一般保留默认值，遇到数据库关键字（Java关键字），使用columnOverride覆盖
     --&gt;
    &lt;property name=&quot;autoDelimitKeywords&quot; value=&quot;false&quot;/&gt;
    &lt;!-- 生成的Java文件的编码 --&gt;
    &lt;property name=&quot;javaFileEncoding&quot; value=&quot;UTF-8&quot;/&gt;
    &lt;!-- 格式化java代码 --&gt;
    &lt;property name=&quot;javaFormatter&quot; value=&quot;org.mybatis.generator.api.dom.DefaultJavaFormatter&quot;/&gt;
    &lt;!-- 格式化XML代码 --&gt;
    &lt;property name=&quot;xmlFormatter&quot; value=&quot;org.mybatis.generator.api.dom.DefaultXmlFormatter&quot;/&gt;

    &lt;!-- beginningDelimiter和endingDelimiter：指明数据库的用于标记数据库对象名的符号，比如ORACLE就是双引号，MYSQL默认是`反引号； --&gt;
    &lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot;/&gt;
    &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt;

    &lt;!-- 必须要有的，使用这个配置链接数据库
        @TODO:是否可以扩展
     --&gt;
    &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql:///pss&quot; userId=&quot;root&quot; password=&quot;admin&quot;&gt;
        &lt;!-- 这里面可以设置property属性，每一个property属性都设置到配置的Driver上 --&gt;
    &lt;/jdbcConnection&gt;

    &lt;!-- java类型处理器 
        用于处理DB中的类型到Java中的类型，默认使用JavaTypeResolverDefaultImpl；
        注意一点，默认会先尝试使用Integer，Long，Short等来对应DECIMAL和 NUMERIC数据类型； 
    --&gt;
    &lt;javaTypeResolver type=&quot;org.mybatis.generator.internal.types.JavaTypeResolverDefaultImpl&quot;&gt;
        &lt;!-- 
            true：使用BigDecimal对应DECIMAL和 NUMERIC数据类型
            false：默认,
                scale&gt;0;length&gt;18：使用BigDecimal;
                scale=0;length[10,18]：使用Long；
                scale=0;length[5,9]：使用Integer；
                scale=0;length&lt;5：使用Short；
         --&gt;
        &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&gt;
    &lt;/javaTypeResolver&gt;


    &lt;!-- java模型创建器，是必须要的元素
        负责：1，key类（见context的defaultModelType）；2，java类；3，查询类
        targetPackage：生成的类要放的包，真实的包受enableSubPackages属性控制；
        targetProject：目标项目，指定一个存在的目录下，生成的内容会放到指定目录中，如果目录不存在，MBG不会自动建目录
     --&gt;
    &lt;javaModelGenerator targetPackage=&quot;com._520it.mybatis.domain&quot; targetProject=&quot;src/main/java&quot;&gt;
        &lt;!--  for MyBatis3/MyBatis3Simple
            自动为每一个生成的类创建一个构造方法，构造方法包含了所有的field；而不是使用setter；
         --&gt;
        &lt;property name=&quot;constructorBased&quot; value=&quot;false&quot;/&gt;

        &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt;
        &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;

        &lt;!-- for MyBatis3 / MyBatis3Simple
            是否创建一个不可变的类，如果为true，
            那么MBG会创建一个没有setter方法的类，取而代之的是类似constructorBased的类
         --&gt;
        &lt;property name=&quot;immutable&quot; value=&quot;false&quot;/&gt;

        &lt;!-- 设置一个根对象，
            如果设置了这个根对象，那么生成的keyClass或者recordClass会继承这个类；在Table的rootClass属性中可以覆盖该选项
            注意：如果在key class或者record class中有root class相同的属性，MBG就不会重新生成这些属性了，包括：
                1，属性名相同，类型相同，有相同的getter/setter方法；
         --&gt;
        &lt;property name=&quot;rootClass&quot; value=&quot;com._520it.mybatis.domain.BaseDomain&quot;/&gt;

        &lt;!-- 设置是否在getter方法中，对String类型字段调用trim()方法 --&gt;
        &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt;
    &lt;/javaModelGenerator&gt;


    &lt;!-- 生成SQL map的XML文件生成器，
        注意，在Mybatis3之后，我们可以使用mapper.xml文件+Mapper接口（或者不用mapper接口），
            或者只使用Mapper接口+Annotation，所以，如果 javaClientGenerator配置中配置了需要生成XML的话，这个元素就必须配置
        targetPackage/targetProject:同javaModelGenerator
     --&gt;
    &lt;sqlMapGenerator targetPackage=&quot;com._520it.mybatis.mapper&quot; targetProject=&quot;src/main/resources&quot;&gt;
        &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt;
        &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;
    &lt;/sqlMapGenerator&gt;


    &lt;!-- 对于mybatis来说，即生成Mapper接口，注意，如果没有配置该元素，那么默认不会生成Mapper接口 
        targetPackage/targetProject:同javaModelGenerator
        type：选择怎么生成mapper接口（在MyBatis3/MyBatis3Simple下）：
            1，ANNOTATEDMAPPER：会生成使用Mapper接口+Annotation的方式创建（SQL生成在annotation中），不会生成对应的XML；
            2，MIXEDMAPPER：使用混合配置，会生成Mapper接口，并适当添加合适的Annotation，但是XML会生成在XML中；
            3，XMLMAPPER：会生成Mapper接口，接口完全依赖XML；
        注意，如果context是MyBatis3Simple：只支持ANNOTATEDMAPPER和XMLMAPPER
    --&gt;
    &lt;javaClientGenerator targetPackage=&quot;com._520it.mybatis.mapper&quot; type=&quot;ANNOTATEDMAPPER&quot; targetProject=&quot;src/main/java&quot;&gt;
        &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt;
        &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;

        &lt;!-- 可以为所有生成的接口添加一个父接口，但是MBG只负责生成，不负责检查
        &lt;property name=&quot;rootInterface&quot; value=&quot;&quot;/&gt;
         --&gt;
    &lt;/javaClientGenerator&gt;

    &lt;!-- 选择一个table来生成相关文件，可以有一个或多个table，必须要有table元素
        选择的table会生成一下文件：
        1，SQL map文件
        2，生成一个主键类；
        3，除了BLOB和主键的其他字段的类；
        4，包含BLOB的类；
        5，一个用户生成动态查询的条件类（selectByExample, deleteByExample），可选；
        6，Mapper接口（可选）

        tableName（必要）：要生成对象的表名；
        注意：大小写敏感问题。正常情况下，MBG会自动的去识别数据库标识符的大小写敏感度，在一般情况下，MBG会
            根据设置的schema，catalog或tablename去查询数据表，按照下面的流程：
            1，如果schema，catalog或tablename中有空格，那么设置的是什么格式，就精确的使用指定的大小写格式去查询；
            2，否则，如果数据库的标识符使用大写的，那么MBG自动把表名变成大写再查找；
            3，否则，如果数据库的标识符使用小写的，那么MBG自动把表名变成小写再查找；
            4，否则，使用指定的大小写格式查询；
        另外的，如果在创建表的时候，使用的&quot;&quot;把数据库对象规定大小写，就算数据库标识符是使用的大写，在这种情况下也会使用给定的大小写来创建表名；
        这个时候，请设置delimitIdentifiers=&quot;true&quot;即可保留大小写格式；

        可选：
        1，schema：数据库的schema；
        2，catalog：数据库的catalog；
        3，alias：为数据表设置的别名，如果设置了alias，那么生成的所有的SELECT SQL语句中，列名会变成：alias_actualColumnName
        4，domainObjectName：生成的domain类的名字，如果不设置，直接使用表名作为domain类的名字；可以设置为somepck.domainName，那么会自动把domainName类再放到somepck包里面；
        5，enableInsert（默认true）：指定是否生成insert语句；
        6，enableSelectByPrimaryKey（默认true）：指定是否生成按照主键查询对象的语句（就是getById或get）；
        7，enableSelectByExample（默认true）：MyBatis3Simple为false，指定是否生成动态查询语句；
        8，enableUpdateByPrimaryKey（默认true）：指定是否生成按照主键修改对象的语句（即update)；
        9，enableDeleteByPrimaryKey（默认true）：指定是否生成按照主键删除对象的语句（即delete）；
        10，enableDeleteByExample（默认true）：MyBatis3Simple为false，指定是否生成动态删除语句；
        11，enableCountByExample（默认true）：MyBatis3Simple为false，指定是否生成动态查询总条数语句（用于分页的总条数查询）；
        12，enableUpdateByExample（默认true）：MyBatis3Simple为false，指定是否生成动态修改语句（只修改对象中不为空的属性）；
        13，modelType：参考context元素的defaultModelType，相当于覆盖；
        14，delimitIdentifiers：参考tableName的解释，注意，默认的delimitIdentifiers是双引号，如果类似MYSQL这样的数据库，使用的是`（反引号，那么还需要设置context的beginningDelimiter和endingDelimiter属性）
        15，delimitAllColumns：设置是否所有生成的SQL中的列名都使用标识符引起来。默认为false，delimitIdentifiers参考context的属性

        注意，table里面很多参数都是对javaModelGenerator，context等元素的默认属性的一个复写；
     --&gt;
    &lt;table tableName=&quot;userinfo&quot; &gt;

        &lt;!-- 参考 javaModelGenerator 的 constructorBased属性--&gt;
        &lt;property name=&quot;constructorBased&quot; value=&quot;false&quot;/&gt;

        &lt;!-- 默认为false，如果设置为true，在生成的SQL中，table名字不会加上catalog或schema； --&gt;
        &lt;property name=&quot;ignoreQualifiersAtRuntime&quot; value=&quot;false&quot;/&gt;

        &lt;!-- 参考 javaModelGenerator 的 immutable 属性 --&gt;
        &lt;property name=&quot;immutable&quot; value=&quot;false&quot;/&gt;

        &lt;!-- 指定是否只生成domain类，如果设置为true，只生成domain类，如果还配置了sqlMapGenerator，那么在mapper XML文件中，只生成resultMap元素 --&gt;
        &lt;property name=&quot;modelOnly&quot; value=&quot;false&quot;/&gt;

        &lt;!-- 参考 javaModelGenerator 的 rootClass 属性 
        &lt;property name=&quot;rootClass&quot; value=&quot;&quot;/&gt;
         --&gt;

        &lt;!-- 参考javaClientGenerator 的  rootInterface 属性
        &lt;property name=&quot;rootInterface&quot; value=&quot;&quot;/&gt;
        --&gt;

        &lt;!-- 如果设置了runtimeCatalog，那么在生成的SQL中，使用该指定的catalog，而不是table元素上的catalog 
        &lt;property name=&quot;runtimeCatalog&quot; value=&quot;&quot;/&gt;
        --&gt;

        &lt;!-- 如果设置了runtimeSchema，那么在生成的SQL中，使用该指定的schema，而不是table元素上的schema 
        &lt;property name=&quot;runtimeSchema&quot; value=&quot;&quot;/&gt;
        --&gt;

        &lt;!-- 如果设置了runtimeTableName，那么在生成的SQL中，使用该指定的tablename，而不是table元素上的tablename 
        &lt;property name=&quot;runtimeTableName&quot; value=&quot;&quot;/&gt;
        --&gt;

        &lt;!-- 注意，该属性只针对MyBatis3Simple有用；
            如果选择的runtime是MyBatis3Simple，那么会生成一个SelectAll方法，如果指定了selectAllOrderByClause，那么会在该SQL中添加指定的这个order条件；
         --&gt;
        &lt;property name=&quot;selectAllOrderByClause&quot; value=&quot;age desc,username asc&quot;/&gt;

        &lt;!-- 如果设置为true，生成的model类会直接使用column本身的名字，而不会再使用驼峰命名方法，比如BORN_DATE，生成的属性名字就是BORN_DATE,而不会是bornDate --&gt;
        &lt;property name=&quot;useActualColumnNames&quot; value=&quot;false&quot;/&gt;


        &lt;!-- generatedKey用于生成生成主键的方法，
            如果设置了该元素，MBG会在生成的&lt;insert&gt;元素中生成一条正确的&lt;selectKey&gt;元素，该元素可选
            column:主键的列名；
            sqlStatement：要生成的selectKey语句，有以下可选项：
                Cloudscape:相当于selectKey的SQL为： VALUES IDENTITY_VAL_LOCAL()
                DB2       :相当于selectKey的SQL为： VALUES IDENTITY_VAL_LOCAL()
                DB2_MF    :相当于selectKey的SQL为：SELECT IDENTITY_VAL_LOCAL() FROM SYSIBM.SYSDUMMY1
                Derby      :相当于selectKey的SQL为：VALUES IDENTITY_VAL_LOCAL()
                HSQLDB      :相当于selectKey的SQL为：CALL IDENTITY()
                Informix  :相当于selectKey的SQL为：select dbinfo(&#39;sqlca.sqlerrd1&#39;) from systables where tabid=1
                MySql      :相当于selectKey的SQL为：SELECT LAST_INSERT_ID()
                SqlServer :相当于selectKey的SQL为：SELECT SCOPE_IDENTITY()
                SYBASE      :相当于selectKey的SQL为：SELECT @@IDENTITY
                JDBC      :相当于在生成的insert元素上添加useGeneratedKeys=&quot;true&quot;和keyProperty属性
        &lt;generatedKey column=&quot;&quot; sqlStatement=&quot;&quot;/&gt;
         --&gt;

        &lt;!-- 
            该元素会在根据表中列名计算对象属性名之前先重命名列名，非常适合用于表中的列都有公用的前缀字符串的时候，
            比如列名为：CUST_ID,CUST_NAME,CUST_EMAIL,CUST_ADDRESS等；
            那么就可以设置searchString为&quot;^CUST_&quot;，并使用空白替换，那么生成的Customer对象中的属性名称就不是
            custId,custName等，而是先被替换为ID,NAME,EMAIL,然后变成属性：id，name，email；

            注意，MBG是使用java.util.regex.Matcher.replaceAll来替换searchString和replaceString的，
            如果使用了columnOverride元素，该属性无效；

        &lt;columnRenamingRule searchString=&quot;&quot; replaceString=&quot;&quot;/&gt;
         --&gt;


         &lt;!-- 用来修改表中某个列的属性，MBG会使用修改后的列来生成domain的属性；
             column:要重新设置的列名；
             注意，一个table元素中可以有多个columnOverride元素哈~
          --&gt;
         &lt;columnOverride column=&quot;username&quot;&gt;
             &lt;!-- 使用property属性来指定列要生成的属性名称 --&gt;
             &lt;property name=&quot;property&quot; value=&quot;userName&quot;/&gt;

             &lt;!-- javaType用于指定生成的domain的属性类型，使用类型的全限定名
             &lt;property name=&quot;javaType&quot; value=&quot;&quot;/&gt;
              --&gt;

             &lt;!-- jdbcType用于指定该列的JDBC类型 
             &lt;property name=&quot;jdbcType&quot; value=&quot;&quot;/&gt;
              --&gt;

             &lt;!-- typeHandler 用于指定该列使用到的TypeHandler，如果要指定，配置类型处理器的全限定名
                 注意，mybatis中，不会生成到mybatis-config.xml中的typeHandler
                 只会生成类似：where id = #{id,jdbcType=BIGINT,typeHandler=com._520it.mybatis.MyTypeHandler}的参数描述
             &lt;property name=&quot;jdbcType&quot; value=&quot;&quot;/&gt;
             --&gt;

             &lt;!-- 参考table元素的delimitAllColumns配置，默认为false
             &lt;property name=&quot;delimitedColumnName&quot; value=&quot;&quot;/&gt;
              --&gt;
         &lt;/columnOverride&gt;

         &lt;!-- ignoreColumn设置一个MGB忽略的列，如果设置了改列，那么在生成的domain中，生成的SQL中，都不会有该列出现 
             column:指定要忽略的列的名字；
             delimitedColumnName：参考table元素的delimitAllColumns配置，默认为false

             注意，一个table元素中可以有多个ignoreColumn元素
         &lt;ignoreColumn column=&quot;deptId&quot; delimitedColumnName=&quot;&quot;/&gt;
         --&gt;
    &lt;/table&gt;

&lt;/context&gt;

&lt;/generatorConfiguration&gt;
</code></pre><p>好了，就到这里了，可以作为一个工具文档查看。 </p>
]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
    
    </summary>
    
      <category term="JavaWeb" scheme="https://wangyu1997.github.io/categories/JavaWeb/"/>
    
    
      <category term="javaweb" scheme="https://wangyu1997.github.io/tags/javaweb/"/>
    
      <category term="gradle" scheme="https://wangyu1997.github.io/tags/gradle/"/>
    
      <category term="mybatis" scheme="https://wangyu1997.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>Groovy读取yaml和properties文件</title>
    <link href="https://wangyu1997.github.io/2017/10/10/JavaWeb/Groovy%E8%AF%BB%E5%8F%96yaml%E5%92%8Cproperties%E6%96%87%E4%BB%B6/"/>
    <id>https://wangyu1997.github.io/2017/10/10/JavaWeb/Groovy读取yaml和properties文件/</id>
    <published>2017-10-10T02:43:11.000Z</published>
    <updated>2017-10-24T06:36:53.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a> 
<p>Java 可以使用 <code>PropertiesConfiguration</code> 来读取 properties 属性文件，Spring 4.3 后还支持了 <code>Yaml 格式的属性文件</code></p>
<ul>
<li>PropertiesConfiguration: 读取时可以自动进行类型转换，可以给定默认值</li>
<li>Yaml 格式的属性文件: 可以使用树形结构，方便分组，比 <code>.properties</code> 属性文件更灵活，但是以普通的 <code>java.util.Properties</code> 来读取</li>
</ul>
<h1 id="Gradle-依赖"><a href="#Gradle-依赖" class="headerlink" title="Gradle 依赖"></a>Gradle 依赖</h1><pre><code>compile &#39;org.springframework:spring-context:4.3.0.RELEASE&#39;

compile &#39;org.yaml:snakeyaml:1.17&#39;

compile &#39;commons-configuration:commons-configuration:1.10&#39;

testCompile &#39;org.springframework:spring-test:4.3.0.RELEASE&#39;

testCompile &#39;junit:junit:4.12&#39;
</code></pre><h1 id="属性文件"><a href="#属性文件" class="headerlink" title="属性文件"></a>属性文件</h1><blockquote>
<p>config.properties </p>
</blockquote>
<pre><code>username=Dr. Alice 

age=22 

config.yml
</code></pre><p>#mysql </p>
<pre><code>mysql: 

    jdbc: 

        url: jdbc:mysql://localhost:3306 

        dirverClass: com.mysql.jdbc.Driver 

        username: root 

        password: root 

        username: Ritchie Yu 
</code></pre><h1 id="Spring-Bean-配置文件"><a href="#Spring-Bean-配置文件" class="headerlink" title="Spring Bean 配置文件"></a>Spring Bean 配置文件</h1><blockquote>
<p>spring-beans-config.xml </p>
</blockquote>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;

xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;

xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans

http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

&lt;bean id=&quot;yamlProperties&quot; class=&quot;org.springframework.beans.factory.config.YamlPropertiesFactoryBean&quot;&gt;

&lt;property name=&quot;resources&quot;&gt;

&lt;list&gt;

&lt;value&gt;classpath:config.yml&lt;/value&gt;

&lt;/list&gt;

&lt;/property&gt;

&lt;/bean&gt;

&lt;bean id=&quot;propertiesConfig&quot; class=&quot;org.apache.commons.configuration.PropertiesConfiguration&quot;&gt;

&lt;constructor-arg value=&quot;config.properties&quot;/&gt;

&lt;/bean&gt;

&lt;/beans&gt;
</code></pre><h1 id="测试案例"><a href="#测试案例" class="headerlink" title="测试案例"></a>测试案例</h1><pre><code>import org.apache.commons.configuration.PropertiesConfiguration; 

import org.junit.runner.RunWith; 

import org.junit.Test; 

import org.springframework.test.context.ContextConfiguration; 

import org.springframework.test.context.junit4.SpringRunner; 

import javax.annotation.Resource; 

import java.util.Properties; 

@RunWith(SpringRunner.class) 

@ContextConfiguration({&quot;classpath:spring-beans-config.xml&quot;}) 

public class TestYamlPropertiesAndPropertiesConfig { 

@Resource(name = &quot;yamlProperties&quot;) 

private Properties yamlProperties; 

@Resource(name = &quot;propertiesConfig&quot;) 

private PropertiesConfiguration propertiesConfig; 

@Test

public void testYamlProperties() { 

System.out.println(yamlProperties.getProperty(&quot;mysql.jdbc.url&quot;)); 

System.out.println(yamlProperties.getProperty(&quot;username&quot;)); 

} 

@Test

public void testPropertiesConfig() { 

System.out.println(propertiesConfig.getString(&quot;username&quot;)); 

System.out.println(propertiesConfig.getInteger(&quot;age&quot;, 0)); 

} 

} 
</code></pre><p>输出: </p>
<pre><code>Dr. Alice 

22 

jdbc:mysql://localhost:3306 

Ritchie Yu 
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
    
    </summary>
    
      <category term="JavaWeb" scheme="https://wangyu1997.github.io/categories/JavaWeb/"/>
    
    
      <category term="gradle" scheme="https://wangyu1997.github.io/tags/gradle/"/>
    
      <category term="groovy" scheme="https://wangyu1997.github.io/tags/groovy/"/>
    
      <category term="yaml" scheme="https://wangyu1997.github.io/tags/yaml/"/>
    
  </entry>
  
  <entry>
    <title>Intellij Ideal下Gradle部署mybatis</title>
    <link href="https://wangyu1997.github.io/2017/10/09/JavaWeb/Gradle%E9%83%A8%E7%BD%B2mybatis/"/>
    <id>https://wangyu1997.github.io/2017/10/09/JavaWeb/Gradle部署mybatis/</id>
    <published>2017-10-09T02:43:11.000Z</published>
    <updated>2017-10-24T07:01:03.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a> 
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="http://www.mybatis.org/generator/index.html" target="_blank" rel="external">Mybatis Generator</a>是一个mybatis工具项目，用于生成mybatis的model,mapper,dao持久层代码。<strong>Mybatis Generator</strong>提供了maven plugin,ant target，java三种方式启动。现在主流的构建工具是<a href="https://gradle.org/" target="_blank" rel="external">Gradle</a>,虽然mybatis generator没有提供gradle的插件，但gradle可以调用ant任务，因此，gradle也能启动Mybatis Generator。 </p>
<h2 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h2><ul>
<li>数据库:mysql</li>
<li>数据库配置文件:src/main/resources/jdbc.properties</li>
<li>项目中使用了通用mapper 3.3.2 插件</li>
</ul>
<h2 id="项目依赖"><a href="#项目依赖" class="headerlink" title="项目依赖"></a>项目依赖</h2><p>在<strong>build.gradle</strong>中: 运行ant需要运行环境，也就是相应的jar包，因此添加一个配置 </p>
<pre><code>configurations {
    mybatisGenerator
}
</code></pre><p>给这个配置添加依赖 </p>
<pre><code>dependencies {
    mybatisGenerator &quot;org.mybatis.generator:mybatis-generator-core:${generatorVersion}&quot;
    mybatisGenerator &quot;mysql:mysql-connector-java:${mysqlVersion}&quot;
    mybatisGenerator &quot;tk.mybatis:mapper:${mybatisMapperVersion}&quot;
}
</code></pre><h2 id="配置task"><a href="#配置task" class="headerlink" title="配置task"></a>配置task</h2><pre><code>def getDbProperties = {
    def properties = new Properties()
    file(&quot;src/main/resources/jdbc.properties&quot;).withInputStream { inputStream -&gt;
        properties.load(inputStream)
    }
    properties;
}
task mybatisGenerate &lt;&lt; {
    def properties = getDbProperties()
    ant.properties[&#39;targetProject&#39;] = projectDir.path
    ant.properties[&#39;driverClass&#39;] = properties.getProperty(&quot;jdbc.driverClassName&quot;)
    ant.properties[&#39;connectionURL&#39;] = properties.getProperty(&quot;jdbc.url&quot;)
    ant.properties[&#39;userId&#39;] = properties.getProperty(&quot;jdbc.username&quot;)
    ant.properties[&#39;password&#39;] = properties.getProperty(&quot;jdbc.password&quot;)
    ant.properties[&#39;src_main_java&#39;] = sourceSets.main.java.srcDirs[0].path
    ant.properties[&#39;src_main_resources&#39;] = sourceSets.main.resources.srcDirs[0].path
    ant.properties[&#39;modelPackage&#39;] = this.modelPackage
    ant.properties[&#39;mapperPackage&#39;] = this.mapperPackage
    ant.properties[&#39;sqlMapperPackage&#39;] = this.sqlMapperPackage
    ant.taskdef(
            name: &#39;mbgenerator&#39;,
            classname: &#39;org.mybatis.generator.ant.GeneratorAntTask&#39;,
            classpath: configurations.mybatisGenerator.asPath
    )
    ant.mbgenerator(overwrite: true,
            configfile: &#39;src/main/resources/generatorConfig.xml&#39;, verbose: true) {
        propertyset {
            propertyref(name: &#39;targetProject&#39;)
            propertyref(name: &#39;userId&#39;)
            propertyref(name: &#39;driverClass&#39;)
            propertyref(name: &#39;connectionURL&#39;)
            propertyref(name: &#39;password&#39;)
            propertyref(name: &#39;src_main_java&#39;)
            propertyref(name: &#39;src_main_resources&#39;)
            propertyref(name: &#39;modelPackage&#39;)
            propertyref(name: &#39;mapperPackage&#39;)
            propertyref(name: &#39;sqlMapperPackage&#39;)
        }
    }
}
</code></pre><p>大致思路 </p>
<ul>
<li>从_jdbc.propertis_读取配置</li>
<li>_把配置注入ant任务_</li>
<li>_运行ant_生成文件</li>
</ul>
<p>jdbc.properties </p>
<pre><code>jdbc.driverClassName=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://127.0.0.1:3306/userdb?useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;allowMultiQueries=true
jdbc.username=root
jdbc.password=admin
</code></pre><p>其他配置_gradle.propertis_ </p>
<pre><code>#生成实体类所在的包
modelPackage=test.mybatis.pojo
#生成的mapper接口类所在包
mapperPackage=test.mybatis.mapper
#生成的mapper xml文件所在包，默认存储在resources目录下
sqlMapperPackage=mybatis
</code></pre><h2 id="generatorConfig配置"><a href="#generatorConfig配置" class="headerlink" title="generatorConfig配置"></a>generatorConfig配置</h2><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE generatorConfiguration
        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;
&lt;generatorConfiguration&gt;
    &lt;context id=&quot;Mysql&quot; targetRuntime=&quot;MyBatis3Simple&quot; defaultModelType=&quot;flat&quot;&gt;
        &lt;commentGenerator&gt;
            &lt;property name=&quot;suppressAllComments&quot; value=&quot;false&quot;&gt;&lt;/property&gt;
            &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;&gt;&lt;/property&gt;
            &lt;property name=&quot;javaFileEncoding&quot; value=&quot;utf-8&quot;/&gt;
        &lt;/commentGenerator&gt;

        &lt;jdbcConnection driverClass=&quot;${driverClass}&quot;
                        connectionURL=&quot;${connectionURL}&quot;
                        userId=&quot;${userId}&quot;
                        password=&quot;${password}&quot;&gt;
        &lt;/jdbcConnection&gt;

        &lt;javaTypeResolver &gt;
            &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt;
        &lt;/javaTypeResolver&gt;

        &lt;javaModelGenerator targetPackage=&quot;${modelPackage}&quot; targetProject=&quot;${src_main_java}&quot;&gt;
            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot;&gt;&lt;/property&gt;
            &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;&gt;&lt;/property&gt;
        &lt;/javaModelGenerator&gt;

        &lt;sqlMapGenerator targetPackage=&quot;${sqlMapperPackage}&quot; targetProject=&quot;${src_main_resources}&quot;&gt;
            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot;&gt;&lt;/property&gt;
        &lt;/sqlMapGenerator&gt;


        &lt;javaClientGenerator targetPackage=&quot;${mapperPackage}&quot; targetProject=&quot;${src_main_java}&quot; type=&quot;XMLMAPPER&quot;&gt;
            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot;/&gt;
        &lt;/javaClientGenerator&gt;

        &lt;table tableName=&quot;ta_user&quot; enableCountByExample=&quot;false&quot;
               enableDeleteByExample=&quot;false&quot;
               enableSelectByExample=&quot;false&quot;
               enableUpdateByExample=&quot;false&quot;&gt;
            &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;MySql&quot; identity=&quot;true&quot;/&gt;
        &lt;/table&gt;
    &lt;/context&gt;
&lt;/generatorConfiguration&gt;
</code></pre><h2 id="run生成代码"><a href="#run生成代码" class="headerlink" title="run生成代码"></a>run生成代码</h2><pre><code>gradle  mybatisGenerate
</code></pre><h2 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构"></a>项目目录结构</h2><p><img src="http://dandandeshangni.oss-cn-beijing.aliyuncs.com/github/gradle_mybatis_generator.png" alt=""></p>
<p>dependencies.gradle配置 </p>
<pre><code>ext {
    //gradle
    gradleVersion = &#39;2.5&#39;
    //junit
    junitVersion = &#39;4.12&#39;
    //log4j
    log4jVersion = &#39;1.2.16&#39;
    //mybatis
    mybatisMapperVersion = &#39;3.3.2&#39;
    //mybatis
    mybatisVersion = &#39;3.2.6&#39;
    //mysql驱动
    mysqlVersion = &#39;5.1.18&#39;
    //mybatis-spring
    mybatisSpringVersion = &#39;1.3.0&#39;
    //generatorVersion
    generatorVersion = &#39;1.3.2&#39;
}
</code></pre><p>build.gradle完整配置 </p>
<pre><code>group &#39;test.mybatis&#39;
version &#39;1.0-SNAPSHOT&#39;

apply from: &quot;${rootDir}/gradle/dependencies.gradle&quot;

apply plugin: &#39;java&#39;
apply plugin: &#39;war&#39;

configurations {
    mybatisGenerator
}

repositories {
    mavenCentral()
}
dependencies {
    mybatisGenerator &quot;org.mybatis.generator:mybatis-generator-core:${generatorVersion}&quot;
    mybatisGenerator &quot;mysql:mysql-connector-java:${mysqlVersion}&quot;
    mybatisGenerator &quot;tk.mybatis:mapper:${mybatisMapperVersion}&quot;
}



compileJava {
    sourceCompatibility = JavaVersion.VERSION_1_8
    targetCompatibility = JavaVersion.VERSION_1_8
}

repositories {
    jcenter()
    mavenCentral()
}

dependencies {
//    compile &#39;tk.mybatis:mapper:3.3.9&#39;
    compile &quot;log4j:log4j:${log4jVersion}&quot;
    compile &quot;org.mybatis:mybatis:${mybatisVersion}&quot;
    compile &quot;mysql:mysql-connector-java:${mysqlVersion}&quot;
    compile &quot;junit:junit:${junitVersion}&quot;
    compile &quot;org.mybatis:mybatis-spring:${mybatisSpringVersion}&quot;
}

def getDbProperties = {
    def properties = new Properties()
    file(&quot;src/main/resources/jdbc.properties&quot;).withInputStream { inputStream -&gt;
        properties.load(inputStream)
    }
    properties;
}
task mybatisGenerate &lt;&lt; {
    def properties = getDbProperties()
    ant.properties[&#39;targetProject&#39;] = projectDir.path
    ant.properties[&#39;driverClass&#39;] = properties.getProperty(&quot;jdbc.driverClassName&quot;)
    ant.properties[&#39;connectionURL&#39;] = properties.getProperty(&quot;jdbc.url&quot;)
    ant.properties[&#39;userId&#39;] = properties.getProperty(&quot;jdbc.username&quot;)
    ant.properties[&#39;password&#39;] = properties.getProperty(&quot;jdbc.password&quot;)
    ant.properties[&#39;src_main_java&#39;] = sourceSets.main.java.srcDirs[0].path
    ant.properties[&#39;src_main_resources&#39;] = sourceSets.main.resources.srcDirs[0].path
    ant.properties[&#39;modelPackage&#39;] = this.modelPackage
    ant.properties[&#39;mapperPackage&#39;] = this.mapperPackage
    ant.properties[&#39;sqlMapperPackage&#39;] = this.sqlMapperPackage
    ant.taskdef(
            name: &#39;mbgenerator&#39;,
            classname: &#39;org.mybatis.generator.ant.GeneratorAntTask&#39;,
            classpath: configurations.mybatisGenerator.asPath
    )
    ant.mbgenerator(overwrite: true,
            configfile: &#39;src/main/resources/generatorConfig.xml&#39;, verbose: true) {
        propertyset {
            propertyref(name: &#39;targetProject&#39;)
            propertyref(name: &#39;userId&#39;)
            propertyref(name: &#39;driverClass&#39;)
            propertyref(name: &#39;connectionURL&#39;)
            propertyref(name: &#39;password&#39;)
            propertyref(name: &#39;src_main_java&#39;)
            propertyref(name: &#39;src_main_resources&#39;)
            propertyref(name: &#39;modelPackage&#39;)
            propertyref(name: &#39;mapperPackage&#39;)
            propertyref(name: &#39;sqlMapperPackage&#39;)
        }
    }
}
</code></pre><p>刷新gradle出现mybatisGenerate <img src="http://dandandeshangni.oss-cn-beijing.aliyuncs.com/github/gradle_mybatisgenerate.png" alt=""></p>
<p>完整项目地址：<a href="https://github.com/longfeizheng/mybatisDemo" target="_blank" rel="external">mybatisDemo</a></p>
<p>参考链接 </p>
<ul>
<li><a href="http://chenkaihua.com/2015/12/19/running-mybatis-generator-with-gradle/" target="_blank" rel="external">http://chenkaihua.com/2015/12/19/running-mybatis-generator-with-gradle/</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
    
    </summary>
    
      <category term="JavaWeb" scheme="https://wangyu1997.github.io/categories/JavaWeb/"/>
    
    
      <category term="javaweb" scheme="https://wangyu1997.github.io/tags/javaweb/"/>
    
      <category term="gradle" scheme="https://wangyu1997.github.io/tags/gradle/"/>
    
      <category term="mybatis" scheme="https://wangyu1997.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>CSS布局--flex</title>
    <link href="https://wangyu1997.github.io/2017/10/04/VueJs/flex%E5%B8%83%E5%B1%80/"/>
    <id>https://wangyu1997.github.io/2017/10/04/VueJs/flex布局/</id>
    <published>2017-10-03T17:43:11.000Z</published>
    <updated>2017-10-24T07:12:07.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a> 
<p>网页布局（layout）是 CSS 的一个重点应用。 </p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071001.gif" alt=""></p>
<p>布局的传统解决方案，基于<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/box_model" target="_blank" rel="external">盒状模型</a>，依赖 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/display" target="_blank" rel="external"><code>display</code></a> 属性 + <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/position" target="_blank" rel="external"><code>position</code></a>属性 + <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/float" target="_blank" rel="external"><code>float</code></a>属性。它对于那些特殊布局非常不方便，比如，<a href="https://css-tricks.com/centering-css-complete-guide/" target="_blank" rel="external">垂直居中</a>就不容易实现。 </p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071002.png" alt=""></p>
<p>2009年，W3C 提出了一种新的方案—-Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。 </p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071003.jpg" alt=""></p>
<p>Flex 布局将成为未来布局的首选方案。本文介绍它的语法，<a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" target="_blank" rel="external">下一篇文章</a>给出常见布局的 Flex 写法。网友 <a href="http://vgee.cn/" target="_blank" rel="external">JailBreak</a> 为本文的所有示例制作了 <a href="http://static.vgee.cn/static/index.html" target="_blank" rel="external">Demo</a>，也可以参考。 </p>
<p>以下内容主要参考了下面两篇文章：<a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/" target="_blank" rel="external">A Complete Guide to Flexbox</a> 和 <a href="https://scotch.io/tutorials/a-visual-guide-to-css3-flexbox-properties" target="_blank" rel="external">A Visual Guide to CSS3 Flexbox Properties</a>。 </p>
<h2 id="一、Flex-布局是什么？"><a href="#一、Flex-布局是什么？" class="headerlink" title="一、Flex 布局是什么？"></a>一、Flex 布局是什么？</h2><p>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 </p>
<p>任何一个容器都可以指定为 Flex 布局。 </p>
<blockquote>
<p>.box{<br>      display: flex;<br>    }</p>
</blockquote>
<p>行内元素也可以使用 Flex 布局。 </p>
<blockquote>
<p>.box{<br>      display: inline-flex;<br>    }</p>
</blockquote>
<p>Webkit 内核的浏览器，必须加上<code>-webkit</code>前缀。 </p>
<blockquote>
<p>.box{<br>      display: -webkit-flex; /<em> Safari </em>/<br>      display: flex;<br>    }</p>
</blockquote>
<p>注意，设为 Flex 布局以后，子元素的<code>float</code>、<code>clear</code>和<code>vertical-align</code>属性将失效。 </p>
<h2 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h2><p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。 </p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071004.png" alt=""></p>
<p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做<code>main start</code>，结束位置叫做<code>main end</code>；交叉轴的开始位置叫做<code>cross start</code>，结束位置叫做<code>cross end</code>。 </p>
<p>项目默认沿主轴排列。单个项目占据的主轴空间叫做<code>main size</code>，占据的交叉轴空间叫做<code>cross size</code>。 </p>
<h2 id="三、容器的属性"><a href="#三、容器的属性" class="headerlink" title="三、容器的属性"></a>三、容器的属性</h2><p>以下6个属性设置在容器上。 </p>
<blockquote>
<ul>
<li>flex-direction</li>
<li>flex-wrap</li>
<li>flex-flow</li>
<li>justify-content</li>
<li>align-items</li>
<li>align-content</li>
</ul>
</blockquote>
<h3 id="3-1-flex-direction属性"><a href="#3-1-flex-direction属性" class="headerlink" title="3.1 flex-direction属性"></a>3.1 flex-direction属性</h3><p><code>flex-direction</code>属性决定主轴的方向（即项目的排列方向）。 </p>
<blockquote>
<p>.box {<br>      flex-direction: row | row-reverse | column | column-reverse;<br>    }</p>
</blockquote>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071005.png" alt=""></p>
<p>它可能有4个值。 </p>
<blockquote>
<ul>
<li><code>row</code>（默认值）：主轴为水平方向，起点在左端。</li>
<li><code>row-reverse</code>：主轴为水平方向，起点在右端。</li>
<li><code>column</code>：主轴为垂直方向，起点在上沿。</li>
<li><code>column-reverse</code>：主轴为垂直方向，起点在下沿。</li>
</ul>
</blockquote>
<h3 id="3-2-flex-wrap属性"><a href="#3-2-flex-wrap属性" class="headerlink" title="3.2 flex-wrap属性"></a>3.2 flex-wrap属性</h3><p>默认情况下，项目都排在一条线（又称”轴线”）上。<code>flex-wrap</code>属性定义，如果一条轴线排不下，如何换行。 </p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071006.png" alt=""></p>
<blockquote>
<p>.box{<br>      flex-wrap: nowrap | wrap | wrap-reverse;<br>    }</p>
</blockquote>
<p>它可能取三个值。 </p>
<p>（1）<code>nowrap</code>（默认）：不换行。 </p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071007.png" alt=""></p>
<p>（2）<code>wrap</code>：换行，第一行在上方。 </p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071008.jpg" alt=""></p>
<p>（3）<code>wrap-reverse</code>：换行，第一行在下方。 </p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071009.jpg" alt=""></p>
<h3 id="3-3-flex-flow"><a href="#3-3-flex-flow" class="headerlink" title="3.3 flex-flow"></a>3.3 flex-flow</h3><p><code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code>。 </p>
<blockquote>
<p>.box {<br>      flex-flow: <flex-direction> || <flex-wrap>;<br>    }</flex-wrap></flex-direction></p>
</blockquote>
<h3 id="3-4-justify-content属性"><a href="#3-4-justify-content属性" class="headerlink" title="3.4 justify-content属性"></a>3.4 justify-content属性</h3><p><code>justify-content</code>属性定义了项目在主轴上的对齐方式。 </p>
<blockquote>
<p>.box {<br>      justify-content: flex-start | flex-end | center | space-between | space-around;<br>    }</p>
</blockquote>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071010.png" alt=""></p>
<p>它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。 </p>
<blockquote>
<ul>
<li><code>flex-start</code>（默认值）：左对齐</li>
<li><code>flex-end</code>：右对齐</li>
<li><code>center</code>： 居中</li>
<li><code>space-between</code>：两端对齐，项目之间的间隔都相等。</li>
<li><code>space-around</code>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li>
</ul>
</blockquote>
<h3 id="3-5-align-items属性"><a href="#3-5-align-items属性" class="headerlink" title="3.5 align-items属性"></a>3.5 align-items属性</h3><p><code>align-items</code>属性定义项目在交叉轴上如何对齐。 </p>
<blockquote>
<p>.box {<br>      align-items: flex-start | flex-end | center | baseline | stretch;<br>    }</p>
</blockquote>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071011.png" alt=""></p>
<p>它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。 </p>
<blockquote>
<ul>
<li><code>flex-start</code>：交叉轴的起点对齐。</li>
<li><code>flex-end</code>：交叉轴的终点对齐。</li>
<li><code>center</code>：交叉轴的中点对齐。</li>
<li><code>baseline</code>: 项目的第一行文字的基线对齐。</li>
<li><code>stretch</code>（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li>
</ul>
</blockquote>
<h3 id="3-6-align-content属性"><a href="#3-6-align-content属性" class="headerlink" title="3.6 align-content属性"></a>3.6 align-content属性</h3><p><code>align-content</code>属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 </p>
<blockquote>
<p>.box {<br>      align-content: flex-start | flex-end | center | space-between | space-around | stretch;<br>    }</p>
</blockquote>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071012.png" alt=""></p>
<p>该属性可能取6个值。 </p>
<blockquote>
<ul>
<li><code>flex-start</code>：与交叉轴的起点对齐。</li>
<li><code>flex-end</code>：与交叉轴的终点对齐。</li>
<li><code>center</code>：与交叉轴的中点对齐。</li>
<li><code>space-between</code>：与交叉轴两端对齐，轴线之间的间隔平均分布。</li>
<li><code>space-around</code>：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li>
<li><code>stretch</code>（默认值）：轴线占满整个交叉轴。</li>
</ul>
</blockquote>
<h3 id="四、项目的属性"><a href="#四、项目的属性" class="headerlink" title="四、项目的属性"></a>四、项目的属性</h3><p>以下6个属性设置在项目上。 </p>
<blockquote>
<ul>
<li><code>order</code></li>
<li><code>flex-grow</code></li>
<li><code>flex-shrink</code></li>
<li><code>flex-basis</code></li>
<li><code>flex</code></li>
<li><code>align-self</code></li>
</ul>
</blockquote>
<h3 id="4-1-order属性"><a href="#4-1-order属性" class="headerlink" title="4.1 order属性"></a>4.1 order属性</h3><p><code>order</code>属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 </p>
<blockquote>
<p>.item {<br>      order: <integer>;<br>    }</integer></p>
</blockquote>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071013.png" alt=""></p>
<h3 id="4-2-flex-grow属性"><a href="#4-2-flex-grow属性" class="headerlink" title="4.2 flex-grow属性"></a>4.2 flex-grow属性</h3><p><code>flex-grow</code>属性定义项目的放大比例，默认为<code>0</code>，即如果存在剩余空间，也不放大。 </p>
<blockquote>
<p>.item {<br>      flex-grow: <number>; /<em> default 0 </em>/<br>    }</number></p>
</blockquote>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071014.png" alt=""></p>
<p>如果所有项目的<code>flex-grow</code>属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的<code>flex-grow</code>属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 </p>
<h3 id="4-3-flex-shrink属性"><a href="#4-3-flex-shrink属性" class="headerlink" title="4.3 flex-shrink属性"></a>4.3 flex-shrink属性</h3><p><code>flex-shrink</code>属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 </p>
<blockquote>
<p>.item {<br>      flex-shrink: <number>; /<em> default 1 </em>/<br>    }</number></p>
</blockquote>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071015.jpg" alt=""></p>
<p>如果所有项目的<code>flex-shrink</code>属性都为1，当空间不足时，都将等比例缩小。如果一个项目的<code>flex-shrink</code>属性为0，其他项目都为1，则空间不足时，前者不缩小。 </p>
<p>负值对该属性无效。 </p>
<h3 id="4-4-flex-basis属性"><a href="#4-4-flex-basis属性" class="headerlink" title="4.4 flex-basis属性"></a>4.4 flex-basis属性</h3><p><code>flex-basis</code>属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为<code>auto</code>，即项目的本来大小。 </p>
<blockquote>
<p>.item {<br>      flex-basis: <length> | auto; /<em> default auto </em>/<br>    }</length></p>
</blockquote>
<p>它可以设为跟<code>width</code>或<code>height</code>属性一样的值（比如350px），则项目将占据固定空间。 </p>
<h3 id="4-5-flex属性"><a href="#4-5-flex属性" class="headerlink" title="4.5 flex属性"></a>4.5 flex属性</h3><p><code>flex</code>属性是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选。 </p>
<blockquote>
<p>.item {<br>      flex: none | [ &lt;’flex-grow’&gt; &lt;’flex-shrink’&gt;? || &lt;’flex-basis’&gt; ]<br>    }</p>
</blockquote>
<p>该属性有两个快捷值：<code>auto</code> (<code>1 1 auto</code>) 和 none (<code>0 0 auto</code>)。 </p>
<p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 </p>
<h3 id="4-6-align-self属性"><a href="#4-6-align-self属性" class="headerlink" title="4.6 align-self属性"></a>4.6 align-self属性</h3><p><code>align-self</code>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。 </p>
<blockquote>
<p>.item {<br>      align-self: auto | flex-start | flex-end | center | baseline | stretch;<br>    }</p>
</blockquote>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071016.png" alt=""></p>
<p>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。 </p>
]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
    
    </summary>
    
      <category term="VueJs" scheme="https://wangyu1997.github.io/categories/VueJs/"/>
    
    
      <category term="css" scheme="https://wangyu1997.github.io/tags/css/"/>
    
      <category term="boxing" scheme="https://wangyu1997.github.io/tags/boxing/"/>
    
      <category term="flexing box" scheme="https://wangyu1997.github.io/tags/flexing-box/"/>
    
  </entry>
  
  <entry>
    <title>Stylus使用指南</title>
    <link href="https://wangyu1997.github.io/2017/10/03/VueJs/Stylus%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>https://wangyu1997.github.io/2017/10/03/VueJs/Stylus使用指南/</id>
    <published>2017-10-02T17:43:11.000Z</published>
    <updated>2017-10-24T07:13:55.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a> 
<blockquote>
<p>很少有文章针对Sass、LESS和Stylus做这么详细的对比。<a href="http://weibo.com/u/1143654280" target="_blank" rel="external">@Justineo</a>写的《<a href="http://efe.baidu.com/blog/revisiting-css-preprocessors/" target="_blank" rel="external">再谈 CSS 预处理器</a>》让我受益良多，特将此文转载到小站。 </p>
</blockquote>
<p>CSS 预处理器是什么？一般来说，它们基于 CSS 扩展了一套属于自己的 DSL，来解决我们书写 CSS 时难以解决的问题： </p>
<ul>
<li>语法不够强大，比如无法嵌套书写导致模块化开发中需要书写很多重复的选择器；</li>
<li>没有变量和合理的样式复用机制，使得逻辑上相关的属性值必须以字面量的形式重复输出，导致难以维护。</li>
</ul>
<p>所以这就决定了 CSS 预处理器的主要目标：提供 CSS 缺失的样式层复用机制、减少冗余代码，提高样式代码的可维护性。这不是锦上添花，而恰恰是雪中送炭。 </p>
<p>网上已经有不少对比目前最主流的三个预处理器 Less、Sass 和 Stylus（按字母顺序排名）的文章了，但是似乎都不是很详细，或者内容有些过时。下面我会更详细地探讨一下这三种预处理器的特性和它们的差异。 </p>
<p>下面主要会分为如下几方面来讨论： </p>
<ul>
<li>基本语法</li>
<li>嵌套语法</li>
<li>变量</li>
<li><code>@import</code></li>
<li>混入</li>
<li>继承</li>
<li>函数</li>
<li>逻辑控制</li>
</ul>
<p>事先声明一下，平时我在开发中主要使用的是 Less，所以可能对 Sass 和 Stylus 的熟悉程度稍差一些，比较时主要参考三者官网的语言特性说明，有一些正在开发的功能可能会遗漏。 </p>
<p>本文中对 CSS 语法的话术与 MDN 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Syntax" target="_blank" rel="external">CSS 语法</a>介绍一致。 </p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>Less 的基本语法属于「CSS 风格」，而 Sass、Stylus 相比之下激进一些，利用缩进、空格和换行来减少需要输入的字符。不过区别在于 Sass、Stylus 同时也兼容「CSS 风格」代码。多一种选择在更灵活的同时，在团队开发中也免不了增加更多约定来保持风格统一。而对个人而言，语法风格按自己口味选择即可。 </p>
<p><strong>注：后面的 Sass 代码会用被更多人接受的 SCSS 风格给出。</strong></p>
<p>Less &amp; SCSS： </p>
<pre><code>.box {
  display: block;
}
</code></pre><p>Sass： </p>
<pre><code>.box
  display: block
</code></pre><p>Stylus： </p>
<pre><code>.box
  display: block
</code></pre><h2 id="嵌套语法"><a href="#嵌套语法" class="headerlink" title="嵌套语法"></a>嵌套语法</h2><p>三者的嵌套语法都是一致的，甚至连引用父级选择器的标记 `&amp;`` 也相同。区别只是 Sass 和 Stylus 可以用没有大括号的方式书写。以 Less 为例： </p>
<pre><code>.a {
  &amp;.b {
    color: red;
  }
}
</code></pre><p>生成的 CSS 为： </p>
<pre><code>.a.b {
  color: red;
}
</code></pre><p>除了规则集的嵌套，Sass 额外提供了一个我个人认为比较另（jī）类（lèi）的「属性嵌套」： </p>
<pre><code>.funky {
  font: {
    family: fantasy;
    size: 30em;
    weight: bold;
  }
}
</code></pre><h2 id="选择器引用"><a href="#选择器引用" class="headerlink" title="选择器引用"></a>选择器引用</h2><p>三者都支持用 <code>&amp;</code> 在嵌套的规则集中引用上层的选择器，这可以是嵌套书写 CSS 时的「惯例」了。语法相同，但是逻辑上有些许差异。在一个选择器中用两次以上 <code>&amp;</code> 且父选择器是一个列表时，Less 会对选择器进行排列组合，而 Sass 和 Stylus 不会这么做。 </p>
<p>也就是说，假设上层选择器为 <code>.a</code>, <code>.b</code>，则内部的 <code>&amp; &amp;</code> 在 Less 中会成为 <code>.a .a</code>, <code>.a .b</code>, <code>.b .a</code>, <code>.b .b</code>，而 Sass 和 Stylus 则输出 <code>.a .a, .b .b</code>。 </p>
<p>假设我们要用预处理器书写 [WHATWG 推荐的 section 标题样式][4]，在 Less 中可以方便地书写为： </p>
<pre><code>   [4]: https://html.spec.whatwg.org/multipage/rendering.html#sections-and-headings
</code></pre><p>article, aside, nav, section {<br>          h1 {<br>            margin-top: 0.83em; margin-bottom: 0.83em; font-size: 1.50em;<br>          }<br>          &amp; &amp; h1 {<br>            margin-top: 1.00em; margin-bottom: 1.00em; font-size: 1.17em;<br>          }<br>          &amp; &amp; &amp; h1 {<br>            margin-top: 1.33em; margin-bottom: 1.33em; font-size: 1.00em;<br>          }<br>          &amp; &amp; &amp; &amp; h1 {<br>            margin-top: 1.67em; margin-bottom: 1.67em; font-size: 0.83em;<br>          }<br>          &amp; &amp; &amp; &amp; &amp; h1 {<br>            margin-top: 2.33em; margin-bottom: 2.33em; font-size: 0.67em;<br>          }<br>        }</p>
<p>当然，这个推荐样式十分脑残，编译出来的结果会有 47KB 之巨，根本不可用，这里只是借来演示一下。 </p>
<p>除了 <code>&amp;</code>，Sass 和 Stylus 更进一步，分别用 <code>@at-root</code> 和 <code>/</code> 符号作为嵌套时「根」规则集的选择器引用。这有什么用呢？举个例子，假设 HTML 结构是这样的： </p>
<pre><code>&lt;article class=&quot;post&quot;&gt;
  &lt;h1&gt;我是一篇文章&lt;/h1&gt;
  &lt;section&gt;
    &lt;h1 class=&quot;section-title&quot;&gt;&lt;a href=&quot;#s1&quot; class=&quot;section-link&quot;&gt;#&lt;/a&gt;我是章节标题&lt;/h1&gt;
    &lt;p&gt;我只是一个&lt;em&gt;例子&lt;/em&gt;。&lt;/p&gt;
  &lt;/section&gt;
&lt;/article&gt;
</code></pre><p>如果我这么写 Sass 代码，是完全符合业务的嵌套关系的： </p>
<pre><code>.post {
  section {
    .section-title {
      color: #333;
      .section-link {
        color: #999;
      }
    }
    /* other section styles */
  }
  /* other post styles */
}
</code></pre><p>但是这样生成出来的选择器会有 <code>.post section .section-title .section-link</code>，很多时候我们觉得写成 <code>.post .section-link</code> 就够了。 </p>
<p>于是我们在 Stylus 中可以这么写： </p>
<pre><code>.post
  section
    .section-title
      color #333
      /.post .section-link
        color #999
    /* other section styles */

  /* other post styles */
</code></pre><p>这样输出的 CSS 就会是： </p>
<pre><code>.post section .section-title {
  color: #333;
}
.post .section-link {
  color: #999;
}
</code></pre><p>这就是我们想要的样子了。当然也可以这样写： </p>
<pre><code>.post
  section
    .section-title
      color #333
    /* other section styles */

  .section-link
    color #999
  /* other post styles */
</code></pre><p>我个人是推荐这种写法（不使用 <code>root</code> 引用）的，因为当你确定 <code>.section-link</code> 的样式不依赖于它位于 <code>section</code> 或 <code>.section-title</code> 下时，就不应该嵌套于此。否则如果为了一点点性能上的考虑（还不一定会是优化），使得设计意图变得更不准确，我觉得得不偿失。 </p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量无疑为 CSS 增加了一种有效的复用方式，减少了原来在 CSS 中无法避免的重复「硬编码」。 </p>
<p>Less： </p>
<pre><code>@red: #c00;

strong {
  color: @red;
}
</code></pre><p>Sass： </p>
<pre><code>$red: #c00;

strong {
  color: $red;
}
</code></pre><p>Stylus： </p>
<pre><code>red = #c00

strong
  color: red
</code></pre><p>Less 的选择有一个问题：<code>@</code>规则在 CSS 中可以算是一种「原生」的扩展方式，变量名用 <code>@</code>开头很可能会和以后的新 <code>@</code>规则冲突。（当然理论上只要 CSS 规范不引入 <code>@a: b</code> 这样的规则，问题也不大。而且规范制定的时候也会参考很多现有的实现。） </p>
<p>相比之下 Sass 的选择中规中矩，而 Stylus 就不同了，不需要额外的标志符。这意味着：在 Stylus 中，我们可以覆写 CSS 原生的属性值！Stylus 的设计让人有一种「你以为你在写 CSS，但其实你不是」的感觉，后面会有更多这样的例子。 </p>
<p>顺便说一下，CSS 规范也有关于变量实现的草案，目前的方案是这个样子的： </p>
<pre><code>/* global scope */
:root {
  --red: #c00;
}

strong {
  color: var(--red);
}
</code></pre><p>不管语法槽点如何，原生 CSS 变量可以通过 DOM 结构来继承，也就是说是代码真正「运行」时（runtime）决定的。元素引用一个变量时会按 DOM 向上查找定义在上层元素上的同名变量。这一点是任何预处理语言都无法做到的。可以用 Firefox 31+ 看一下这个 <a href="http://jsbin.com/webuju/1/edit" target="_blank" rel="external">demo</a>。至于这种机制是不是好用，暂时还没研究过。不过从开发的思维惯性来看，还很难一下子适应这种方式。 </p>
<h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>三种预处理器的变量作用域都是按嵌套的规则集划分，并且在当前规则集下找不到对应变量时会逐级向上查找，注意这个和原生 CSS 的逻辑是完全不同的。 </p>
<p>如果我们在代码中重写某个已经定义的变量的值，Less 的处理逻辑和其他两者有非常关键的区别。在 Less 中，这个行为被称为「<a href="http://lesscss.org/features/#variables-feature-lazy-loading" target="_blank" rel="external">懒加载（Lazy Loading）</a>」。所有 Less 变量的计算，都是以这个变量最后一次被定义的值为准。举一个例子更容易说清楚： </p>
<p>Less： </p>
<pre><code>@size: 10px;
.box {
    width: @size;
}

@size: 20px;
.ball {
    width: @size;
}
</code></pre><p>输出： </p>
<pre><code>.box {
  width: 20px;
}
.ball {
  width: 20px;
}
</code></pre><p>而在 Stylus 中： </p>
<pre><code>size = 10px
.box
  width: size

size = 20px
.ball
  width: size
</code></pre><p>输出： </p>
<pre><code>.box {
  width: 10px;
}
.ball {
  width: 20px;
}
</code></pre><p>Sass 的处理方式和 Stylus 相同，变量值输出时根据之前最近的一次定义计算。这其实代表了两种理念：Less 更倾向接近 CSS 的声明式，计算过程弱化调用时机；而 Sass 和 Stylus 更倾向于指令式。这两种方式会导致怎样的结果呢？ </p>
<p>举个例子来说，对于 Less，如果项目中引入了这样一个文件： </p>
<pre><code>@error-color: #c00;
@success-color: #0c0;
.error {
  color: @error-color;
  background-color: lighten(@error-color, 40%);
}
.success {
  color: @success-color;
  background-color: lighten(@success-color, 40%);
}
</code></pre><p>在业务代码中，在不修改外部引入文件的情况下，如果我想重写这两种状态的配色，只需要重新配置 <code>@error-color</code> 和 <code>@success-color</code> 这两个变量，就能改变 <code>.error</code> 和 <code>.success</code> 的样式。 </p>
<p>而在 Stylus 中，如果引入的第三方样式库中有这样的代码： </p>
<pre><code>error-color = #c00
success-color = #0c0

.error
  color: error-color
  background-color: lighten(error-color, 40%)

.success
  color: success-color
  background-color: lighten(success-color, 40%)
</code></pre><p>这种情况下后面的代码就无法通过重写变量值来覆盖样式了。Sass 也是如此。优点是 Stylus 和 Sass 这样的处理会不容易受多个第三方库变量名冲突的影响，因为一个变量不能影响在定义它以前的输出样式。 </p>
<p>由于 Sass 和 Stylus 变量在「运行」过程中使用完可以修改后再使用输出不同的值，所以这两者还提供了「仅当变量不存在时才赋值」的功能： </p>
<p>Sass： </p>
<pre><code>$x: 1;
$x: 5 !default;
$y: 3 !default;

// $x = 1, $y = 3
</code></pre><p>Stylus： </p>
<pre><code>x = 1
x := 5 // or x ?= 5
y = 3

// x = 1, y = 3
</code></pre><p>因为变量只能在输出前修改才能生效，所以如果要定制第三方库的样式，用户代码理论上得插入第三方库的配置与样式之间才能生效。而有了 <code>!default</code>，第三方库在提供默认配置时可以将开发给用户修改的变量设置为 <code>!default</code>，这样只要用户提前引入配置进行覆盖，就可以按需重写默认配置了： </p>
<pre><code>// lib.scss
$alert-color: red !default;
.alert {
  color: $alert-color;
}
// var.scss
$alert-color: #c00;
// page.scss
@import var
@import lib
</code></pre><p>这样最终页面输出的效果就是被用户重定义过的内容了。 </p>
<pre><code>/* page.css */
.alert {
  color: #c00;
}
</code></pre><p>由于 Less 处理变量的方式，如果我们要引入多个外部样式库或在多个团队进行合作开发时，如果不能确保开发过程可控，那为变量添加模块前缀就变得很有必要。 </p>
<p>此外，Sass 中提供一个 <code>!global</code> 的语法来让局部变量变成全局变量，也就是说 Sass 代码可以在内层覆盖全局变量的值。输出一段局部的样式可能使得后续所有样式都受到全局变量变化的影响。（这其实是 Sass 开始时默认的逻辑，Sass 3.3 以前所有变量都是全局的，之后改成了和 Less 和 Stylus 一样有嵌套作用域，全局变量要显式指定 <code>!global</code>。） </p>
<h2 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h2><p>预处理器都有定义变量的功能，除了在最常见的属性值中使用，其他还有哪些地方能用变量来增强对样式的抽象、复用呢？ </p>
<h2 id="变量名插值"><a href="#变量名插值" class="headerlink" title="变量名插值"></a>变量名插值</h2><p>Less 中支持 <code>@@foo</code> 的形式引用变量，即该变量的名字是由 <code>@foo</code> 的值决定的。比如我们可以利用它简化更清晰地调用 mixin： </p>
<pre><code>// some icon font lib

// variables with prefix to prevent conflicts
@content-apple: &quot;A&quot;;
@content-google: &quot;G&quot;;

// clearer argument values
.icon-content(@icon) {
  @var: ~&quot;content-@{icon}&quot;;
  &amp;::before {
    content: @@var;
  }
}

.icon-apple {
  .icon-content(apple); // &quot;A&quot;
}

.icon-google {
  .icon-content(google); // &quot;G&quot;
}
</code></pre><h2 id="选择器插值"><a href="#选择器插值" class="headerlink" title="选择器插值"></a>选择器插值</h2><p>选择器是样式表和 DOM 的纽带，是我们实际暴露给 HTML 的接口。支持插值显然可以让接口更不容易和其他内容冲突。假设我们在开发一个 UI 库，生成的组件类名希望有一个可配置的前缀，这时选择器插值就变得相当重要。初看下来，三者用法类似： </p>
<p>Less： </p>
<pre><code>@prefix: ui;
.@{prefix}-button {
  color: #333;
}
</code></pre><p>Sass： </p>
<pre><code>$prefix: ui
.#{$prefix}-button
  color: #333;
</code></pre><p>Stylus： </p>
<pre><code>prefix = ui
.{prefix}-button
  color #333
</code></pre><p>但是在 Less 中，有一个很严重的问题：通过选择器插值生成的规则无法被继承（<a href="https://github.com/less/less.js/issues/2200%EF%BC%89" target="_blank" rel="external">Extend dynamically generated selectors</a>！当然，如果有类似 Placeholder 的机制，这都不是事儿了。问题是 Less 没有！未来的方案看来可能是通过 <code>:extend(.mixin()</code>) 的方式实现类似功能（<a href="https://github.com/less/less.js/issues/1177" target="_blank" rel="external"><code>:extend mixins</code></a>），虽然用 <code>:extend</code> 本身的语法说不过去，但是在现有机制上来看还算可以接受。关于样式的继承复用，后面会详细讲到。 </p>
<h2 id="import-语句插值"><a href="#import-语句插值" class="headerlink" title="@import 语句插值"></a>@import 语句插值</h2><p>Sass 中只能在使用 <code>url()</code> 表达式引入时进行变量插值： </p>
<pre><code>$device: mobile;
@import url(styles.#{$device}.css);
</code></pre><p>Less 中可以在字符串中进行插值： </p>
<pre><code>@device: mobile;
@import &quot;styles.@{device}.css&quot;;
</code></pre><p>Stylus 中在这里插值不管用，但是可以利用其字符串拼接的功能实现： </p>
<pre><code>device = &quot;mobile&quot;
@import &quot;styles.&quot; + device + &quot;.css&quot;
</code></pre><p>注意由于 Less 的 Lazy Load 特性，即使是 <code>@import</code> 也是可以在后面的文件内容中进行覆盖的，修改掉变量就可以在前面引入不同的外部文件。而 Sass 与 Stylus 一旦输出语句，就无法通过变量改变了。 </p>
<h2 id="属性名插值"><a href="#属性名插值" class="headerlink" title="属性名插值"></a>属性名插值</h2><p>三个预处理器的目前版本都支持属性名插值，用法也类似。这里仅以 Stylus 为例： </p>
<pre><code>red-border(sides)
  for side in sides
    border-{side}-color: red // property name interpolation

.x
  red-border(top right)
</code></pre><p>输出： </p>
<pre><code>.x {
  border-top-color: #f00;
  border-right-color: #f00;
}
</code></pre><h2 id="其他-规则插值"><a href="#其他-规则插值" class="headerlink" title="其他 @ 规则插值"></a>其他 @ 规则插值</h2><p>三种预处理器均支持在 <code>@media</code>、<code>@keyframes</code>、<code>@counter-style</code> 等规则中进行插值。<code>@media</code> 插值主要用来做响应式的配置，而 <code>@keyframes</code> 这样带名称名称的 <code>@</code>规则则可以通过插值来避免命名冲突。 </p>
<p>Less： </p>
<pre><code>@m: screen;
@orient: landscape;
@media @m and (orientation: @orient) {
  body {
    width: 960px;
  }
}

@prefix: ui;
@keyframes ~&quot;@{prefix}-fade-in&quot; {
  0% {
    opacity: 0;
  }
  100% {
    opacity: 1;
  }
}
</code></pre><p>Sass： </p>
<pre><code>$m: screen;
$orient: landscape;
@media #{$m} and (orientation: $orient) {
  body {
    width: 1000px;
  }
}

$prefix: ui;
@keyframes #{$prefix}-fade-in {
  0% {
    opacity: 0;
  }
  100% {
    opacity: 1;
  }
}
</code></pre><p>Stylus： </p>
<pre><code>m = screen
orient = landscape
mq = m + &quot; and (orientation: &quot; + orient + &quot;)&quot;
@media mq
  body
    width: 960px

vendors = official
prefix = ui;
@keyframes {prefix}-fade-in {
  0% {
    opacity: 0;
  }
  100% {
    opacity: 1;
  }
}
</code></pre><p>三者均会输出如下 CSS： </p>
<pre><code>@media screen and (orientation: landscape) {
  body {
    width: 960px;
  }
}
@keyframes ui-fade-in {
  0% {
    opacity: 0;
  }
  100% {
    opacity: 1;
  }
}
</code></pre><p>Stylus 中似乎有 <code>and</code>时由于表达式计算的逻辑不能直接像 Less 与 Sass 那样写插值，所以这里采用了字符串拼接的方式。 </p>
<h2 id="import"><a href="#import" class="headerlink" title="@import"></a>@import</h2><p><code>@import</code> 对于模块化开发来说非常有帮助，但就这个功能来说，三种预处理器的行为各不相同。 </p>
<p>先说 Less，Less 扩展了语法，为 <code>@import</code> 增加了多种选项： </p>
<ul>
<li><code>@import (less) somefile.ext</code>:会将无论什么扩展名的文件都作为 Less 文件引入、一起编译；</li>
<li><code>@import (css) somefile.ext</code>:直接编译生成 <code>@import somefile.ext</code>，当做原生 <code>@import</code>；</li>
<li><code>@import (inline) somefile.ext</code>:直接将外部文件拷贝进输出文件的这个位置，但不会参与编译；</li>
<li><code>@import (reference) somefile.ext</code>:外部文件参与编译，但不输出内容，仅用来被本文件中的样式继承；</li>
<li><code>@import (optional) somefile.ext</code>:引入文件但在文件不存在时不报错，静默失败。</li>
</ul>
<p>上面的选项是可以联合使用的，比如可以这样写： </p>
<pre><code>@import (less, optional) somefile.ext;
</code></pre><p>除此之外还有 <code>once</code> 和 <code>multiple</code> 选项分别用来表示去重和不去重的引入方式，默认为 <code>once</code>。在不写任何选项时，Less 会根据扩展名进行推断来决定引入逻辑。 </p>
<p>Sass 没有扩展语法，而是自己推断引入的方式。<code>.css</code> 后缀、绝对路径、<code>url()</code> 表达式和带有 media query 的 <code>@import</code> 会直接用原生 <code>@import</code>，其他都会作为 Sass 代码参与编译。相比之下 Less 更灵活也更复杂。Sass 有个特有的功能叫做「partial」，因为 Sass 默认的编译工具可以编译整个目录下的文件，所以当一些文件不需要编译时，可以在文件名前加上 <code>_</code> 表明这是一个被别的模块引入本身不需要编译的代码片段。Less 的 lessc 由于本来就只处理一个文件，所以这件事就交给用户自己去写编译脚本了。Sass 中有一个比较棘手的问题是，<code>@import</code> 不会被去重，多次引入会导致一个样式文件被多次输出到编译结果中。为了解决这个问题，Foundation 做了如下的 <a href="https://github.com/ecomfe/spec/blob/master/less-code-style.md#user-content-%E6%B7%B7%E5%85%A5mixin-1" target="_blank" rel="external">hack</a>： </p>
<pre><code>   [9]: https://github.com/zurb/foundation/blob/a1eb7561ef835313e20995488afb3f627b27354a/scss/foundation/_functions.scss#L8-L21
</code></pre><p>// IMPORT ONCE<br>// We use this to prevent styles from being loaded multiple times for components that rely on other components.<br>$modules: () !default; </p>
<pre><code>@mixin exports($name) {
  // Import from global scope
  $modules: $modules !global;
  // Check if a module is already on the list
  $module_index: index($modules, $name);
  @if (($module_index == null) or ($module_index == false)) {
    $modules: append($modules, $name) !global;
    @content;
  }
}
</code></pre><p>然后在定义样式时都调用 <code>exports</code> 这个 mixin 来输出，起到只输出一次的效果。 </p>
<p>Stylus 和 Sass 比较接近，也使用隐性推断的方式，但在处理重复输出的问题上，Stylus 给出了一个自定义指令 <code>@require</code>，用法和 <code>@import</code> 完全一样，但只会输出一次。Stylus 还支持通配符，比如<code>@import &#39;product/*&#39;</code> 会引入 <code>product</code> 目录下的所有 <code>.styl</code> 文件，但因为一般引入样式都要显式指定顺序，所以这个功能实用性不高。 </p>
<p>三者相比较之下，Sass 的引入功能似乎有点残缺，不能去重是很大的硬伤。虽然能用 Foundation 那种方式「解决」，但实际上这是语言本身应该解决的问题。 </p>
<h2 id="混入"><a href="#混入" class="headerlink" title="混入"></a>混入</h2><p>混入（mixin）应该说是预处理器最精髓的功能之一了。它提供了 CSS 缺失的最关键的东西：样式层面的抽象。从语法上来说，三种预处理器的差异也比较大，这甚至会直接影响到我们的开发方式。 </p>
<p>Less 的混入有两种方式： </p>
<ul>
<li>直接在目标位置混入另一个类样式（输出已经确定，无法使用参数）；</li>
<li>定义一个不输出的样式片段（可以输入参数），在目标位置输出。（注：后面如无特殊说明，mixin 均用来指代此类混入。）</li>
</ul>
<p>举例来说： </p>
<pre><code>.alert {
  font-weight: 700;
}

.highlight(@color: red) {
  font-size: 1.2em;
  color: @color;
}

.heads-up {
  .alert;
  .highlight(red);
}
</code></pre><p>最后输出： </p>
<pre><code>.alert {
  font-weight: 700;
}
.heads-up {
  font-weight: 700;
  font-size: 1.2em;
  color: red;
}
</code></pre><p>可以混入已有类样式这一点很值得商榷。在上面的例子中，<code>.alert</code> 样式在被混入时甚至可以是 <code>.alert();</code>；<code>.highlight()</code> 混入时也可以写成 <code>.highlight;</code>。那么我们遇到这样的代码时根本不知道 <code>alert</code> 会不会是一个 HTML class。但由于这一点是在 Less 还不支持 <code>extend</code> 时就有的，所以也能够理解作者可能就是将这作为 <code>extend</code> 来用了。所以目前比较好的实践是：用代码规范规约开发者不得使用直接混入已有类样式的方式，而是先定义 mixin 然后在输出的类样式中进行调用，调用时必须显式加上 <code>()</code> 来表明这不是一个 class（事实上百度 EFE 已有的 <a href="https://github.com/ecomfe/spec/blob/master/less-code-style.md#user-content-%E6%B7%B7%E5%85%A5mixin-1" target="_blank" rel="external">Less 编码规范</a>就是这么定义的）。继承则应该直接通过 Less 的 <code>:extend</code> 来实现。 </p>
<p>另外需要注意的是，Less 在进行混入时，会找到所有符合调用参数的「mixin 签名」的样式一起输出。比如： </p>
<pre><code>.mixin(dark; @color) {
  color: darken(@color, 10%);
}
.mixin(light; @color) {
  color: lighten(@color, 10%);
}
.mixin(@_; @color) {
  display: block;
}

@switch: light;
.class {
  .mixin(@switch; #888);
}
</code></pre><p>这个例子中，第二个和第三个 mixin 都匹配了调用时的参数，于是它们的规则都会被输出： </p>
<pre><code>.class {
  color: #a2a2a2;
  display: block;
}
</code></pre><p>也就是说同名的 mixin 不是后面覆盖前面，而是会累加输出。只要参数符合定义，就会将 mixin 内部的样式规则、甚至变量全部拷贝到目标作用域下。 </p>
<p>这一点同样会带来一个问题：如果存在和 mixin 同名的 class 样式，如果 mixin 没有参数则在调用时会把对应的 class 样式一起输出，这显然是不符合预期的。 </p>
<p>假设有个叫 <code>.clearfix</code> 的 mixin，有两个 class 样式调用了它（其中一个也叫 <code>clearfix</code>）： </p>
<pre><code>.clearfix() {
  *zoom: 1;
  &amp;:before,
  &amp;:after {
    display: table;
    content: &quot;&quot;;
  }
}

.clearfix {
  .clearfix();
}

.list {
  .clearfix();
}
</code></pre><p>得到的输出是： </p>
<pre><code>.clearfix {
  *zoom: 1;
}
.clearfix:before,
.clearfix:after {
  display: table;
  content: &quot;&quot;;
}
.clearfix:after {
  clear: both;
}
.list {
  *zoom: 1;
}
.list:before,
.list:after {
  display: table;
  content: &quot;&quot;;
}
.list:after {
  clear: both;
}
.list:before,
.list:after {
  display: table;
  content: &quot;&quot;;
}
.list:after {
  clear: both;
}
</code></pre><p><code>.list</code> 的样式调用了两次！这一点在开发中一定要注意，不要给和非输出型 mixin 同名的类定义样式。 </p>
<p>对于 Sass，语义非常明确： </p>
<pre><code>@mixin large-text {
  font: {
    family: Arial;
    size: 20px;
    weight: bold;
  }
  color: #ff0000;
}

.page-title {
  @include large-text;
  padding: 4px;
  margin-top: 10px;
}
</code></pre><p>Sass 用 <code>@mixin</code> 和 <code>@include</code></p>
<p>两个指令清楚地描述了语义，不存在混入类样式的情况，但是书写时略显繁琐一些。当然，用 Sass 语法 而非 SCSS 语法的话可以简单地用 <code>=</code>定义 mixin，用 <code>+</code>引入 mixin： </p>
<pre><code>=large-text
  font:
    family: Arial
    size: 20px
    weight: bold
  color: #ff0000

.page-title
  +large-text
  padding: 4px
  margin-top: 10px
</code></pre><p>和 Less 不同，同名的 mixin 可以覆盖之前的定义，作用机制类似变量。 </p>
<p>Stylus 和 Sass 类似，但不用什么特殊的标记来引入： </p>
<pre><code>border-radius(n)
  -webkit-border-radius: n
  -moz-border-radius: n
  border-radius: n

.circle
  border-radius(50%)
</code></pre><p>Stylus 中还有一个「透明 mixin」的功能，也就是说引入 mixin 完全可以和引入普通属性一样！例如上面的这个 mixin，也可以这样引入： </p>
<pre><code>.circle
  border-radius: 50%
</code></pre><p>这意味着可以把兼容性上的处理隐藏在 mixin 中，直接用标准属性同名的 mixin 按普通属性的方式输出。当不需要兼容老浏览器时，直接把 mixin 定义删除仍然能够正常输出。不过这种写法虽然感觉非常「爽快」，但要求开发者必须能很好地区分原生属性和某个样式库中提供的 mixin 功能（对于有经验的开发者问题不大），而且透明意味着看到一个普通属性开发者不能判断是否已经在某处用 mixin 进行了重写，无法明确知道这里的代码最后输出会不会发生变化。在可控条件下，这个功能应该说是非常诱人的。 </p>
<h2 id="将声明块作为混入参数"><a href="#将声明块作为混入参数" class="headerlink" title="将声明块作为混入参数"></a>将声明块作为混入参数</h2><p>如果说调用时想传入一组样式声明而非单个值，三种预处理器都提供了相应的功能，但实现方式各有不同。 </p>
<p>在 Less 中需要先定义一个「规则集变量」（detached ruleset，其实就是 CSS 声明块，即规则集去掉选择器的部分），然后在调用 mixin 时把它作为参数传进去，然后在 mixin 中用 <code>@var()</code> 的方式输出： </p>
<pre><code>.red(@custom) {
  color: red;
  @custom();
}

.alert {
  @styles: {
    font-weight: 700;
    font-size: 1.5em;
  }

  .red(@styles);
}
</code></pre><p>在 Sass 和 Stylus 中，都支持直接在 mixin 调用下层传入声明块： </p>
<p>Sass 下直接跟一个声明块即可，然后用关键字 <code>@content</code> 来进行输出： </p>
<pre><code>@mixin red() {
  color: red;
  @content;
}

.alert {
  @include red() {
    font-weight: 700;
    font-size: 1.5em;
  }
}
</code></pre><p>Stylus 支持两种方法，首先是 Less 那样的「具名」声明块，调用时当做变量： </p>
<pre><code>red(foo)
  color: red
  {foo}

.alert
  foo =
    font-weight: 700
    font-size: 1.5em
  red(foo)
</code></pre><p>第二种是 Sass 那样类似传入「字面量」，并且用关键词 block 输出的方式。这种方式需要为要传入声明块的 mixin 前添加一个 <code>+</code> 符号（可能是来自 SCSS 的对应功能）： </p>
<pre><code>red()
  color: red
  {block}

.alert
  +red()
    font-weight: 700
    font-size: 1.5em
</code></pre><p>第二种方式可以看做是第一种方式的语法糖，在 mixin 只需要传入一个声明块时可以免去起名字带来的困扰。 </p>
<p>相比之下 Less 只支持先定义变量后传入的方式，优点是可以传入多个声明块；而 Sass 只支持传入一个「匿名」声明块但是更简单；Stylus 则是两种方式都支持。这个功能在抽象「需要应用样式的条件」时非常有用，比如我们基于 Stylus 的样式库 <a href="https://github.com/ecomfe/rider" target="_blank" rel="external">rider</a> 中就用它来实现<a href="https://github.com/ecomfe/rider/blob/master/lib/rider/breakpoint.styl" target="_blank" rel="external">对 media query 的抽象封装</a>。 </p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>混入很好用，可也有问题：如果多个地方都混入同样的代码，会造成输出代码的多次重复。比如在 Stylus 下： </p>
<pre><code>message()
  padding: 10px
  border: 1px solid #eee

.message
  message()

.warning
  message()
  color: #e2e21e
</code></pre><p>会输出： </p>
<pre><code>.message {
  padding: 10px;
  border: 1px solid #eee;
}
.warning {
  padding: 10px;
  border: 1px solid #eee;
  color: #e2e21e;
}
</code></pre><p>而我们可能期望的输出是： </p>
<pre><code>.message,
.warning {
  padding: 10px;
  border: 1px solid #eee;
}
.warning {
  color: #e2e21e;
}
</code></pre><p>也许大家会说可以这么写： </p>
<pre><code>message()
  padding: 10px
  border: 1px solid #eee

.message,
.warning
  message()

.warning
  color: #e2e21e
</code></pre><p>这样就可以按需要输出了。但其实预处理器的一个好处就是可以方便我们进行模块化开发。上面的例子中，<code>.message</code> 和 <code>.warning</code> 的样式如果是分布在两个模块中的，我合并过的选择器组样式写在哪里呢？情况更复杂的时候就更棘手了。 </p>
<p>这个时候就该继承出场了： </p>
<pre><code>.message
  padding: 10px
  border: 1px solid #eee

.warning
  @extend .message
  color: #e2e21e
</code></pre><p>这样就可以按模块进行开发（不管是分文件还是在同一文件中按业务功能安排样式的顺序），同时兼顾输出的效率了。 </p>
<p>Stylus 的继承方式来自 Sass，两者如出一辙。 而 Less 则又「独树一帜」地用伪类来描述继承关系： </p>
<pre><code>.message {
  padding: 10px;
  border: 1px solid #eee;
}

.warning {
  &amp;:extend(.message);
  color: #e2e21e;
}
/* Or:
.warning:extend(.message) {
  color: #e2e21e;
}
*/
</code></pre><p>同时，Less 默认只继承父类本身的样式，如果要同时继承嵌套定义在父类作用域下的样式，得使用关键字 <code>all</code>，比如 <code>&amp;:extend(.message all);</code>。 </p>
<p>关于使用伪类描述继承关系，<a href="http://weibo.com/u/1960954893" target="_blank" rel="external">Hax</a> 在 Less 的另一个 issue 下曾经<a href="https://github.com/less/less.js/issues/1177#issuecomment-17404003" target="_blank" rel="external">言辞激烈地提出了批评</a>，同时也遭到了 Less 项目组毫不客气的回应。我个人完全赞同 Hax 的看法，因为选择器是用来在树结构中找到元素的，和样式本身完全无关。但 Less 社区在当时却对<a href="https://github.com/less/less.js/pull/509#issuecomment-9963343" target="_blank" rel="external">这个语法</a>表示了一致的赞同，不禁让人对其感到担忧。 </p>
<p>不管语法如何，继承功能还有一个潜在的问题：继承会影响输出的顺序。假设有如下的 Sass 代码： </p>
<pre><code>.active {
   color: red;
}
button.primary {
   color: green;
}
button.active {
   @extend .active;
}
</code></pre><p>而对应的 HTML 代码是： </p>
<pre><code>&lt;button class=&quot;primary active&quot;&gt;Submit&lt;/button&gt;
</code></pre><p>很容易误以为效果是红色的。而其实生成的 CSS 顺序如下： </p>
<pre><code>.active, button.active {
  color: red;
}

button.primary {
  color: green;
}
</code></pre><p>由于合并选择器的关系 <code>.active</code> 被移到了 <code>.primary</code> 之前，所以依赖顺序而非选择器 specificity 时可能会遇到陷阱。 </p>
<h2 id="placeholder"><a href="#placeholder" class="headerlink" title="placeholder"></a>placeholder</h2><p>Placeholder 是什么？简单来说就是一个声明块（预处理器 DSL 中的声明块，包含其下嵌套规则），但是不会在最终的 CSS 中输出。其实这是一组「抽象」样式，只存在于预处理器的编译过程中（类似 mixin），但不同之处是它可以被继承。这样我们就可以在纯样式层为声明块起与样式强耦合的名称而不怕它出现在 CSS 与 HTML 的「接口」——选择器之中了。 </p>
<p>Sass： </p>
<pre><code>%red-card {
  border: 1px solid #300;
  background-color: #ecc;
  color: #c00;
}

.alert {
  @extend %red-card;
}
</code></pre><p>Stylus： </p>
<pre><code>$red-card
  border: 1px solid #300
  background-color: #ecc
  color: #c00

.alert
  @extend $red-card
</code></pre><p>均输出： </p>
<pre><code>.alert {
  border: 1px solid #300;
  background-color: #ecc;
  color: #c00;
}
</code></pre><p>Less 目前不支持这个功能，但开发组目前的共识是可能会用<a href="https://github.com/less/less.js/issues/1878" target="_blank" rel="external">继承 mixin</a> 的方式来实现，比如上面的这个例子未来可能可以通过如下方法实现： </p>
<pre><code>   [16]: https://github.com/less/less.js/issues/1177
</code></pre><p>.red-card() {<br>border: 1px solid #300;<br>background-color: #ecc;<br>color: #c00;<br>} </p>
<pre><code>.alert {
  &amp;:extend(.red-card());
}
</code></pre><p>当前在 Less 下也有一个 hack 来模拟 placeholder 功能，原理是利用 <code>@import (reference)</code> 来实现「placeholder」不输出的功能： </p>
<pre><code>// placeholder.less
.red-card {
  border: 1px solid #300;
  background-color: #ecc;
  color: #c00;
}

// style.less
@import (reference) &quot;placeholder.less&quot;;
.alert {
  &amp;:extend(.red-card);
}
</code></pre><p>不过 <code>@import (reference)</code> 在复杂一些的情况下（被引入的文件有 <code>@import</code>、有 <code>:extend</code> 等）可能会遇到一些 bug，比如：<a href="https://github.com/less/less.js/issues/1851" target="_blank" rel="external">#1851</a>、<a href="https://github.com/less/less.js/issues/1878" target="_blank" rel="external">#1878</a>、<a href="https://github.com/less/less.js/issues/1896" target="_blank" rel="external">#1896</a>。目前以 reference 方式引入 Bootstrap 时就会直接产生代码输出。 </p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>先说说原生函数。三种预处理器都自带了诸如色彩处理、类型判断、数值计算等内置函数，目前版本的数量都在 80 个左右。由于 Sass 和 Stylus 都内置脚本语言，所以自带函数中包括了很多处理不同数据类型、修改选择器的函数。Sass 更是提供了不少特性检测函数比如 <a href="http://sass-lang.com/documentation/Sass/Script/Functions.html#feature_exists-instance_method" target="_blank" rel="external">feature-exists($feature)、variable-exists($name)</a> 等，这为第三方库的兼容性提供了很好的保障。因为有了这些函数可以方便地对不同版本的 Sass 编译器有针对性地提供兼容，而不怕在老版本的编译环境中直接报错。 </p>
<p>三者调用函数的方式几乎一致，不同之处在于 Sass 和 Stylus 支持直接指定参数名的方式传入参数。以 Stylus 为例： </p>
<pre><code>subtract(a, b)
  a - b

subtract(b: 10, a: 25) // same as substract(25, 10)
</code></pre><p>这样做的好处是，如果参数列表比较长，Stylus 可以直接为列表后面的参数赋值，而不需要一路将之前的参数填上 <code>null</code> 或默认值。Stylus 将这个特性称为「Named parameters」，而 Sass 称为「Keyword arguments」。 </p>
<p>关于函数，真正的区别在于：Sass 和 Stylus 都支持用 DSL 直接添加自定义函数，而 Less 中如果要添加自定义函数必须通过使用插件（2.0.0 以后的版本才支持插件）。这决定了用 Sass 和 Stylus 书写的代码可移植性更高，不需要编译环境有插件即可运行，而 Less 则需要额外添加编译时的依赖。 </p>
<p>Sass 中自定义函数需要使用 <code>@function</code> 指令，并用 <code>@return</code> 指令返回结果： </p>
<pre><code>@function golden-ratio($n) {
  @return $n * 0.618;
}

.golden-box {
  width: 200px;
  height: golden-ratio(200px);
}
</code></pre><p>在 Stylus 中，这些都是隐含的，最后一个表达式的值会作为返回值： </p>
<pre><code>golden-ratio(n)
  n * 0.618

.golden-box
  width: 200px
  height: golden-ratio(@width)
</code></pre><p>这种写法和 mixin 有什么区别？当把函数作为 mixin 调用时，如果其中有 <code>prop: value</code> 这样格式的内容，就会被当做样式规则输出。Stylus 中大量的内容都是根据调用时的 context 去隐式推断该使用什么逻辑进行输出，而非 Less 和 Sass 那样使用关键字去显式地进行区分。 </p>
<h2 id="逻辑控制"><a href="#逻辑控制" class="headerlink" title="逻辑控制"></a>逻辑控制</h2><p>Sass 中通过常见的 <code>@if</code>、<code>@else if</code>、<code>@else</code> 实现条件分支，通过 <code>@for</code>、<code>@each</code>、<code>@while</code> 实现循环，配合 map 和 list 这两种数据类型可以轻松地实现多数编程语言提供的功能。 </p>
<p>在 Stylus 中，不需要使用 <code>@</code> 规则，提供了 <code>if</code>、<code>else if</code>、<code>else</code>、<code>unless</code>、<code>for...in</code> 来实现类似功能，语法比 Sass 更简洁灵活。 </p>
<p>再来看 Less，上面说到的功能 Less 都没有提供。那在 Less 中如何进行逻辑控制呢？Less 中只有一个方式：使用 mixin。 </p>
<p>Less 中的 mixin 通过「guard」的方式支持简单的条件分支控制。比如我们要实现一个控制 <code>::placeholder</code> 样式的 mixin，当传入颜色时只设置颜色，当传入声明块时输出对应的样式规则，其他情况输出一个默认的 <code>color</code>： </p>
<pre><code>.mixin(@val) when (iscolor(@val)) {
  color: @val;
}
.mixin(@val) when (isruleset(@val)) {
  @val();
}
.mixin(@val) when (default()) {
  // default() in guards acts as else
  color: #666;
}
</code></pre><p>Guard 语句中的语法非常类似 CSS media query 中的对应功能，事实上这也是 Less 一直以来的理念：保持声明式语法，弱化指令和流程。但是事实上，这为书写需要提供灵活接口的样式库造成了非常大的不便。最简单的三元表达式在 Less 中也需要先定义一个 mixin，根据判断条件写对应的 guard 表达式，然后再输出。 </p>
<p>而对于循环，Less 本身并不支持。但官网给出了一个使用 mixin 递归调用模拟循环的例子： </p>
<pre><code>.loop(@counter) when (@counter &gt; 0) {
  .loop((@counter - 1));    // next iteration
  width: (10px * @counter); // code for each iteration
}

div {
  .loop(5); // launch the loop
}
</code></pre><p>编译结果为： </p>
<pre><code>div {
  width: 10px;
  width: 20px;
  width: 30px;
  width: 40px;
  width: 50px;
}
</code></pre><p>这是一种非常别（dàn）扭（téng）的实现方式，但从 Less 开发团队的态度来看，未来并没什么可能在 Less 中见到真正的条件分支和循环——因为「Less 不是 Sass」。 </p>
<p>由于逻辑处理能力不能与 Sass 和 Stylus 相比，所以在 Less 中可能还会需要借助 JS 表达式来进行 mixin 参数的解析处理。这个功能 Less 官方已经是不推荐使用的了（已经从官网文档中移除）——因为使用这一功能也会导致 Less 代码的可移植性变低，因为直接内嵌 JS 代码，所以无法使用 <a href="http://www.dotlesscss.org/" target="_blank" rel="external">dotless</a> 等其他语言的 Less 编译器进行处理。而且不同 JS 引擎还可能有兼容性差异。 </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我个人认为，Less 从语言特性的设计到功能的健壮程度和另外两者相比都有一些缺陷，但因为 Bootstrap 引入了 Less，导致 Less 在今天还是有很多用户。用 Less 可以满足大多数场景的需求，但相比另外两者，基于 Less 开发类库会复杂得多，实现的代码会比较脏，能实现的功能也会受到 DSL 的制约。比 Stylus 语义更清晰、比 Sass 更接近 CSS 语法，使得刚刚转用 CSS 预编译的开发者能够更平滑地进行切换。当初 Sass 并不支持 SCSS 语法，使得转投 Sass 成本较高，所以 <a href="http://cloudhead.io/" target="_blank" rel="external">Alexis Sellier</a>才萌生开发一个更「CSS」的预处理器的念头。大获成功以后反过来影响到了 Sass，迫使其也支持类似 CSS 语法的 SCSS。另外，Less 支持浏览器端编译，这无疑降低了开发门槛，使得很多非专业的开发者能够更快地上手（对于一些个人项目来说，能让项目跑起来就行，对前端的性能并没有专业工程师那么高的要求）。 </p>
<p>Sass 在三者之中历史最久，也吸收了其他两者的一些有点。从功能上来说 Sass 大而全，语义明晰但是代码很容易显得累赘。主项目基于 Ruby 可能也是一部分人不选择它的理由（Less 开始也是基于 Ruby 开发，后来逐渐转到 <a href="https://github.com/less/less.js" target="_blank" rel="external">less.js</a> 项目中）。 Sass 有一个「事实标准」库——<a href="http://compass-style.org/" target="_blank" rel="external">Compass</a>，于是对于很多开发者而言省去了选择类库的烦恼，对于提升开发效率也有不小的帮助。 </p>
<p>Stylus 的语法非常灵活，很多语义都是根据上下文隐含的。基于 Stylus 可以写出非常简洁的代码，但对使用团队的开发素养要求也更高，更需要有良好的开发规范或约定。Stylus 是前 Node.js 圈第一大神 <a href="https://github.com/tj/" target="_blank" rel="external">TJ Holowaychuk</a> 的作品，虽然他已经弃坑了，但是仍然有不小的号召力。和 Sass 有 Compass 类似，Stylus 有一个官方开发的样式库 <a href="http://tj.github.io/nib/" target="_blank" rel="external">nib</a>，同样提供了不少好用的 mixin。对于比较有经验的开发者，用 Stylus 可能更会有一种畅快的感觉。总的来说用一个词形容 Stylus 的话，我会用「sexy」。 </p>
<p>总的来说，三种预处理器百分之七八十的功能是类似的。Less 适合帮助团队更快地上手预处理代码的开发，而 Sass 和 Stylus 的差异更在于口味。比如有的人喜欢 jQuery 用一个 <code>$</code> 做大部分的事，而另一些人觉得不一样的功能就该有明确的语义上的差别。在这里我不会做具体的推荐。当然，再次声明一下由于我个人接触 Less 开发比较多，所以可能遇到的坑也多一些，文中没有列出 Sass 和 Stylus 的问题并不代表他们没有。 </p>
<blockquote>
<p><strong>特别声明：本文转自<a href="http://efe.baidu.com/" target="_blank" rel="external">百度EFE团队</a>的<a href="http://weibo.com/u/1143654280" target="_blank" rel="external">@Justineo</a>写的《<a href="http://efe.baidu.com/blog/revisiting-css-preprocessors/" target="_blank" rel="external">再谈 CSS 预处理器</a>》。如需转载，烦请注明原文出处：<a href="http://efe.baidu.com/blog/revisiting-css-preprocessors/" target="_blank" rel="external">http://efe.baidu.com/blog/revisiting-css-preprocessors/</a></strong></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
    
    </summary>
    
      <category term="VueJs" scheme="https://wangyu1997.github.io/categories/VueJs/"/>
    
    
      <category term="vue" scheme="https://wangyu1997.github.io/tags/vue/"/>
    
      <category term="css" scheme="https://wangyu1997.github.io/tags/css/"/>
    
      <category term="loader" scheme="https://wangyu1997.github.io/tags/loader/"/>
    
      <category term="stylus" scheme="https://wangyu1997.github.io/tags/stylus/"/>
    
  </entry>
  
  <entry>
    <title>Vue轮播解决方案--BetterScroll</title>
    <link href="https://wangyu1997.github.io/2017/10/03/VueJs/BetterScroll/"/>
    <id>https://wangyu1997.github.io/2017/10/03/VueJs/BetterScroll/</id>
    <published>2017-10-02T17:43:11.000Z</published>
    <updated>2017-10-24T07:13:58.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a> 
<p>From: <a href="https://wangyu1997.github.io/2017/10/03/VueJs/BetterScroll/">https://wangyu1997.github.io/2017/10/03/VueJs/BetterScroll/</a></p>
<p>inspired by iscroll, and it has a better scroll perfermance <a href="https://link.juejin.im?target=https%3A%2F%2Fustbhuangyi.github.io%2Fbetter-scroll%2F" target="_blank" rel="external">ustbhuangyi.github.io/better-scro…</a></p>
<h2 id="立即使用"><a href="#立即使用" class="headerlink" title="立即使用"></a>立即使用</h2><pre><code>&lt;body&gt;
  &lt;div id=&quot;wrapper&quot;&gt;
    &lt;ul&gt;
           &lt;li&gt;...&lt;/li&gt;
           &lt;li&gt;...&lt;/li&gt;
           ...
    &lt;/ul&gt;
  &lt;/div&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;better-scroll.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  new BScroll(document.getElementById(&#39;wrapper&#39;));
&lt;/script&gt;
&lt;/body&gt;
</code></pre><p>搞定 ! </p>
<h2 id="通过npm引入"><a href="#通过npm引入" class="headerlink" title="通过npm引入"></a>通过npm引入</h2><p>安装better-scroll </p>
<pre><code>npm install better-scroll
</code></pre><p>引入better-scroll </p>
<pre><code>import BScroll from &#39;better-scroll&#39;
</code></pre><blockquote>
<p>如果不支持import, 请使用 </p>
</blockquote>
<pre><code>var BScroll = require(&#39;better-scroll&#39;)
</code></pre><h2 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h2><p>better-scroll 的源码是基于 Webpack 构建的 </p>
<p>首先，clone项目源码 </p>
<pre><code>git clone https://github.com/ustbhuangyi/better-scroll.git
</code></pre><p>安装依赖 </p>
<pre><code>cd better-scroll
npm install
</code></pre><p>测试demo页 </p>
<pre><code>npm run dev
</code></pre><p>打开浏览器访问如下地址, 查看效果 </p>
<blockquote>
<p>localhost:9090 </p>
</blockquote>
<h2 id="Options-参数"><a href="#Options-参数" class="headerlink" title="Options 参数"></a>Options 参数</h2><p>Example: </p>
<pre><code>let scroll = new BScroll(document.getElementById(&#39;wrapper&#39;), {
  startX: 0,
  startY: 0
})
</code></pre><p>Options List: </p>
<ul>
<li>startX: <code>0</code> 开始的X轴位置</li>
<li>startY: <code>0</code> 开始的Y轴位置</li>
<li>scrollY: <code>true</code> 滚动方向为 Y 轴</li>
<li>scrollX: ‘true’ 滚动方向为 X 轴</li>
<li>click: <code>true</code> 是否派发click事件</li>
<li>directionLockThreshold: <code>5</code></li>
<li>momentum: <code>true</code> 当快速滑动时是否开启滑动惯性</li>
<li>bounce: <code>true</code> 是否启用回弹动画效果</li>
<li>selectedIndex: <code>0</code> wheel 为 true 时有效，表示被选中的 wheel 索引</li>
<li>rotate: <code>25</code> wheel 为 true 时有效，表示被选中的 wheel 每一层的旋转角度</li>
<li>wheel: <code>false</code> 该属性是给 picker 组件使用的，普通的列表滚动不需要配置</li>
<li>snap: <code>false</code> 该属性是给 slider 组件使用的，普通的列表滚动不需要配置</li>
<li>snapLoop: <code>false</code> 是否可以无缝循环轮播</li>
<li>snapThreshold: <code>0.1</code> 用手指滑动时页面可切换的阈值，大于这个阈值可以滑动的下一页</li>
<li>snapSpeed: <code>400</code>, 轮播图切换的动画时间</li>
<li>swipeTime: <code>2500</code> swipe 持续时间</li>
<li>bounceTime: <code>700</code> 弹力动画持续的毫秒数</li>
<li>adjustTime: <code>400</code> wheel 为 true 有用，调整停留位置的时间</li>
<li>swipeBounceTime: <code>1200</code> swipe 回弹 时间</li>
<li>deceleration: <code>0.001</code> 滚动动量减速越大越快，建议不大于0.01</li>
<li>momentumLimitTime: <code>300</code> 符合惯性拖动的最大时间</li>
<li>momentumLimitDistance: <code>15</code> 符合惯性拖动的最小拖动距离</li>
<li>resizePolling: <code>60</code> 重新调整窗口大小时，重新计算better-scroll的时间间隔</li>
<li>preventDefault: <code>true</code> 是否阻止默认事件</li>
<li>preventDefaultException: <code>{ tagName: /^(INPUT|TEXTAREA|BUTTON|SELECT)$/ }</code> 阻止默认事件的例外配置</li>
<li>HWCompositing: <code>true</code> 是否启用硬件加速</li>
<li>useTransition: <code>true</code> 是否使用CSS3的Transition属性</li>
<li>useTransform: <code>true</code> 是否使用CSS3的Transform属性</li>
<li>probeType: <code>1</code> 会截流,只有在滚动结束的时候派发一个 scroll 事件。<code>2</code>在手指 move 的时候也会实时派发 scroll 事件，不会截流。 <code>3</code>除了手指 move 的时候派发scroll事件，在 swipe（手指迅速滑动一小段距离）的情况下，列表会有一个长距离的滚动动画，这个滚动的动画过程中也会实时派发滚动事件</li>
</ul>
<h2 id="Events-事件"><a href="#Events-事件" class="headerlink" title="Events 事件"></a>Events 事件</h2><p>Example: </p>
<pre><code>let scroll = new BScroll(document.getElementById(&#39;wrapper&#39;),{
   probeType: 3
})

scroll.on(&#39;scroll&#39;, (pos) =&gt; {
  console.log(pos.x + &#39;~&#39; + pos.y)
  ...
})
</code></pre><p>Events 列表 </p>
<ul>
<li>beforeScrollStart - 滚动开始之前触发</li>
<li>scrollStart - 滚动开始时触发</li>
<li>scroll - 滚动时触发</li>
<li>scrollCancel - 取消滚动时触发</li>
<li>scrollEnd - 滚动结束时触发</li>
<li>touchend - 手指移开屏幕时触发</li>
<li>flick - 轻拂时触发</li>
<li>refresh - 当 better-scroll 刷新时触发</li>
<li>destroy - 销毁 better-scroll 实例时触发</li>
</ul>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul>
<li>scrollTo(x, y, time, easing)</li>
</ul>
<p>滚动到某个位置，x,y 代表坐标，time 表示动画时间，easing 表示缓动函数 </p>
<p>Example: </p>
<pre><code>let scroll = new BScroll(document.getElementById(&#39;wrapper&#39;))
scroll.scrollTo(0, 500)
...
</code></pre><ul>
<li>scrollToElement(el, time, offsetX, offsetY, easing)</li>
</ul>
<p>滚动到某个元素，el（必填）表示 dom 元素，time 表示动画时间，offsetX 和 offsetY 表示坐标偏移量，easing 表示缓动函数 </p>
<ul>
<li>refresh()</li>
</ul>
<p>强制 scroll 重新计算，当 better-scroll 中的元素发生变化的时候调用此方法。 </p>
<ul>
<li>getCurrentPage()</li>
</ul>
<p>当 snap 为 true 时，获取滚动的当前页，返回的对象结构为 {x, y, pageX, pageY}，其中 x,y 代表滚动横向和纵向的位置；pageX，pageY 表示横向和纵向的页面索引 </p>
<ul>
<li>goToPage(x, y, time, easing)</li>
</ul>
<p>当 snap 为 true，滚动到对应的页面，x 表示横向页面索引，y 表示纵向页面索引， time 表示动画，easing 表示缓动函数 </p>
<ul>
<li>enable()</li>
</ul>
<p>启用 better-scroll，默认开启 </p>
<ul>
<li>disable()</li>
</ul>
<p>禁用 better-scroll </p>
<ul>
<li>destroy()</li>
</ul>
<p>销毁 better-scroll，解绑事件 </p>
]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
    
    </summary>
    
      <category term="VueJs" scheme="https://wangyu1997.github.io/categories/VueJs/"/>
    
    
      <category term="better scroll" scheme="https://wangyu1997.github.io/tags/better-scroll/"/>
    
      <category term="vue" scheme="https://wangyu1997.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue实战</title>
    <link href="https://wangyu1997.github.io/2017/10/02/VueJs/Vue%E5%AE%9E%E6%88%98/"/>
    <id>https://wangyu1997.github.io/2017/10/02/VueJs/Vue实战/</id>
    <published>2017-10-01T17:43:11.000Z</published>
    <updated>2017-10-24T07:13:50.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a> 
<p>这个系统使用的技术栈为：Vue+Webpack+Element+Axios+vueRouter.系统是一个快餐店的POS系统，当然我们不可能实现一个完整POS系统的所有功能（业余时间我会开发完成并开源），我们在视频中只完成收银模块的制作。你在这个视频中会学习到很多实战的技巧，让你在真实的工作中得心应手，脱颖而出。 </p>
<p>如果你是一个Vue新手，你可能还不能完全掌握文章的内容，你需要一些Vue的初级知识和中级知识。如果你是新手是不是感到很无奈，幸运的是本站为你提供了全部的前置视频学习资源，你可以踏踏实实的学习。 </p>
<h3 id="学习前置课程："><a href="#学习前置课程：" class="headerlink" title="学习前置课程："></a>学习前置课程：</h3><p><strong>初级课程：</strong></p>
<ol>
<li><a href="https://link.juejin.im?target=http%3A%2F%2Fjspang.com%2F2017%2F02%2F23%2Fvue2_01%2F" target="_blank" rel="external">【第一季】Vue2.0视频教程-内部指令(共8集)</a></li>
<li><a href="https://link.juejin.im?target=http%3A%2F%2Fjspang.com%2F2017%2F03%2F14%2Fvue2_02%2F" target="_blank" rel="external">【第二季】Vue2.0视频教程-全局API(共9集)</a></li>
<li><a href="https://link.juejin.im?target=http%3A%2F%2Fjspang.com%2F2017%2F03%2F26%2Fvue3%2F" target="_blank" rel="external">【第三季】Vue2.0视频教程-选项（共6集）</a></li>
<li><a href="https://link.juejin.im?target=http%3A%2F%2Fjspang.com%2F2017%2F04%2F09%2Fvue2_4%2F" target="_blank" rel="external">【第四季】Vue2.0视频教程-实例和内置组件（共4集）</a></li>
</ol>
<p><strong>中级课程：</strong></p>
<ol>
<li><a href="https://link.juejin.im?target=http%3A%2F%2Fjspang.com%2F2017%2F04%2F10%2Fvue-cli%2F" target="_blank" rel="external">技术胖的Vue-cli 视频教程（共3集）</a></li>
<li><a href="https://link.juejin.im?target=http%3A%2F%2Fjspang.com%2F2017%2F04%2F13%2Fvue-router%2F" target="_blank" rel="external">技术胖的Vue-router视频教程（共11集）</a></li>
<li><a href="https://link.juejin.im?target=http%3A%2F%2Fjspang.com%2F2017%2F05%2F03%2Fvuex%2F" target="_blank" rel="external">技术胖的vuex视频教程（共6集）</a></li>
</ol>
<p>Mockplus是产品经理装逼使用的利器，但是真的很好用，作为一个已经工作的程序员必须舔产品经理的脸，所以你也要对Mockplus的使用有所了解，并会简单的使用。其实Mockplus就是一个线框图制作工具，能把我们的想法或者不太好用语言表达的地方，快速画出线框草图增加理解能力。 </p>
<h3 id="为什么选择快餐店POS系统？"><a href="#为什么选择快餐店POS系统？" class="headerlink" title="为什么选择快餐店POS系统？"></a>为什么选择快餐店POS系统？</h3><p>刚开始我想作一套以酒水商城为背景的手机端应用，但是我发现网上这样的应用太多了，什么仿饿了么，什么知乎，什么购物车都可以在网上找到，所以你完全可以Github网站中下载，自学掌握。我觉的既然作了这个实战，就要够酷够复杂，我下面列举了三个原因，大家可以看一下（你其实可以忽略前两点）。 </p>
<ul>
<li>这个收银界面足够复杂：我们采用三栏布局，每栏的交互操作都很有技术技巧，让你快速掌握复杂应用的开发。</li>
<li>用到的知识点多：用到实战中90%以上的知识点，让你把Vue的知识串联起来，快速成为单位中的技术牛人。</li>
<li>为了更好的和女神啪啪啪：京东-强东哥的女神愿望就是开奶茶店，我的女神愿望就是开个快餐店。</li>
</ul>
<h3 id="MockPlus软件下载："><a href="#MockPlus软件下载：" class="headerlink" title="MockPlus软件下载："></a>MockPlus软件下载：</h3><p>Mockplus是一款免费的软件，你可以随便下载：<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.mockplus.cn%2F" target="_blank" rel="external">www.mockplus.cn/</a> 。下载好后你需要注册一个账户，就可以正常使用了。 </p>
<p><img src="https://user-gold-cdn.xitu.io/2017/6/15/fcb4c4f46535eea5ef279118eec3ce60?imageView2/0/w/1280/h/960" alt=""></p>
<p>软件的基本需求分析和画的过程，请看视频，这里就不用文字描述了，去看视频吧。 </p>
<h3 id="项目框线图；"><a href="#项目框线图；" class="headerlink" title="项目框线图；"></a>项目框线图；</h3><p>下面是我们用Mockplus制作的应用框线图，虽然简单，但是已经把我脑海中快餐店Pos系统的大体样式画出来了。在作项目之前，一定要画出框线图，反复讨论需求和技术实现，这样能避免开发中的大范围修改，在实际工作当中非常重要。 </p>
<p><img src="https://user-gold-cdn.xitu.io/2017/6/15/5060628e6a2352003bd2ac33c04792b9?imageView2/0/w/1280/h/960" alt=""></p>
<p>我们采用Vue-cli进行快速搭建，如果你对Vue-cli还不了解，请观看下面的文章，大概30分钟可完全掌握Vue-cli。 </p>
<ol>
<li><a href="https://link.juejin.im?target=http%3A%2F%2Fjspang.com%2F2017%2F04%2F10%2Fvue-cli%2F" target="_blank" rel="external">技术胖的Vue-cli 视频教程（共3集）</a></li>
</ol>
<h3 id="搭建项目架构："><a href="#搭建项目架构：" class="headerlink" title="搭建项目架构："></a>搭建项目架构：</h3><p>项目采用Webpack+Vue-router的架构方式，开始安装（全部在windows系统上操作，我也没有mac电脑）。 </p>
<ol>
<li><p>按Win+R，然后在文本框中输入cmd，回车打开命令行，输入vue-cli安装命令：</p>
<p>mpm install vue-cli -g</p>
</li>
</ol>
<p>这里的-g代表全局安装。 </p>
<ol>
<li><p>在命令行中初始化项目，我们采用的是webpack模板，输入初始化命令：</p>
<p>vue init webpack AwesomePos</p>
</li>
</ol>
<p>这里的AwesmonePos是我的项目文件夹名称，你可以起一个自己喜欢的名称。安装时根据项目需要配置所需要的模块。这里有一个小技巧，就是在你已经提前建立好了文件夹的时候，我们也进入了文件夹，这时候我们可以省略这个文件夹名称。如下情况： </p>
<pre><code>mikdir AwesomePos
cd AwesomePos
vue init webpack
</code></pre><ol>
<li>在命令行中，进入项目目录，使用npm install 安装package.json里项目的依赖包。如果你网速较慢的话，可以使用淘宝镜像的cnpm来进行安装。</li>
<li>查看是否安装正确。在命令行中输入 npm run dev ，如果能在浏览器中正常打开页面，说明安装正确。</li>
</ol>
<p>到这里为止，我们的项目架构就建立好了，我们需要对Vue-cli给我们生成的文件进行一些必要的修改。 </p>
<h3 id="修改项目文件内容："><a href="#修改项目文件内容：" class="headerlink" title="修改项目文件内容："></a>修改项目文件内容：</h3><ol>
<li><p>修改根目录下的index.html文件，我们想写一些CSS样式，这样作是为了更好的布局，然后修改一下标题栏。让标题符合项目这里起名叫“AwesomePOS-快餐店管理系统”。index.html修改后内容如下。</p>
<p>   &lt;!DOCTYPE html&gt;<br>   <html></html></p>
<pre><code> &lt;head&gt;
   &lt;meta charset=&quot;utf-8&quot;&gt;
   &lt;title&gt;AwesomePOS-快餐管理系统&lt;/title&gt;
   &lt;link rel=&quot;stylesheet&quot; href=&quot;http://at.alicdn.com/t/font_wyhhdpv5lhvbzkt9.css&quot;&gt;
   &lt;style&gt;
     html,body,#app{height:100%;padding: 0;margin:0;}
   &lt;/style&gt;
 &lt;/head&gt;
 &lt;body &gt;
</code></pre></li>
</ol>
<pre><code>        &lt;div id=&quot;app&quot; &gt;&lt;/div&gt;
        &lt;!-- built files will be auto injected --&gt;

      &lt;/body&gt;

    &lt;/html&gt;
</code></pre><ol>
<li><p>新建Pos组件，这个相当于程序员的入口文件。在src/components/page/目录下新建Pos.vue文件。文件内容写出vue模板的架构就可以。</p>
   <template><br>     <div class="pos"><br>      Hello Pos Demo!<br>     </div><br>   </template>

<p>   <script><br>   export default {</p>
<pre><code> name: &#39;Pos&#39;
</code></pre><p>   }<br>   </script></p>
   <style scoped>

   </style>


</li>
</ol>
<ol>
<li><p>修改路由文件，项目根目录/src/router/index.js，让入口文件变成Pos组件。<br>先用import引入了Pos模板组件，然后修改routes里边的内容。如果你对Vue-router的知识还不了解，可以去看我以前的课程，这里就不作过多的讲解了。</p>
<p>import Vue from ‘vue’<br>import Router from ‘vue-router’<br>import Pos from ‘@/components/page/Pos’</p>
<p>Vue.use(Router)</p>
<p>export default new Router({<br> routes: [<br>   {</p>
<pre><code> path: &#39;/&#39;,
 name: &#39;Pos&#39;,
 component: Pos
</code></pre><p>   }<br> ]<br>})</p>
</li>
</ol>
<p>这时候看一下浏览器中的网页，如果显示出了Hello Pos Demo.我们就算成功搭建项目架构了。下节课我们确定一下项目中使用的图标。 </p>
<p>在开发中经常会遇到小图标的使用问题，小图标的使用可以让程序更美观和增加可用性。网上给程序加上小图标的方法有很多。曾经为了寻找一款使用简单，图标美观的图标库，我真的是到处搜索，直到遇到了IconFont，我觉的它能满足我的大部分要求。那在这里我推荐大家使用IconFont，这是阿里巴巴的矢量图标库。（这绝对不是广告，只是自己使用的一些感受） </p>
<p>挑选自己喜欢的图标 </p>
<p>Iconfont中有很多图标，我们可以像在超市逛街一样，挑选自己喜欢的商品，然后放入购物车。 </p>
<h3 id="挑选图标的过程（共6步）"><a href="#挑选图标的过程（共6步）" class="headerlink" title="挑选图标的过程（共6步）"></a>挑选图标的过程（共6步）</h3><ol>
<li>进入网站：Iconfont网址：[<a href="http://www.iconfont.cn][12" target="_blank" rel="external">http://www.iconfont.cn][12</a>]</li>
<li>点击网站上方的“官方图标库”，选择自己喜欢的图标。在这里我选择天猫的图标库。</li>
<li>选择好自己喜欢的图标，你可以有两个选择，下载代码 和 添加至项目。</li>
<li>我们这两选择添加至项目，然后新建项目，并输入名称。</li>
<li>项目添加好后，会自动给我们转入到我们项目库中。点击查看在线链接。</li>
<li>生产css引入的代码，生成后就可以在项目首页index.html引入了。</li>
</ol>
<pre><code>   [12]: http://www.iconfont.cn

 &lt;link rel=&quot;stylesheet&quot; href=&quot;http://at.alicdn.com/t/font_wyhhdpv5lhvbzkt9.css&quot;&gt;
</code></pre><h3 id="图标的使用："><a href="#图标的使用：" class="headerlink" title="图标的使用："></a>图标的使用：</h3><p>图标顺利引入到项目中，已经可以使用它们了，在“我的项目中”你会看到图标的font class值。可以直接复制代码粘贴，也可以自己写代码。 </p>
<pre><code>&lt;i class=&quot;icon iconfont icon-hanbao&quot;&gt;&lt;/i&gt;
</code></pre><p>这样在页面中就可以看到图标了。 </p>
<h3 id="添加更多图标："><a href="#添加更多图标：" class="headerlink" title="添加更多图标："></a>添加更多图标：</h3><p>如果在项目中觉的图标不够用了，需要添加更多图标。可以利用下面四步进行添加。 </p>
<ol>
<li>去Iconfont网站继续挑选，把相中的图标加入购物车中。</li>
<li>把购物车中的图标加入到项目中。</li>
<li>重新生成在线链接。（这部很重要）</li>
<li>在项目主页中(index.html)，更换css引入链接。</li>
</ol>
<p>实战项目开发的知识点就是很多，也很杂，但是这些都很实用，你也会快速成长，不要感觉和Vue无关就忽略，让我们共同努力，变成更好的自己。 </p>
<p>上节学习了inconFont的使用，可以在项目中加入漂亮的icon图标了。这节课我们要快速撸一个侧边栏组件出来。组件的作用就是在可以复用，想在那个页面使用都可以，并且像写html标签一样简单。 </p>
<h3 id="建立leftNav-vue文件："><a href="#建立leftNav-vue文件：" class="headerlink" title="建立leftNav.vue文件："></a>建立leftNav.vue文件：</h3><p>我们在src/components目录下，先新建一个common和page文件夹。 </p>
<ul>
<li>common文件夹用来放共用组件，下面写的leftNav.vue组件就放到这里。</li>
<li>page文件夹用来放我们的页面模板组件，页面的模板文件放到这里。</li>
</ul>
<p>在common文件夹下，新建leftNav.vue文件。 </p>
<p>开始动手写代码： </p>
<p>建立好文件后，我们先给components来个基本组件结构，你可以复制粘贴也可以手写。 </p>
<pre><code>&lt;template&gt;
  &lt;div class=&quot;left-nav&quot;&gt;

  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: &#39;leftNav&#39;,
  data () {
    return {
    }
  }
}
&lt;/script&gt;
&lt;style&gt;

&lt;/style&gt;
</code></pre><p>开始写html结构，我们用列表li来代表导航。菜单栏有收银、店铺、商品、会员、统计。我们编写的html结构如下 </p>
<pre><code> &lt;ul&gt;
        &lt;li&gt;
            &lt;i class=&quot;icon iconfont icon-wodezichan&quot;&gt;&lt;/i&gt;
            &lt;div&gt;收银&lt;/div&gt;
        &lt;/li&gt;

        &lt;li&gt;
            &lt;i class=&quot;icon iconfont icon-dianpu&quot;&gt;&lt;/i&gt;
            &lt;div&gt;店铺&lt;/div&gt;
        &lt;/li&gt;

        &lt;li&gt;
            &lt;i class=&quot;icon iconfont icon-hanbao&quot;&gt;&lt;/i&gt;
            &lt;div&gt;商品&lt;/div&gt;
        &lt;/li&gt;

         &lt;li&gt;
            &lt;i class=&quot;icon iconfont icon-huiyuanqia&quot;&gt;&lt;/i&gt;
            &lt;div&gt;会员&lt;/div&gt;
        &lt;/li&gt;


        &lt;li&gt;
            &lt;i class=&quot;icon iconfont icon-tongji&quot;&gt;&lt;/i&gt;
            &lt;div&gt;统计&lt;/div&gt;
        &lt;/li&gt;
&lt;/ul&gt;
</code></pre><p>注意：这里你也许和我使用的图标不一样，请自行改成你图标用的代码，不要无脑拷贝，图标会显示不出来。 </p>
<p>components（组件）基本结构写好后，开始动手写CSS样式，让我们的组件变的好看。 </p>
<pre><code>&lt;style&gt;
    .left-nav{
       color:#fff;
       font-size:10px;
       height:100%;
       background-color: #1D8ce0;
       float:left;
       width:5%;
    }
    .iconfont{
       font-size:24px;
    }
    .left-nav ul{
        padding:0px;
        margin: 0px;
    }
    .left-nav li{
        list-style: none;
        text-align: center;
        border-bottom:1px solid #20a0ff;
        padding:10px;
    }
&lt;/style&gt;
</code></pre><p>编写完CSS样式，这个组件算是大体写好了，以后根据需求我们会在组件里添加标签。但是现在还没有这个需求，所以暂时不添加。 </p>
<h3 id="把leftNav组件放到模板中"><a href="#把leftNav组件放到模板中" class="headerlink" title="把leftNav组件放到模板中"></a>把leftNav组件放到模板中</h3><p>先用import在App.vue中引入leftNav组件。 </p>
<pre><code>import leftNav from &#39;@/components/common/leftNav&#39;
</code></pre><p>引入后在vue的构造器里添加components属性，并放入我们的leftNav组件。 </p>
<pre><code>export default {
  name: &#39;app&#39;,
  components:{
    leftNav
  }
}
</code></pre><p>这样组件就算在也页面引入成功了，接下来我们就可以在区域里愉快的使用它（）。贴出引入使用全部代码，方便大家学习查看。 </p>
<pre><code>&lt;template&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;!--左侧导航--&gt;

        &lt;leftNav&gt;&lt;/leftNav&gt;

    &lt;!--操作区域--&gt;
    &lt;div class=&quot;main&quot;&gt;
      &lt;router-view&gt;&lt;/router-view&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import leftNav from &#39;@/components/common/leftNav&#39;
export default {
  name: &#39;app&#39;,
  components:{
    leftNav
  }
}
&lt;/script&gt;

&lt;style&gt;
#app {
  font-family: &#39;Microsoft YaHei&#39;,&#39;Avenir&#39;, Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-align: left;
  color: #2c3e50;
   height:100%;
}

.main{
  float:left;
  width:95%; 
  background-color: #EFF2F7;
  height:100%;
  overflow: auto;

}
&lt;/style&gt;
</code></pre><p>Element是一套为开发者、设计师和产品经理准备的基于Vue2.0的组件库，提供了配套设计资源，帮助你的网站快速成型。在项目中自己写组件虽然灵活，但是效率并不高效，所以要学会站在巨人的肩膀上干活，Element就是巨人的肩旁，也是现在国内比较成熟的以一套Vue的组件库。所以我决定 使用这个组件库开发项目。 </p>
<h3 id="npm安装"><a href="#npm安装" class="headerlink" title="npm安装"></a>npm安装</h3><p>这里使用npm的方式安装，它能更好地和webpack打包工具配合使用。 </p>
<pre><code>npm install element-ui --save
</code></pre><p>如果你网络状况不佳可以使用cnpm来进行安装。 </p>
<h3 id="完整引入项目"><a href="#完整引入项目" class="headerlink" title="完整引入项目"></a>完整引入项目</h3><p>在main.js中写入以下内容: </p>
<pre><code>import Vue from &#39;vue&#39;
import ElementUI from &#39;element-ui&#39;
import &#39;element-ui/lib/theme-default/index.css&#39;
import App from &#39;./App.vue&#39;

Vue.use(ElementUI)

new Vue({
  el: &#39;#app&#39;,
  render: h =&gt; h(App)
})
</code></pre><p>以上代码便完成了Element的引入。需要注意的是，样式文件需要单独引入。 </p>
<h3 id="用Element的el-row的布个局"><a href="#用Element的el-row的布个局" class="headerlink" title="用Element的el-row的布个局"></a>用Element的el-row的布个局</h3><p>安装好，先做个简单的布局小试牛刀，这里作两栏布局，Element支持用24栏的形式进行布局。 </p>
<p><strong>在Pos.vue里添加模版布局：</strong></p>
<pre><code>&lt;template&gt;
  &lt;div class=&quot;pos&quot;&gt;
    &lt;div&gt;
        &lt;el-row &gt;
            &lt;el-col :span=&#39;7&#39;&gt;
            我是订单栏
            &lt;/el-col&gt;
            &lt;!--商品展示--&gt;
            &lt;el-col :span=&quot;17&quot;&gt;
             我是产品栏
            &lt;/el-col&gt;
        &lt;/el-row&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: &#39;Pos&#39;,
  data () {
    return { 
    }
  }
}
&lt;/script&gt;
&lt;style scoped&gt;
&lt;/style&gt;
</code></pre><h3 id="解决100-高的问题"><a href="#解决100-高的问题" class="headerlink" title="解决100%高的问题"></a>解决100%高的问题</h3><p>在页面中使用了Element组件，这样他会自动给我们生产虚拟DOM，我们无法设置高度100%； </p>
<p>这时候可以利用javascript，来设置100%高度问题。先要给我们的标签上添加一个id，我们这里把ID设置为 </p>
<p>order-list。然后在vue构造器里使用mounted钩子函数来设置高度。 </p>
<pre><code>  mounted:function(){
      var orderHeight=document.body.clientHeight;
      document.getElementById(&quot;order-list&quot;).style.height=orderHeight+&#39;px&#39;;
  },
</code></pre><p>布局的基本架构，我们已经做好，剩下的就是一些细节。下节课我们将用一节课的时间制作大部分CSS样式内容。 </p>
<p>这节课我们将快速利用Element进行布局页面，这章视频中我会直接拷贝Style代码，因为我觉的你学Vue，那CSS也没有任何问题的，所以不耽误大家的宝贵事件。 </p>
<h3 id="el-tabs标签页组件"><a href="#el-tabs标签页组件" class="headerlink" title="el-tabs标签页组件"></a>el-tabs标签页组件</h3><p>用Element里提供的el-tabs组件可以快速制作我们的tabs标签页效果，具体使用方法可以到Element的官网查看API。 </p>
<p>基本用法很简单，可以直接在模板中引入标签，标签里边用来代表每个每个标签页。 </p>
<p>先看一个最简单的代码： </p>
<pre><code>&lt;el-tabs&gt;
      &lt;el-tab-pane label=&quot;点餐&quot;&gt;
       点餐   
      &lt;/el-tab-pane&gt;
      &lt;el-tab-pane label=&quot;挂单&quot;&gt;
      挂单
      &lt;/el-tab-pane&gt;
      &lt;el-tab-pane label=&quot;外卖&quot;&gt;
      外卖
     &lt;/el-tab-pane&gt;
&lt;/el-tabs&gt;
</code></pre><p>细心的小伙伴会看到每个里会有一个label属性，这个属性就是你标签页的标题。内容可以直接写在里。 </p>
<h3 id="el-table组件制作表格"><a href="#el-table组件制作表格" class="headerlink" title="el-table组件制作表格"></a>el-table组件制作表格</h3><p>需要在订单的tab标签页里放入表格，把点选的食品放入到待结账列表里,可以使用Element的内置组件el-table。如果你对el-table不了解， 可以去Element官网去查看一下。我这里不作太多的解释，先把代码贴过来，然后根据代码在讲解。 </p>
<pre><code>&lt;el-table :data=&quot;tableData&quot; border show-summary style=&quot;width: 100%&quot; &gt;

    &lt;el-table-column prop=&quot;goodsName&quot; label=&quot;商品&quot;  &gt;&lt;/el-table-column&gt;
    &lt;el-table-column prop=&quot;count&quot; label=&quot;量&quot; width=&quot;50&quot;&gt;&lt;/el-table-column&gt;
    &lt;el-table-column prop=&quot;price&quot; label=&quot;金额&quot; width=&quot;70&quot;&gt;&lt;/el-table-column&gt;
    &lt;el-table-column  label=&quot;操作&quot; width=&quot;100&quot; fixed=&quot;right&quot;&gt;
        &lt;template scope=&quot;scope&quot;&gt;
            &lt;el-button type=&quot;text&quot; size=&quot;small&quot;&gt;删除&lt;/el-button&gt;
            &lt;el-button type=&quot;text&quot; size=&quot;small&quot;&gt;增加&lt;/el-button&gt;

        &lt;/template&gt;
    &lt;/el-table-column&gt;
&lt;/el-table&gt;
</code></pre><p>这里我们采用了五列布表格， 在第1行中的:data是用来绑定数据源的， border代表表格有边框效果。在这视频里我会有详细的讲解。 </p>
<p>tableData中的数据源的值，为了布局方便，所以我们进行了写死，以后会改成动态添加的数据。 </p>
<pre><code> tableData: [{

          goodsName: &#39;可口可乐&#39;,
          price: 8,
          count:1
        }, {

          goodsName: &#39;香辣鸡腿堡&#39;,
          price: 15,
          count:1
        }, {

          goodsName: &#39;爱心薯条&#39;,
          price: 8,
          count:1
        }, {

          goodsName: &#39;甜筒&#39;,
          price: 8,
          count:1
        }]
</code></pre><p>你现在可以打开浏览器进行一下预览，看一下效果了。如果效果正常，我们可以继续往下编写了。 </p>
<h3 id="el-button-按钮组件"><a href="#el-button-按钮组件" class="headerlink" title="el-button 按钮组件"></a>el-button 按钮组件</h3><p>需要在点餐表格的下方放入三个功能性按钮，分别是挂单按钮、删除按钮、结账按钮。同样使用Element里的组件，进行快速写入。el-button 的type属性是设置按钮样式的，为了学些和区分我们这里用三个属性来设置按钮。 </p>
<pre><code>&lt;el-button type=&quot;warning&quot; &gt;挂单&lt;/el-button&gt;
&lt;el-button type=&quot;danger&quot; &gt;删除&lt;/el-button&gt;
&lt;el-button type=&quot;success&quot; &gt;结账&lt;/el-button&gt;
</code></pre><p>到这里我们左边最重要的订单操作区域就布局完成了，下节课我们布局右侧的商品布局。 </p>
<p>上节完成了左边订单栏的布局，这节我们还是利用Element完成大部分布局。 </p>
<p><img src="https://user-gold-cdn.xitu.io/2017/6/15/6ddcd9473d6c915981d98eec79f41aad?imageView2/0/w/1280/h/960" alt=""></p>
<p>这是完成布局的图片 </p>
<h3 id="常用商品区域布局："><a href="#常用商品区域布局：" class="headerlink" title="常用商品区域布局："></a>常用商品区域布局：</h3><p>在标签里增加一个层，然后在层内进行布局。因为里边的商品实际意义上是列表，所以用无序列表 </p>
<ul>
<li>来布局商品。贴出布局的html代码。</li>
<li><div class="often-goods"><br>    <div class="title">常用商品</div><br>    <div class="often-goods-list"><br><br>        <ul><br>            <li><br>                <span>香辣鸡腿堡</span><br>                <span class="o-price">￥15元</span><br>            </li><br><br>        </ul><br>    </div><br></div>


</li>
</ul>
<p>有了基本html结构后，需要增加一些css样式来美化页面： </p>
<pre><code> .title{
       height: 20px;
       border-bottom:1px solid #D3DCE6;
       background-color: #F9FAFC;
       padding:10px;
   }
   .often-goods-list ul li{
      list-style: none;
      float:left;
      border:1px solid #E5E9F2;
      padding:10px;
      margin:5px;
      background-color:#fff;
   }
  .o-price{
      color:#58B7FF; 
   }
</code></pre><p>现在页面变的漂亮了，我们这时候为了页面更逼近真实效果，我们在Vue的构造器里临时加一个数组，用作常用商品使用。声明的变量叫oftenGoods（真实项目不能这样起名字，这里只是练习使用）。 </p>
<pre><code> oftenGoods:[
          {
              goodsId:1,
              goodsName:&#39;香辣鸡腿堡&#39;,
              price:18
          }, {
              goodsId:2,
              goodsName:&#39;田园鸡腿堡&#39;,
              price:15
          }, {
              goodsId:3,
              goodsName:&#39;和风汉堡&#39;,
              price:15
          }, {
              goodsId:4,
              goodsName:&#39;快乐全家桶&#39;,
              price:80
          }, {
              goodsId:5,
              goodsName:&#39;脆皮炸鸡腿&#39;,
              price:10
          }, {
              goodsId:6,
              goodsName:&#39;魔法鸡块&#39;,
              price:20
          }, {
              goodsId:7,
              goodsName:&#39;可乐大杯&#39;,
              price:10
          }, {
              goodsId:8,
              goodsName:&#39;雪顶咖啡&#39;,
              price:18
          }, {
              goodsId:9,
              goodsName:&#39;大块鸡米花&#39;,
              price:15
          }, {
              goodsId:20,
              goodsName:&#39;香脆鸡柳&#39;,
              price:17
          }

      ]
</code></pre><p>有了数据，可以使用v-for循环来输出到html模板中。 </p>
<h3 id="商品分类布局："><a href="#商品分类布局：" class="headerlink" title="商品分类布局："></a>商品分类布局：</h3><p>这样我们商品的上半部分就布局完成了，现在需要布局下半部分，我们在下半部分先添加一个tabs的标签样式。 </p>
<pre><code>&lt;div class=&quot;goods-type&quot;&gt;

    &lt;el-tabs&gt;
        &lt;el-tab-pane label=&quot;汉堡&quot;&gt;
            汉堡
        &lt;/el-tab-pane&gt;
            &lt;el-tab-pane label=&quot;小食&quot;&gt;
            小食
        &lt;/el-tab-pane&gt;
        &lt;el-tab-pane label=&quot;饮料&quot;&gt;
            饮料
        &lt;/el-tab-pane&gt;
        &lt;el-tab-pane label=&quot;套餐&quot;&gt;
            套餐
        &lt;/el-tab-pane&gt;

    &lt;/el-tabs&gt;
&lt;/div&gt;
</code></pre><p>有上节课作tabs标签页的经验，这个变的异常简单。 </p>
<p>制作商品的无序列表： </p>
<pre><code>&lt;ul class=&#39;cookList&#39;&gt;
    &lt;li&gt;
        &lt;span class=&quot;foodImg&quot;&gt;&lt;img src=&quot;http://7xjyw1.com1.z0.glb.clouddn.com/pos001.jpg&quot; width=&quot;100%&quot;&gt;&lt;/span&gt;
        &lt;span class=&quot;foodName&quot;&gt;香辣鸡腿堡&lt;/span&gt;
        &lt;span class=&quot;foodPrice&quot;&gt;￥20.00元&lt;/span&gt;
    &lt;/li&gt;
&lt;/ul&gt;
</code></pre><p>对无序列表进行CSS样式编写： </p>
<pre><code>.cookList li{
       list-style: none;
       width:23%;
       border:1px solid #E5E9F2;
       height: auot;
       overflow: hidden;
       background-color:#fff;
       padding: 2px;
       float:left;
       margin: 2px;

   }
   .cookList li span{

        display: block;
        float:left;
   }
   .foodImg{
       width: 40%;
   }
   .foodName{
       font-size: 18px;
       padding-left: 10px;
       color:brown;

   }
   .foodPrice{
       font-size: 16px;
       padding-left: 10px;
       padding-top:10px;
   }
</code></pre><p>有了基本的样式，我们可以在Vue的构造器里添加汉堡类的数据。声明一个type0Goods的数据，数据格式如下。 </p>
<pre><code>    type0Goods:[
          {
              goodsId:1,
              goodsImg:&quot;http://7xjyw1.com1.z0.glb.clouddn.com/pos001.jpg&quot;,
              goodsName:&#39;香辣鸡腿堡&#39;,
              price:18
          }, {
              goodsId:2,
              goodsImg:&quot;http://7xjyw1.com1.z0.glb.clouddn.com/pos002.jpg&quot;,
              goodsName:&#39;田园鸡腿堡&#39;,
              price:15
          }, {
              goodsId:3,
              goodsImg:&quot;http://7xjyw1.com1.z0.glb.clouddn.com/pos004.jpg&quot;,
              goodsName:&#39;和风汉堡&#39;,
              price:15
          }, {
              goodsId:4,
               goodsImg:&quot;http://7xjyw1.com1.z0.glb.clouddn.com/pos003.jpg&quot;,
              goodsName:&#39;快乐全家桶&#39;,
              price:80
          }, {
              goodsId:5,
               goodsImg:&quot;http://7xjyw1.com1.z0.glb.clouddn.com/pos003.jpg&quot;,
              goodsName:&#39;脆皮炸鸡腿&#39;,
              price:10
          }, {
              goodsId:6,
               goodsImg:&quot;http://7xjyw1.com1.z0.glb.clouddn.com/pos004.jpg&quot;,
              goodsName:&#39;魔法鸡块&#39;,
              price:20
          }, {
              goodsId:7,
               goodsImg:&quot;http://7xjyw1.com1.z0.glb.clouddn.com/pos001.jpg&quot;,
              goodsName:&#39;可乐大杯&#39;,
              price:10
          }, {
              goodsId:8,
               goodsImg:&quot;http://7xjyw1.com1.z0.glb.clouddn.com/pos003.jpg&quot;,
              goodsName:&#39;雪顶咖啡&#39;,
              price:18
          }, {
              goodsId:9,
               goodsImg:&quot;http://7xjyw1.com1.z0.glb.clouddn.com/pos002.jpg&quot;,
              goodsName:&#39;大块鸡米花&#39;,
              price:15
          }, {
              goodsId:20,
               goodsImg:&quot;http://7xjyw1.com1.z0.glb.clouddn.com/pos002.jpg&quot;,
              goodsName:&#39;香脆鸡柳&#39;,
              price:17
          }

      ],
</code></pre><p>用v-for改造我们的无序列表： </p>
<pre><code>&lt;li v-for=&quot;goods in type0Goods&quot;&gt;
    &lt;span class=&quot;foodImg&quot;&gt;&lt;img :src=&quot;goods.goodsImg&quot; width=&quot;100%&quot;&gt;&lt;/span&gt;
    &lt;span class=&quot;foodName&quot;&gt;{{goods.goodsName}}&lt;/span&gt;
    &lt;span class=&quot;foodPrice&quot;&gt;￥{{goods.price}}元&lt;/span&gt;
&lt;/li&gt;
</code></pre><p>页面的基本布局我们已经制作完成，终于看起来像个收银界面了。但是现在的数据都是写死的，下节课我们将从后端用Axios拉去数据。 </p>
<p>上节课我们利用Elemnt已经把页面布局的差不多了，如果你觉的不够美观，可以自己再进行美化，因为课程的原因css细节我们这里就不深入美化了。这节课我们开始学习Axios的知识，并把商品数据从远端读取到页面上。学这节课时技术胖已经为大家准备好了后端数据，你们只要调用相应的页面就可以调取，在实际开发中，这些后台数据是需要后端程序员和你共同讨论制作的。我们现在只做前端，数据大家只要会调用即可。 </p>
<h3 id="安装Axios"><a href="#安装Axios" class="headerlink" title="安装Axios"></a>安装Axios</h3><p>我们直接使用npm install来进行安装。 </p>
<pre><code>npm install axios --save
</code></pre><p>由于axios是需要打包到生产环境中的，所以我们使用–save来进行安装。 </p>
<h3 id="引入Axios"><a href="#引入Axios" class="headerlink" title="引入Axios"></a>引入Axios</h3><p>我们在Pos.vue页面引入Axios，由于使用了npm来进行安装，所以这里不需要填写路径。 </p>
<pre><code>import axios from &#39;axios&#39;
</code></pre><h3 id="服务端拉取常用商品数据"><a href="#服务端拉取常用商品数据" class="headerlink" title="服务端拉取常用商品数据"></a>服务端拉取常用商品数据</h3><p>远端服务器地址：<a href="http://jspang.com/DemoApi/oftenGoods.php" target="_blank" rel="external">http://jspang.com/DemoApi/oftenGoods.php</a></p>
<p>（在实际项目中这个后台接口地址是后端程序员提供给你的，你可以随便调用这个接口，我已经放到服务器上了。） </p>
<p>可以先把地址放到地址栏访问一下，是可以正常访问的，并且输出了json格式的字符串，这就是我们需要的远端数据了。这里我们使用Axios的get 方式来获得数据。 </p>
<pre><code>  created(){
      axios.get(&#39;http://jspang.com/DemoApi/oftenGoods.php&#39;)
      .then(response=&gt;{
         console.log(response);
         this.oftenGoods=response.data;
      })
      .catch(error=&gt;{
          console.log(error);
          alert(&#39;网络错误，不能访问&#39;);
      })
  },
</code></pre><p>把axios的方法写到了created钩子函数中，我们使用了get 方法进行拉取数据，如果拉取成功用远端数据对oftenGoods进行赋值。 </p>
<p>拉取报错，一般有两种情况： </p>
<pre><code>1. 网络不通：网络状况不是很好，这可以在失败后隔5秒再次请求。
2. 报决绝访问：这种多是后端程序员设置了不允许跨域访问，需要你和后端程序员一起调试解决。
</code></pre><h3 id="拉取分类商品数据："><a href="#拉取分类商品数据：" class="headerlink" title="拉取分类商品数据："></a>拉取分类商品数据：</h3><p>远端服务器地址：<a href="http://jspang.com/DemoApi/typeGoods.php" target="_blank" rel="external">http://jspang.com/DemoApi/typeGoods.php</a></p>
<p>依然用Get进行拉取，拉取后先用consoe.log(response)查看一下数据结构，让后进行赋值。由于知识跟上边的很像，文字版我就不多描述了，详细可以查看视频教程。 </p>
<p>在这里贴出拉取和分配不同分类代码： </p>
<pre><code>       //读取分类商品列表
      axios.get(&#39;http://jspang.com/DemoApi/typeGoods.php&#39;)
      .then(response=&gt;{
         console.log(response);
         //this.oftenGoods=response.data;
         this.type0Goods=response.data[0];
         this.type1Goods=response.data[1];
         this.type2Goods=response.data[2];
         this.type3Goods=response.data[3];

      })
      .catch(error=&gt;{
          console.log(error);
          alert(&#39;网络错误，不能访问&#39;);
      })
</code></pre><p>html模板输出代码： </p>
<pre><code>&lt;ul class=&#39;cookList&#39;&gt;
     &lt;li v-for=&quot;goods in type3Goods&quot;&gt;
         &lt;span class=&quot;foodImg&quot;&gt;&lt;img :src=&quot;goods.goodsImg&quot; width=&quot;100%&quot;&gt;&lt;/span&gt;
         &lt;span class=&quot;foodName&quot;&gt;{{goods.goodsName}}&lt;/span&gt;
         &lt;span class=&quot;foodPrice&quot;&gt;￥{{goods.price}}元&lt;/span&gt;
      &lt;/li&gt;
&lt;/ul&gt;
</code></pre><p>在实际开发中类别也是循环出来的，这里为了教学演示，没有写的那么复杂，你只要明白了如何操作，以后你可以自己增加。就像我这个项目一样，在视频结束后，会慢慢写完善所有功能，最后送给女神，赢得女神芳心。 </p>
<p>下节课我们学习订单操作里需要的功能，比如点击商品，添加到左边的订单栏里，增加，删除商品，模拟订单提交到后台。如果下节课一节讲不完，我们就分成两节课来讲。 </p>
<p>经过上节课的学习，我们已经可以从后台取得数据了。这节课要完成的任务是实现页面左侧的订单列表页面的添加操作。本来我想一节课讲完的，但是内容还是比较多的，又不想让大家每节课学习很长时间，所以我把这个内容进行了划分。 </p>
<h3 id="添加商品到订单页面"><a href="#添加商品到订单页面" class="headerlink" title="添加商品到订单页面"></a>添加商品到订单页面</h3><p>我们在vue的构造器里加入methods方法，在methods方法里再加入addOrderList方法。这个方法的作用是点击右侧的商品，然后把商品添加到左边的列表里。 </p>
<p>addOrderList方法(也许你只看文字版无法理解，推荐查看视频)： </p>
<pre><code>methods:{
      //添加订单列表的方法
      addOrderList(goods){
            this.totalCount=0; //汇总数量清0
            this.totalMoney=0;
            let isHave=false;
            //判断是否这个商品已经存在于订单列表
            for (let i=0; i&lt;this.tableData.length;i++){
                console.log(this.tableData[i].goodsId);
                if(this.tableData[i].goodsId==goods.goodsId){
                    isHave=true; //存在
                }
            }
            //根据isHave的值判断订单列表中是否已经有此商品
            if(isHave){
                //存在就进行数量添加
                 let arr = this.tableData.filter(o =&gt;o.goodsId == goods.goodsId);
                 arr[0].count++;
                 //console.log(arr);
            }else{
                //不存在就推入数组
                let newGoods={goodsId:goods.goodsId,goodsName:goods.goodsName,price:goods.price,count:1};
                 this.tableData.push(newGoods);

            }

            //进行数量和价格的汇总计算
            this.tableData.forEach((element) =&gt; {
                this.totalCount+=element.count;
                this.totalMoney=this.totalMoney+(element.price*element.count);   
            });

      }
  }
</code></pre><p>在作这个方法的时候，在订单列表的下方又添加了订单的统计功能，其实也就两项：<strong>订单价格汇总</strong>和订单商品数量汇总。我们在data里声明的值是totalMoney和totalCount。 </p>
<p>写完这个方法后，我们还需要在我们的商品上绑定方法，来进行调用添加方法。 </p>
<pre><code> @click=&quot;addOrderList(goods)&quot;
</code></pre><p>这样在点击商品时订单列表就会根据我们的程序逻辑发生变化。 </p>
<h3 id="订单列表中的增加按钮"><a href="#订单列表中的增加按钮" class="headerlink" title="订单列表中的增加按钮"></a><strong>订单列表中的增加按钮</strong></h3><p>商品中绑定addOrderList方法是非常容易的，如果在订单列表中绑定是需要特殊处理一下的，需要用到template的scope值，让后进行绑定。 </p>
<pre><code>&lt;el-button type=&quot;text&quot; size=&quot;small&quot; @click=&quot;addOrderList(scope.row)&quot;&gt;增加&lt;/el-button&gt;
</code></pre><p>这节课我们把订单增加的操作制作完成了，下节课我们要制作订单商品的删除和订单的整体删除功能，最后模拟一下订单的结账功能。 </p>
<p>继续制作订单模块，这节课主要三个功能的制作，删除列表中的单个商品，删除列表中的全部商品，简单模拟结账。 </p>
<h3 id="删除单个商品"><a href="#删除单个商品" class="headerlink" title="删除单个商品"></a>删除单个商品</h3><p>在veu构造器methods属性里增加一个delSingleGoods方法，并接收goods对象为参数，用数组的filter可以轻松删除数组中单个的商品。 </p>
<pre><code>    //删除单个商品
      delSingleGoods(goods){
        console.log(goods);
        this.tableData=this.tableData.filter(o =&gt; o.goodsId !=goods.goodsId);

      },
</code></pre><p>现在可以npm run dev试一下了，会发现现在商品可以正确的删除了，但是统计的数量和金额是不正确的，我们需要写一些统计的代码。在下手之前你会发现在增加商品方法中也有类似统计的方法，既然两个功能很像，我们就重新写一个方法。 </p>
<pre><code>//汇总数量和金额
getAllMoney(){
    this.totalCount=0;
    this.totalMoney=0;
    if(this.tableData){
            this.tableData.forEach((element) =&gt; {
        this.totalCount+=element.count;
        this.totalMoney=this.totalMoney+(element.price*element.count);   
    });
    }

}
</code></pre><p>需要注意的是，以前我们是单独使用的，所以不用把totoalCount和totalMoney清零，但是做成公用方法了，记得清零。方法做好了，我们在需要的地方直接用this.getAllMoney()引用就可以了。 </p>
<p>功能做好了，我们还需要为删除按钮绑定事件： </p>
<pre><code>&lt;el-button type=&quot;text&quot; size=&quot;small&quot; @click=&quot;delSingleGoods(scope.row)&quot;&gt;删除&lt;/el-button&gt;
</code></pre><p>这样我们就把删除单个订单商品的功能做好了，我们可以测试调试一下。 </p>
<h3 id="删除全部订单商品"><a href="#删除全部订单商品" class="headerlink" title="删除全部订单商品"></a>删除全部订单商品</h3><p>这个功能其实很简单，只要把this.tableData清空就可以了，在methods属性中写一个delAllGoods的方法。 </p>
<pre><code>      //删除所有商品
        delAllGoods() {
            this.tableData = [];
            this.totalCount = 0;
            this.totalMoney = 0;
        },
</code></pre><p>有的小伙伴会好奇，你完全可以再次复用getAllMoney()方法进行汇总，为什么不用那？汇总方法里毕竟是有业务逻辑的，我们只做两个清零，这样消耗的资源更少，所以我们没有使用。 </p>
<h3 id="模拟结账"><a href="#模拟结账" class="headerlink" title="模拟结账"></a>模拟结账</h3><p>因为模拟结账需要Post数据到后台，我的服务器又不能提供这样的借口给大家，所以我只说制作思路，大家可以在自己的服务器上去实现。 </p>
<p>1、设置我们Aixos的Pos方法。 </p>
<p>2、接受返回值进行处理。 </p>
<p>3、如果成功，清空现有构造器里的tableData，totalMoney，totalCount数据。 </p>
<p>4、进行用户的友好提示。 </p>
<p>由于前两个步骤不能演示，所以这里我们只模拟3和4步。在methods里作一个结账方法，清空数据和进行友好提示。 </p>
<pre><code>checkout() {
    if (this.totalCount!=0) {
        this.tableData = [];
        this.totalCount = 0;
        this.totalMoney = 0;
        this.$message({
            message: &#39;结账成功，感谢你又为店里出了一份力!&#39;,
            type: &#39;success&#39;
        });

    }else{
        this.$message.error(&#39;不能空结。老板了解你急切的心情！&#39;);
    }

}
</code></pre><p>订单模块基本的功能就制作完成了，我希望大家都能动手练习一下，如果你不动手练习你永远学不会的。 </p>
<p>一直追看的小伙伴可能知道原来还有一节挂单功能的制作，但是在录制的过程中我发现90%的知识点都是重复的，不重复的知识点讲的还和Vue没有关系，是html5的localStorage操作，所以我去掉了这节。这节我们主要讲一下打包需要注意的事项和总结一下我们学习的知识。 </p>
<h3 id="打包注意事项："><a href="#打包注意事项：" class="headerlink" title="打包注意事项："></a>打包注意事项：</h3><p>1、把绝对路径改为相对路径 </p>
<p>我们打开config/index.js 会看到一个build属性，这里就我们打包的基本配置了。你在这里可以修改打包的目录，打包的文件名。最重要的是一定要把绝对目录改为相对目录。 </p>
<pre><code>assetsPublicPath:&#39;./&#39;
</code></pre><p>这样才能保证我们打包出去的项目可以正常预览。 </p>
<p>2、在命令行中用npm run build 进行打包。 </p>
<pre><code>npm run build
</code></pre><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
    
    </summary>
    
      <category term="VueJs" scheme="https://wangyu1997.github.io/categories/VueJs/"/>
    
    
      <category term="vue" scheme="https://wangyu1997.github.io/tags/vue/"/>
    
      <category term="实战" scheme="https://wangyu1997.github.io/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>AOP实战</title>
    <link href="https://wangyu1997.github.io/2017/10/01/JavaWeb/AOP%E5%AE%9E%E6%88%98/"/>
    <id>https://wangyu1997.github.io/2017/10/01/JavaWeb/AOP实战/</id>
    <published>2017-10-01T02:43:11.000Z</published>
    <updated>2017-10-24T06:31:06.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a> 
<p>接上一小节<a href="https://wangyu1997.github.io/2017/10/01/JavaWeb/AOP%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3/">彻底征服 Spring AOP 之 理论篇</a></p>
<h2 id="Spring-AOP-实战"><a href="#Spring-AOP-实战" class="headerlink" title="Spring AOP 实战"></a>Spring AOP 实战</h2><p>看了上面这么多的理论知识, 不知道大家有没有觉得枯燥哈. 不过不要急, 俗话说理论是实践的基础, 对 Spring AOP 有了基本的理论认识后, 我们来看一下下面几个具体的例子吧.<br>下面的几个例子是我在工作中所遇见的比较常用的 Spring AOP 的使用场景, 我精简了很多有干扰我们学习的注意力的细枝末节, 以力求整个例子的简洁性. </p>
<p>下面几个 Demo 的源码都可以在我的 <a href="https://github.com/yongshun/some_java_code" target="_blank" rel="external">Github</a> 上下载到. </p>
<h3 id="HTTP-接口鉴权"><a href="#HTTP-接口鉴权" class="headerlink" title="HTTP 接口鉴权"></a>HTTP 接口鉴权</h3><p>首先让我们来想象一下如下场景: 我们需要提供的 HTTP RESTful 服务, 这个服务会提供一些比较敏感的信息, 因此对于某些接口的调用会进行调用方权限的校验, 而某些不太敏感的接口则不设置权限, 或所需要的权限比较低(例如某些监控接口, 服务状态接口等).<br>实现这样的需求的方法有很多, 例如我们可以在每个 HTTP 接口方法中对服务请求的调用方进行权限的检查, 当调用方权限不符时, 方法返回错误. 当然这样做并无不可, 不过如果我们的 api 接口很多, 每个接口都进行这样的判断, 无疑有很多冗余的代码, 并且很有可能有某个粗心的家伙忘记了对调用者的权限进行验证, 这样就会造成潜在的 bug.<br>那么除了上面的所说的方法外, 还有没有别的比较优雅的方式来实现呢? 当然有啦, 不然我在这啰嗦半天干嘛呢, 它就是我们今天的主角: <code>AOP</code>. </p>
<p>让我们来提炼一下我们的需求: </p>
<ol>
<li><p>可以定制地为某些指定的 HTTP RESTful api 提供权限验证功能. </p>
</li>
<li><p>当调用方的权限不符时, 返回错误. </p>
</li>
</ol>
<p>根据上面所提出的需求, 我们可以进行如下设计: </p>
<ol>
<li><p>提供一个特殊的注解 <code>AuthChecker</code>, 这个是一个方法注解, 有此注解所标注的 Controller 需要进行调用方权限的认证. </p>
</li>
<li><p>利用 Spring AOP, 以 <strong>@annotation</strong> 切点标志符来匹配有注解 <code>AuthChecker</code> 所标注的 joinpoint. </p>
</li>
<li><p>在 advice 中, 简单地检查调用者请求中的 Cookie 中是否有我们指定的 token, 如果有, 则认为此调用者权限合法, 允许调用, 反之权限不合法, 范围错误. </p>
</li>
</ol>
<p>根据上面的设计, 我们来看一下具体的源码吧.<br>首先是 <code>AuthChecker</code> 注解的定义:<br><strong>AuthChecker.java:</strong></p>
<pre><code>@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface AuthChecker {
}
</code></pre><p><code>AuthChecker</code> 注解是一个方法注解, 它用于注解 RequestMapping 方法. </p>
<p>有了注解的定义, 那我们再来看一下 aspect 的实现吧:<br><strong>HttpAopAdviseDefine.java:</strong></p>
<pre><code>@Component
@Aspect
public class HttpAopAdviseDefine {

    // 定义一个 Pointcut, 使用 切点表达式函数 来描述对哪些 Join point 使用 advise.
    @Pointcut(&quot;@annotation(com.xys.demo1.AuthChecker)&quot;)
    public void pointcut() {
    }

    // 定义 advise
    @Around(&quot;pointcut()&quot;)
    public Object checkAuth(ProceedingJoinPoint joinPoint) throws Throwable {
        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes())
                .getRequest();

        // 检查用户所传递的 token 是否合法
        String token = getUserToken(request);
        if (!token.equalsIgnoreCase(&quot;123456&quot;)) {
            return &quot;错误, 权限不合法!&quot;;
        }

        return joinPoint.proceed();
    }

    private String getUserToken(HttpServletRequest request) {
        Cookie[] cookies = request.getCookies();
        if (cookies == null) {
            return &quot;&quot;;
        }
        for (Cookie cookie : cookies) {
            if (cookie.getName().equalsIgnoreCase(&quot;user_token&quot;)) {
                return cookie.getValue();
            }
        }
        return &quot;&quot;;
    }
}
</code></pre><p>在这个 aspect 中, 我们首先定义了一个 pointcut, 以 <strong>@annotation</strong> 切点标志符来匹配有注解 <code>AuthChecker</code> 所标注的 joinpoint, 即: </p>
<pre><code>// 定义一个 Pointcut, 使用 切点表达式函数 来描述对哪些 Join point 使用 advise.
@Pointcut(&quot;@annotation(com.xys.demo1.AuthChecker)&quot;)
public void pointcut() {
}
</code></pre><p>然后再定义一个 advice: </p>
<pre><code>// 定义 advise
@Around(&quot;pointcut()&quot;)
public Object checkAuth(ProceedingJoinPoint joinPoint) throws Throwable {
    HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes())
            .getRequest();

    // 检查用户所传递的 token 是否合法
    String token = getUserToken(request);
    if (!token.equalsIgnoreCase(&quot;123456&quot;)) {
        return &quot;错误, 权限不合法!&quot;;
    }

    return joinPoint.proceed();
}
</code></pre><p>当被 <code>AuthChecker</code> 注解所标注的方法调用前, 会执行我们的这个 advice, 而这个 advice 的处理逻辑很简单, 即从 HTTP 请求中获取名为 <code>user_token</code> 的 cookie 的值, 如果它的值是 <code>123456</code>, 则我们认为此 HTTP 请求合法, 进而调用 <code>joinPoint.proceed()</code> 将 HTTP 请求转交给相应的控制器处理; 而如果<code>user_token</code> cookie 的值不是 <code>123456</code>, 或为空, 则认为此 HTTP 请求非法, 返回错误. </p>
<p>接下来我们来写一个模拟的 HTTP 接口:<br><strong>DemoController.java:</strong></p>
<pre><code>@RestController
public class DemoController {
    @RequestMapping(&quot;/aop/http/alive&quot;)
    public String alive() {
        return &quot;服务一切正常&quot;;
    }

    @AuthChecker
    @RequestMapping(&quot;/aop/http/user_info&quot;)
    public String callSomeInterface() {
        return &quot;调用了 user_info 接口.&quot;;
    }
}
</code></pre><p>注意到上面我们提供了两个 HTTP 接口, 其中 接口 <strong>/aop/http/alive</strong> 是没有 <code>AuthChecker</code> 标注的, 而 <strong>/aop/http/user_info</strong> 接口则用到了 <code>@AuthChecker</code> 标注. 那么自然地, 当请求了 <strong>/aop/http/user_info</strong> 接口时, 就会触发我们所设置的权限校验逻辑. </p>
<p>接下来我们来验证一下, 我们所实现的功能是否有效吧.<br>首先在 Postman 中, 调用 <strong>/aop/http/alive</strong> 接口, 请求头中不加任何参数: </p>
<p>可以看到, 我们的 HTTP 请求完全没问题. </p>
<p>那么再来看一下请求 <strong>/aop/http/user_info</strong> 接口会怎样呢: </p>
<p>当我们请求 <strong>/aop/http/user_info</strong> 接口时, 服务返回一个权限异常的错误, 为什么会这样呢? 自然就是我们的权限认证系统起了作为: 当一个方法被调用并且这个方法有 <code>AuthChecker</code> 标注时, 那么首先会执行到我们的 <code>around advice</code>, 在这个 advice 中, 我们会校验 HTTP 请求的 cookie 字段中是否有携带 <code>user_token</code> 字段时, 如果没有, 则返回权限错误.<br>那么为了能够正常地调用 <strong>/aop/http/user_info</strong> 接口, 我们可以在 Cookie 中添加 <strong>user_token=123456</strong>, 这样我们可以愉快的玩耍了: </p>
<blockquote>
<p><code>注意</code>, Postman 默认是不支持 Cookie 的, 所以为了实现添加 Cookie 的功能, 我们需要安装 Postman 的 <code>interceptor</code> 插件. 安装方法可以看<a href="https://www.getpostman.com/docs/interceptor_cookies" target="_blank" rel="external">官网的文章</a></p>
</blockquote>
<h4 id="完整源码"><a href="#完整源码" class="headerlink" title="完整源码"></a>完整源码</h4><p><a href="https://github.com/yongshun/some_java_code/tree/master/SpringAOPDemo/src/main/java/com/xys/demo1" target="_blank" rel="external">HTTP 接口鉴权</a></p>
<h3 id="方法调用日志"><a href="#方法调用日志" class="headerlink" title="方法调用日志"></a>方法调用日志</h3><p>第二个 AOP 实例是记录一个方法调用的log. 这应该是一个很常见的功能了.<br>首先假设我们有如下需求: </p>
<ol>
<li><p>某个服务下的方法的调用需要有 log: 记录调用的参数以及返回结果. </p>
</li>
<li><p>当方法调用出异常时, 有特殊处理, 例如打印异常 log, 报警等. </p>
</li>
</ol>
<p>根据上面的需求, 我们可以使用 before advice 来在调用方法前打印调用的参数, 使用 after returning advice 在方法返回打印返回的结果. 而当方法调用失败后, 可以使用 after throwing advice 来做相应的处理.<br>那么我们来看一下 aspect 的实现: </p>
<pre><code>@Component
@Aspect
public class LogAopAdviseDefine {
    private Logger logger = LoggerFactory.getLogger(getClass());

    // 定义一个 Pointcut, 使用 切点表达式函数 来描述对哪些 Join point 使用 advise.
    @Pointcut(&quot;within(NeedLogService)&quot;)
    public void pointcut() {
    }

    // 定义 advise
    @Before(&quot;pointcut()&quot;)
    public void logMethodInvokeParam(JoinPoint joinPoint) {
        logger.info(&quot;---Before method {} invoke, param: {}---&quot;, joinPoint.getSignature().toShortString(), joinPoint.getArgs());
    }

    @AfterReturning(pointcut = &quot;pointcut()&quot;, returning = &quot;retVal&quot;)
    public void logMethodInvokeResult(JoinPoint joinPoint, Object retVal) {
        logger.info(&quot;---After method {} invoke, result: {}---&quot;, joinPoint.getSignature().toShortString(), joinPoint.getArgs());
    }

    @AfterThrowing(pointcut = &quot;pointcut()&quot;, throwing = &quot;exception&quot;)
    public void logMethodInvokeException(JoinPoint joinPoint, Exception exception) {
        logger.info(&quot;---method {} invoke exception: {}---&quot;, joinPoint.getSignature().toShortString(), exception.getMessage());
    }
}
</code></pre><p>第一步, 自然是定义一个 <code>pointcut</code>, 以 <strong>within</strong> 切点标志符来匹配类 <code>NeedLogService</code> 下的所有 joinpoint, 即: </p>
<pre><code>@Pointcut(&quot;within(NeedLogService)&quot;)
public void pointcut() {
}
</code></pre><p>接下来根据我们前面的设计, 我们分别定义了三个 advice, 第一个是一个 before advice: </p>
<pre><code>@Before(&quot;pointcut()&quot;)
public void logMethodInvokeParam(JoinPoint joinPoint) {
    logger.info(&quot;---Before method {} invoke, param: {}---&quot;, joinPoint.getSignature().toShortString(), joinPoint.getArgs());
}
</code></pre><p>它在一个符合要求的 joinpoint 方法调用前执行, 打印调用的方法名和调用的参数. </p>
<p>第二个是 after return advice: </p>
<pre><code>@AfterReturning(pointcut = &quot;pointcut()&quot;, returning = &quot;retVal&quot;)
public void logMethodInvokeResult(JoinPoint joinPoint, Object retVal) {
    logger.info(&quot;---After method {} invoke, result: {}---&quot;, joinPoint.getSignature().toShortString(), joinPoint.getArgs());
}
</code></pre><p>这个 advice 会在方法调用成功后打印出方法名还反的参数. </p>
<p>最后一个是 after throw advice: </p>
<pre><code>@AfterThrowing(pointcut = &quot;pointcut()&quot;, throwing = &quot;exception&quot;)
public void logMethodInvokeException(JoinPoint joinPoint, Exception exception) {
    logger.info(&quot;---method {} invoke exception: {}---&quot;, joinPoint.getSignature().toShortString(), exception.getMessage());
}
</code></pre><p>这个 advice 会在指定的 joinpoint 抛出异常时执行, 打印异常的信息. </p>
<p>接下来我们再写两个 Service 类:<br><strong>NeedLogService.java:</strong></p>
<pre><code>@Service
public class NeedLogService {
    private Logger logger = LoggerFactory.getLogger(getClass());
    private Random random = new Random(System.currentTimeMillis());

    public int logMethod(String someParam) {
        logger.info(&quot;---NeedLogService: logMethod invoked, param: {}---&quot;, someParam);
        return random.nextInt();
    }

    public void exceptionMethod() throws Exception {
        logger.info(&quot;---NeedLogService: exceptionMethod invoked---&quot;);
        throw new Exception(&quot;Something bad happened!&quot;);
    }
}
</code></pre><p><strong>NormalService.java:</strong></p>
<pre><code>@Service
public class NormalService {
    private Logger logger = LoggerFactory.getLogger(getClass());

    public void someMethod() {
        logger.info(&quot;---NormalService: someMethod invoked---&quot;);
    }
}
</code></pre><p>根据我们 pointcut 的规则, 类 NeedLogService 下的所有方法都会被织入 advice, 而类 NormalService 则不会. </p>
<p>最后我们分别调用这几个方法: </p>
<pre><code>@PostConstruct
public void test() {
    needLogService.logMethod(&quot;xys&quot;);
    try {
        needLogService.exceptionMethod();
    } catch (Exception e) {
        // Ignore
    }
    normalService.someMethod();
}
</code></pre><p>我们可以看到有如下输出: </p>
<pre><code>---Before method NeedLogService.logMethod(..) invoke, param: [xys]---
---NeedLogService: logMethod invoked, param: xys---
---After method NeedLogService.logMethod(..) invoke, result: [xys]---

---Before method NeedLogService.exceptionMethod() invoke, param: []---
---NeedLogService: exceptionMethod invoked---
---method NeedLogService.exceptionMethod() invoke exception: Something bad happened!---

---NormalService: someMethod invoked---
</code></pre><p>根据 log, 我们知道, NeedLogService.logMethod 执行的前后确实有 advice 执行了, 并且在 NeedLogService.exceptionMethod 抛出异常后, <code>logMethodInvokeException</code> 这个 advice 也被执行了. 而由于 pointcut 的匹配规则, 在 <code>NormalService</code> 类中的方法则不会织入 advice. </p>
<h4 id="完整源码-1"><a href="#完整源码-1" class="headerlink" title="完整源码"></a>完整源码</h4><p><a href="https://github.com/yongshun/some_java_code/tree/master/SpringAOPDemo/src/main/java/com/xys/demo2" target="_blank" rel="external">方法调用日志</a></p>
<h3 id="方法耗时统计"><a href="#方法耗时统计" class="headerlink" title="方法耗时统计"></a>方法耗时统计</h3><p>作为程序员, 我们都知道服务监控对于一个服务能够长期稳定运行的重要性, 因此很多公司都有自己内部的监控报警系统, 或者是使用一些开源的系统, 例如小米的 Falcon 监控系统. </p>
<p>那么在程序监控中, AOP 有哪些用武之地呢? 我们来假想一下如下场景: </p>
<blockquote>
<p>有一天, leader 对小王说, “小王啊, 你负责的那个服务不太稳定啊, 经常有超时发生! 你有对这些服务接口进行过耗时统计吗?”<br>耗时统计? 小王嘀咕了, 小声的回答到: “还没有加呢.”<br>leader: “你看着办吧, 我明天要看到各个时段的服务接口调用的耗时分布!”<br>小王这就犯难了, 虽然说计算一个方法的调用耗时并不是一个很难的事情, 但是整个服务有二十来个接口呢, 一个一个地添加统计代码, 那还不是要累死人了.<br>看着同事一个一个都下班回家了, 小王眉头更加紧了. 不过此时小王灵机一动: “噫, 有了!”.<br>小王想到了一个好方法, 立即动手, 吭哧吭哧地几分钟就搞定了. </p>
</blockquote>
<p>那么小王的解决方法是什么呢? 自然是我们的主角 <code>AOP</code> 啦. </p>
<p>首先让我们来提炼一下需求: </p>
<ol>
<li><p>为服务中的每个方法调用进行调用耗时记录. </p>
</li>
<li><p>将方法调用的时间戳, 方法名, 调用耗时上报到监控平台 </p>
</li>
</ol>
<p>有了需求, 自然设计实现就很简单了. 首先我们可以使用 around advice, 然后在方法调用前, 记录一下开始时间, 然后在方法调用结束后, 记录结束时间, 它们的时间差就是方法的调用耗时. </p>
<p>我们来看一下具体的 aspect 实现: </p>
<p><strong>ExpiredAopAdviseDefine.java:</strong></p>
<pre><code>@Component
@Aspect
public class ExpiredAopAdviseDefine {
    private Logger logger = LoggerFactory.getLogger(getClass());

    // 定义一个 Pointcut, 使用 切点表达式函数 来描述对哪些 Join point 使用 advise.
    @Pointcut(&quot;within(SomeService)&quot;)
    public void pointcut() {
    }

    // 定义 advise
    // 定义 advise
    @Around(&quot;pointcut()&quot;)
    public Object methodInvokeExpiredTime(ProceedingJoinPoint pjp) throws Throwable {
        StopWatch stopWatch = new StopWatch();
        stopWatch.start();
        // 开始
        Object retVal = pjp.proceed();
        stopWatch.stop();
        // 结束

        // 上报到公司监控平台
        reportToMonitorSystem(pjp.getSignature().toShortString(), stopWatch.getTotalTimeMillis());

        return retVal;
    }


    public void reportToMonitorSystem(String methodName, long expiredTime) {
        logger.info(&quot;---method {} invoked, expired time: {} ms---&quot;, methodName, expiredTime);
        //
    }
}
</code></pre><p>aspect 一开始定义了一个 <code>pointcut</code>, 匹配 <code>SomeService</code> 类下的所有的方法.<br>接着呢, 定义了一个 around advice: </p>
<pre><code>@Around(&quot;pointcut()&quot;)
public Object methodInvokeExpiredTime(ProceedingJoinPoint pjp) throws Throwable {
    StopWatch stopWatch = new StopWatch();
    stopWatch.start();
    // 开始
    Object retVal = pjp.proceed();
    stopWatch.stop();
    // 结束

    // 上报到公司监控平台
    reportToMonitorSystem(pjp.getSignature().toShortString(), stopWatch.getTotalTimeMillis());

    return retVal;
}
</code></pre><p>advice 中的代码也很简单, 它使用了 Spring 提供的 StopWatch 来统计一段代码的执行时间. 首先我们先调用 <strong>stopWatch.start()</strong> 开始计时, 然后通过 <code>pjp.proceed()</code> 来调用我们实际的服务方法, 当调用结束后, 通过 <strong>stopWatch.stop()</strong> 来结束计时. </p>
<p>接着我们来写一个简单的服务, 这个服务提供一个 <strong>someMethod</strong> 方法用于模拟一个耗时的方法调用:<br><strong>SomeService.java:</strong></p>
<pre><code>@Service
public class SomeService {
    private Logger logger = LoggerFactory.getLogger(getClass());
    private Random random = new Random(System.currentTimeMillis());

    public void someMethod() {
        logger.info(&quot;---SomeService: someMethod invoked---&quot;);
        try {
            // 模拟耗时任务
            Thread.sleep(random.nextInt(500));
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
</code></pre><p>这样当 <code>SomeService</code> 类下的方法调用时, 我们所提供的 advice 就会被执行, 因此就可以自动地为我们统计此方法的调用耗时, 并自动上报到监控系统中了.<br>看到 <code>AOP</code> 的威力了吧, 我们这里仅仅使用了寥寥数语就把一个需求完美地解决了, 并且还与原来的业务逻辑完全解耦, 扩展及其方便. </p>
<h4 id="完整源码-2"><a href="#完整源码-2" class="headerlink" title="完整源码"></a>完整源码</h4><p><a href="https://github.com/yongshun/some_java_code/tree/master/SpringAOPDemo/src/main/java/com/xys/demo3" target="_blank" rel="external">方法耗时统计</a></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过上面的几个简单例子, 我们对 <code>Spring AOP</code> 的使用应该有了一个更为深入的了解了. 其实 Spring AOP 的使用的地方不止这些, 例如 Spring 的 <code>声明式事务</code> 就是在 AOP 之上构建的. 读者朋友也可以根据自己的实际业务场景, 合理使用 Spring AOP, 发挥它的强大功能! </p>
<h2 id="End"><a href="#End" class="headerlink" title="End."></a>End.</h2>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
    
    </summary>
    
      <category term="JavaWeb" scheme="https://wangyu1997.github.io/categories/JavaWeb/"/>
    
    
      <category term="AOP" scheme="https://wangyu1997.github.io/tags/AOP/"/>
    
      <category term="javaweb" scheme="https://wangyu1997.github.io/tags/javaweb/"/>
    
      <category term="Spring" scheme="https://wangyu1997.github.io/tags/Spring/"/>
    
  </entry>
  
</feed>
