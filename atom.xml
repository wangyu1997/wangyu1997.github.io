<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>人不如故</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wangyu1997.github.io/"/>
  <updated>2017-10-24T06:52:10.000Z</updated>
  <id>https://wangyu1997.github.io/</id>
  
  <author>
    <name>人不如故</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>学习Spring第四天</title>
    <link href="https://wangyu1997.github.io/2017/10/22/Spring/AspectJ/"/>
    <id>https://wangyu1997.github.io/2017/10/22/Spring/AspectJ/</id>
    <published>2017-10-22T13:43:11.000Z</published>
    <updated>2017-10-24T06:52:10.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a>  
<h2 id="Spring-PropertyPlaceholderConfigurer的使用"><a href="#Spring-PropertyPlaceholderConfigurer的使用" class="headerlink" title="Spring PropertyPlaceholderConfigurer的使用"></a>Spring PropertyPlaceholderConfigurer的使用</h2><blockquote>
<p>对于一些隐秘的或者是全局变量的操作我们希望可以统一的管理他，我们可以把这些配置写在properties或者yaml文件里，然后在xml配置文件里获取相应的值，PropertyPlaceholderConfigurer就可以帮助我们实现这个功能 </p>
</blockquote>
<p>我们还是从简单的jdbc开始，项目结构如下： </p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15086031216749.jpg" alt=""></p>
<blockquote>
<p>gradle依赖 </p>
</blockquote>
<pre><code>testCompile group: &#39;junit&#39;, name: &#39;junit&#39;, version: &#39;4.12&#39;

compile group: &#39;org.springframework&#39;, name: &#39;spring-context&#39;, version: &#39;5.0.0.RELEASE&#39;

compile group: &#39;mysql&#39;, name: &#39;mysql-connector-java&#39;, version: &#39;8.0.8-dmr&#39;

compile group: &#39;org.springframework&#39;, name: &#39;spring-jdbc&#39;, version: &#39;5.0.0.RELEASE&#39;

compile group: &#39;org.springframework&#39;, name: &#39;spring-core&#39;, version: &#39;5.0.0.RELEASE&#39;
</code></pre><p>数据表如下: </p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15086032783308.jpg" alt=""></p>
<blockquote>
<p>首先我们新建一个Entity </p>
</blockquote>
<pre><code>Customer.java

package com.demo.Model;

public class Customer {
    private int custId;
    private String name;
    private int age;

    public void setCustId(int custId) {
        this.custId = custId;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public int getCustId() {
        return custId;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    @Override
    public String toString() {
        return &quot;Cust_Id: &quot; + custId + &quot;\nName: &quot; + name + &quot;\nAge: &quot; + age;
    }
}
</code></pre><blockquote>
<p>Dao层接口实现 </p>
</blockquote>
<pre><code>CustomerDao.java

package com.demo.Dao;

import com.demo.Model.Customer;

public interface CustomerDao {
    void insert(Customer customer);

    Customer findById(int custId);
}
</code></pre><blockquote>
<p>Impl实现接口方法 </p>
</blockquote>
<pre><code>CustomerDaoImpl.java

package com.demo.Impl;

import com.demo.Dao.CustomerDao;
import com.demo.Model.Customer;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.support.JdbcDaoSupport;

import java.util.List;

public class CustomerDaoImpl extends JdbcDaoSupport implements CustomerDao {
    @Override
    public void insert(Customer customer) {

        String sql = &quot;INSERT INTO customer VALUES (? ,? ,?)&quot;;
        getJdbcTemplate().update(sql, customer.getCustId(), customer.getName(), customer.getAge());
    }

    @Override
    public Customer findById(int custId) {
        String sql = &quot;SELECT * FROM customer WHERE CUST_ID = ?&quot;;

        List&lt;Customer&gt; customers = getJdbcTemplate().query(sql, new Object[]{custId}, new BeanPropertyRowMapper&lt;&gt;(Customer.class));

        return customers.get(0);
    }
}
</code></pre><p>上面都是很基本的Jdbc操作，通过增删改查来测试代码 </p>
<blockquote>
<p>不同于之前，我们把数据库的变量写在properties里 </p>
</blockquote>
<pre><code>data-config.properties

jdbc.driverClassName=com.mysql.cj.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/Spring
jdbc.username=root
jdbc.password=19970819wy
</code></pre><blockquote>
<p>Spring-Beans中配置dataSource和beans </p>
</blockquote>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-4.0.xsd&quot;&gt;

    &lt;bean class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt;
        &lt;property name=&quot;location&quot; value=&quot;database-config.properties&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driverClassName}&quot;/&gt;
        &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;customer&quot; class=&quot;com.demo.Impl.CustomerDaoImpl&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre><p>这里我们首先通过PropertyPlaceholderConfigurer来导入properties里的变量(location属性定位properties文件)<br>然后我们就可以在dataSource里通过${}来获取对应的值 </p>
<blockquote>
<p>测试类 </p>
</blockquote>
<pre><code>App.java

package com.demo;

import com.demo.Impl.CustomerDaoImpl;
import com.demo.Model.Customer;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class App {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;Spring-Beans.xml&quot;);

        Customer customer = new Customer();
        customer.setCustId(1);
        customer.setName(&quot;RenBuRuGu&quot;);
        customer.setAge(20);

        CustomerDaoImpl impl = context.getBean(CustomerDaoImpl.class);

        impl.insert(customer);

        System.out.println(impl.findById(1));
    }
}
</code></pre><h2 id="Bean的继承"><a href="#Bean的继承" class="headerlink" title="Bean的继承"></a>Bean的继承</h2><p>继承的方式有两种 直接继承和抽象继承<br>子类可以继承父类的一系列属性 </p>
<blockquote>
<p>直接继承 </p>
</blockquote>
<p>我个人认为有两种 一种是class由父类指定，子类不指定class，那么父类和子类都会共享同一个实体类，子类可以省略父类既定的字段或者重写。第二种是父类子类都指定class，这里的class不一定要存在继承关系，只要相应的class有共享的字段即可(我感觉这样不是很好) </p>
<blockquote>
<p>创建一个entity </p>
</blockquote>
<pre><code>package com.demo.Model;

public class Customer {
    private int type;
    private String action;
    private String country;

    public int getType() {
        return type;
    }

    public void setType(int type) {
        this.type = type;
    }

    public String getAction() {
        return action;
    }

    public void setAction(String action) {
        this.action = action;
    }

    public String getCountry() {
        return country;
    }

    public void setCountry(String country) {
        this.country = country;
    }

    @Override
    public String toString() {
        return &quot;type: &quot; + type + &quot;\naction: &quot; + action + &quot;\ncountry: &quot; + country;
        }
    }
</code></pre><blockquote>
<p>xml配置文件 </p>
</blockquote>
<pre><code>&lt;bean id=&quot;baseBean&quot; class=&quot;com.demo.Model.Customer&quot;&gt;
    &lt;property name=&quot;country&quot; value=&quot;China&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;customerBean&quot; parent=&quot;baseBean&quot;&gt;
    &lt;property name=&quot;action&quot; value=&quot;buy&quot;/&gt;
    &lt;property name=&quot;type&quot; value=&quot;1&quot;/&gt;
&lt;/bean&gt;
</code></pre><blockquote>
<p>这样子类的country字段就变成China了 运行结果如下: </p>
</blockquote>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15086384239944.jpg" alt=""></p>
<blockquote>
<p>抽象继承 </p>
</blockquote>
<p>抽象继承也分为两种，一般抽象继承和纯抽象继承 </p>
<p>抽象继承的目的是为了父类只提供属性模板而不可被实例化，直接抽象继承很简单，只需要在父类后面加一个<code>abstract=&quot;true&quot;</code>即可 </p>
<pre><code>&lt;bean id=&quot;baseBean&quot; class=&quot;com.demo.Model.Customer&quot; abstract=&quot;true&quot;&gt;
    &lt;property name=&quot;country&quot; value=&quot;China&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;customerBean&quot; parent=&quot;baseBean&quot;&gt;
    &lt;property name=&quot;action&quot; value=&quot;buy&quot;/&gt;
    &lt;property name=&quot;type&quot; value=&quot;1&quot;/&gt;
&lt;/bean&gt;
</code></pre><p>纯抽象继承允许父类不设置class，只是为了共享字段使用 </p>
<pre><code>&lt;bean id=&quot;baseBean&quot; abstract=&quot;true&quot;&gt;
    &lt;property name=&quot;country&quot; value=&quot;China&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;customerBean&quot; parent=&quot;baseBean&quot; class=&quot;com.demo.Model.Customer&quot;&gt;
    &lt;property name=&quot;action&quot; value=&quot;buy&quot;/&gt;
    &lt;property name=&quot;type&quot; value=&quot;1&quot;/&gt;
&lt;/bean&gt;
</code></pre><ul>
<li>父类的属性值在子类中可以被覆盖</li>
</ul>
<p>##依赖检查(感觉4.x这个功能不被支持，更多的使用注解完成(如@Required字段)) </p>
<blockquote>
<p>当我们在xml配置文件中没有对属性值进行赋值时，一般不会报错，如果我们需要它报错，就要用到依赖检查这个功能(<code>dependency-check</code>)<br>依赖检查分为四种 none(默认) simple objects all </p>
</blockquote>
<p>默认方式为none，即他不会检查是否赋值 </p>
<p>simple方式只检查基本数据类型(int, long,double…)和集合类型(map, list..)，如果以上任何属性都没有设置，UnsatisfiedDependencyException将被抛出 </p>
<p>objects方式检查对象类型的数据 </p>
<p>all检查任何类型的数据 </p>
<blockquote>
<p>举一个objects的例子 </p>
</blockquote>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-2.5.xsd&quot;&gt;

    &lt;bean id=&quot;CustomerBean&quot; class=&quot;com.demo.Model.Customer&quot; 
            dependency-check=&quot;objects&quot;&gt;
        &lt;property name=&quot;action&quot; value=&quot;buy&quot; /&gt;
        &lt;property name=&quot;type&quot; value=&quot;1&quot; /&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;PersonBean&quot; class=&quot;com.demo.Model.Person&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;RenBuRuGu&quot; /&gt;
        &lt;property name=&quot;address&quot; value=&quot;address ABC&quot; /&gt;
        &lt;property name=&quot;age&quot; value=&quot;20&quot; /&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre><p>这里我们漏掉了person的注入，由于使用objects的依赖检查方式，将会收到UnsatisfiedDependencyException报错 </p>
<h2 id="Required注解"><a href="#Required注解" class="headerlink" title="@Required注解"></a>@Required注解</h2><blockquote>
<p>对于必须的字段我们可以采用@Required注解的方式 </p>
</blockquote>
<pre><code>public class Customer 
{
    private Person person;
    private int type;
    private String action;

    public Person getPerson() {
        return person;
    }

    @Required
    public void setPerson(Person person) {
        this.person = person;
    }
}
</code></pre><p>还要在xml配置文件中打开annotation注解，像以前一样，有两种方式 </p>
<p><code>&lt;context:annotation-config/&gt;</code>和<code>&lt;bean class=&quot;org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor&quot;/&gt;</code></p>
<h2 id="自定义required注解-个人感觉没什么用…"><a href="#自定义required注解-个人感觉没什么用…" class="headerlink" title="自定义required注解(个人感觉没什么用…)"></a>自定义required注解(个人感觉没什么用…)</h2><blockquote>
<p>首先自定义一个注解 </p>
</blockquote>
<pre><code>import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Mandatory {
}
</code></pre><blockquote>
<p>现在我们可以在业务逻辑中使用它 </p>
</blockquote>
<pre><code>public class Customer 
{
    private Person person;
    private int type;
    private String action;

    @Mandatory
    public void setPerson(Person person) {
        this.person = person;
    }

}
</code></pre><blockquote>
<p>最后需要在xml中去注册它 </p>
</blockquote>
<pre><code>&lt;bean class=&quot;org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor&quot;&gt;
    &lt;property name=&quot;requiredAnnotationType&quot; value=&quot;com.demo.Annotation.Mandatory&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;CustomerBean&quot; class=&quot;com.demo.Model.Customer&quot;&gt;
    &lt;property name=&quot;action&quot; value=&quot;buy&quot; /&gt;
    &lt;property name=&quot;type&quot; value=&quot;1&quot; /&gt;
&lt;/bean&gt;
</code></pre><h2 id="InitializingBean和DisposableBean接口"><a href="#InitializingBean和DisposableBean接口" class="headerlink" title="InitializingBean和DisposableBean接口"></a>InitializingBean和DisposableBean接口</h2><p>这两个接口在我理解中是两个钩子，分别用在bean初始化完成和即将被销毁时调用<br>InitializingBean中的afterPropertiesSet()用于执行初始化方法<br>DisposableBean中的destroy()用于执行bean被容器销毁之前的操作 </p>
<pre><code>Person.java

package com.demo.Model;

import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.InitializingBean;

public class Person implements InitializingBean,DisposableBean {
    private int age;
    private String name;
    private String address;

    @Override
    public void destroy() throws Exception {
        System.out.println(&quot;Destroy&quot;);
    }

    @Override
    public void afterPropertiesSet() throws Exception {
        System.out.println(&quot;Init&quot;);
    }
}

App.java

public class App {
    public static void main(String[] args) {
        ConfigurableApplicationContext context = new ClassPathXmlApplicationContext(&quot;Spring-Beans.xml&quot;);

        Person person = context.getBean(Person.class);

        context.close();
    }
}
</code></pre><p>运行结果如下: </p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15086423947200.jpg" alt=""></p>
<p>官方不推荐这么做，我也不推荐，因为如果钩子方法都写在业务代码中，就违反了Spring的低耦合机制，业务代码和Spring容器的耦合度大大加强。 </p>
<h2 id="init-method和destroy-method"><a href="#init-method和destroy-method" class="headerlink" title="init-method和destroy-method"></a>init-method和destroy-method</h2><blockquote>
<p>不继承接口，我们单纯的写两个方法，然后在xml配置文件中将他们指定为初始化和销毁之前执行的方法 </p>
</blockquote>
<pre><code>package com.demo.Model;

import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.InitializingBean;

public class Person{
    private int age;
    private String name;
    private String address;

    public void destroy() throws Exception {
        System.out.println(&quot;Destroy&quot;);
    }

    public void init() throws Exception {
        System.out.println(&quot;Init&quot;);
    }
}
</code></pre><blockquote>
<p>我们在xml中手动管理 </p>
</blockquote>
<pre><code>&lt;bean id=&quot;person&quot; class=&quot;com.demo.Model.Person&quot;
        init-method=&quot;init&quot;
        destroy-method=&quot;destroy&quot;
        p:name=&quot;RenBuRuGu&quot;
        p:age=&quot;20&quot;
        p:address=&quot;JiangSu NanJing&quot;/&gt;
</code></pre><ul>
<li><p>@PostConstruct 和 @PreDestroy可以帮我们达到同样的目的 当然前提是需要在xml中开启注解</p>
<p>package com.demo.Model;</p>
<p>import org.springframework.beans.factory.DisposableBean;<br>import org.springframework.beans.factory.InitializingBean;</p>
<p>import javax.annotation.PostConstruct;<br>import javax.annotation.PreDestroy;</p>
<p>public class Person{</p>
<pre><code>private int age;
private String name;
private String address;

@PreDestroy
public void destroy() throws Exception {
    System.out.println(&quot;Destroy&quot;);
}

@PostConstruct
public void init() throws Exception {
    System.out.println(&quot;Init&quot;);
}
</code></pre><p>}</p>
</li>
</ul>
<p>xml中不需要写init和destroy方法 </p>
<h2 id="Spring中的EL表达式"><a href="#Spring中的EL表达式" class="headerlink" title="Spring中的EL表达式"></a>Spring中的EL表达式</h2><p>el表达式可以简化代码量，我觉得还是很有必要了解的 </p>
<p>1、在使用PropertyPlaceholderConfigurer从properties文件引入配置信息时，使用<code>${SpEL expression}</code>来引用<br>2、引用同一xml中的其他bean的属性,使用<code>#{SpEL expression}</code></p>
<pre><code>&lt;bean id=&quot;itemBean&quot; class=&quot;com.demo.Model.Item&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;RenBuRuGu&quot;/&gt;
    &lt;property name=&quot;qty&quot; value=&quot;10&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;customer&quot; class=&quot;com.demo.Model.Customer&quot;&gt;
    &lt;property name=&quot;item&quot; value=&quot;#{itemBean}&quot;/&gt;
    &lt;property name=&quot;itemName&quot; value=&quot;#{itemBean.name}&quot;/&gt;
&lt;/bean&gt;
</code></pre><p>Spring EL也可以使用纯注解的方式完成，但是有几个前提<br>1、每一个bean使用Component注解(个人理解相当于xml中配置bean)<br>2、相应的字段增加@Value注解，Spring EL表达式写在注解中<br>3、xml配置文件中开启自动扫描Components </p>
<blockquote>
<p>item.java </p>
</blockquote>
<pre><code>package com.demo.Model;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component(&quot;itemBean&quot;)
public class Item {
    @Value(&quot;RenBuRuGu&quot;)
    private String name;

    @Value(&quot;10&quot;)
    private int qty;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getQty() {
        return qty;
    }

    public void setQty(int qty) {
        this.qty = qty;
    }

    @Override
    public String toString() {
        return name + &quot;  &quot; + qty;
    }
}
</code></pre><blockquote>
<p>Customer.java </p>
</blockquote>
<pre><code>package com.demo.Model;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component(&quot;customerBean&quot;)
public class Customer {

    @Value(&quot;#{itemBean}&quot;)
    private Item item;

    @Value(&quot;#{itemBean.name}&quot;)
    private String itemName;

    public Item getItem() {
        return item;
    }

    public void setItem(Item item) {
        this.item = item;
    }

    public String getItemName() {
        return itemName;
    }

    public void setItemName(String itemName) {
        this.itemName = itemName;
    }

    @Override
    public String toString() {
        return item + &quot;  &quot; + itemName;
    }
}
</code></pre><blockquote>
<p>Spring-Beans.xml </p>
</blockquote>
<pre><code>&lt;context:component-scan base-package=&quot;com.demo.Model&quot;/&gt;
</code></pre><ul>
<li>EL表达式可以直接引用Entity实例、属性和方法，也可以执行java内置的方法，运算符和三元表达式</li>
<li><p>EL表达式中的正则匹配 可以简单的使用<code>matches</code>关键字</p>
<p>@Component(“customerBean”)<br>public class Customer {</p>
</li>
</ul>
<pre><code>    String emailRegEx = &quot;^[_A-Za-z0-9-]+(\\.[_A-Za-z0-9-]+)&quot; +
                &quot;*@[A-Za-z0-9]+(\\.[A-Za-z0-9]+)*(\\.[A-Za-z]{2,})$&quot;;


    @Value(&quot;#{&#39;100&#39; matches &#39;\\d+&#39; }&quot;)
    private boolean validDigit;


    @Value(&quot;#{ (&#39;100&#39; matches &#39;\\d+&#39;) == true ? &quot; +
                &quot;&#39;yes this is digit&#39; : &#39;No this is not a digit&#39;  }&quot;)
    private String msg;


    @Value(&quot;#{emailBean.emailAddress matches customerBean.emailRegEx}&quot;)
    private boolean validEmail;


}
</code></pre><h3 id="ExpressionParser-不知道有什么用…"><a href="#ExpressionParser-不知道有什么用…" class="headerlink" title="ExpressionParser(不知道有什么用…)"></a>ExpressionParser(不知道有什么用…)</h3><p>看意思好像大概也许是提取字符并转化成相应的数据类型 </p>
<pre><code>ExpressionParser parser = new SpelExpressionParser();
Expression exp = parser.parseExpression(&quot;&#39;put spel expression here&#39;&quot;);
String msg = exp.getValue(String.class);
</code></pre><p>下面给个例子自己感受一下 </p>
<pre><code>import org.springframework.expression.Expression;
import org.springframework.expression.ExpressionParser;
import org.springframework.expression.spel.standard.SpelExpressionParser;
import org.springframework.expression.spel.support.StandardEvaluationContext;

public class App {
    public static void main(String[] args) {

        ExpressionParser parser = new SpelExpressionParser();

        Expression exp = parser.parseExpression(&quot;&#39;Hello World&#39;&quot;);
        String msg1 = exp.getValue(String.class);
        System.out.println(msg1);

        Expression exp2 = parser.parseExpression(&quot;&#39;Hello World&#39;.length()&quot;);  
        int msg2 = (Integer) exp2.getValue();
        System.out.println(msg2);

        Expression exp3 = parser.parseExpression(&quot;100 * 2&quot;);  
        int msg3 = (Integer) exp3.getValue();
        System.out.println(msg3);

        Item item = new Item(&quot;RenBuRuGu&quot;, 100);

        StandardEvaluationContext itemContext = new StandardEvaluationContext(item);


        Expression exp4 = parser.parseExpression(&quot;name&quot;);
        String msg4 = exp4.getValue(itemContext, String.class);
        System.out.println(msg4);

        Expression exp5 = parser.parseExpression(&quot;name == &#39;RenBuRuGu&#39;&quot;);
        boolean msg5 = exp5.getValue(itemContext, Boolean.class);
        System.out.println(msg5);

    }
}
</code></pre><h2 id="Spring自动扫描组件"><a href="#Spring自动扫描组件" class="headerlink" title="Spring自动扫描组件"></a>Spring自动扫描组件</h2><p>Spring的业务逻辑分为好多层(DAO,Service,Controller,Views)，主要目的还是为了解耦 </p>
<blockquote>
<p>一般我们都会通过xml的方式来注册组件<br>Dao层<br>首先创建一个CustomerDao </p>
</blockquote>
<pre><code>package com.demo.Dao;

public class CustomerDao {
    @Override
    public String toString() {
        return &quot;Hello, This is CustomerDao&quot;;
    }
}
</code></pre><blockquote>
<p>Service层实现业务逻辑 </p>
</blockquote>
<pre><code>package com.demo.Service;

import com.demo.Dao.CustomerDao;

public class CustomerService {
    CustomerDao customerDao;

    public void setCustomerDao(CustomerDao customerDao) {
        this.customerDao = customerDao;
    }

    @Override
    public String toString() {
        return &quot;CustomerService [ customerDao = &quot; +  customerDao + &quot; ]&quot;;
    }
}
</code></pre><blockquote>
<p>xml注册bean </p>
</blockquote>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-4.0.xsd&quot;&gt;
    &lt;bean id=&quot;customerDao&quot; class=&quot;com.demo.Dao.CustomerDao&quot;/&gt;

    &lt;bean id=&quot;customerService&quot; class=&quot;com.demo.Service.CustomerService&quot;&gt;
        &lt;property name=&quot;customerDao&quot; ref=&quot;customerDao&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre><blockquote>
<p>测试函数 </p>
</blockquote>
<pre><code>package com.demo;

import com.demo.Service.CustomerService;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class App {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;Spring-Beans.xml&quot;);

        CustomerService service = context.getBean(CustomerService.class);

        System.out.println(service);
    }
}
</code></pre><p>运行结果如下: </p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15086548386608.jpg" alt=""></p>
<p>这是一般做法 </p>
<blockquote>
<p>我们还可以通过自动扫描组件来完成相同的工作 </p>
</blockquote>
<p>像之前所说，给所有的实体类加上@Components注解，通过注解的方式注册实体类 </p>
<pre><code>CustomerDao.java

package com.demo.Dao;

import org.springframework.stereotype.Component;

@Component
public class CustomerDao {
    @Override
    public String toString() {
        return &quot;Hello, This is CustomerDao&quot;;
    }
}

CustomerService.java

package com.demo.Service;

import com.demo.Dao.CustomerDao;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class CustomerService {
    private CustomerDao customerDao;

    @Autowired
    public void setCustomerDao(CustomerDao customerDao) {
        this.customerDao = customerDao;
    }

    @Override
    public String toString() {
        return &quot;CustomerService [ customerDao = &quot; +  customerDao + &quot; ]&quot;;
    }
}
</code></pre><blockquote>
<p>然后在xml中开启自动扫描beans </p>
</blockquote>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;context:component-scan base-package=&quot;com.demo&quot;/&gt;
&lt;/beans&gt;
</code></pre><p>运行结果相同 </p>
<p>为了区分开功能不同的各个模块，Spring官方给出了四种注解 </p>
<pre><code>@Component – 指示自动扫描组件。
@Repository – 表示在持久层DAO组件。
@Service – 表示在业务层服务组件。
@Controller – 表示在表示层控制器组件。
</code></pre><p>所有的注解最后都会被编译为Components，但是这样就可以很好的区分业务层和持久层的组件 </p>
<blockquote>
<p>附上代码 </p>
</blockquote>
<pre><code>CustomerDao.java

package com.demo.Dao;

import org.springframework.stereotype.Repository;

@Repository
public class CustomerDao {
    @Override
    public String toString() {
        return &quot;Hello, This is CustomerDao&quot;;
    }
}

CustomerService.java

package com.demo.Service;

import com.demo.Dao.CustomerDao;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class CustomerService {
    private CustomerDao customerDao;

    @Autowired
    public void setCustomerDao(CustomerDao customerDao) {
        this.customerDao = customerDao;
    }

    @Override
    public String toString() {
        return &quot;CustomerService [ customerDao = &quot; +  customerDao + &quot; ]&quot;;
    }
}
</code></pre><h3 id="component-scan过滤器的使用"><a href="#component-scan过滤器的使用" class="headerlink" title="component-scan过滤器的使用"></a>component-scan过滤器的使用</h3><p>过滤器有两种(include-filter和exclude-filter)，顾名思义，一个是包含的过滤器另一个则是排除的过滤器.<br>filter可以通过很多种方式进行过滤,有以下几种类型: </p>
<pre><code>annotation  注解方式
regix       正则表达式
custom      自定义方式
assignable  未知.....
aspectj     切片方式(面向切片编程)
</code></pre><blockquote>
<p>通过正则过滤 </p>
</blockquote>
<pre><code>&lt;context:component-scan base-package=&quot;com.yiibai&quot; &gt;

    &lt;context:include-filter type=&quot;regex&quot; 
                    expression=&quot;com.demo.Dao.*DAO.*&quot; /&gt;

    &lt;context:include-filter type=&quot;regex&quot; 
                    expression=&quot;com.demo.Services.*Service.*&quot; /&gt;

&lt;/context:component-scan&gt;
</code></pre><p>通过include的方式，Spring只会扫描在com.demo.Dao和com.demo.Service包下面名为_Dao._和_Service._的文件 </p>
<blockquote>
<p>通过annotation注解的方式 </p>
</blockquote>
<pre><code>&lt;context:component-scan base-package=&quot;com.demo&quot;&gt;
    &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Service&quot;/&gt;
&lt;/context:component-scan&gt;
</code></pre><p>通过exclude-filter方式，所有@Service注解的entity将会被Spring忽略 </p>
<h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><ul>
<li>面向接口编程</li>
</ul>
<p>我们首先来创建一个简单的小例子 </p>
<blockquote>
<p>创建Service层 </p>
</blockquote>
<pre><code>CustomerService.java

package com.demo.Service;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

@Service
public class CustomerService {

    @Value(&quot;RenBuRuGu&quot;)
    private String name;

    @Value(&quot;https://wangyu1997.github.io/&quot;)
    private String url;

    public void printName() {
        System.out.println(&quot;Customer name: &quot; + this.name);
    }

    public void printUrl() {
        System.out.println(&quot;Customer url: &quot; + this.url);
    }

    public void printThrowException() {
        throw new IllegalArgumentException();
    }
}
</code></pre><blockquote>
<p>创建入口测试函数 </p>
</blockquote>
<pre><code>package com.demo;

import com.demo.Service.CustomerService;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

@Configuration
@ComponentScan({&quot;com.demo.Service&quot;})
public class App {
    public static void main(String[] args) {
        ApplicationContext context = new AnnotationConfigApplicationContext(App.class);

        CustomerService customerService = context.getBean(CustomerService.class);

        customerService.printName();
        customerService.printUrl();
        customerService.printThrowException();
    }
}
</code></pre><p>运行结果如下: </p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15086575392576.jpg" alt=""></p>
<blockquote>
<p>通过注解的方式加入AOP </p>
</blockquote>
<p>1、之前通知 </p>
<p>首先实现MethodBeforeAdvice方法 </p>
<pre><code>@Component(&quot;heiBeforeMethod&quot;)
public class HiBeforeMethod implements MethodBeforeAdvice {
    @Override
    public void before(Method method, Object[] args, @Nullable Object target) throws Throwable {
        System.out.println(&quot;Method Before:  Hey Spring AOP !&quot;);
    }
}
</code></pre><p>在配置文件中注册一个代理bean </p>
<pre><code>@Configuration
public class CustomerServiceProxy {

    @Bean(&quot;customerServiceProxy&quot;)
    public ProxyFactoryBean proxyFactoryBean() {
        ProxyFactoryBean bean = new ProxyFactoryBean();
        bean.setTargetName(&quot;customerService&quot;);
        bean.setInterceptorNames(&quot;heiBeforeMethod&quot;);

        return bean;
    }

}
</code></pre><p>测试类中调用 </p>
<pre><code>@Configuration
@ComponentScan({&quot;com.demo.Service&quot;,&quot;com.demo.Impl&quot;})
@Import({CustomerServiceProxy.class})
public class App {
    public static void main(String[] args) {
        ApplicationContext context = new AnnotationConfigApplicationContext(App.class);
        CustomerService customerService = (CustomerService) context.getBean(&quot;customerServiceProxy&quot;);

        customerService.printName();
        customerService.printUrl();
        try {
            customerService.printThrowException();
        }catch (IllegalArgumentException e){
            System.out.println(&quot;Throw exception...&quot;);
        }
    }
}
</code></pre><p>注意这里的引用不再是<code>customerService</code>而是<code>customerServiceProxy</code></p>
<p>运行结果如下: </p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15086609643673.jpg" alt=""></p>
<p>2、返回后通知 </p>
<p>通过重写AfterReturningAdvice的afterReturning方法来实现功能 </p>
<blockquote>
<p>接着上面再加一个类 </p>
</blockquote>
<pre><code>package com.demo.Impl;

import org.springframework.aop.AfterReturningAdvice;
import org.springframework.lang.Nullable;
import org.springframework.stereotype.Component;

import java.lang.reflect.Method;

@Component(&quot;afterReturn&quot;)
public class AfterReturn implements AfterReturningAdvice {
    @Override
    public void afterReturning(@Nullable Object returnValue, Method method, Object[] args, @Nullable Object target) throws Throwable {
        System.out.println(&quot;Spring after returning: Spring AOP!&quot;);
    }
}
</code></pre><blockquote>
<p>CustomerServiceProxy中InterceptorNames加入该类 </p>
</blockquote>
<p><code>bean.setInterceptorNames(&quot;afterReturn&quot;,&quot;heiBeforeMethod&quot;);</code></p>
<p>运行结果如下: </p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15086613289318.jpg" alt=""></p>
<p>3、抛出后通知，即方法抛出异常后调用 </p>
<p>同上，新建一个类实现ThrowsAdvice的afterThrowing方法即可 </p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15086615601291.jpg" alt=""></p>
<p>不过，我感觉，可能是在新版本中被删除了吧… </p>
<p>4、环绕通知 </p>
<p>我感觉这种方式十分强大，首先实现MethodInterceptor的invoke方法，这里用到了反射 </p>
<pre><code>package com.demo.Impl;

import org.aopalliance.intercept.MethodInterceptor;
import org.aopalliance.intercept.MethodInvocation;
import org.springframework.stereotype.Component;

import java.util.Arrays;

@Component(&quot;aroundMethod&quot;)
public class AroundMethod implements MethodInterceptor {
    @Override
    public Object invoke(MethodInvocation invocation) throws Throwable {
        System.out.println(&quot;Method name : &quot; + invocation.getMethod().getName());
        System.out.println(&quot;Method arguments : &quot; + Arrays.toString(invocation.getArguments()));

        System.out.println(&quot;Around: Method Before&quot;);
        try {
            Object result = invocation.proceed();

            System.out.println(&quot;Around: Method After&quot;);

            return result;
        } catch (Exception ignored) {
            System.out.println(&quot;Around: Method Exception&quot;);

            throw ignored;
        }
    }
}
</code></pre><p>运行结果如下: </p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15086622863646.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
    
    </summary>
    
      <category term="Spring" scheme="https://wangyu1997.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="https://wangyu1997.github.io/tags/Spring/"/>
    
      <category term="AspectJ" scheme="https://wangyu1997.github.io/tags/AspectJ/"/>
    
      <category term="PropertyPlaceholderConfigurer" scheme="https://wangyu1997.github.io/tags/PropertyPlaceholderConfigurer/"/>
    
      <category term="Spring AOP" scheme="https://wangyu1997.github.io/tags/Spring-AOP/"/>
    
      <category term="dependency" scheme="https://wangyu1997.github.io/tags/dependency/"/>
    
      <category term="inheritance" scheme="https://wangyu1997.github.io/tags/inheritance/"/>
    
  </entry>
  
  <entry>
    <title>学习Spring第三天</title>
    <link href="https://wangyu1997.github.io/2017/10/21/Spring/JdbcTemplate/"/>
    <id>https://wangyu1997.github.io/2017/10/21/Spring/JdbcTemplate/</id>
    <published>2017-10-21T13:43:11.000Z</published>
    <updated>2017-10-24T06:49:48.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a>  
<h2 id="JdbcTemplate"><a href="#JdbcTemplate" class="headerlink" title="JdbcTemplate"></a>JdbcTemplate</h2><hr>
<blockquote>
<p>原始的jdbc </p>
</blockquote>
<pre><code>public void insert(Customer customer) {
    String sql = &quot;INSERT INTO customer(CUST_ID,NAME,AGE) VALUES(?,?,?)&quot;;
    Connection conn = null;

    try {
        conn = dataSource.getConnection();
        PreparedStatement ps = conn.prepareStatement(sql);
        ps.setInt(1, customer.getCusId());
        ps.setString(2, customer.getName());
        ps.setInt(3, customer.getAge());
        ps.executeUpdate();
        ps.close();
    } catch (SQLException e) {
        e.printStackTrace();
    } finally {
        if (conn != null) {
            try {
                conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }
}
</code></pre><blockquote>
<p>改用JdbcTemplate方法 </p>
</blockquote>
<pre><code>private DataSource dataSource;
private JdbcTemplate jdbcTemplate;

public void setDataSource(DataSource dataSource) {
    this.dataSource = dataSource;
}

@Override
public void insert(Customer customer) {
    String sql = &quot;INSERT INTO customer(CUST_ID,NAME,AGE) VALUES(?,?,?)&quot;;

    jdbcTemplate = new JdbcTemplate(dataSource);
    jdbcTemplate.update(sql,customer.getCusId(),customer.getName(),customer.getAge());
}
</code></pre><p>瞬间感觉代码量少了很多，对比之前复杂的原生操作，jdbctemplate还是很容易理解的 </p>
<blockquote>
<p>JdbcDaoSupport </p>
</blockquote>
<pre><code>public class JdbcCustomerDao extends JdbcDaoSupport implements CustomerDao {


    @Override
    public void insert(Customer customer) {
        String sql = &quot;INSERT INTO customer(CUST_ID,NAME,AGE) VALUES(?,?,?)&quot;;

        getJdbcTemplate().update(sql, customer.getCusId(), customer.getName(), customer.getAge());
    }

    @Override
    public Customer findByCustomerId(int cusId) {
        String sql = &quot;SELECT * FROM customer WHERE CUST_ID = ?&quot;;
        List&lt;Customer&gt; customers = new ArrayList&lt;&gt;();
        getJdbcTemplate().query(sql, new Object[]{cusId}, new RowCallbackHandler() {
            Customer customer;

            @Override
            public void processRow(ResultSet rs) throws SQLException {
                customer = new Customer(rs.getInt(&quot;CUST_ID&quot;), rs.getString(&quot;NAME&quot;), rs.getInt(&quot;AGE&quot;));
                customers.add(customer);
            }
        });
        return customers.get(0);
    }
}
</code></pre><hr>
<h2 id="自定义RowMapper"><a href="#自定义RowMapper" class="headerlink" title="自定义RowMapper"></a>自定义RowMapper</h2><p>JdbcTemplate推荐使用自定义的RowMapper进行字段的映射 </p>
<blockquote>
<p>我们自定义一个Mapper </p>
</blockquote>
<pre><code>package com.demo.Mapper;

import com.demo.Model.Customer;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.lang.Nullable;

import java.sql.ResultSet;
import java.sql.SQLException;

public class CustomerRowMapper implements RowMapper&lt;Customer&gt; {
    @Nullable
    @Override
    public Customer mapRow(ResultSet rs, int rowNum) throws SQLException {
        Customer customer = new Customer();
        customer.setCusId(rs.getInt(&quot;CUST_ID&quot;));
        customer.setName(rs.getString(&quot;NAME&quot;));
        customer.setAge(rs.getInt(&quot;AGE&quot;));

        return customer;
    }
}
</code></pre><blockquote>
<p>FindByCustomerId方法可以重写了 </p>
</blockquote>
<pre><code>@Override
public Customer findByCustomerId(int cusId) {
    String sql = &quot;SELECT * FROM customer WHERE CUST_ID = ?&quot;;
    List&lt;Customer&gt; customers = new ArrayList&lt;&gt;();
    customers = getJdbcTemplate().query(sql, new Object[]{cusId}, new RowMapperResultSetExtractor&lt;&gt;(new CustomerRowMapper()));
    return customers.get(0);
}
</code></pre><p>运行结果也是不变的.<br>如果我们想限制数量可以在RowMapperResultSetExtractor加上第二的参数，表示查询的数量，为1时则为单个实体类，其他的情况下是该实体类的List集合 </p>
<blockquote>
<p>Example </p>
</blockquote>
<pre><code>JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);  
RowMapper rowMapper = new UserRowMapper();  

List allUsers = (List) jdbcTemplate.query(
        &quot;select * from user&quot;,
        new RowMapperResultSetExtractor(rowMapper, 10));

User user = (User) jdbcTemplate.queryForObject(
        &quot;select * from user where id=?&quot;, new Object[] {id},
        new RowMapperResultSetExtractor(rowMapper, 1));
</code></pre><blockquote>
<p>BeanPropertyRowMapper </p>
</blockquote>
<p>当Entity属性的名称和数据表的字段名称一致的时候可以用BeanPropertyRowMapper来进行映射 </p>
<pre><code>customers = getJdbcTemplate().query(sql, new Object[]{cusId}, new BeanPropertyRowMapper&lt;&gt;(Customer.class));
</code></pre><blockquote>
<p>batchUpdate的用法 </p>
</blockquote>
<p>当我们需要批量操作(同时插入多个值),重复调用相同的方法会显得相当麻烦,这时我们可以使用batchUpdate方法 </p>
<p>我们写一个批量插入的方法 </p>
<pre><code>public void insertBatch(List&lt;Customer&gt; customers) {
    String sql = &quot;INSERT INTO customer(CUST_ID,NAME,AGE) VALUES(?,?,?)&quot;;

    getJdbcTemplate().batchUpdate(sql, new BatchPreparedStatementSetter() {
        @Override
        public void setValues(PreparedStatement ps, int i) throws SQLException      {
            Customer customer = customers.get(i);
            ps.setInt(1, customer.getCustId());
            ps.setString(2, customer.getName());
            ps.setInt(3, customer.getAge());
        }

        @Override
        public int getBatchSize() {
            return customers.size();
        }
    });
}
</code></pre><p>这里使用了jdbcTemplate的batchUpdate方法,通过第二个参数设置字段映射.当你的字段与数据库字段一致时可以省略 </p>
<p>记录一下JdbcDaoSupport的用法 </p>
<blockquote>
<p>原生sql语句执行 </p>
</blockquote>
<pre><code>jdbcTemplate.execute(&quot;CREATE TABLE USER (user_id integer, name varchar(100))&quot;);
</code></pre><blockquote>
<p>如果是UPDATE或INSERT,可以用update()方法 </p>
</blockquote>
<pre><code>jdbcTemplate.update(&quot;INSERT INTO USER VALUES(&#39;&quot;  
        + user.getId() + &quot;&#39;, &#39;&quot;  
        + user.getName() + &quot;&#39;, &#39;&quot;  
        + user.getSex() + &quot;&#39;, &#39;&quot;  
        + user.getAge() + &quot;&#39;)&quot;);
</code></pre><blockquote>
<p>带参数的更新 </p>
</blockquote>
<pre><code>jdbcTemplate.update(&quot;UPDATE USER SET name = ? WHERE user_id = ?&quot;, new Object[] {name, id});

jdbcTemplate.update(&quot;INSERT INTO USER VALUES(?, ?, ?, ?)&quot;, new Object[] {user.getId(), user.getName(), user.getSex(), user.getAge()});
</code></pre><blockquote>
<p>使用JdbcTemplate进行查询时，使用queryForXXX()等方法 </p>
</blockquote>
<pre><code>int count = jdbcTemplate.queryForInt(&quot;SELECT COUNT(*) FROM USER&quot;);

String name = (String) jdbcTemplate.queryForObject(&quot;SELECT name FROM USER WHERE user_id = ?&quot;, new Object[] {id}, java.lang.String.class);
</code></pre><blockquote>
<p>使用iterator迭代器查询 </p>
</blockquote>
<pre><code>List rows = jdbcTemplate.queryForList(&quot;SELECT * FROM USER&quot;);  

List rows = jdbcTemplate.queryForList(&quot;SELECT * FROM USER&quot;);  
Iterator it = rows.iterator();  
while(it.hasNext()) {  
    Map userMap = (Map) it.next();  
    System.out.print(userMap.get(&quot;user_id&quot;) + &quot;\t&quot;);  
    System.out.print(userMap.get(&quot;name&quot;) + &quot;\t&quot;);  
    System.out.print(userMap.get(&quot;sex&quot;) + &quot;\t&quot;);  
    System.out.println(userMap.get(&quot;age&quot;) + &quot;\t&quot;);  
}
</code></pre><blockquote>
<p>在update或者query时还可以通过callback回调设置你的字段 </p>
</blockquote>
<pre><code>final String id = user.getId();  
final String name = user.getName();  
final String sex = user.getSex() + &quot;&quot;;  
final int age = user.getAge();  

jdbcTemplate.update(&quot;INSERT INTO USER VALUES(?, ?, ?, ?)&quot;,  
                    new PreparedStatementSetter() {  
                        public void setValues(PreparedStatement ps) throws SQLException {  
                                ps.setString(1, id);  
                                ps.setString(2, name);            
                                ps.setString(3, sex);  
                                ps.setInt(4, age);  
                                }  
                        });


final User user = new User();  
jdbcTemplate.query(&quot;SELECT * FROM USER WHERE user_id = ?&quot;,  
                    new Object[] {id},  
                    new RowCallbackHandler() {  
                        public void processRow(ResultSet rs) throws SQLException {  
                                user.setId(rs.getString(&quot;user_id&quot;));  
                                user.setName(rs.getString(&quot;name&quot;));  
                                user.setSex(rs.getString(&quot;sex&quot;).charAt(0));  
                                user.setAge(rs.getInt(&quot;age&quot;));  
                        }  
                    });
</code></pre><blockquote>
<p>RowMapper </p>
</blockquote>
<pre><code>class UserRowMapper implements RowMapper {  
    public Object mapRow(ResultSet rs, int index) throws SQLException {  
        User user = new User();  

        user.setId(rs.getString(&quot;user_id&quot;));  
        user.setName(rs.getString(&quot;name&quot;));  
        user.setSex(rs.getString(&quot;sex&quot;).charAt(0));  
        user.setAge(rs.getInt(&quot;age&quot;));  

        return user;  
    }  
}  

public List findAllByRowMapperResultReader() {  
    String sql = &quot;SELECT * FROM USER&quot;;  
    return jdbcTemplate.query(sql, new RowMapperResultReader(new UserRowMapper()));  
}



public User getUser(final String id) throws DataAccessException {  
    String sql = &quot;SELECT * FROM USER WHERE user_id=?&quot;;  
    final Object[] params = new Object[] { id };  
    List list = jdbcTemplate.query(sql, params, new RowMapperResultReader(new UserRowMapper()));  

    return (User) list.get(0);  
}
</code></pre><hr>
<h2 id="Spring自动装配Beans"><a href="#Spring自动装配Beans" class="headerlink" title="Spring自动装配Beans"></a>Spring自动装配Beans</h2><p>Spring对于Bean采用自动装配(AueoWire)机制<br>分为五种： </p>
<pre><code>1、no 省缺情况下，通过ref属性绑定     
2、byName 根据属性名自动装配 如果一个property的name和另一个bean的id相同，Spring将会自动装配  
3、byType 根据属性数据类型自动装配 如果一个property的属性和另一个bean的数据类型相同，Spring将会自动装配   
4、construtor 对于构造函数的属性使用byType方式    
5、autodetect 如果找到默认的构造函数采用“自动装配使用构造”，否则使用“按类型装配”
</code></pre><p>这里演示使用constructor的方式 </p>
<blockquote>
<p>Person Model </p>
</blockquote>
<pre><code>package com.demo.Model;

public class Person {
    private String name;
    private int age;
    private String address;

    public Person() {
    }

    public Person(String name, int age, String address) {
        this.name = name;
        this.age = age;
        this.address = address;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }
}
</code></pre><blockquote>
<p>Customer Model </p>
</blockquote>
<pre><code>package com.demo.Model;

public class Customer {
    private Person person;

    public Customer(Person person) {
        this.person = person;
    }

    public Person getPerson() {
        return person;
    }

    public void setPerson(Person person) {
        this.person = person;
    }
}
</code></pre><blockquote>
<p>在resources中加入配置文件Spring-Beans.xml </p>
</blockquote>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-4.0.xsd&quot;&gt;

    &lt;bean id=&quot;customer&quot; class=&quot;com.demo.Model.Customer&quot; autowire=&quot;constructor&quot;/&gt;

    &lt;bean id=&quot;person&quot; class=&quot;com.demo.Model.Person&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;RenBuRuGu&quot;/&gt;
        &lt;property name=&quot;age&quot; value=&quot;20&quot;/&gt;
        &lt;property name=&quot;address&quot; value=&quot;JiangSu NanJing&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre><blockquote>
<p>测试类App </p>
</blockquote>
<pre><code>package com.demo;

import com.demo.Model.Customer;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class App {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;Spring-Beans.xml&quot;);

        Customer customer = context.getBean(Customer.class);

        System.out.println(customer.getPerson().getAddress());
        System.out.println(customer.getPerson().getAge());
        System.out.println(customer.getPerson().getName());
    }
}
</code></pre><blockquote>
<p>运行结果如下: </p>
</blockquote>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15085762440587.jpg" alt=""></p>
<h3 id="AutoWired字段"><a href="#AutoWired字段" class="headerlink" title="@AutoWired字段"></a>@AutoWired字段</h3><blockquote>
<p>首先在beans中加入 </p>
<pre><code>&lt;context:annotation-config /&gt;
</code></pre></blockquote>
<p>或者 </p>
<pre><code>&lt;bean class=&quot;org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor&quot;/&gt;
</code></pre><blockquote>
<p>@AutoWired注解可以在属性、setter方法、或者构造方法中使用 </p>
</blockquote>
<p>Spring-Beans.xml </p>
<pre><code>&lt;context:annotation-config/&gt;

&lt;bean id=&quot;customer&quot; class=&quot;com.demo.Model.Customer&quot;/&gt;

&lt;bean id=&quot;person&quot; class=&quot;com.demo.Model.Person&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;RenBuRuGu&quot;/&gt;
    &lt;property name=&quot;age&quot; value=&quot;20&quot;/&gt;
    &lt;property name=&quot;address&quot; value=&quot;JiangSu NanJing&quot;/&gt;
&lt;/bean&gt;
</code></pre><blockquote>
<p>setter方法 </p>
</blockquote>
<pre><code>public class Customer {
    private Person person;

    public Person getPerson() {
            return person;
    }

    @Autowired
    public void setPerson(Person person) {
        this.person = person;
    }
}
</code></pre><blockquote>
<p>属性 </p>
</blockquote>
<pre><code>public class Customer {
    @Autowired
    private Person person;

    public Person getPerson() {
            return person;
    }
}
</code></pre><blockquote>
<p>构造方法 </p>
</blockquote>
<pre><code>public class Customer {

    private Person person;

    @Autowired
    public Customer(Person person) {
        this.person = person;
    }

    public Person getPerson() {
        return person;
    }
}
</code></pre><h3 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h3><blockquote>
<p>当自动装载的bean有冲突时，就可以用@Qualifier属性 </p>
</blockquote>
<pre><code>import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;

public class Customer {

    @Autowired
    @Qualifier(&quot;personA&quot;)
    private Person person;

}
</code></pre><h2 id="JavaConfig"><a href="#JavaConfig" class="headerlink" title="JavaConfig"></a>JavaConfig</h2><blockquote>
<p>我们之前注册bean都是通过xml注册的,形式如下: </p>
</blockquote>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-4.0.xsd&quot;&gt;

    &lt;bean id=&quot;helloBean&quot; class=&quot;com.demo.Model.HelloBean&quot;&gt;
        &lt;property name=&quot;id&quot; value=&quot;1&quot;/&gt;
        &lt;property name=&quot;content&quot; value=&quot;Hello Spring&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre><p>实体类代码如下: </p>
<pre><code>package com.demo.Model;

public class HelloBean {
    private int id;
    private String content;

    public void setId(int id) {
        this.id = id;
    }

    public void setContent(String content) {
        this.content = content;
    }

    public void print() {
        System.out.println(&quot;HelloBean:[ &quot; + id + &quot; &quot; + content + &quot; ]&quot;);
    }
}
</code></pre><p>我们写一个测试类来测试一下: </p>
<pre><code>package com.demo;

import com.demo.Model.HelloBean;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class App {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;Spring-Beans.xml&quot;);
        HelloBean helloBean = context.getBean(HelloBean.class);

        helloBean.print();
    }
}
</code></pre><p>输出结果如下: </p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15085829234470.jpg" alt=""></p>
<blockquote>
<p>我们也可以通过Spring注解的方式来用java代码完成配置 </p>
</blockquote>
<pre><code>package com.demo;

import com.demo.Model.HelloBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class AppConfig {
    @Bean(name = &quot;helloBean&quot;)
    public HelloBean helloBean(){
        HelloBean bean = new HelloBean();
        bean.setContent(&quot;Hello Spring&quot;);
        bean.setId(1);
        return bean;
    }
}
</code></pre><p>在Spring中，配置文件必须用configuration注解，相应的bean用@Bean注入 </p>
<p>相应的修改一下App测试类 </p>
<pre><code>import com.demo.Model.HelloBean;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class App {
    public static void main(String[] args) {

        ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);

        HelloBean helloBean = context.getBean(HelloBean.class);

        helloBean.print();
    }
}
</code></pre><p>输出结果完全一致 </p>
<h3 id="Import的使用"><a href="#Import的使用" class="headerlink" title="@Import的使用"></a>@Import的使用</h3><p>通常我们会把不同功能的配置文件分开到不同的xml中书写，然后统一在一个xml中导入进来，就像下面: </p>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-2.5.xsd&quot;&gt;

    &lt;import resource=&quot;config/customer.xml&quot;/&gt;
    &lt;import resource=&quot;config/scheduler.xml&quot;/&gt;

&lt;/beans&gt;
</code></pre><blockquote>
<p>我们可以使用Import注解来完成相同的功能 </p>
</blockquote>
<pre><code>import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;

@Configuration
@Import({ CustomerConfig.class, SchedulerConfig.class })
public class AppConfig {

}
</code></pre><blockquote>
<p>我们分别创建两个实体类CustomerBo和SchedulerBo </p>
</blockquote>
<pre><code>package com.demo.Model;

public class CustomerBo {
    public void printMsg(String msg) {
        System.out.println(&quot;CustomerBo: &quot; + msg);
    }
}

package com.demo.Model;

public class SchedulerBo {

    public void printMsg(String msg) {
        System.out.println(&quot;SchedulerBo: &quot; + msg);
    }
}
</code></pre><blockquote>
<p>接着创建相应的配置文件 </p>
</blockquote>
<pre><code>package com.demo.Config;

import com.demo.Model.CustomerBo;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class CustomerConfig {
    @Bean(name = &quot;customer&quot;)
    public CustomerBo customerBo(){
        return new CustomerBo();
    }
}

package com.demo.Config;

import com.demo.Model.SchedulerBo;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class SchedulerConfig {
    @Bean(name = &quot;scheduler&quot;)
    public SchedulerBo schedulerBo() {
        return new SchedulerBo();
    }
}
</code></pre><blockquote>
<p>然后在AppConfig中引用 </p>
</blockquote>
<pre><code>package com.demo;

import com.demo.Config.CustomerConfig;
import com.demo.Config.SchedulerConfig;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;

@Configuration
@Import({CustomerConfig.class, SchedulerConfig.class})
public class AppConfig {

}
</code></pre><blockquote>
<p>我们在测试类中就可以正常获取到这两个实体类了 </p>
</blockquote>
<pre><code>public class App {
    public static void main(String[] args) {
        ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);

        CustomerBo customerBo = context.getBean(CustomerBo.class);

        SchedulerBo schedulerBo = context.getBean(SchedulerBo.class);

        customerBo.printMsg(&quot;hello Spring&quot;);

        schedulerBo.printMsg(&quot;hello Spring&quot;);
    }
}
</code></pre><p>运行结果如下: </p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15085854585356.jpg" alt=""></p>
<h2 id="DI注入的小问题"><a href="#DI注入的小问题" class="headerlink" title="DI注入的小问题"></a>DI注入的小问题</h2><blockquote>
<p>我们通过在xml中书写配置文件进行DI注入,有两种方式:setter函数注入和构造函数注入 </p>
</blockquote>
<p>setter函数注入：用ref引用相应的bean<br>构造函数注入：用<code>&lt;constructor-arg&gt;</code>标签<br>如果存在多个构造函数，为了避免歧义，需要手动指定数据类型 </p>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-2.5.xsd&quot;&gt;

    &lt;bean id=&quot;CustomerBean&quot; class=&quot;com.yiibai.common.Customer&quot;&gt;

        &lt;constructor-arg type=&quot;java.lang.String&quot;&gt;
            &lt;value&gt;yiibai&lt;/value&gt;
        &lt;/constructor-arg&gt;

        &lt;constructor-arg type=&quot;java.lang.String&quot;&gt;
            &lt;value&gt;188&lt;/value&gt;
        &lt;/constructor-arg&gt;

        &lt;constructor-arg type=&quot;int&quot;&gt;
            &lt;value&gt;28&lt;/value&gt;
        &lt;/constructor-arg&gt;

    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre><h2 id="Spring中对Bean的引用"><a href="#Spring中对Bean的引用" class="headerlink" title="Spring中对Bean的引用"></a>Spring中对Bean的引用</h2><p>有两种方式bean和local </p>
<p><code>&lt;ref&gt;</code> 提供了如下几方面的属性 :<br>1)bean: 在当前 Spring XML 配置文件中，或者在同一 BeanFactory(ApplicationContext) 中的其他 JavaBean 中 .<br>2)local: 在当前 Spring XML 配置文件中 . 其依赖的 JavaBean 必须存在于当前 Spring XML配置文件中 . 如果借助于 Spring IDE, 则在编译期可以对其依赖的 JavaBean 进行验证。基于 local 方式，开发者能够使用到 XML 本身提供 的优势，而进行验证。<br>3)parent: 用于指定其依赖的父 JavaBean 定义。 </p>
<p>local属性在Spring 4.x中被废弃 </p>
<pre><code>&lt;bean id=&quot;OutputHelper&quot; class=&quot;com.yiibai.output.OutputHelper&quot;&gt;
    &lt;property name=&quot;outputGenerator&quot; &gt;
            &lt;ref local=&quot;CsvOutputGenerator&quot;/&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id=&quot;OutputHelper&quot; class=&quot;com.yiibai.output.OutputHelper&quot;&gt;
    &lt;property name=&quot;outputGenerator&quot; &gt;
        &lt;ref bean=&quot;CsvOutputGenerator&quot;/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre><blockquote>
<p>在xml中注入属性有三种方式 正常模式、快捷方式和P模式 </p>
</blockquote>
<p>正常模式(4.x不推荐使用) </p>
<pre><code>&lt;bean id=&quot;helloBean&quot; class=&quot;com.demo.Model.CustomerBo&quot;&gt;
    &lt;property name=&quot;content&quot;&gt;
        &lt;value&gt;Hello World&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre><p>快捷方式(value属性) </p>
<pre><code>&lt;bean id=&quot;helloBean&quot; class=&quot;com.demo.Model.CustomerBo&quot;&gt;
    &lt;property name=&quot;content&quot; value=&quot;Hello World&quot;/&gt;
&lt;/bean&gt;
</code></pre><p>P模式(value和value-ref两种模式 分别表示直接赋值和引用) </p>
<pre><code>&lt;bean id=&quot;helloBean&quot; class=&quot;com.demo.Model.CustomerBo&quot; p:content=&quot;hello world&quot;/&gt;
</code></pre><h2 id="Spring-Bean的作用域"><a href="#Spring-Bean的作用域" class="headerlink" title="Spring Bean的作用域"></a>Spring Bean的作用域</h2><p>Spring中Bean的作用域有两种 singleton(默认)单例模式和prototype 原型模式<br>生命作用域的方式很简单，至于要在xml的bean中使用<code>scope</code>属性即可 </p>
<p>我们还可以通过@Scope注解的方式来实现相同的效果 </p>
<pre><code>@Service
@Scope(&quot;prototype&quot;)
public class CustomerService 
{
    String message;

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }
}
</code></pre><p>需要在xml中开启自动扫描组件功能 </p>
<pre><code>&lt;context:component-scan base-package=&quot;com.yiibai.customer&quot; /&gt;
</code></pre><h2 id="Spring中注册List-Map-Set-Properties等集合"><a href="#Spring中注册List-Map-Set-Properties等集合" class="headerlink" title="Spring中注册List Map Set Properties等集合"></a>Spring中注册List Map Set Properties等集合</h2><blockquote>
<p>Spring中支持对这些集合类的注册和使用，下面是例子 </p>
</blockquote>
<p>创建两个实体类Person和Customer </p>
<pre><code>Person.java

package com.demo.Model;

public class Person {
    private String name;
    private String address;
    private int age;

    public void setName(String name) {
        this.name = name;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return &quot;[ name: &quot; + name + &quot;address: &quot; + address + &quot;age: &quot; + age + &quot; ]&quot;;
    }
}

Customer.java

package com.demo.Model;

import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;

public class Customer {
    private List&lt;Object&gt; lists;
    private Set&lt;Object&gt; sets;
    private Map&lt;Object, Object&gt; maps;
    private Properties props;

    public void setLists(List&lt;Object&gt; lists) {
        this.lists = lists;
    }

    public void setSets(Set&lt;Object&gt; sets) {
        this.sets = sets;
    }

    public void setMaps(Map&lt;Object, Object&gt; maps) {
        this.maps = maps;
    }

    public void setProps(Properties props) {
        this.props = props;
    }

    @Override
    public String toString() {
        StringBuffer buffer = new StringBuffer();
        buffer.append(&quot;list:\n&quot;);
        for (Object o : lists) {
            buffer.append(o.toString() + &quot;\n&quot;);
        }
        buffer.append(&quot;set:\n&quot;);
        for (Object o : sets) {
            buffer.append(o.toString() + &quot;\n&quot;);
        }
        buffer.append(&quot;map:\n&quot;);
        for (Object o : maps.keySet()) {
            buffer.append(&quot;key: &quot; + o.toString() + &quot;  value: &quot; + maps.get(o).toString() + &quot;\n&quot;);
        }
        buffer.append(&quot;properties:\n&quot;);
        for (Object o : props.keySet()) {
            buffer.append(&quot;key: &quot; + o.toString() + &quot;  value: &quot; + props.get(o).toString() + &quot;\n&quot;);
        }
        return buffer.toString();
    }
}
</code></pre><p>我们可以在xml中去注册这些属性值 </p>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-4.0.xsd&quot;&gt;

    &lt;bean id=&quot;customer&quot; class=&quot;com.demo.Model.Customer&quot;&gt;
        &lt;property name=&quot;lists&quot;&gt;
            &lt;list&gt;
                &lt;value&gt;1&lt;/value&gt;
                &lt;ref bean=&quot;person&quot;/&gt;
                &lt;bean class=&quot;com.demo.Model.Person&quot;
                        p:name=&quot;RenBuRuGu123&quot;
                        p:address=&quot;JiangSu NanJing&quot;
                        p:age=&quot;22&quot;/&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;property name=&quot;maps&quot;&gt;
            &lt;map&gt;
                &lt;entry key=&quot;1&quot; value=&quot;1&quot;/&gt;
                &lt;entry key=&quot;2&quot; value-ref=&quot;person&quot;/&gt;
                &lt;entry key=&quot;hello&quot;&gt;
                    &lt;bean class=&quot;com.demo.Model.Person&quot;
                            p:name=&quot;RenBuRuGu&quot;
                            p:address=&quot;JiangSu NanJing&quot;
                            p:age=&quot;20&quot;/&gt;
                &lt;/entry&gt;
            &lt;/map&gt;
        &lt;/property&gt;
        &lt;property name=&quot;props&quot;&gt;
            &lt;props&gt;
                &lt;prop key=&quot;admin&quot;&gt;Admin@123&lt;/prop&gt;
                &lt;prop key=&quot;support&quot;&gt;support@gmail.com&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
        &lt;property name=&quot;sets&quot;&gt;
            &lt;set&gt;
                &lt;set&gt;
                    &lt;value&gt;1&lt;/value&gt;
                    &lt;ref bean=&quot;person&quot;/&gt;
                    &lt;bean class=&quot;com.demo.Model.Person&quot;&gt;
                        &lt;property name=&quot;name&quot; value=&quot;Test Set&quot;/&gt;
                        &lt;property name=&quot;address&quot; value=&quot;Hainan Haikou&quot;/&gt;
                        &lt;property name=&quot;age&quot; value=&quot;28&quot;/&gt;
                    &lt;/bean&gt;
                &lt;/set&gt;
            &lt;/set&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;person&quot; class=&quot;com.demo.Model.Person&quot;
            p:name=&quot;RenBuRuGu&quot;
            p:address=&quot;JiangSu NanJing&quot;
            p:age=&quot;20&quot;/&gt;
&lt;/beans&gt;
</code></pre><p>测试类: </p>
<pre><code>public class App {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;Spring-Beans.xml&quot;);
        Customer customer = context.getBean(Customer.class);

        System.out.println(customer);
    }
}
</code></pre><p>运行结果如下: </p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15085930603056.jpg" alt=""></p>
<blockquote>
<p>自定义List类型 </p>
</blockquote>
<p>如果想要返回的List是ArrayList数据类型的 你有两种方式去实现它 ListFactoryBean 和 util:list<br>分别举个例子 </p>
<blockquote>
<p>ListFactoryBean方式 </p>
</blockquote>
<pre><code>&lt;property name=&quot;lists&quot;&gt;
    &lt;bean class=&quot;org.springframework.beans.factory.config.ListFactoryBean&quot;&gt;
        &lt;property name=&quot;targetListClass&quot; value=&quot;java.util.ArrayList&quot;/&gt;
        &lt;property name=&quot;sourceList&quot;&gt;
            &lt;list&gt;
                &lt;value&gt;1&lt;/value&gt;
                &lt;ref bean=&quot;person&quot;/&gt;
                &lt;bean class=&quot;com.demo.Model.Person&quot;
                        p:name=&quot;RenBuRuGu123&quot;
                        p:address=&quot;JiangSu NanJing&quot;
                        p:age=&quot;22&quot;/&gt;
            &lt;/list&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/property&gt;
</code></pre><p>通过targetListClass指定List的数据类型，sourceList包裹原list数据 </p>
<blockquote>
<p>util:list方式 </p>
</blockquote>
<pre><code>&lt;util:list list-class=&quot;java.util.ArrayList&quot;&gt;
    &lt;value&gt;1&lt;/value&gt;
    &lt;ref bean=&quot;person&quot;/&gt;
    &lt;bean class=&quot;com.demo.Model.Person&quot;
            p:name=&quot;RenBuRuGu123&quot;
            p:address=&quot;JiangSu NanJing&quot;
            p:age=&quot;22&quot;/&gt;
&lt;/util:list&gt;
</code></pre><p>效果完全一样，个人觉得这种方式比较简便 </p>
<ul>
<li>MapFactoryBean和SetFactoryBean用法完全相同,不做过多介绍…</li>
</ul>
<h2 id="Spring注入日期类型的数据"><a href="#Spring注入日期类型的数据" class="headerlink" title="Spring注入日期类型的数据"></a>Spring注入日期类型的数据</h2><p>1、通过factoryBean的方式 </p>
<pre><code>&lt;bean id=&quot;dateFormat&quot; class=&quot;java.text.SimpleDateFormat&quot;&gt;
    &lt;constructor-arg value=&quot;yyyy-MM-dd&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;customer&quot; class=&quot;com.demo.Model.Customer&quot;&gt;
    &lt;property name=&quot;date&quot;&gt;
        &lt;bean factory-bean=&quot;dateFormat&quot; factory-method=&quot;parse&quot;&gt;
            &lt;constructor-arg value=&quot;2015-12-31&quot;/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre><p>我们创建一个SimpleDateFormat的Bean然后通过Factory-bean和Factory-method方法调用SimpleDataFormat的prase方法来初始化我们的日期 </p>
<p>2、通过CustomDateEditor的方式(反正我不会用，一直报错) </p>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-2.5.xsd&quot;&gt;

    &lt;bean id=&quot;dateEditor&quot;
        class=&quot;org.springframework.beans.propertyeditors.CustomDateEditor&quot;&gt;

        &lt;constructor-arg&gt;
            &lt;bean class=&quot;java.text.SimpleDateFormat&quot;&gt;
                &lt;constructor-arg value=&quot;yyyy-MM-dd&quot; /&gt;
            &lt;/bean&gt;
        &lt;/constructor-arg&gt;
        &lt;constructor-arg value=&quot;true&quot; /&gt;

    &lt;/bean&gt;

    &lt;bean class=&quot;org.springframework.beans.factory.config.CustomEditorConfigurer&quot;&gt;
        &lt;property name=&quot;customEditors&quot;&gt;
            &lt;map&gt;
                &lt;entry key=&quot;java.util.Date&quot;&gt;
                    &lt;ref local=&quot;dateEditor&quot; /&gt;
                &lt;/entry&gt;
            &lt;/map&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;customer&quot; class=&quot;com.yiibai.common.Customer&quot;&gt;
        &lt;property name=&quot;date&quot; value=&quot;2015-12-31&quot; /&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre><ul>
<li><code>&lt;ref local=&quot;&quot;&gt;</code>用法好像在4.x中被删除了</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
    
    </summary>
    
      <category term="Spring" scheme="https://wangyu1997.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="https://wangyu1997.github.io/tags/Spring/"/>
    
      <category term="AutoWire" scheme="https://wangyu1997.github.io/tags/AutoWire/"/>
    
      <category term="Beans" scheme="https://wangyu1997.github.io/tags/Beans/"/>
    
      <category term="JdbcTemplate" scheme="https://wangyu1997.github.io/tags/JdbcTemplate/"/>
    
      <category term="SimpleJdbcTemplate" scheme="https://wangyu1997.github.io/tags/SimpleJdbcTemplate/"/>
    
  </entry>
  
  <entry>
    <title>学习Spring第二天</title>
    <link href="https://wangyu1997.github.io/2017/10/20/Spring/Spring%E4%BD%BF%E7%94%A8jdbc/"/>
    <id>https://wangyu1997.github.io/2017/10/20/Spring/Spring使用jdbc/</id>
    <published>2017-10-20T13:43:11.000Z</published>
    <updated>2017-10-24T06:48:11.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a>  
<h2 id="在Spring中使用jdbc"><a href="#在Spring中使用jdbc" class="headerlink" title="在Spring中使用jdbc"></a>在Spring中使用jdbc</h2><hr>
<blockquote>
<p>添加gradle依赖 </p>
</blockquote>
<pre><code>dependencies {

testCompile group: &#39;junit&#39;, name: &#39;junit&#39;, version: &#39;4.12&#39;

compile group: &#39;org.springframework&#39;, name: &#39;spring-context&#39;, version: &#39;5.0.0.RELEASE&#39;

compile group: &#39;org.springframework&#39;, name: &#39;spring-jdbc&#39;, version: &#39;5.0.0.RELEASE&#39;

compile group: &#39;mysql&#39;, name: &#39;mysql-connector-java&#39;, version: &#39;8.0.8-dmr&#39;

}
</code></pre><blockquote>
<p>首先创建数据表 </p>
</blockquote>
<pre><code>CREATE TABLE `customer` (
    `CUST_ID` int(10) unsigned NOT NULL AUTO_INCREMENT,
    `NAME` varchar(100) NOT NULL,
    `AGE` int(10) unsigned NOT NULL,
        PRIMARY KEY (`CUST_ID`)
) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;
</code></pre><p>下面实现业务代码 </p>
<blockquote>
<p>创建一个Customer实体类 </p>
</blockquote>
<pre><code>package com.demo.Model;

public class Customer {
    private int cusId;
    private String name;
    private int age;

    public Customer(int cusId, String name, int age) {
        this.cusId = cusId;
        this.name = name;
        this.age = age;
    }

    public int getCusId() {
        return cusId;
    }

    public void setCusId(int cusId) {
        this.cusId = cusId;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return &quot;id: &quot; + cusId + &quot;\nname: &quot; + name + &quot;\nage: &quot; + age;
    }
}
</code></pre><blockquote>
<p>下面创建一个DAO </p>
</blockquote>
<pre><code>public interface CustomerDao {
    void insert(Customer customer);

    Customer findByCustomerId(int cusId);
}
</code></pre><blockquote>
<p>创建一个DAO的实现层 </p>
</blockquote>
<pre><code>public class JdbcCustomerDao implements CustomerDao {
    private DataSource dataSource;

    public void setDataSource(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    @Override
    public void insert(Customer customer) {
        String sql = &quot;INSERT INTO customer(CUST_ID,NAME,AGE) VALUES(?,?,?)&quot;;
        Connection conn = null;

        try {
            conn = dataSource.getConnection();
            PreparedStatement ps = conn.prepareStatement(sql);
            ps.setInt(1, customer.getCusId());
            ps.setString(2, customer.getName());
            ps.setInt(3, customer.getAge());
            ps.executeUpdate();
            ps.close();
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            if (conn != null) {
                try {
                    conn.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
</code></pre><p>这里采用最原始的jdbc对数据库进行操作，通过dataSource的方式获取connection.dataSource通过Spring-DataSource.xml获取 </p>
<blockquote>
<p>下面创建Spring-Dataource.xml </p>
</blockquote>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-4.0.xsd&quot;&gt;

    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/Spring&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;19970819wy&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre><p>这里使用Spring-JDBC，配置好jdbc的一系列信息 </p>
<blockquote>
<p>Spring-Customer.xml </p>
</blockquote>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-4.0.xsd&quot;&gt;

    &lt;bean id=&quot;customerDAO&quot; class=&quot;com.demo.DaoImpl.JdbcCustomerDao&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre><blockquote>
<p>Spring-Moudle.xml </p>
</blockquote>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-4.0.xsd&quot;&gt;

    &lt;import resource=&quot;Spring-DataSource.xml&quot;/&gt;
    &lt;import resource=&quot;Spring-Customer.xml&quot;/&gt;
&lt;/beans&gt;
</code></pre><p>到此为止xml配置文件已经写完了，最后写个测试类测试一下 </p>
<blockquote>
<p>App.java </p>
</blockquote>
<pre><code>package com.demo;

import com.demo.Dao.CustomerDao;
import com.demo.Model.Customer;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class App
{
    public static void main( String[] args )
    {
        ApplicationContext context =
                new ClassPathXmlApplicationContext(&quot;Spring-Moudle.xml&quot;);

        CustomerDao customerDAO = (CustomerDao) context.getBean(&quot;customerDAO&quot;);
        Customer customer = new Customer(1, &quot;RenBuRuGu&quot;,20);
        customerDAO.insert(customer);

        Customer customer1 = customerDAO.findByCustomerId(1);
        System.out.println(customer1);

    }
}
</code></pre><p>运行结果如下: </p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15085578276768.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
    
    </summary>
    
      <category term="Spring" scheme="https://wangyu1997.github.io/categories/Spring/"/>
    
    
      <category term="spring" scheme="https://wangyu1997.github.io/tags/spring/"/>
    
      <category term="jdbc" scheme="https://wangyu1997.github.io/tags/jdbc/"/>
    
      <category term="mysql" scheme="https://wangyu1997.github.io/tags/mysql/"/>
    
      <category term="spring-jdbc" scheme="https://wangyu1997.github.io/tags/spring-jdbc/"/>
    
  </entry>
  
  <entry>
    <title>学习Spring第一天</title>
    <link href="https://wangyu1997.github.io/2017/10/19/Spring/xml%E8%8E%B7%E5%8F%96Bean/"/>
    <id>https://wangyu1997.github.io/2017/10/19/Spring/xml获取Bean/</id>
    <published>2017-10-19T13:43:11.000Z</published>
    <updated>2017-10-24T06:47:02.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a>  
<h2 id="在xml中装载Bean实体"><a href="#在xml中装载Bean实体" class="headerlink" title="在xml中装载Bean实体"></a>在xml中装载Bean实体</h2><hr>
<blockquote>
<p>首先新建一个实体类 HelloWorld.java </p>
</blockquote>
<pre><code>public class HelloWorld{
    private String name;

    public void setName(String name){
        this.name = name;
    }

    public void printHello(){
        System.out.println(&quot;Spring 4: Hello!&quot; + name);
    }  
}
</code></pre><p>一个实体类就创建完成了，接下来我们在xml中注册这个实体类. </p>
<blockquote>
<p>在resources文件夹下创建applicationContext.xml </p>
</blockquote>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15084257704294.jpg" alt=""></p>
<p>代码结构如上，我们在xml中配置beans. </p>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-4.0.xsd&quot;&gt;

    &lt;bean id=&quot;helloBean&quot; class=&quot;com.demo.Entity.HelloWorld&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;RenBuRuGu&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre><p>其中id为bean的唯一编号，每一个实体类都需要注册成一个bean。class为对应的entity，property为属性值，对应着HelloWorld里的name，spring会根据setName函数自动为name赋值.<br>完成了这一步之后，下面我们来编写一个测试函数调用一下. </p>
<blockquote>
<p>在com.demo根目录下创建App.java. </p>
</blockquote>
<pre><code>public class App {
    public static void main(String[] args){

        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;application.xml&quot;);

        HelloWorld helloWorld = context.getBean(&quot;helloBean&quot;);

        helloWorld.printHello();
    }

}
</code></pre><p>我们通过ClassPathXmlApplicationContext获取xml的bean实体，然后通过Spring的IOC从容器中获取HelloWorld. </p>
<blockquote>
<p>运行结果如下. </p>
</blockquote>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15084265313737.jpg" alt=""></p>
<hr>
<h2 id="Spring的松耦合机制"><a href="#Spring的松耦合机制" class="headerlink" title="Spring的松耦合机制"></a>Spring的松耦合机制</h2><blockquote>
<p>下面为大家介绍一下Spring的松耦合机制. </p>
</blockquote>
<p>项目结构如下:<br><img src="http://oq5d32gij.bkt.clouddn.com/15084583360437.jpg" alt=""><br>如果我们想实现一个可以用Csv和Json格式输出的功能，稍微有点经验的java程序员可能会把输出功能抽象成一个接口然后分别实现. </p>
<blockquote>
<p>先创建一个输出功能的interface </p>
</blockquote>
<pre><code>public interface IOutputGenerator{
    void generateOutput();
}
</code></pre><blockquote>
<p>然后我们创建两个类分别去实现这个接口.<br>CsvOutputGenerator </p>
</blockquote>
<pre><code>public class CsvOutputGenerator implements IOutputGenerator {

    @Override
    public void generateOutput(){
        System.out.println(&quot;Csv Output Generator&quot;);
    }
}
</code></pre><blockquote>
<p>JsonOutputGenerator </p>
</blockquote>
<pre><code>public class JsonOutputGenerator implements IOutputGenerator {

    @Override
    public void generateOutput(){
        System.out.println(&quot;Json Output Generator&quot;);
    }
}
</code></pre><p>如果我们想要在业务逻辑代码中使用输出功能，有如下三个方法: </p>
<pre><code>IoutputGenerator output = new CsvOutputGenerator();

output.generateOutput();
</code></pre><p>这种方式肯定是不好的，如果需求变了或者需要使用新的Generator，必须在所有引用到的地方都手动修改，这种方式的工作量是巨大的. </p>
<pre><code>public class OutputHelper{
    private IOutputGenerator output;

    public OutputHelper(){
        this.output = new CsvOutputGenerator();
    }

    public generateOutput(){
        output.generateOutput();
    }

}
</code></pre><p>当我们需要使用的时候直接调用OutputHelper就可以了. </p>
<pre><code>OutputHelper helper = new OutputHelper();

helper.generateOutput();
</code></pre><p>这种方法比第一种好，当需求改变时(比如从csv变成json)，我们只需要在OutputHelper里手动修改就好了. </p>
<p>第三种方法是用Spring的松耦合机制.<br>我们先在xml中配置bean. </p>
<blockquote>
<p>Spring-common.xml </p>
</blockquote>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-4.0.xsd&quot;&gt;
    &lt;bean id=&quot;outputHelper&quot; class=&quot;com.demo.Helper.OutputHelper&quot;&gt;
        &lt;property name=&quot;outputGenerator&quot; ref=&quot;csvOutputGenerator&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;csvOutputGenerator&quot; class=&quot;com.demo.Generator.CsvOutputGenerator&quot;/&gt;
    &lt;bean id=&quot;jsonOutputGenerator&quot; class=&quot;com.demo.Generator.JsonOutputGenerator&quot;/&gt;
&lt;/beans&gt;
</code></pre><blockquote>
<p>OutputHelper </p>
</blockquote>
<pre><code>public class OutputHelper {

    private IOutputGenerator outputGenerator;

    public void setOutputGenerator(IOutputGenerator outputGenerator) {
        this.outputGenerator = outputGenerator;
    }

    public void generatorOutput() {
        outputGenerator.generateOutput();
    }
}
</code></pre><p>我们现在可以这么使用它: </p>
<pre><code>public class App {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;Spring-common.xml&quot;);
        OutputHelper outputHelper = (OutputHelper) context.getBean(&quot;outputHelper&quot;);

        outputHelper.generatorOutput();
    }
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
    
    </summary>
    
      <category term="Spring" scheme="https://wangyu1997.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="https://wangyu1997.github.io/tags/Spring/"/>
    
      <category term="ClassPathXmlApplicationCOntext" scheme="https://wangyu1997.github.io/tags/ClassPathXmlApplicationCOntext/"/>
    
      <category term="Hello World" scheme="https://wangyu1997.github.io/tags/Hello-World/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis最详细配置</title>
    <link href="https://wangyu1997.github.io/2017/10/10/JavaWeb/MyBatis%E6%9C%80%E8%AF%A6%E7%BB%86%E9%85%8D%E7%BD%AE/"/>
    <id>https://wangyu1997.github.io/2017/10/10/JavaWeb/MyBatis最详细配置/</id>
    <published>2017-10-10T02:43:11.000Z</published>
    <updated>2017-10-24T06:34:07.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a> 
<p>同学们有福了，花了一些时间，重新整理了一个最完整的Mybatis Generator（简称MBG）的最完整配置文件，带详解，再也不用去看EN的User Guide了；  </p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE generatorConfiguration
  PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;
&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;
&lt;!-- 配置生成器 --&gt;
&lt;generatorConfiguration&gt;
&lt;!-- 可以用于加载配置项或者配置文件，在整个配置文件中就可以使用${propertyKey}的方式来引用配置项
    resource：配置资源加载地址，使用resource，MBG从classpath开始找，比如com/myproject/generatorConfig.properties        
    url：配置资源加载地质，使用URL的方式，比如file:///C:/myfolder/generatorConfig.properties.
    注意，两个属性只能选址一个;

    另外，如果使用了mybatis-generator-maven-plugin，那么在pom.xml中定义的properties都可以直接在generatorConfig.xml中使用
&lt;properties resource=&quot;&quot; url=&quot;&quot; /&gt;
 --&gt;

 &lt;!-- 在MBG工作的时候，需要额外加载的依赖包
     location属性指明加载jar/zip包的全路径
&lt;classPathEntry location=&quot;/Program Files/IBM/SQLLIB/java/db2java.zip&quot; /&gt;
  --&gt;

&lt;!-- 
    context:生成一组对象的环境 
    id:必选，上下文id，用于在生成错误时提示
    defaultModelType:指定生成对象的样式
        1，conditional：类似hierarchical；
        2，flat：所有内容（主键，blob）等全部生成在一个对象中；
        3，hierarchical：主键生成一个XXKey对象(key class)，Blob等单独生成一个对象，其他简单属性在一个对象中(record class)
    targetRuntime:
        1，MyBatis3：默认的值，生成基于MyBatis3.x以上版本的内容，包括XXXBySample；
        2，MyBatis3Simple：类似MyBatis3，只是不生成XXXBySample；
    introspectedColumnImpl：类全限定名，用于扩展MBG
--&gt;
&lt;context id=&quot;mysql&quot; defaultModelType=&quot;hierarchical&quot; targetRuntime=&quot;MyBatis3Simple&quot; &gt;

    &lt;!-- 自动识别数据库关键字，默认false，如果设置为true，根据SqlReservedWords中定义的关键字列表；
        一般保留默认值，遇到数据库关键字（Java关键字），使用columnOverride覆盖
     --&gt;
    &lt;property name=&quot;autoDelimitKeywords&quot; value=&quot;false&quot;/&gt;
    &lt;!-- 生成的Java文件的编码 --&gt;
    &lt;property name=&quot;javaFileEncoding&quot; value=&quot;UTF-8&quot;/&gt;
    &lt;!-- 格式化java代码 --&gt;
    &lt;property name=&quot;javaFormatter&quot; value=&quot;org.mybatis.generator.api.dom.DefaultJavaFormatter&quot;/&gt;
    &lt;!-- 格式化XML代码 --&gt;
    &lt;property name=&quot;xmlFormatter&quot; value=&quot;org.mybatis.generator.api.dom.DefaultXmlFormatter&quot;/&gt;

    &lt;!-- beginningDelimiter和endingDelimiter：指明数据库的用于标记数据库对象名的符号，比如ORACLE就是双引号，MYSQL默认是`反引号； --&gt;
    &lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot;/&gt;
    &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt;

    &lt;!-- 必须要有的，使用这个配置链接数据库
        @TODO:是否可以扩展
     --&gt;
    &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql:///pss&quot; userId=&quot;root&quot; password=&quot;admin&quot;&gt;
        &lt;!-- 这里面可以设置property属性，每一个property属性都设置到配置的Driver上 --&gt;
    &lt;/jdbcConnection&gt;

    &lt;!-- java类型处理器 
        用于处理DB中的类型到Java中的类型，默认使用JavaTypeResolverDefaultImpl；
        注意一点，默认会先尝试使用Integer，Long，Short等来对应DECIMAL和 NUMERIC数据类型； 
    --&gt;
    &lt;javaTypeResolver type=&quot;org.mybatis.generator.internal.types.JavaTypeResolverDefaultImpl&quot;&gt;
        &lt;!-- 
            true：使用BigDecimal对应DECIMAL和 NUMERIC数据类型
            false：默认,
                scale&gt;0;length&gt;18：使用BigDecimal;
                scale=0;length[10,18]：使用Long；
                scale=0;length[5,9]：使用Integer；
                scale=0;length&lt;5：使用Short；
         --&gt;
        &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&gt;
    &lt;/javaTypeResolver&gt;


    &lt;!-- java模型创建器，是必须要的元素
        负责：1，key类（见context的defaultModelType）；2，java类；3，查询类
        targetPackage：生成的类要放的包，真实的包受enableSubPackages属性控制；
        targetProject：目标项目，指定一个存在的目录下，生成的内容会放到指定目录中，如果目录不存在，MBG不会自动建目录
     --&gt;
    &lt;javaModelGenerator targetPackage=&quot;com._520it.mybatis.domain&quot; targetProject=&quot;src/main/java&quot;&gt;
        &lt;!--  for MyBatis3/MyBatis3Simple
            自动为每一个生成的类创建一个构造方法，构造方法包含了所有的field；而不是使用setter；
         --&gt;
        &lt;property name=&quot;constructorBased&quot; value=&quot;false&quot;/&gt;

        &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt;
        &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;

        &lt;!-- for MyBatis3 / MyBatis3Simple
            是否创建一个不可变的类，如果为true，
            那么MBG会创建一个没有setter方法的类，取而代之的是类似constructorBased的类
         --&gt;
        &lt;property name=&quot;immutable&quot; value=&quot;false&quot;/&gt;

        &lt;!-- 设置一个根对象，
            如果设置了这个根对象，那么生成的keyClass或者recordClass会继承这个类；在Table的rootClass属性中可以覆盖该选项
            注意：如果在key class或者record class中有root class相同的属性，MBG就不会重新生成这些属性了，包括：
                1，属性名相同，类型相同，有相同的getter/setter方法；
         --&gt;
        &lt;property name=&quot;rootClass&quot; value=&quot;com._520it.mybatis.domain.BaseDomain&quot;/&gt;

        &lt;!-- 设置是否在getter方法中，对String类型字段调用trim()方法 --&gt;
        &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt;
    &lt;/javaModelGenerator&gt;


    &lt;!-- 生成SQL map的XML文件生成器，
        注意，在Mybatis3之后，我们可以使用mapper.xml文件+Mapper接口（或者不用mapper接口），
            或者只使用Mapper接口+Annotation，所以，如果 javaClientGenerator配置中配置了需要生成XML的话，这个元素就必须配置
        targetPackage/targetProject:同javaModelGenerator
     --&gt;
    &lt;sqlMapGenerator targetPackage=&quot;com._520it.mybatis.mapper&quot; targetProject=&quot;src/main/resources&quot;&gt;
        &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt;
        &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;
    &lt;/sqlMapGenerator&gt;


    &lt;!-- 对于mybatis来说，即生成Mapper接口，注意，如果没有配置该元素，那么默认不会生成Mapper接口 
        targetPackage/targetProject:同javaModelGenerator
        type：选择怎么生成mapper接口（在MyBatis3/MyBatis3Simple下）：
            1，ANNOTATEDMAPPER：会生成使用Mapper接口+Annotation的方式创建（SQL生成在annotation中），不会生成对应的XML；
            2，MIXEDMAPPER：使用混合配置，会生成Mapper接口，并适当添加合适的Annotation，但是XML会生成在XML中；
            3，XMLMAPPER：会生成Mapper接口，接口完全依赖XML；
        注意，如果context是MyBatis3Simple：只支持ANNOTATEDMAPPER和XMLMAPPER
    --&gt;
    &lt;javaClientGenerator targetPackage=&quot;com._520it.mybatis.mapper&quot; type=&quot;ANNOTATEDMAPPER&quot; targetProject=&quot;src/main/java&quot;&gt;
        &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt;
        &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;

        &lt;!-- 可以为所有生成的接口添加一个父接口，但是MBG只负责生成，不负责检查
        &lt;property name=&quot;rootInterface&quot; value=&quot;&quot;/&gt;
         --&gt;
    &lt;/javaClientGenerator&gt;

    &lt;!-- 选择一个table来生成相关文件，可以有一个或多个table，必须要有table元素
        选择的table会生成一下文件：
        1，SQL map文件
        2，生成一个主键类；
        3，除了BLOB和主键的其他字段的类；
        4，包含BLOB的类；
        5，一个用户生成动态查询的条件类（selectByExample, deleteByExample），可选；
        6，Mapper接口（可选）

        tableName（必要）：要生成对象的表名；
        注意：大小写敏感问题。正常情况下，MBG会自动的去识别数据库标识符的大小写敏感度，在一般情况下，MBG会
            根据设置的schema，catalog或tablename去查询数据表，按照下面的流程：
            1，如果schema，catalog或tablename中有空格，那么设置的是什么格式，就精确的使用指定的大小写格式去查询；
            2，否则，如果数据库的标识符使用大写的，那么MBG自动把表名变成大写再查找；
            3，否则，如果数据库的标识符使用小写的，那么MBG自动把表名变成小写再查找；
            4，否则，使用指定的大小写格式查询；
        另外的，如果在创建表的时候，使用的&quot;&quot;把数据库对象规定大小写，就算数据库标识符是使用的大写，在这种情况下也会使用给定的大小写来创建表名；
        这个时候，请设置delimitIdentifiers=&quot;true&quot;即可保留大小写格式；

        可选：
        1，schema：数据库的schema；
        2，catalog：数据库的catalog；
        3，alias：为数据表设置的别名，如果设置了alias，那么生成的所有的SELECT SQL语句中，列名会变成：alias_actualColumnName
        4，domainObjectName：生成的domain类的名字，如果不设置，直接使用表名作为domain类的名字；可以设置为somepck.domainName，那么会自动把domainName类再放到somepck包里面；
        5，enableInsert（默认true）：指定是否生成insert语句；
        6，enableSelectByPrimaryKey（默认true）：指定是否生成按照主键查询对象的语句（就是getById或get）；
        7，enableSelectByExample（默认true）：MyBatis3Simple为false，指定是否生成动态查询语句；
        8，enableUpdateByPrimaryKey（默认true）：指定是否生成按照主键修改对象的语句（即update)；
        9，enableDeleteByPrimaryKey（默认true）：指定是否生成按照主键删除对象的语句（即delete）；
        10，enableDeleteByExample（默认true）：MyBatis3Simple为false，指定是否生成动态删除语句；
        11，enableCountByExample（默认true）：MyBatis3Simple为false，指定是否生成动态查询总条数语句（用于分页的总条数查询）；
        12，enableUpdateByExample（默认true）：MyBatis3Simple为false，指定是否生成动态修改语句（只修改对象中不为空的属性）；
        13，modelType：参考context元素的defaultModelType，相当于覆盖；
        14，delimitIdentifiers：参考tableName的解释，注意，默认的delimitIdentifiers是双引号，如果类似MYSQL这样的数据库，使用的是`（反引号，那么还需要设置context的beginningDelimiter和endingDelimiter属性）
        15，delimitAllColumns：设置是否所有生成的SQL中的列名都使用标识符引起来。默认为false，delimitIdentifiers参考context的属性

        注意，table里面很多参数都是对javaModelGenerator，context等元素的默认属性的一个复写；
     --&gt;
    &lt;table tableName=&quot;userinfo&quot; &gt;

        &lt;!-- 参考 javaModelGenerator 的 constructorBased属性--&gt;
        &lt;property name=&quot;constructorBased&quot; value=&quot;false&quot;/&gt;

        &lt;!-- 默认为false，如果设置为true，在生成的SQL中，table名字不会加上catalog或schema； --&gt;
        &lt;property name=&quot;ignoreQualifiersAtRuntime&quot; value=&quot;false&quot;/&gt;

        &lt;!-- 参考 javaModelGenerator 的 immutable 属性 --&gt;
        &lt;property name=&quot;immutable&quot; value=&quot;false&quot;/&gt;

        &lt;!-- 指定是否只生成domain类，如果设置为true，只生成domain类，如果还配置了sqlMapGenerator，那么在mapper XML文件中，只生成resultMap元素 --&gt;
        &lt;property name=&quot;modelOnly&quot; value=&quot;false&quot;/&gt;

        &lt;!-- 参考 javaModelGenerator 的 rootClass 属性 
        &lt;property name=&quot;rootClass&quot; value=&quot;&quot;/&gt;
         --&gt;

        &lt;!-- 参考javaClientGenerator 的  rootInterface 属性
        &lt;property name=&quot;rootInterface&quot; value=&quot;&quot;/&gt;
        --&gt;

        &lt;!-- 如果设置了runtimeCatalog，那么在生成的SQL中，使用该指定的catalog，而不是table元素上的catalog 
        &lt;property name=&quot;runtimeCatalog&quot; value=&quot;&quot;/&gt;
        --&gt;

        &lt;!-- 如果设置了runtimeSchema，那么在生成的SQL中，使用该指定的schema，而不是table元素上的schema 
        &lt;property name=&quot;runtimeSchema&quot; value=&quot;&quot;/&gt;
        --&gt;

        &lt;!-- 如果设置了runtimeTableName，那么在生成的SQL中，使用该指定的tablename，而不是table元素上的tablename 
        &lt;property name=&quot;runtimeTableName&quot; value=&quot;&quot;/&gt;
        --&gt;

        &lt;!-- 注意，该属性只针对MyBatis3Simple有用；
            如果选择的runtime是MyBatis3Simple，那么会生成一个SelectAll方法，如果指定了selectAllOrderByClause，那么会在该SQL中添加指定的这个order条件；
         --&gt;
        &lt;property name=&quot;selectAllOrderByClause&quot; value=&quot;age desc,username asc&quot;/&gt;

        &lt;!-- 如果设置为true，生成的model类会直接使用column本身的名字，而不会再使用驼峰命名方法，比如BORN_DATE，生成的属性名字就是BORN_DATE,而不会是bornDate --&gt;
        &lt;property name=&quot;useActualColumnNames&quot; value=&quot;false&quot;/&gt;


        &lt;!-- generatedKey用于生成生成主键的方法，
            如果设置了该元素，MBG会在生成的&lt;insert&gt;元素中生成一条正确的&lt;selectKey&gt;元素，该元素可选
            column:主键的列名；
            sqlStatement：要生成的selectKey语句，有以下可选项：
                Cloudscape:相当于selectKey的SQL为： VALUES IDENTITY_VAL_LOCAL()
                DB2       :相当于selectKey的SQL为： VALUES IDENTITY_VAL_LOCAL()
                DB2_MF    :相当于selectKey的SQL为：SELECT IDENTITY_VAL_LOCAL() FROM SYSIBM.SYSDUMMY1
                Derby      :相当于selectKey的SQL为：VALUES IDENTITY_VAL_LOCAL()
                HSQLDB      :相当于selectKey的SQL为：CALL IDENTITY()
                Informix  :相当于selectKey的SQL为：select dbinfo(&#39;sqlca.sqlerrd1&#39;) from systables where tabid=1
                MySql      :相当于selectKey的SQL为：SELECT LAST_INSERT_ID()
                SqlServer :相当于selectKey的SQL为：SELECT SCOPE_IDENTITY()
                SYBASE      :相当于selectKey的SQL为：SELECT @@IDENTITY
                JDBC      :相当于在生成的insert元素上添加useGeneratedKeys=&quot;true&quot;和keyProperty属性
        &lt;generatedKey column=&quot;&quot; sqlStatement=&quot;&quot;/&gt;
         --&gt;

        &lt;!-- 
            该元素会在根据表中列名计算对象属性名之前先重命名列名，非常适合用于表中的列都有公用的前缀字符串的时候，
            比如列名为：CUST_ID,CUST_NAME,CUST_EMAIL,CUST_ADDRESS等；
            那么就可以设置searchString为&quot;^CUST_&quot;，并使用空白替换，那么生成的Customer对象中的属性名称就不是
            custId,custName等，而是先被替换为ID,NAME,EMAIL,然后变成属性：id，name，email；

            注意，MBG是使用java.util.regex.Matcher.replaceAll来替换searchString和replaceString的，
            如果使用了columnOverride元素，该属性无效；

        &lt;columnRenamingRule searchString=&quot;&quot; replaceString=&quot;&quot;/&gt;
         --&gt;


         &lt;!-- 用来修改表中某个列的属性，MBG会使用修改后的列来生成domain的属性；
             column:要重新设置的列名；
             注意，一个table元素中可以有多个columnOverride元素哈~
          --&gt;
         &lt;columnOverride column=&quot;username&quot;&gt;
             &lt;!-- 使用property属性来指定列要生成的属性名称 --&gt;
             &lt;property name=&quot;property&quot; value=&quot;userName&quot;/&gt;

             &lt;!-- javaType用于指定生成的domain的属性类型，使用类型的全限定名
             &lt;property name=&quot;javaType&quot; value=&quot;&quot;/&gt;
              --&gt;

             &lt;!-- jdbcType用于指定该列的JDBC类型 
             &lt;property name=&quot;jdbcType&quot; value=&quot;&quot;/&gt;
              --&gt;

             &lt;!-- typeHandler 用于指定该列使用到的TypeHandler，如果要指定，配置类型处理器的全限定名
                 注意，mybatis中，不会生成到mybatis-config.xml中的typeHandler
                 只会生成类似：where id = #{id,jdbcType=BIGINT,typeHandler=com._520it.mybatis.MyTypeHandler}的参数描述
             &lt;property name=&quot;jdbcType&quot; value=&quot;&quot;/&gt;
             --&gt;

             &lt;!-- 参考table元素的delimitAllColumns配置，默认为false
             &lt;property name=&quot;delimitedColumnName&quot; value=&quot;&quot;/&gt;
              --&gt;
         &lt;/columnOverride&gt;

         &lt;!-- ignoreColumn设置一个MGB忽略的列，如果设置了改列，那么在生成的domain中，生成的SQL中，都不会有该列出现 
             column:指定要忽略的列的名字；
             delimitedColumnName：参考table元素的delimitAllColumns配置，默认为false

             注意，一个table元素中可以有多个ignoreColumn元素
         &lt;ignoreColumn column=&quot;deptId&quot; delimitedColumnName=&quot;&quot;/&gt;
         --&gt;
    &lt;/table&gt;

&lt;/context&gt;

&lt;/generatorConfiguration&gt;
</code></pre><p>好了，就到这里了，可以作为一个工具文档查看。 </p>
]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
    
    </summary>
    
      <category term="JavaWeb" scheme="https://wangyu1997.github.io/categories/JavaWeb/"/>
    
    
      <category term="javaweb" scheme="https://wangyu1997.github.io/tags/javaweb/"/>
    
      <category term="gradle" scheme="https://wangyu1997.github.io/tags/gradle/"/>
    
      <category term="mybatis" scheme="https://wangyu1997.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>Groovy读取yaml和properties文件</title>
    <link href="https://wangyu1997.github.io/2017/10/10/JavaWeb/Groovy%E8%AF%BB%E5%8F%96yaml%E5%92%8Cproperties%E6%96%87%E4%BB%B6/"/>
    <id>https://wangyu1997.github.io/2017/10/10/JavaWeb/Groovy读取yaml和properties文件/</id>
    <published>2017-10-10T02:43:11.000Z</published>
    <updated>2017-10-24T06:36:53.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a> 
<p>Java 可以使用 <code>PropertiesConfiguration</code> 来读取 properties 属性文件，Spring 4.3 后还支持了 <code>Yaml 格式的属性文件</code></p>
<ul>
<li>PropertiesConfiguration: 读取时可以自动进行类型转换，可以给定默认值</li>
<li>Yaml 格式的属性文件: 可以使用树形结构，方便分组，比 <code>.properties</code> 属性文件更灵活，但是以普通的 <code>java.util.Properties</code> 来读取</li>
</ul>
<h1 id="Gradle-依赖"><a href="#Gradle-依赖" class="headerlink" title="Gradle 依赖"></a>Gradle 依赖</h1><pre><code>compile &#39;org.springframework:spring-context:4.3.0.RELEASE&#39;

compile &#39;org.yaml:snakeyaml:1.17&#39;

compile &#39;commons-configuration:commons-configuration:1.10&#39;

testCompile &#39;org.springframework:spring-test:4.3.0.RELEASE&#39;

testCompile &#39;junit:junit:4.12&#39;
</code></pre><h1 id="属性文件"><a href="#属性文件" class="headerlink" title="属性文件"></a>属性文件</h1><blockquote>
<p>config.properties </p>
</blockquote>
<pre><code>username=Dr. Alice 

age=22 

config.yml
</code></pre><p>#mysql </p>
<pre><code>mysql: 

    jdbc: 

        url: jdbc:mysql://localhost:3306 

        dirverClass: com.mysql.jdbc.Driver 

        username: root 

        password: root 

        username: Ritchie Yu 
</code></pre><h1 id="Spring-Bean-配置文件"><a href="#Spring-Bean-配置文件" class="headerlink" title="Spring Bean 配置文件"></a>Spring Bean 配置文件</h1><blockquote>
<p>spring-beans-config.xml </p>
</blockquote>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;

xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;

xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans

http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

&lt;bean id=&quot;yamlProperties&quot; class=&quot;org.springframework.beans.factory.config.YamlPropertiesFactoryBean&quot;&gt;

&lt;property name=&quot;resources&quot;&gt;

&lt;list&gt;

&lt;value&gt;classpath:config.yml&lt;/value&gt;

&lt;/list&gt;

&lt;/property&gt;

&lt;/bean&gt;

&lt;bean id=&quot;propertiesConfig&quot; class=&quot;org.apache.commons.configuration.PropertiesConfiguration&quot;&gt;

&lt;constructor-arg value=&quot;config.properties&quot;/&gt;

&lt;/bean&gt;

&lt;/beans&gt;
</code></pre><h1 id="测试案例"><a href="#测试案例" class="headerlink" title="测试案例"></a>测试案例</h1><pre><code>import org.apache.commons.configuration.PropertiesConfiguration; 

import org.junit.runner.RunWith; 

import org.junit.Test; 

import org.springframework.test.context.ContextConfiguration; 

import org.springframework.test.context.junit4.SpringRunner; 

import javax.annotation.Resource; 

import java.util.Properties; 

@RunWith(SpringRunner.class) 

@ContextConfiguration({&quot;classpath:spring-beans-config.xml&quot;}) 

public class TestYamlPropertiesAndPropertiesConfig { 

@Resource(name = &quot;yamlProperties&quot;) 

private Properties yamlProperties; 

@Resource(name = &quot;propertiesConfig&quot;) 

private PropertiesConfiguration propertiesConfig; 

@Test

public void testYamlProperties() { 

System.out.println(yamlProperties.getProperty(&quot;mysql.jdbc.url&quot;)); 

System.out.println(yamlProperties.getProperty(&quot;username&quot;)); 

} 

@Test

public void testPropertiesConfig() { 

System.out.println(propertiesConfig.getString(&quot;username&quot;)); 

System.out.println(propertiesConfig.getInteger(&quot;age&quot;, 0)); 

} 

} 
</code></pre><p>输出: </p>
<pre><code>Dr. Alice 

22 

jdbc:mysql://localhost:3306 

Ritchie Yu 
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
    
    </summary>
    
      <category term="JavaWeb" scheme="https://wangyu1997.github.io/categories/JavaWeb/"/>
    
    
      <category term="gradle" scheme="https://wangyu1997.github.io/tags/gradle/"/>
    
      <category term="groovy" scheme="https://wangyu1997.github.io/tags/groovy/"/>
    
      <category term="yaml" scheme="https://wangyu1997.github.io/tags/yaml/"/>
    
  </entry>
  
  <entry>
    <title>Intellij Ideal下Gradle部署mybatis</title>
    <link href="https://wangyu1997.github.io/2017/10/09/JavaWeb/Gradle%E9%83%A8%E7%BD%B2mybatis/"/>
    <id>https://wangyu1997.github.io/2017/10/09/JavaWeb/Gradle部署mybatis/</id>
    <published>2017-10-09T02:43:11.000Z</published>
    <updated>2017-10-24T07:01:03.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a> 
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="http://www.mybatis.org/generator/index.html" target="_blank" rel="external">Mybatis Generator</a>是一个mybatis工具项目，用于生成mybatis的model,mapper,dao持久层代码。<strong>Mybatis Generator</strong>提供了maven plugin,ant target，java三种方式启动。现在主流的构建工具是<a href="https://gradle.org/" target="_blank" rel="external">Gradle</a>,虽然mybatis generator没有提供gradle的插件，但gradle可以调用ant任务，因此，gradle也能启动Mybatis Generator。 </p>
<h2 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h2><ul>
<li>数据库:mysql</li>
<li>数据库配置文件:src/main/resources/jdbc.properties</li>
<li>项目中使用了通用mapper 3.3.2 插件</li>
</ul>
<h2 id="项目依赖"><a href="#项目依赖" class="headerlink" title="项目依赖"></a>项目依赖</h2><p>在<strong>build.gradle</strong>中: 运行ant需要运行环境，也就是相应的jar包，因此添加一个配置 </p>
<pre><code>configurations {
    mybatisGenerator
}
</code></pre><p>给这个配置添加依赖 </p>
<pre><code>dependencies {
    mybatisGenerator &quot;org.mybatis.generator:mybatis-generator-core:${generatorVersion}&quot;
    mybatisGenerator &quot;mysql:mysql-connector-java:${mysqlVersion}&quot;
    mybatisGenerator &quot;tk.mybatis:mapper:${mybatisMapperVersion}&quot;
}
</code></pre><h2 id="配置task"><a href="#配置task" class="headerlink" title="配置task"></a>配置task</h2><pre><code>def getDbProperties = {
    def properties = new Properties()
    file(&quot;src/main/resources/jdbc.properties&quot;).withInputStream { inputStream -&gt;
        properties.load(inputStream)
    }
    properties;
}
task mybatisGenerate &lt;&lt; {
    def properties = getDbProperties()
    ant.properties[&#39;targetProject&#39;] = projectDir.path
    ant.properties[&#39;driverClass&#39;] = properties.getProperty(&quot;jdbc.driverClassName&quot;)
    ant.properties[&#39;connectionURL&#39;] = properties.getProperty(&quot;jdbc.url&quot;)
    ant.properties[&#39;userId&#39;] = properties.getProperty(&quot;jdbc.username&quot;)
    ant.properties[&#39;password&#39;] = properties.getProperty(&quot;jdbc.password&quot;)
    ant.properties[&#39;src_main_java&#39;] = sourceSets.main.java.srcDirs[0].path
    ant.properties[&#39;src_main_resources&#39;] = sourceSets.main.resources.srcDirs[0].path
    ant.properties[&#39;modelPackage&#39;] = this.modelPackage
    ant.properties[&#39;mapperPackage&#39;] = this.mapperPackage
    ant.properties[&#39;sqlMapperPackage&#39;] = this.sqlMapperPackage
    ant.taskdef(
            name: &#39;mbgenerator&#39;,
            classname: &#39;org.mybatis.generator.ant.GeneratorAntTask&#39;,
            classpath: configurations.mybatisGenerator.asPath
    )
    ant.mbgenerator(overwrite: true,
            configfile: &#39;src/main/resources/generatorConfig.xml&#39;, verbose: true) {
        propertyset {
            propertyref(name: &#39;targetProject&#39;)
            propertyref(name: &#39;userId&#39;)
            propertyref(name: &#39;driverClass&#39;)
            propertyref(name: &#39;connectionURL&#39;)
            propertyref(name: &#39;password&#39;)
            propertyref(name: &#39;src_main_java&#39;)
            propertyref(name: &#39;src_main_resources&#39;)
            propertyref(name: &#39;modelPackage&#39;)
            propertyref(name: &#39;mapperPackage&#39;)
            propertyref(name: &#39;sqlMapperPackage&#39;)
        }
    }
}
</code></pre><p>大致思路 </p>
<ul>
<li>从_jdbc.propertis_读取配置</li>
<li>_把配置注入ant任务_</li>
<li>_运行ant_生成文件</li>
</ul>
<p>jdbc.properties </p>
<pre><code>jdbc.driverClassName=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://127.0.0.1:3306/userdb?useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;allowMultiQueries=true
jdbc.username=root
jdbc.password=admin
</code></pre><p>其他配置_gradle.propertis_ </p>
<pre><code>#生成实体类所在的包
modelPackage=test.mybatis.pojo
#生成的mapper接口类所在包
mapperPackage=test.mybatis.mapper
#生成的mapper xml文件所在包，默认存储在resources目录下
sqlMapperPackage=mybatis
</code></pre><h2 id="generatorConfig配置"><a href="#generatorConfig配置" class="headerlink" title="generatorConfig配置"></a>generatorConfig配置</h2><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE generatorConfiguration
        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;
&lt;generatorConfiguration&gt;
    &lt;context id=&quot;Mysql&quot; targetRuntime=&quot;MyBatis3Simple&quot; defaultModelType=&quot;flat&quot;&gt;
        &lt;commentGenerator&gt;
            &lt;property name=&quot;suppressAllComments&quot; value=&quot;false&quot;&gt;&lt;/property&gt;
            &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;&gt;&lt;/property&gt;
            &lt;property name=&quot;javaFileEncoding&quot; value=&quot;utf-8&quot;/&gt;
        &lt;/commentGenerator&gt;

        &lt;jdbcConnection driverClass=&quot;${driverClass}&quot;
                        connectionURL=&quot;${connectionURL}&quot;
                        userId=&quot;${userId}&quot;
                        password=&quot;${password}&quot;&gt;
        &lt;/jdbcConnection&gt;

        &lt;javaTypeResolver &gt;
            &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt;
        &lt;/javaTypeResolver&gt;

        &lt;javaModelGenerator targetPackage=&quot;${modelPackage}&quot; targetProject=&quot;${src_main_java}&quot;&gt;
            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot;&gt;&lt;/property&gt;
            &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;&gt;&lt;/property&gt;
        &lt;/javaModelGenerator&gt;

        &lt;sqlMapGenerator targetPackage=&quot;${sqlMapperPackage}&quot; targetProject=&quot;${src_main_resources}&quot;&gt;
            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot;&gt;&lt;/property&gt;
        &lt;/sqlMapGenerator&gt;


        &lt;javaClientGenerator targetPackage=&quot;${mapperPackage}&quot; targetProject=&quot;${src_main_java}&quot; type=&quot;XMLMAPPER&quot;&gt;
            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot;/&gt;
        &lt;/javaClientGenerator&gt;

        &lt;table tableName=&quot;ta_user&quot; enableCountByExample=&quot;false&quot;
               enableDeleteByExample=&quot;false&quot;
               enableSelectByExample=&quot;false&quot;
               enableUpdateByExample=&quot;false&quot;&gt;
            &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;MySql&quot; identity=&quot;true&quot;/&gt;
        &lt;/table&gt;
    &lt;/context&gt;
&lt;/generatorConfiguration&gt;
</code></pre><h2 id="run生成代码"><a href="#run生成代码" class="headerlink" title="run生成代码"></a>run生成代码</h2><pre><code>gradle  mybatisGenerate
</code></pre><h2 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构"></a>项目目录结构</h2><p><img src="http://dandandeshangni.oss-cn-beijing.aliyuncs.com/github/gradle_mybatis_generator.png" alt=""></p>
<p>dependencies.gradle配置 </p>
<pre><code>ext {
    //gradle
    gradleVersion = &#39;2.5&#39;
    //junit
    junitVersion = &#39;4.12&#39;
    //log4j
    log4jVersion = &#39;1.2.16&#39;
    //mybatis
    mybatisMapperVersion = &#39;3.3.2&#39;
    //mybatis
    mybatisVersion = &#39;3.2.6&#39;
    //mysql驱动
    mysqlVersion = &#39;5.1.18&#39;
    //mybatis-spring
    mybatisSpringVersion = &#39;1.3.0&#39;
    //generatorVersion
    generatorVersion = &#39;1.3.2&#39;
}
</code></pre><p>build.gradle完整配置 </p>
<pre><code>group &#39;test.mybatis&#39;
version &#39;1.0-SNAPSHOT&#39;

apply from: &quot;${rootDir}/gradle/dependencies.gradle&quot;

apply plugin: &#39;java&#39;
apply plugin: &#39;war&#39;

configurations {
    mybatisGenerator
}

repositories {
    mavenCentral()
}
dependencies {
    mybatisGenerator &quot;org.mybatis.generator:mybatis-generator-core:${generatorVersion}&quot;
    mybatisGenerator &quot;mysql:mysql-connector-java:${mysqlVersion}&quot;
    mybatisGenerator &quot;tk.mybatis:mapper:${mybatisMapperVersion}&quot;
}



compileJava {
    sourceCompatibility = JavaVersion.VERSION_1_8
    targetCompatibility = JavaVersion.VERSION_1_8
}

repositories {
    jcenter()
    mavenCentral()
}

dependencies {
//    compile &#39;tk.mybatis:mapper:3.3.9&#39;
    compile &quot;log4j:log4j:${log4jVersion}&quot;
    compile &quot;org.mybatis:mybatis:${mybatisVersion}&quot;
    compile &quot;mysql:mysql-connector-java:${mysqlVersion}&quot;
    compile &quot;junit:junit:${junitVersion}&quot;
    compile &quot;org.mybatis:mybatis-spring:${mybatisSpringVersion}&quot;
}

def getDbProperties = {
    def properties = new Properties()
    file(&quot;src/main/resources/jdbc.properties&quot;).withInputStream { inputStream -&gt;
        properties.load(inputStream)
    }
    properties;
}
task mybatisGenerate &lt;&lt; {
    def properties = getDbProperties()
    ant.properties[&#39;targetProject&#39;] = projectDir.path
    ant.properties[&#39;driverClass&#39;] = properties.getProperty(&quot;jdbc.driverClassName&quot;)
    ant.properties[&#39;connectionURL&#39;] = properties.getProperty(&quot;jdbc.url&quot;)
    ant.properties[&#39;userId&#39;] = properties.getProperty(&quot;jdbc.username&quot;)
    ant.properties[&#39;password&#39;] = properties.getProperty(&quot;jdbc.password&quot;)
    ant.properties[&#39;src_main_java&#39;] = sourceSets.main.java.srcDirs[0].path
    ant.properties[&#39;src_main_resources&#39;] = sourceSets.main.resources.srcDirs[0].path
    ant.properties[&#39;modelPackage&#39;] = this.modelPackage
    ant.properties[&#39;mapperPackage&#39;] = this.mapperPackage
    ant.properties[&#39;sqlMapperPackage&#39;] = this.sqlMapperPackage
    ant.taskdef(
            name: &#39;mbgenerator&#39;,
            classname: &#39;org.mybatis.generator.ant.GeneratorAntTask&#39;,
            classpath: configurations.mybatisGenerator.asPath
    )
    ant.mbgenerator(overwrite: true,
            configfile: &#39;src/main/resources/generatorConfig.xml&#39;, verbose: true) {
        propertyset {
            propertyref(name: &#39;targetProject&#39;)
            propertyref(name: &#39;userId&#39;)
            propertyref(name: &#39;driverClass&#39;)
            propertyref(name: &#39;connectionURL&#39;)
            propertyref(name: &#39;password&#39;)
            propertyref(name: &#39;src_main_java&#39;)
            propertyref(name: &#39;src_main_resources&#39;)
            propertyref(name: &#39;modelPackage&#39;)
            propertyref(name: &#39;mapperPackage&#39;)
            propertyref(name: &#39;sqlMapperPackage&#39;)
        }
    }
}
</code></pre><p>刷新gradle出现mybatisGenerate <img src="http://dandandeshangni.oss-cn-beijing.aliyuncs.com/github/gradle_mybatisgenerate.png" alt=""></p>
<p>完整项目地址：<a href="https://github.com/longfeizheng/mybatisDemo" target="_blank" rel="external">mybatisDemo</a></p>
<p>参考链接 </p>
<ul>
<li><a href="http://chenkaihua.com/2015/12/19/running-mybatis-generator-with-gradle/" target="_blank" rel="external">http://chenkaihua.com/2015/12/19/running-mybatis-generator-with-gradle/</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
    
    </summary>
    
      <category term="JavaWeb" scheme="https://wangyu1997.github.io/categories/JavaWeb/"/>
    
    
      <category term="javaweb" scheme="https://wangyu1997.github.io/tags/javaweb/"/>
    
      <category term="gradle" scheme="https://wangyu1997.github.io/tags/gradle/"/>
    
      <category term="mybatis" scheme="https://wangyu1997.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>CSS布局--flex</title>
    <link href="https://wangyu1997.github.io/2017/10/04/VueJs/flex%E5%B8%83%E5%B1%80/"/>
    <id>https://wangyu1997.github.io/2017/10/04/VueJs/flex布局/</id>
    <published>2017-10-03T17:43:11.000Z</published>
    <updated>2017-10-24T07:12:07.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a> 
<p>网页布局（layout）是 CSS 的一个重点应用。 </p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071001.gif" alt=""></p>
<p>布局的传统解决方案，基于<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/box_model" target="_blank" rel="external">盒状模型</a>，依赖 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/display" target="_blank" rel="external"><code>display</code></a> 属性 + <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/position" target="_blank" rel="external"><code>position</code></a>属性 + <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/float" target="_blank" rel="external"><code>float</code></a>属性。它对于那些特殊布局非常不方便，比如，<a href="https://css-tricks.com/centering-css-complete-guide/" target="_blank" rel="external">垂直居中</a>就不容易实现。 </p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071002.png" alt=""></p>
<p>2009年，W3C 提出了一种新的方案—-Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。 </p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071003.jpg" alt=""></p>
<p>Flex 布局将成为未来布局的首选方案。本文介绍它的语法，<a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" target="_blank" rel="external">下一篇文章</a>给出常见布局的 Flex 写法。网友 <a href="http://vgee.cn/" target="_blank" rel="external">JailBreak</a> 为本文的所有示例制作了 <a href="http://static.vgee.cn/static/index.html" target="_blank" rel="external">Demo</a>，也可以参考。 </p>
<p>以下内容主要参考了下面两篇文章：<a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/" target="_blank" rel="external">A Complete Guide to Flexbox</a> 和 <a href="https://scotch.io/tutorials/a-visual-guide-to-css3-flexbox-properties" target="_blank" rel="external">A Visual Guide to CSS3 Flexbox Properties</a>。 </p>
<h2 id="一、Flex-布局是什么？"><a href="#一、Flex-布局是什么？" class="headerlink" title="一、Flex 布局是什么？"></a>一、Flex 布局是什么？</h2><p>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 </p>
<p>任何一个容器都可以指定为 Flex 布局。 </p>
<blockquote>
<p>.box{<br>      display: flex;<br>    }</p>
</blockquote>
<p>行内元素也可以使用 Flex 布局。 </p>
<blockquote>
<p>.box{<br>      display: inline-flex;<br>    }</p>
</blockquote>
<p>Webkit 内核的浏览器，必须加上<code>-webkit</code>前缀。 </p>
<blockquote>
<p>.box{<br>      display: -webkit-flex; /<em> Safari </em>/<br>      display: flex;<br>    }</p>
</blockquote>
<p>注意，设为 Flex 布局以后，子元素的<code>float</code>、<code>clear</code>和<code>vertical-align</code>属性将失效。 </p>
<h2 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h2><p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。 </p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071004.png" alt=""></p>
<p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做<code>main start</code>，结束位置叫做<code>main end</code>；交叉轴的开始位置叫做<code>cross start</code>，结束位置叫做<code>cross end</code>。 </p>
<p>项目默认沿主轴排列。单个项目占据的主轴空间叫做<code>main size</code>，占据的交叉轴空间叫做<code>cross size</code>。 </p>
<h2 id="三、容器的属性"><a href="#三、容器的属性" class="headerlink" title="三、容器的属性"></a>三、容器的属性</h2><p>以下6个属性设置在容器上。 </p>
<blockquote>
<ul>
<li>flex-direction</li>
<li>flex-wrap</li>
<li>flex-flow</li>
<li>justify-content</li>
<li>align-items</li>
<li>align-content</li>
</ul>
</blockquote>
<h3 id="3-1-flex-direction属性"><a href="#3-1-flex-direction属性" class="headerlink" title="3.1 flex-direction属性"></a>3.1 flex-direction属性</h3><p><code>flex-direction</code>属性决定主轴的方向（即项目的排列方向）。 </p>
<blockquote>
<p>.box {<br>      flex-direction: row | row-reverse | column | column-reverse;<br>    }</p>
</blockquote>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071005.png" alt=""></p>
<p>它可能有4个值。 </p>
<blockquote>
<ul>
<li><code>row</code>（默认值）：主轴为水平方向，起点在左端。</li>
<li><code>row-reverse</code>：主轴为水平方向，起点在右端。</li>
<li><code>column</code>：主轴为垂直方向，起点在上沿。</li>
<li><code>column-reverse</code>：主轴为垂直方向，起点在下沿。</li>
</ul>
</blockquote>
<h3 id="3-2-flex-wrap属性"><a href="#3-2-flex-wrap属性" class="headerlink" title="3.2 flex-wrap属性"></a>3.2 flex-wrap属性</h3><p>默认情况下，项目都排在一条线（又称”轴线”）上。<code>flex-wrap</code>属性定义，如果一条轴线排不下，如何换行。 </p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071006.png" alt=""></p>
<blockquote>
<p>.box{<br>      flex-wrap: nowrap | wrap | wrap-reverse;<br>    }</p>
</blockquote>
<p>它可能取三个值。 </p>
<p>（1）<code>nowrap</code>（默认）：不换行。 </p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071007.png" alt=""></p>
<p>（2）<code>wrap</code>：换行，第一行在上方。 </p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071008.jpg" alt=""></p>
<p>（3）<code>wrap-reverse</code>：换行，第一行在下方。 </p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071009.jpg" alt=""></p>
<h3 id="3-3-flex-flow"><a href="#3-3-flex-flow" class="headerlink" title="3.3 flex-flow"></a>3.3 flex-flow</h3><p><code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code>。 </p>
<blockquote>
<p>.box {<br>      flex-flow: <flex-direction> || <flex-wrap>;<br>    }</flex-wrap></flex-direction></p>
</blockquote>
<h3 id="3-4-justify-content属性"><a href="#3-4-justify-content属性" class="headerlink" title="3.4 justify-content属性"></a>3.4 justify-content属性</h3><p><code>justify-content</code>属性定义了项目在主轴上的对齐方式。 </p>
<blockquote>
<p>.box {<br>      justify-content: flex-start | flex-end | center | space-between | space-around;<br>    }</p>
</blockquote>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071010.png" alt=""></p>
<p>它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。 </p>
<blockquote>
<ul>
<li><code>flex-start</code>（默认值）：左对齐</li>
<li><code>flex-end</code>：右对齐</li>
<li><code>center</code>： 居中</li>
<li><code>space-between</code>：两端对齐，项目之间的间隔都相等。</li>
<li><code>space-around</code>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li>
</ul>
</blockquote>
<h3 id="3-5-align-items属性"><a href="#3-5-align-items属性" class="headerlink" title="3.5 align-items属性"></a>3.5 align-items属性</h3><p><code>align-items</code>属性定义项目在交叉轴上如何对齐。 </p>
<blockquote>
<p>.box {<br>      align-items: flex-start | flex-end | center | baseline | stretch;<br>    }</p>
</blockquote>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071011.png" alt=""></p>
<p>它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。 </p>
<blockquote>
<ul>
<li><code>flex-start</code>：交叉轴的起点对齐。</li>
<li><code>flex-end</code>：交叉轴的终点对齐。</li>
<li><code>center</code>：交叉轴的中点对齐。</li>
<li><code>baseline</code>: 项目的第一行文字的基线对齐。</li>
<li><code>stretch</code>（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li>
</ul>
</blockquote>
<h3 id="3-6-align-content属性"><a href="#3-6-align-content属性" class="headerlink" title="3.6 align-content属性"></a>3.6 align-content属性</h3><p><code>align-content</code>属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 </p>
<blockquote>
<p>.box {<br>      align-content: flex-start | flex-end | center | space-between | space-around | stretch;<br>    }</p>
</blockquote>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071012.png" alt=""></p>
<p>该属性可能取6个值。 </p>
<blockquote>
<ul>
<li><code>flex-start</code>：与交叉轴的起点对齐。</li>
<li><code>flex-end</code>：与交叉轴的终点对齐。</li>
<li><code>center</code>：与交叉轴的中点对齐。</li>
<li><code>space-between</code>：与交叉轴两端对齐，轴线之间的间隔平均分布。</li>
<li><code>space-around</code>：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li>
<li><code>stretch</code>（默认值）：轴线占满整个交叉轴。</li>
</ul>
</blockquote>
<h3 id="四、项目的属性"><a href="#四、项目的属性" class="headerlink" title="四、项目的属性"></a>四、项目的属性</h3><p>以下6个属性设置在项目上。 </p>
<blockquote>
<ul>
<li><code>order</code></li>
<li><code>flex-grow</code></li>
<li><code>flex-shrink</code></li>
<li><code>flex-basis</code></li>
<li><code>flex</code></li>
<li><code>align-self</code></li>
</ul>
</blockquote>
<h3 id="4-1-order属性"><a href="#4-1-order属性" class="headerlink" title="4.1 order属性"></a>4.1 order属性</h3><p><code>order</code>属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 </p>
<blockquote>
<p>.item {<br>      order: <integer>;<br>    }</integer></p>
</blockquote>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071013.png" alt=""></p>
<h3 id="4-2-flex-grow属性"><a href="#4-2-flex-grow属性" class="headerlink" title="4.2 flex-grow属性"></a>4.2 flex-grow属性</h3><p><code>flex-grow</code>属性定义项目的放大比例，默认为<code>0</code>，即如果存在剩余空间，也不放大。 </p>
<blockquote>
<p>.item {<br>      flex-grow: <number>; /<em> default 0 </em>/<br>    }</number></p>
</blockquote>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071014.png" alt=""></p>
<p>如果所有项目的<code>flex-grow</code>属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的<code>flex-grow</code>属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 </p>
<h3 id="4-3-flex-shrink属性"><a href="#4-3-flex-shrink属性" class="headerlink" title="4.3 flex-shrink属性"></a>4.3 flex-shrink属性</h3><p><code>flex-shrink</code>属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 </p>
<blockquote>
<p>.item {<br>      flex-shrink: <number>; /<em> default 1 </em>/<br>    }</number></p>
</blockquote>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071015.jpg" alt=""></p>
<p>如果所有项目的<code>flex-shrink</code>属性都为1，当空间不足时，都将等比例缩小。如果一个项目的<code>flex-shrink</code>属性为0，其他项目都为1，则空间不足时，前者不缩小。 </p>
<p>负值对该属性无效。 </p>
<h3 id="4-4-flex-basis属性"><a href="#4-4-flex-basis属性" class="headerlink" title="4.4 flex-basis属性"></a>4.4 flex-basis属性</h3><p><code>flex-basis</code>属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为<code>auto</code>，即项目的本来大小。 </p>
<blockquote>
<p>.item {<br>      flex-basis: <length> | auto; /<em> default auto </em>/<br>    }</length></p>
</blockquote>
<p>它可以设为跟<code>width</code>或<code>height</code>属性一样的值（比如350px），则项目将占据固定空间。 </p>
<h3 id="4-5-flex属性"><a href="#4-5-flex属性" class="headerlink" title="4.5 flex属性"></a>4.5 flex属性</h3><p><code>flex</code>属性是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选。 </p>
<blockquote>
<p>.item {<br>      flex: none | [ &lt;’flex-grow’&gt; &lt;’flex-shrink’&gt;? || &lt;’flex-basis’&gt; ]<br>    }</p>
</blockquote>
<p>该属性有两个快捷值：<code>auto</code> (<code>1 1 auto</code>) 和 none (<code>0 0 auto</code>)。 </p>
<p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 </p>
<h3 id="4-6-align-self属性"><a href="#4-6-align-self属性" class="headerlink" title="4.6 align-self属性"></a>4.6 align-self属性</h3><p><code>align-self</code>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。 </p>
<blockquote>
<p>.item {<br>      align-self: auto | flex-start | flex-end | center | baseline | stretch;<br>    }</p>
</blockquote>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071016.png" alt=""></p>
<p>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。 </p>
]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
    
    </summary>
    
      <category term="VueJs" scheme="https://wangyu1997.github.io/categories/VueJs/"/>
    
    
      <category term="css" scheme="https://wangyu1997.github.io/tags/css/"/>
    
      <category term="boxing" scheme="https://wangyu1997.github.io/tags/boxing/"/>
    
      <category term="flexing box" scheme="https://wangyu1997.github.io/tags/flexing-box/"/>
    
  </entry>
  
  <entry>
    <title>Stylus使用指南</title>
    <link href="https://wangyu1997.github.io/2017/10/03/VueJs/Stylus%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>https://wangyu1997.github.io/2017/10/03/VueJs/Stylus使用指南/</id>
    <published>2017-10-02T17:43:11.000Z</published>
    <updated>2017-10-24T07:13:55.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a> 
<blockquote>
<p>很少有文章针对Sass、LESS和Stylus做这么详细的对比。<a href="http://weibo.com/u/1143654280" target="_blank" rel="external">@Justineo</a>写的《<a href="http://efe.baidu.com/blog/revisiting-css-preprocessors/" target="_blank" rel="external">再谈 CSS 预处理器</a>》让我受益良多，特将此文转载到小站。 </p>
</blockquote>
<p>CSS 预处理器是什么？一般来说，它们基于 CSS 扩展了一套属于自己的 DSL，来解决我们书写 CSS 时难以解决的问题： </p>
<ul>
<li>语法不够强大，比如无法嵌套书写导致模块化开发中需要书写很多重复的选择器；</li>
<li>没有变量和合理的样式复用机制，使得逻辑上相关的属性值必须以字面量的形式重复输出，导致难以维护。</li>
</ul>
<p>所以这就决定了 CSS 预处理器的主要目标：提供 CSS 缺失的样式层复用机制、减少冗余代码，提高样式代码的可维护性。这不是锦上添花，而恰恰是雪中送炭。 </p>
<p>网上已经有不少对比目前最主流的三个预处理器 Less、Sass 和 Stylus（按字母顺序排名）的文章了，但是似乎都不是很详细，或者内容有些过时。下面我会更详细地探讨一下这三种预处理器的特性和它们的差异。 </p>
<p>下面主要会分为如下几方面来讨论： </p>
<ul>
<li>基本语法</li>
<li>嵌套语法</li>
<li>变量</li>
<li><code>@import</code></li>
<li>混入</li>
<li>继承</li>
<li>函数</li>
<li>逻辑控制</li>
</ul>
<p>事先声明一下，平时我在开发中主要使用的是 Less，所以可能对 Sass 和 Stylus 的熟悉程度稍差一些，比较时主要参考三者官网的语言特性说明，有一些正在开发的功能可能会遗漏。 </p>
<p>本文中对 CSS 语法的话术与 MDN 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Syntax" target="_blank" rel="external">CSS 语法</a>介绍一致。 </p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>Less 的基本语法属于「CSS 风格」，而 Sass、Stylus 相比之下激进一些，利用缩进、空格和换行来减少需要输入的字符。不过区别在于 Sass、Stylus 同时也兼容「CSS 风格」代码。多一种选择在更灵活的同时，在团队开发中也免不了增加更多约定来保持风格统一。而对个人而言，语法风格按自己口味选择即可。 </p>
<p><strong>注：后面的 Sass 代码会用被更多人接受的 SCSS 风格给出。</strong></p>
<p>Less &amp; SCSS： </p>
<pre><code>.box {
  display: block;
}
</code></pre><p>Sass： </p>
<pre><code>.box
  display: block
</code></pre><p>Stylus： </p>
<pre><code>.box
  display: block
</code></pre><h2 id="嵌套语法"><a href="#嵌套语法" class="headerlink" title="嵌套语法"></a>嵌套语法</h2><p>三者的嵌套语法都是一致的，甚至连引用父级选择器的标记 `&amp;`` 也相同。区别只是 Sass 和 Stylus 可以用没有大括号的方式书写。以 Less 为例： </p>
<pre><code>.a {
  &amp;.b {
    color: red;
  }
}
</code></pre><p>生成的 CSS 为： </p>
<pre><code>.a.b {
  color: red;
}
</code></pre><p>除了规则集的嵌套，Sass 额外提供了一个我个人认为比较另（jī）类（lèi）的「属性嵌套」： </p>
<pre><code>.funky {
  font: {
    family: fantasy;
    size: 30em;
    weight: bold;
  }
}
</code></pre><h2 id="选择器引用"><a href="#选择器引用" class="headerlink" title="选择器引用"></a>选择器引用</h2><p>三者都支持用 <code>&amp;</code> 在嵌套的规则集中引用上层的选择器，这可以是嵌套书写 CSS 时的「惯例」了。语法相同，但是逻辑上有些许差异。在一个选择器中用两次以上 <code>&amp;</code> 且父选择器是一个列表时，Less 会对选择器进行排列组合，而 Sass 和 Stylus 不会这么做。 </p>
<p>也就是说，假设上层选择器为 <code>.a</code>, <code>.b</code>，则内部的 <code>&amp; &amp;</code> 在 Less 中会成为 <code>.a .a</code>, <code>.a .b</code>, <code>.b .a</code>, <code>.b .b</code>，而 Sass 和 Stylus 则输出 <code>.a .a, .b .b</code>。 </p>
<p>假设我们要用预处理器书写 [WHATWG 推荐的 section 标题样式][4]，在 Less 中可以方便地书写为： </p>
<pre><code>   [4]: https://html.spec.whatwg.org/multipage/rendering.html#sections-and-headings
</code></pre><p>article, aside, nav, section {<br>          h1 {<br>            margin-top: 0.83em; margin-bottom: 0.83em; font-size: 1.50em;<br>          }<br>          &amp; &amp; h1 {<br>            margin-top: 1.00em; margin-bottom: 1.00em; font-size: 1.17em;<br>          }<br>          &amp; &amp; &amp; h1 {<br>            margin-top: 1.33em; margin-bottom: 1.33em; font-size: 1.00em;<br>          }<br>          &amp; &amp; &amp; &amp; h1 {<br>            margin-top: 1.67em; margin-bottom: 1.67em; font-size: 0.83em;<br>          }<br>          &amp; &amp; &amp; &amp; &amp; h1 {<br>            margin-top: 2.33em; margin-bottom: 2.33em; font-size: 0.67em;<br>          }<br>        }</p>
<p>当然，这个推荐样式十分脑残，编译出来的结果会有 47KB 之巨，根本不可用，这里只是借来演示一下。 </p>
<p>除了 <code>&amp;</code>，Sass 和 Stylus 更进一步，分别用 <code>@at-root</code> 和 <code>/</code> 符号作为嵌套时「根」规则集的选择器引用。这有什么用呢？举个例子，假设 HTML 结构是这样的： </p>
<pre><code>&lt;article class=&quot;post&quot;&gt;
  &lt;h1&gt;我是一篇文章&lt;/h1&gt;
  &lt;section&gt;
    &lt;h1 class=&quot;section-title&quot;&gt;&lt;a href=&quot;#s1&quot; class=&quot;section-link&quot;&gt;#&lt;/a&gt;我是章节标题&lt;/h1&gt;
    &lt;p&gt;我只是一个&lt;em&gt;例子&lt;/em&gt;。&lt;/p&gt;
  &lt;/section&gt;
&lt;/article&gt;
</code></pre><p>如果我这么写 Sass 代码，是完全符合业务的嵌套关系的： </p>
<pre><code>.post {
  section {
    .section-title {
      color: #333;
      .section-link {
        color: #999;
      }
    }
    /* other section styles */
  }
  /* other post styles */
}
</code></pre><p>但是这样生成出来的选择器会有 <code>.post section .section-title .section-link</code>，很多时候我们觉得写成 <code>.post .section-link</code> 就够了。 </p>
<p>于是我们在 Stylus 中可以这么写： </p>
<pre><code>.post
  section
    .section-title
      color #333
      /.post .section-link
        color #999
    /* other section styles */

  /* other post styles */
</code></pre><p>这样输出的 CSS 就会是： </p>
<pre><code>.post section .section-title {
  color: #333;
}
.post .section-link {
  color: #999;
}
</code></pre><p>这就是我们想要的样子了。当然也可以这样写： </p>
<pre><code>.post
  section
    .section-title
      color #333
    /* other section styles */

  .section-link
    color #999
  /* other post styles */
</code></pre><p>我个人是推荐这种写法（不使用 <code>root</code> 引用）的，因为当你确定 <code>.section-link</code> 的样式不依赖于它位于 <code>section</code> 或 <code>.section-title</code> 下时，就不应该嵌套于此。否则如果为了一点点性能上的考虑（还不一定会是优化），使得设计意图变得更不准确，我觉得得不偿失。 </p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量无疑为 CSS 增加了一种有效的复用方式，减少了原来在 CSS 中无法避免的重复「硬编码」。 </p>
<p>Less： </p>
<pre><code>@red: #c00;

strong {
  color: @red;
}
</code></pre><p>Sass： </p>
<pre><code>$red: #c00;

strong {
  color: $red;
}
</code></pre><p>Stylus： </p>
<pre><code>red = #c00

strong
  color: red
</code></pre><p>Less 的选择有一个问题：<code>@</code>规则在 CSS 中可以算是一种「原生」的扩展方式，变量名用 <code>@</code>开头很可能会和以后的新 <code>@</code>规则冲突。（当然理论上只要 CSS 规范不引入 <code>@a: b</code> 这样的规则，问题也不大。而且规范制定的时候也会参考很多现有的实现。） </p>
<p>相比之下 Sass 的选择中规中矩，而 Stylus 就不同了，不需要额外的标志符。这意味着：在 Stylus 中，我们可以覆写 CSS 原生的属性值！Stylus 的设计让人有一种「你以为你在写 CSS，但其实你不是」的感觉，后面会有更多这样的例子。 </p>
<p>顺便说一下，CSS 规范也有关于变量实现的草案，目前的方案是这个样子的： </p>
<pre><code>/* global scope */
:root {
  --red: #c00;
}

strong {
  color: var(--red);
}
</code></pre><p>不管语法槽点如何，原生 CSS 变量可以通过 DOM 结构来继承，也就是说是代码真正「运行」时（runtime）决定的。元素引用一个变量时会按 DOM 向上查找定义在上层元素上的同名变量。这一点是任何预处理语言都无法做到的。可以用 Firefox 31+ 看一下这个 <a href="http://jsbin.com/webuju/1/edit" target="_blank" rel="external">demo</a>。至于这种机制是不是好用，暂时还没研究过。不过从开发的思维惯性来看，还很难一下子适应这种方式。 </p>
<h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>三种预处理器的变量作用域都是按嵌套的规则集划分，并且在当前规则集下找不到对应变量时会逐级向上查找，注意这个和原生 CSS 的逻辑是完全不同的。 </p>
<p>如果我们在代码中重写某个已经定义的变量的值，Less 的处理逻辑和其他两者有非常关键的区别。在 Less 中，这个行为被称为「<a href="http://lesscss.org/features/#variables-feature-lazy-loading" target="_blank" rel="external">懒加载（Lazy Loading）</a>」。所有 Less 变量的计算，都是以这个变量最后一次被定义的值为准。举一个例子更容易说清楚： </p>
<p>Less： </p>
<pre><code>@size: 10px;
.box {
    width: @size;
}

@size: 20px;
.ball {
    width: @size;
}
</code></pre><p>输出： </p>
<pre><code>.box {
  width: 20px;
}
.ball {
  width: 20px;
}
</code></pre><p>而在 Stylus 中： </p>
<pre><code>size = 10px
.box
  width: size

size = 20px
.ball
  width: size
</code></pre><p>输出： </p>
<pre><code>.box {
  width: 10px;
}
.ball {
  width: 20px;
}
</code></pre><p>Sass 的处理方式和 Stylus 相同，变量值输出时根据之前最近的一次定义计算。这其实代表了两种理念：Less 更倾向接近 CSS 的声明式，计算过程弱化调用时机；而 Sass 和 Stylus 更倾向于指令式。这两种方式会导致怎样的结果呢？ </p>
<p>举个例子来说，对于 Less，如果项目中引入了这样一个文件： </p>
<pre><code>@error-color: #c00;
@success-color: #0c0;
.error {
  color: @error-color;
  background-color: lighten(@error-color, 40%);
}
.success {
  color: @success-color;
  background-color: lighten(@success-color, 40%);
}
</code></pre><p>在业务代码中，在不修改外部引入文件的情况下，如果我想重写这两种状态的配色，只需要重新配置 <code>@error-color</code> 和 <code>@success-color</code> 这两个变量，就能改变 <code>.error</code> 和 <code>.success</code> 的样式。 </p>
<p>而在 Stylus 中，如果引入的第三方样式库中有这样的代码： </p>
<pre><code>error-color = #c00
success-color = #0c0

.error
  color: error-color
  background-color: lighten(error-color, 40%)

.success
  color: success-color
  background-color: lighten(success-color, 40%)
</code></pre><p>这种情况下后面的代码就无法通过重写变量值来覆盖样式了。Sass 也是如此。优点是 Stylus 和 Sass 这样的处理会不容易受多个第三方库变量名冲突的影响，因为一个变量不能影响在定义它以前的输出样式。 </p>
<p>由于 Sass 和 Stylus 变量在「运行」过程中使用完可以修改后再使用输出不同的值，所以这两者还提供了「仅当变量不存在时才赋值」的功能： </p>
<p>Sass： </p>
<pre><code>$x: 1;
$x: 5 !default;
$y: 3 !default;

// $x = 1, $y = 3
</code></pre><p>Stylus： </p>
<pre><code>x = 1
x := 5 // or x ?= 5
y = 3

// x = 1, y = 3
</code></pre><p>因为变量只能在输出前修改才能生效，所以如果要定制第三方库的样式，用户代码理论上得插入第三方库的配置与样式之间才能生效。而有了 <code>!default</code>，第三方库在提供默认配置时可以将开发给用户修改的变量设置为 <code>!default</code>，这样只要用户提前引入配置进行覆盖，就可以按需重写默认配置了： </p>
<pre><code>// lib.scss
$alert-color: red !default;
.alert {
  color: $alert-color;
}
// var.scss
$alert-color: #c00;
// page.scss
@import var
@import lib
</code></pre><p>这样最终页面输出的效果就是被用户重定义过的内容了。 </p>
<pre><code>/* page.css */
.alert {
  color: #c00;
}
</code></pre><p>由于 Less 处理变量的方式，如果我们要引入多个外部样式库或在多个团队进行合作开发时，如果不能确保开发过程可控，那为变量添加模块前缀就变得很有必要。 </p>
<p>此外，Sass 中提供一个 <code>!global</code> 的语法来让局部变量变成全局变量，也就是说 Sass 代码可以在内层覆盖全局变量的值。输出一段局部的样式可能使得后续所有样式都受到全局变量变化的影响。（这其实是 Sass 开始时默认的逻辑，Sass 3.3 以前所有变量都是全局的，之后改成了和 Less 和 Stylus 一样有嵌套作用域，全局变量要显式指定 <code>!global</code>。） </p>
<h2 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h2><p>预处理器都有定义变量的功能，除了在最常见的属性值中使用，其他还有哪些地方能用变量来增强对样式的抽象、复用呢？ </p>
<h2 id="变量名插值"><a href="#变量名插值" class="headerlink" title="变量名插值"></a>变量名插值</h2><p>Less 中支持 <code>@@foo</code> 的形式引用变量，即该变量的名字是由 <code>@foo</code> 的值决定的。比如我们可以利用它简化更清晰地调用 mixin： </p>
<pre><code>// some icon font lib

// variables with prefix to prevent conflicts
@content-apple: &quot;A&quot;;
@content-google: &quot;G&quot;;

// clearer argument values
.icon-content(@icon) {
  @var: ~&quot;content-@{icon}&quot;;
  &amp;::before {
    content: @@var;
  }
}

.icon-apple {
  .icon-content(apple); // &quot;A&quot;
}

.icon-google {
  .icon-content(google); // &quot;G&quot;
}
</code></pre><h2 id="选择器插值"><a href="#选择器插值" class="headerlink" title="选择器插值"></a>选择器插值</h2><p>选择器是样式表和 DOM 的纽带，是我们实际暴露给 HTML 的接口。支持插值显然可以让接口更不容易和其他内容冲突。假设我们在开发一个 UI 库，生成的组件类名希望有一个可配置的前缀，这时选择器插值就变得相当重要。初看下来，三者用法类似： </p>
<p>Less： </p>
<pre><code>@prefix: ui;
.@{prefix}-button {
  color: #333;
}
</code></pre><p>Sass： </p>
<pre><code>$prefix: ui
.#{$prefix}-button
  color: #333;
</code></pre><p>Stylus： </p>
<pre><code>prefix = ui
.{prefix}-button
  color #333
</code></pre><p>但是在 Less 中，有一个很严重的问题：通过选择器插值生成的规则无法被继承（<a href="https://github.com/less/less.js/issues/2200%EF%BC%89" target="_blank" rel="external">Extend dynamically generated selectors</a>！当然，如果有类似 Placeholder 的机制，这都不是事儿了。问题是 Less 没有！未来的方案看来可能是通过 <code>:extend(.mixin()</code>) 的方式实现类似功能（<a href="https://github.com/less/less.js/issues/1177" target="_blank" rel="external"><code>:extend mixins</code></a>），虽然用 <code>:extend</code> 本身的语法说不过去，但是在现有机制上来看还算可以接受。关于样式的继承复用，后面会详细讲到。 </p>
<h2 id="import-语句插值"><a href="#import-语句插值" class="headerlink" title="@import 语句插值"></a>@import 语句插值</h2><p>Sass 中只能在使用 <code>url()</code> 表达式引入时进行变量插值： </p>
<pre><code>$device: mobile;
@import url(styles.#{$device}.css);
</code></pre><p>Less 中可以在字符串中进行插值： </p>
<pre><code>@device: mobile;
@import &quot;styles.@{device}.css&quot;;
</code></pre><p>Stylus 中在这里插值不管用，但是可以利用其字符串拼接的功能实现： </p>
<pre><code>device = &quot;mobile&quot;
@import &quot;styles.&quot; + device + &quot;.css&quot;
</code></pre><p>注意由于 Less 的 Lazy Load 特性，即使是 <code>@import</code> 也是可以在后面的文件内容中进行覆盖的，修改掉变量就可以在前面引入不同的外部文件。而 Sass 与 Stylus 一旦输出语句，就无法通过变量改变了。 </p>
<h2 id="属性名插值"><a href="#属性名插值" class="headerlink" title="属性名插值"></a>属性名插值</h2><p>三个预处理器的目前版本都支持属性名插值，用法也类似。这里仅以 Stylus 为例： </p>
<pre><code>red-border(sides)
  for side in sides
    border-{side}-color: red // property name interpolation

.x
  red-border(top right)
</code></pre><p>输出： </p>
<pre><code>.x {
  border-top-color: #f00;
  border-right-color: #f00;
}
</code></pre><h2 id="其他-规则插值"><a href="#其他-规则插值" class="headerlink" title="其他 @ 规则插值"></a>其他 @ 规则插值</h2><p>三种预处理器均支持在 <code>@media</code>、<code>@keyframes</code>、<code>@counter-style</code> 等规则中进行插值。<code>@media</code> 插值主要用来做响应式的配置，而 <code>@keyframes</code> 这样带名称名称的 <code>@</code>规则则可以通过插值来避免命名冲突。 </p>
<p>Less： </p>
<pre><code>@m: screen;
@orient: landscape;
@media @m and (orientation: @orient) {
  body {
    width: 960px;
  }
}

@prefix: ui;
@keyframes ~&quot;@{prefix}-fade-in&quot; {
  0% {
    opacity: 0;
  }
  100% {
    opacity: 1;
  }
}
</code></pre><p>Sass： </p>
<pre><code>$m: screen;
$orient: landscape;
@media #{$m} and (orientation: $orient) {
  body {
    width: 1000px;
  }
}

$prefix: ui;
@keyframes #{$prefix}-fade-in {
  0% {
    opacity: 0;
  }
  100% {
    opacity: 1;
  }
}
</code></pre><p>Stylus： </p>
<pre><code>m = screen
orient = landscape
mq = m + &quot; and (orientation: &quot; + orient + &quot;)&quot;
@media mq
  body
    width: 960px

vendors = official
prefix = ui;
@keyframes {prefix}-fade-in {
  0% {
    opacity: 0;
  }
  100% {
    opacity: 1;
  }
}
</code></pre><p>三者均会输出如下 CSS： </p>
<pre><code>@media screen and (orientation: landscape) {
  body {
    width: 960px;
  }
}
@keyframes ui-fade-in {
  0% {
    opacity: 0;
  }
  100% {
    opacity: 1;
  }
}
</code></pre><p>Stylus 中似乎有 <code>and</code>时由于表达式计算的逻辑不能直接像 Less 与 Sass 那样写插值，所以这里采用了字符串拼接的方式。 </p>
<h2 id="import"><a href="#import" class="headerlink" title="@import"></a>@import</h2><p><code>@import</code> 对于模块化开发来说非常有帮助，但就这个功能来说，三种预处理器的行为各不相同。 </p>
<p>先说 Less，Less 扩展了语法，为 <code>@import</code> 增加了多种选项： </p>
<ul>
<li><code>@import (less) somefile.ext</code>:会将无论什么扩展名的文件都作为 Less 文件引入、一起编译；</li>
<li><code>@import (css) somefile.ext</code>:直接编译生成 <code>@import somefile.ext</code>，当做原生 <code>@import</code>；</li>
<li><code>@import (inline) somefile.ext</code>:直接将外部文件拷贝进输出文件的这个位置，但不会参与编译；</li>
<li><code>@import (reference) somefile.ext</code>:外部文件参与编译，但不输出内容，仅用来被本文件中的样式继承；</li>
<li><code>@import (optional) somefile.ext</code>:引入文件但在文件不存在时不报错，静默失败。</li>
</ul>
<p>上面的选项是可以联合使用的，比如可以这样写： </p>
<pre><code>@import (less, optional) somefile.ext;
</code></pre><p>除此之外还有 <code>once</code> 和 <code>multiple</code> 选项分别用来表示去重和不去重的引入方式，默认为 <code>once</code>。在不写任何选项时，Less 会根据扩展名进行推断来决定引入逻辑。 </p>
<p>Sass 没有扩展语法，而是自己推断引入的方式。<code>.css</code> 后缀、绝对路径、<code>url()</code> 表达式和带有 media query 的 <code>@import</code> 会直接用原生 <code>@import</code>，其他都会作为 Sass 代码参与编译。相比之下 Less 更灵活也更复杂。Sass 有个特有的功能叫做「partial」，因为 Sass 默认的编译工具可以编译整个目录下的文件，所以当一些文件不需要编译时，可以在文件名前加上 <code>_</code> 表明这是一个被别的模块引入本身不需要编译的代码片段。Less 的 lessc 由于本来就只处理一个文件，所以这件事就交给用户自己去写编译脚本了。Sass 中有一个比较棘手的问题是，<code>@import</code> 不会被去重，多次引入会导致一个样式文件被多次输出到编译结果中。为了解决这个问题，Foundation 做了如下的 <a href="https://github.com/ecomfe/spec/blob/master/less-code-style.md#user-content-%E6%B7%B7%E5%85%A5mixin-1" target="_blank" rel="external">hack</a>： </p>
<pre><code>   [9]: https://github.com/zurb/foundation/blob/a1eb7561ef835313e20995488afb3f627b27354a/scss/foundation/_functions.scss#L8-L21
</code></pre><p>// IMPORT ONCE<br>// We use this to prevent styles from being loaded multiple times for components that rely on other components.<br>$modules: () !default; </p>
<pre><code>@mixin exports($name) {
  // Import from global scope
  $modules: $modules !global;
  // Check if a module is already on the list
  $module_index: index($modules, $name);
  @if (($module_index == null) or ($module_index == false)) {
    $modules: append($modules, $name) !global;
    @content;
  }
}
</code></pre><p>然后在定义样式时都调用 <code>exports</code> 这个 mixin 来输出，起到只输出一次的效果。 </p>
<p>Stylus 和 Sass 比较接近，也使用隐性推断的方式，但在处理重复输出的问题上，Stylus 给出了一个自定义指令 <code>@require</code>，用法和 <code>@import</code> 完全一样，但只会输出一次。Stylus 还支持通配符，比如<code>@import &#39;product/*&#39;</code> 会引入 <code>product</code> 目录下的所有 <code>.styl</code> 文件，但因为一般引入样式都要显式指定顺序，所以这个功能实用性不高。 </p>
<p>三者相比较之下，Sass 的引入功能似乎有点残缺，不能去重是很大的硬伤。虽然能用 Foundation 那种方式「解决」，但实际上这是语言本身应该解决的问题。 </p>
<h2 id="混入"><a href="#混入" class="headerlink" title="混入"></a>混入</h2><p>混入（mixin）应该说是预处理器最精髓的功能之一了。它提供了 CSS 缺失的最关键的东西：样式层面的抽象。从语法上来说，三种预处理器的差异也比较大，这甚至会直接影响到我们的开发方式。 </p>
<p>Less 的混入有两种方式： </p>
<ul>
<li>直接在目标位置混入另一个类样式（输出已经确定，无法使用参数）；</li>
<li>定义一个不输出的样式片段（可以输入参数），在目标位置输出。（注：后面如无特殊说明，mixin 均用来指代此类混入。）</li>
</ul>
<p>举例来说： </p>
<pre><code>.alert {
  font-weight: 700;
}

.highlight(@color: red) {
  font-size: 1.2em;
  color: @color;
}

.heads-up {
  .alert;
  .highlight(red);
}
</code></pre><p>最后输出： </p>
<pre><code>.alert {
  font-weight: 700;
}
.heads-up {
  font-weight: 700;
  font-size: 1.2em;
  color: red;
}
</code></pre><p>可以混入已有类样式这一点很值得商榷。在上面的例子中，<code>.alert</code> 样式在被混入时甚至可以是 <code>.alert();</code>；<code>.highlight()</code> 混入时也可以写成 <code>.highlight;</code>。那么我们遇到这样的代码时根本不知道 <code>alert</code> 会不会是一个 HTML class。但由于这一点是在 Less 还不支持 <code>extend</code> 时就有的，所以也能够理解作者可能就是将这作为 <code>extend</code> 来用了。所以目前比较好的实践是：用代码规范规约开发者不得使用直接混入已有类样式的方式，而是先定义 mixin 然后在输出的类样式中进行调用，调用时必须显式加上 <code>()</code> 来表明这不是一个 class（事实上百度 EFE 已有的 <a href="https://github.com/ecomfe/spec/blob/master/less-code-style.md#user-content-%E6%B7%B7%E5%85%A5mixin-1" target="_blank" rel="external">Less 编码规范</a>就是这么定义的）。继承则应该直接通过 Less 的 <code>:extend</code> 来实现。 </p>
<p>另外需要注意的是，Less 在进行混入时，会找到所有符合调用参数的「mixin 签名」的样式一起输出。比如： </p>
<pre><code>.mixin(dark; @color) {
  color: darken(@color, 10%);
}
.mixin(light; @color) {
  color: lighten(@color, 10%);
}
.mixin(@_; @color) {
  display: block;
}

@switch: light;
.class {
  .mixin(@switch; #888);
}
</code></pre><p>这个例子中，第二个和第三个 mixin 都匹配了调用时的参数，于是它们的规则都会被输出： </p>
<pre><code>.class {
  color: #a2a2a2;
  display: block;
}
</code></pre><p>也就是说同名的 mixin 不是后面覆盖前面，而是会累加输出。只要参数符合定义，就会将 mixin 内部的样式规则、甚至变量全部拷贝到目标作用域下。 </p>
<p>这一点同样会带来一个问题：如果存在和 mixin 同名的 class 样式，如果 mixin 没有参数则在调用时会把对应的 class 样式一起输出，这显然是不符合预期的。 </p>
<p>假设有个叫 <code>.clearfix</code> 的 mixin，有两个 class 样式调用了它（其中一个也叫 <code>clearfix</code>）： </p>
<pre><code>.clearfix() {
  *zoom: 1;
  &amp;:before,
  &amp;:after {
    display: table;
    content: &quot;&quot;;
  }
}

.clearfix {
  .clearfix();
}

.list {
  .clearfix();
}
</code></pre><p>得到的输出是： </p>
<pre><code>.clearfix {
  *zoom: 1;
}
.clearfix:before,
.clearfix:after {
  display: table;
  content: &quot;&quot;;
}
.clearfix:after {
  clear: both;
}
.list {
  *zoom: 1;
}
.list:before,
.list:after {
  display: table;
  content: &quot;&quot;;
}
.list:after {
  clear: both;
}
.list:before,
.list:after {
  display: table;
  content: &quot;&quot;;
}
.list:after {
  clear: both;
}
</code></pre><p><code>.list</code> 的样式调用了两次！这一点在开发中一定要注意，不要给和非输出型 mixin 同名的类定义样式。 </p>
<p>对于 Sass，语义非常明确： </p>
<pre><code>@mixin large-text {
  font: {
    family: Arial;
    size: 20px;
    weight: bold;
  }
  color: #ff0000;
}

.page-title {
  @include large-text;
  padding: 4px;
  margin-top: 10px;
}
</code></pre><p>Sass 用 <code>@mixin</code> 和 <code>@include</code></p>
<p>两个指令清楚地描述了语义，不存在混入类样式的情况，但是书写时略显繁琐一些。当然，用 Sass 语法 而非 SCSS 语法的话可以简单地用 <code>=</code>定义 mixin，用 <code>+</code>引入 mixin： </p>
<pre><code>=large-text
  font:
    family: Arial
    size: 20px
    weight: bold
  color: #ff0000

.page-title
  +large-text
  padding: 4px
  margin-top: 10px
</code></pre><p>和 Less 不同，同名的 mixin 可以覆盖之前的定义，作用机制类似变量。 </p>
<p>Stylus 和 Sass 类似，但不用什么特殊的标记来引入： </p>
<pre><code>border-radius(n)
  -webkit-border-radius: n
  -moz-border-radius: n
  border-radius: n

.circle
  border-radius(50%)
</code></pre><p>Stylus 中还有一个「透明 mixin」的功能，也就是说引入 mixin 完全可以和引入普通属性一样！例如上面的这个 mixin，也可以这样引入： </p>
<pre><code>.circle
  border-radius: 50%
</code></pre><p>这意味着可以把兼容性上的处理隐藏在 mixin 中，直接用标准属性同名的 mixin 按普通属性的方式输出。当不需要兼容老浏览器时，直接把 mixin 定义删除仍然能够正常输出。不过这种写法虽然感觉非常「爽快」，但要求开发者必须能很好地区分原生属性和某个样式库中提供的 mixin 功能（对于有经验的开发者问题不大），而且透明意味着看到一个普通属性开发者不能判断是否已经在某处用 mixin 进行了重写，无法明确知道这里的代码最后输出会不会发生变化。在可控条件下，这个功能应该说是非常诱人的。 </p>
<h2 id="将声明块作为混入参数"><a href="#将声明块作为混入参数" class="headerlink" title="将声明块作为混入参数"></a>将声明块作为混入参数</h2><p>如果说调用时想传入一组样式声明而非单个值，三种预处理器都提供了相应的功能，但实现方式各有不同。 </p>
<p>在 Less 中需要先定义一个「规则集变量」（detached ruleset，其实就是 CSS 声明块，即规则集去掉选择器的部分），然后在调用 mixin 时把它作为参数传进去，然后在 mixin 中用 <code>@var()</code> 的方式输出： </p>
<pre><code>.red(@custom) {
  color: red;
  @custom();
}

.alert {
  @styles: {
    font-weight: 700;
    font-size: 1.5em;
  }

  .red(@styles);
}
</code></pre><p>在 Sass 和 Stylus 中，都支持直接在 mixin 调用下层传入声明块： </p>
<p>Sass 下直接跟一个声明块即可，然后用关键字 <code>@content</code> 来进行输出： </p>
<pre><code>@mixin red() {
  color: red;
  @content;
}

.alert {
  @include red() {
    font-weight: 700;
    font-size: 1.5em;
  }
}
</code></pre><p>Stylus 支持两种方法，首先是 Less 那样的「具名」声明块，调用时当做变量： </p>
<pre><code>red(foo)
  color: red
  {foo}

.alert
  foo =
    font-weight: 700
    font-size: 1.5em
  red(foo)
</code></pre><p>第二种是 Sass 那样类似传入「字面量」，并且用关键词 block 输出的方式。这种方式需要为要传入声明块的 mixin 前添加一个 <code>+</code> 符号（可能是来自 SCSS 的对应功能）： </p>
<pre><code>red()
  color: red
  {block}

.alert
  +red()
    font-weight: 700
    font-size: 1.5em
</code></pre><p>第二种方式可以看做是第一种方式的语法糖，在 mixin 只需要传入一个声明块时可以免去起名字带来的困扰。 </p>
<p>相比之下 Less 只支持先定义变量后传入的方式，优点是可以传入多个声明块；而 Sass 只支持传入一个「匿名」声明块但是更简单；Stylus 则是两种方式都支持。这个功能在抽象「需要应用样式的条件」时非常有用，比如我们基于 Stylus 的样式库 <a href="https://github.com/ecomfe/rider" target="_blank" rel="external">rider</a> 中就用它来实现<a href="https://github.com/ecomfe/rider/blob/master/lib/rider/breakpoint.styl" target="_blank" rel="external">对 media query 的抽象封装</a>。 </p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>混入很好用，可也有问题：如果多个地方都混入同样的代码，会造成输出代码的多次重复。比如在 Stylus 下： </p>
<pre><code>message()
  padding: 10px
  border: 1px solid #eee

.message
  message()

.warning
  message()
  color: #e2e21e
</code></pre><p>会输出： </p>
<pre><code>.message {
  padding: 10px;
  border: 1px solid #eee;
}
.warning {
  padding: 10px;
  border: 1px solid #eee;
  color: #e2e21e;
}
</code></pre><p>而我们可能期望的输出是： </p>
<pre><code>.message,
.warning {
  padding: 10px;
  border: 1px solid #eee;
}
.warning {
  color: #e2e21e;
}
</code></pre><p>也许大家会说可以这么写： </p>
<pre><code>message()
  padding: 10px
  border: 1px solid #eee

.message,
.warning
  message()

.warning
  color: #e2e21e
</code></pre><p>这样就可以按需要输出了。但其实预处理器的一个好处就是可以方便我们进行模块化开发。上面的例子中，<code>.message</code> 和 <code>.warning</code> 的样式如果是分布在两个模块中的，我合并过的选择器组样式写在哪里呢？情况更复杂的时候就更棘手了。 </p>
<p>这个时候就该继承出场了： </p>
<pre><code>.message
  padding: 10px
  border: 1px solid #eee

.warning
  @extend .message
  color: #e2e21e
</code></pre><p>这样就可以按模块进行开发（不管是分文件还是在同一文件中按业务功能安排样式的顺序），同时兼顾输出的效率了。 </p>
<p>Stylus 的继承方式来自 Sass，两者如出一辙。 而 Less 则又「独树一帜」地用伪类来描述继承关系： </p>
<pre><code>.message {
  padding: 10px;
  border: 1px solid #eee;
}

.warning {
  &amp;:extend(.message);
  color: #e2e21e;
}
/* Or:
.warning:extend(.message) {
  color: #e2e21e;
}
*/
</code></pre><p>同时，Less 默认只继承父类本身的样式，如果要同时继承嵌套定义在父类作用域下的样式，得使用关键字 <code>all</code>，比如 <code>&amp;:extend(.message all);</code>。 </p>
<p>关于使用伪类描述继承关系，<a href="http://weibo.com/u/1960954893" target="_blank" rel="external">Hax</a> 在 Less 的另一个 issue 下曾经<a href="https://github.com/less/less.js/issues/1177#issuecomment-17404003" target="_blank" rel="external">言辞激烈地提出了批评</a>，同时也遭到了 Less 项目组毫不客气的回应。我个人完全赞同 Hax 的看法，因为选择器是用来在树结构中找到元素的，和样式本身完全无关。但 Less 社区在当时却对<a href="https://github.com/less/less.js/pull/509#issuecomment-9963343" target="_blank" rel="external">这个语法</a>表示了一致的赞同，不禁让人对其感到担忧。 </p>
<p>不管语法如何，继承功能还有一个潜在的问题：继承会影响输出的顺序。假设有如下的 Sass 代码： </p>
<pre><code>.active {
   color: red;
}
button.primary {
   color: green;
}
button.active {
   @extend .active;
}
</code></pre><p>而对应的 HTML 代码是： </p>
<pre><code>&lt;button class=&quot;primary active&quot;&gt;Submit&lt;/button&gt;
</code></pre><p>很容易误以为效果是红色的。而其实生成的 CSS 顺序如下： </p>
<pre><code>.active, button.active {
  color: red;
}

button.primary {
  color: green;
}
</code></pre><p>由于合并选择器的关系 <code>.active</code> 被移到了 <code>.primary</code> 之前，所以依赖顺序而非选择器 specificity 时可能会遇到陷阱。 </p>
<h2 id="placeholder"><a href="#placeholder" class="headerlink" title="placeholder"></a>placeholder</h2><p>Placeholder 是什么？简单来说就是一个声明块（预处理器 DSL 中的声明块，包含其下嵌套规则），但是不会在最终的 CSS 中输出。其实这是一组「抽象」样式，只存在于预处理器的编译过程中（类似 mixin），但不同之处是它可以被继承。这样我们就可以在纯样式层为声明块起与样式强耦合的名称而不怕它出现在 CSS 与 HTML 的「接口」——选择器之中了。 </p>
<p>Sass： </p>
<pre><code>%red-card {
  border: 1px solid #300;
  background-color: #ecc;
  color: #c00;
}

.alert {
  @extend %red-card;
}
</code></pre><p>Stylus： </p>
<pre><code>$red-card
  border: 1px solid #300
  background-color: #ecc
  color: #c00

.alert
  @extend $red-card
</code></pre><p>均输出： </p>
<pre><code>.alert {
  border: 1px solid #300;
  background-color: #ecc;
  color: #c00;
}
</code></pre><p>Less 目前不支持这个功能，但开发组目前的共识是可能会用<a href="https://github.com/less/less.js/issues/1878" target="_blank" rel="external">继承 mixin</a> 的方式来实现，比如上面的这个例子未来可能可以通过如下方法实现： </p>
<pre><code>   [16]: https://github.com/less/less.js/issues/1177
</code></pre><p>.red-card() {<br>border: 1px solid #300;<br>background-color: #ecc;<br>color: #c00;<br>} </p>
<pre><code>.alert {
  &amp;:extend(.red-card());
}
</code></pre><p>当前在 Less 下也有一个 hack 来模拟 placeholder 功能，原理是利用 <code>@import (reference)</code> 来实现「placeholder」不输出的功能： </p>
<pre><code>// placeholder.less
.red-card {
  border: 1px solid #300;
  background-color: #ecc;
  color: #c00;
}

// style.less
@import (reference) &quot;placeholder.less&quot;;
.alert {
  &amp;:extend(.red-card);
}
</code></pre><p>不过 <code>@import (reference)</code> 在复杂一些的情况下（被引入的文件有 <code>@import</code>、有 <code>:extend</code> 等）可能会遇到一些 bug，比如：<a href="https://github.com/less/less.js/issues/1851" target="_blank" rel="external">#1851</a>、<a href="https://github.com/less/less.js/issues/1878" target="_blank" rel="external">#1878</a>、<a href="https://github.com/less/less.js/issues/1896" target="_blank" rel="external">#1896</a>。目前以 reference 方式引入 Bootstrap 时就会直接产生代码输出。 </p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>先说说原生函数。三种预处理器都自带了诸如色彩处理、类型判断、数值计算等内置函数，目前版本的数量都在 80 个左右。由于 Sass 和 Stylus 都内置脚本语言，所以自带函数中包括了很多处理不同数据类型、修改选择器的函数。Sass 更是提供了不少特性检测函数比如 <a href="http://sass-lang.com/documentation/Sass/Script/Functions.html#feature_exists-instance_method" target="_blank" rel="external">feature-exists($feature)、variable-exists($name)</a> 等，这为第三方库的兼容性提供了很好的保障。因为有了这些函数可以方便地对不同版本的 Sass 编译器有针对性地提供兼容，而不怕在老版本的编译环境中直接报错。 </p>
<p>三者调用函数的方式几乎一致，不同之处在于 Sass 和 Stylus 支持直接指定参数名的方式传入参数。以 Stylus 为例： </p>
<pre><code>subtract(a, b)
  a - b

subtract(b: 10, a: 25) // same as substract(25, 10)
</code></pre><p>这样做的好处是，如果参数列表比较长，Stylus 可以直接为列表后面的参数赋值，而不需要一路将之前的参数填上 <code>null</code> 或默认值。Stylus 将这个特性称为「Named parameters」，而 Sass 称为「Keyword arguments」。 </p>
<p>关于函数，真正的区别在于：Sass 和 Stylus 都支持用 DSL 直接添加自定义函数，而 Less 中如果要添加自定义函数必须通过使用插件（2.0.0 以后的版本才支持插件）。这决定了用 Sass 和 Stylus 书写的代码可移植性更高，不需要编译环境有插件即可运行，而 Less 则需要额外添加编译时的依赖。 </p>
<p>Sass 中自定义函数需要使用 <code>@function</code> 指令，并用 <code>@return</code> 指令返回结果： </p>
<pre><code>@function golden-ratio($n) {
  @return $n * 0.618;
}

.golden-box {
  width: 200px;
  height: golden-ratio(200px);
}
</code></pre><p>在 Stylus 中，这些都是隐含的，最后一个表达式的值会作为返回值： </p>
<pre><code>golden-ratio(n)
  n * 0.618

.golden-box
  width: 200px
  height: golden-ratio(@width)
</code></pre><p>这种写法和 mixin 有什么区别？当把函数作为 mixin 调用时，如果其中有 <code>prop: value</code> 这样格式的内容，就会被当做样式规则输出。Stylus 中大量的内容都是根据调用时的 context 去隐式推断该使用什么逻辑进行输出，而非 Less 和 Sass 那样使用关键字去显式地进行区分。 </p>
<h2 id="逻辑控制"><a href="#逻辑控制" class="headerlink" title="逻辑控制"></a>逻辑控制</h2><p>Sass 中通过常见的 <code>@if</code>、<code>@else if</code>、<code>@else</code> 实现条件分支，通过 <code>@for</code>、<code>@each</code>、<code>@while</code> 实现循环，配合 map 和 list 这两种数据类型可以轻松地实现多数编程语言提供的功能。 </p>
<p>在 Stylus 中，不需要使用 <code>@</code> 规则，提供了 <code>if</code>、<code>else if</code>、<code>else</code>、<code>unless</code>、<code>for...in</code> 来实现类似功能，语法比 Sass 更简洁灵活。 </p>
<p>再来看 Less，上面说到的功能 Less 都没有提供。那在 Less 中如何进行逻辑控制呢？Less 中只有一个方式：使用 mixin。 </p>
<p>Less 中的 mixin 通过「guard」的方式支持简单的条件分支控制。比如我们要实现一个控制 <code>::placeholder</code> 样式的 mixin，当传入颜色时只设置颜色，当传入声明块时输出对应的样式规则，其他情况输出一个默认的 <code>color</code>： </p>
<pre><code>.mixin(@val) when (iscolor(@val)) {
  color: @val;
}
.mixin(@val) when (isruleset(@val)) {
  @val();
}
.mixin(@val) when (default()) {
  // default() in guards acts as else
  color: #666;
}
</code></pre><p>Guard 语句中的语法非常类似 CSS media query 中的对应功能，事实上这也是 Less 一直以来的理念：保持声明式语法，弱化指令和流程。但是事实上，这为书写需要提供灵活接口的样式库造成了非常大的不便。最简单的三元表达式在 Less 中也需要先定义一个 mixin，根据判断条件写对应的 guard 表达式，然后再输出。 </p>
<p>而对于循环，Less 本身并不支持。但官网给出了一个使用 mixin 递归调用模拟循环的例子： </p>
<pre><code>.loop(@counter) when (@counter &gt; 0) {
  .loop((@counter - 1));    // next iteration
  width: (10px * @counter); // code for each iteration
}

div {
  .loop(5); // launch the loop
}
</code></pre><p>编译结果为： </p>
<pre><code>div {
  width: 10px;
  width: 20px;
  width: 30px;
  width: 40px;
  width: 50px;
}
</code></pre><p>这是一种非常别（dàn）扭（téng）的实现方式，但从 Less 开发团队的态度来看，未来并没什么可能在 Less 中见到真正的条件分支和循环——因为「Less 不是 Sass」。 </p>
<p>由于逻辑处理能力不能与 Sass 和 Stylus 相比，所以在 Less 中可能还会需要借助 JS 表达式来进行 mixin 参数的解析处理。这个功能 Less 官方已经是不推荐使用的了（已经从官网文档中移除）——因为使用这一功能也会导致 Less 代码的可移植性变低，因为直接内嵌 JS 代码，所以无法使用 <a href="http://www.dotlesscss.org/" target="_blank" rel="external">dotless</a> 等其他语言的 Less 编译器进行处理。而且不同 JS 引擎还可能有兼容性差异。 </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我个人认为，Less 从语言特性的设计到功能的健壮程度和另外两者相比都有一些缺陷，但因为 Bootstrap 引入了 Less，导致 Less 在今天还是有很多用户。用 Less 可以满足大多数场景的需求，但相比另外两者，基于 Less 开发类库会复杂得多，实现的代码会比较脏，能实现的功能也会受到 DSL 的制约。比 Stylus 语义更清晰、比 Sass 更接近 CSS 语法，使得刚刚转用 CSS 预编译的开发者能够更平滑地进行切换。当初 Sass 并不支持 SCSS 语法，使得转投 Sass 成本较高，所以 <a href="http://cloudhead.io/" target="_blank" rel="external">Alexis Sellier</a>才萌生开发一个更「CSS」的预处理器的念头。大获成功以后反过来影响到了 Sass，迫使其也支持类似 CSS 语法的 SCSS。另外，Less 支持浏览器端编译，这无疑降低了开发门槛，使得很多非专业的开发者能够更快地上手（对于一些个人项目来说，能让项目跑起来就行，对前端的性能并没有专业工程师那么高的要求）。 </p>
<p>Sass 在三者之中历史最久，也吸收了其他两者的一些有点。从功能上来说 Sass 大而全，语义明晰但是代码很容易显得累赘。主项目基于 Ruby 可能也是一部分人不选择它的理由（Less 开始也是基于 Ruby 开发，后来逐渐转到 <a href="https://github.com/less/less.js" target="_blank" rel="external">less.js</a> 项目中）。 Sass 有一个「事实标准」库——<a href="http://compass-style.org/" target="_blank" rel="external">Compass</a>，于是对于很多开发者而言省去了选择类库的烦恼，对于提升开发效率也有不小的帮助。 </p>
<p>Stylus 的语法非常灵活，很多语义都是根据上下文隐含的。基于 Stylus 可以写出非常简洁的代码，但对使用团队的开发素养要求也更高，更需要有良好的开发规范或约定。Stylus 是前 Node.js 圈第一大神 <a href="https://github.com/tj/" target="_blank" rel="external">TJ Holowaychuk</a> 的作品，虽然他已经弃坑了，但是仍然有不小的号召力。和 Sass 有 Compass 类似，Stylus 有一个官方开发的样式库 <a href="http://tj.github.io/nib/" target="_blank" rel="external">nib</a>，同样提供了不少好用的 mixin。对于比较有经验的开发者，用 Stylus 可能更会有一种畅快的感觉。总的来说用一个词形容 Stylus 的话，我会用「sexy」。 </p>
<p>总的来说，三种预处理器百分之七八十的功能是类似的。Less 适合帮助团队更快地上手预处理代码的开发，而 Sass 和 Stylus 的差异更在于口味。比如有的人喜欢 jQuery 用一个 <code>$</code> 做大部分的事，而另一些人觉得不一样的功能就该有明确的语义上的差别。在这里我不会做具体的推荐。当然，再次声明一下由于我个人接触 Less 开发比较多，所以可能遇到的坑也多一些，文中没有列出 Sass 和 Stylus 的问题并不代表他们没有。 </p>
<blockquote>
<p><strong>特别声明：本文转自<a href="http://efe.baidu.com/" target="_blank" rel="external">百度EFE团队</a>的<a href="http://weibo.com/u/1143654280" target="_blank" rel="external">@Justineo</a>写的《<a href="http://efe.baidu.com/blog/revisiting-css-preprocessors/" target="_blank" rel="external">再谈 CSS 预处理器</a>》。如需转载，烦请注明原文出处：<a href="http://efe.baidu.com/blog/revisiting-css-preprocessors/" target="_blank" rel="external">http://efe.baidu.com/blog/revisiting-css-preprocessors/</a></strong></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
    
    </summary>
    
      <category term="VueJs" scheme="https://wangyu1997.github.io/categories/VueJs/"/>
    
    
      <category term="vue" scheme="https://wangyu1997.github.io/tags/vue/"/>
    
      <category term="css" scheme="https://wangyu1997.github.io/tags/css/"/>
    
      <category term="loader" scheme="https://wangyu1997.github.io/tags/loader/"/>
    
      <category term="stylus" scheme="https://wangyu1997.github.io/tags/stylus/"/>
    
  </entry>
  
  <entry>
    <title>Vue轮播解决方案--BetterScroll</title>
    <link href="https://wangyu1997.github.io/2017/10/03/VueJs/BetterScroll/"/>
    <id>https://wangyu1997.github.io/2017/10/03/VueJs/BetterScroll/</id>
    <published>2017-10-02T17:43:11.000Z</published>
    <updated>2017-10-24T07:13:58.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a> 
<p>From: <a href="https://wangyu1997.github.io/2017/10/03/VueJs/BetterScroll/">https://wangyu1997.github.io/2017/10/03/VueJs/BetterScroll/</a></p>
<p>inspired by iscroll, and it has a better scroll perfermance <a href="https://link.juejin.im?target=https%3A%2F%2Fustbhuangyi.github.io%2Fbetter-scroll%2F" target="_blank" rel="external">ustbhuangyi.github.io/better-scro…</a></p>
<h2 id="立即使用"><a href="#立即使用" class="headerlink" title="立即使用"></a>立即使用</h2><pre><code>&lt;body&gt;
  &lt;div id=&quot;wrapper&quot;&gt;
    &lt;ul&gt;
           &lt;li&gt;...&lt;/li&gt;
           &lt;li&gt;...&lt;/li&gt;
           ...
    &lt;/ul&gt;
  &lt;/div&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;better-scroll.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  new BScroll(document.getElementById(&#39;wrapper&#39;));
&lt;/script&gt;
&lt;/body&gt;
</code></pre><p>搞定 ! </p>
<h2 id="通过npm引入"><a href="#通过npm引入" class="headerlink" title="通过npm引入"></a>通过npm引入</h2><p>安装better-scroll </p>
<pre><code>npm install better-scroll
</code></pre><p>引入better-scroll </p>
<pre><code>import BScroll from &#39;better-scroll&#39;
</code></pre><blockquote>
<p>如果不支持import, 请使用 </p>
</blockquote>
<pre><code>var BScroll = require(&#39;better-scroll&#39;)
</code></pre><h2 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h2><p>better-scroll 的源码是基于 Webpack 构建的 </p>
<p>首先，clone项目源码 </p>
<pre><code>git clone https://github.com/ustbhuangyi/better-scroll.git
</code></pre><p>安装依赖 </p>
<pre><code>cd better-scroll
npm install
</code></pre><p>测试demo页 </p>
<pre><code>npm run dev
</code></pre><p>打开浏览器访问如下地址, 查看效果 </p>
<blockquote>
<p>localhost:9090 </p>
</blockquote>
<h2 id="Options-参数"><a href="#Options-参数" class="headerlink" title="Options 参数"></a>Options 参数</h2><p>Example: </p>
<pre><code>let scroll = new BScroll(document.getElementById(&#39;wrapper&#39;), {
  startX: 0,
  startY: 0
})
</code></pre><p>Options List: </p>
<ul>
<li>startX: <code>0</code> 开始的X轴位置</li>
<li>startY: <code>0</code> 开始的Y轴位置</li>
<li>scrollY: <code>true</code> 滚动方向为 Y 轴</li>
<li>scrollX: ‘true’ 滚动方向为 X 轴</li>
<li>click: <code>true</code> 是否派发click事件</li>
<li>directionLockThreshold: <code>5</code></li>
<li>momentum: <code>true</code> 当快速滑动时是否开启滑动惯性</li>
<li>bounce: <code>true</code> 是否启用回弹动画效果</li>
<li>selectedIndex: <code>0</code> wheel 为 true 时有效，表示被选中的 wheel 索引</li>
<li>rotate: <code>25</code> wheel 为 true 时有效，表示被选中的 wheel 每一层的旋转角度</li>
<li>wheel: <code>false</code> 该属性是给 picker 组件使用的，普通的列表滚动不需要配置</li>
<li>snap: <code>false</code> 该属性是给 slider 组件使用的，普通的列表滚动不需要配置</li>
<li>snapLoop: <code>false</code> 是否可以无缝循环轮播</li>
<li>snapThreshold: <code>0.1</code> 用手指滑动时页面可切换的阈值，大于这个阈值可以滑动的下一页</li>
<li>snapSpeed: <code>400</code>, 轮播图切换的动画时间</li>
<li>swipeTime: <code>2500</code> swipe 持续时间</li>
<li>bounceTime: <code>700</code> 弹力动画持续的毫秒数</li>
<li>adjustTime: <code>400</code> wheel 为 true 有用，调整停留位置的时间</li>
<li>swipeBounceTime: <code>1200</code> swipe 回弹 时间</li>
<li>deceleration: <code>0.001</code> 滚动动量减速越大越快，建议不大于0.01</li>
<li>momentumLimitTime: <code>300</code> 符合惯性拖动的最大时间</li>
<li>momentumLimitDistance: <code>15</code> 符合惯性拖动的最小拖动距离</li>
<li>resizePolling: <code>60</code> 重新调整窗口大小时，重新计算better-scroll的时间间隔</li>
<li>preventDefault: <code>true</code> 是否阻止默认事件</li>
<li>preventDefaultException: <code>{ tagName: /^(INPUT|TEXTAREA|BUTTON|SELECT)$/ }</code> 阻止默认事件的例外配置</li>
<li>HWCompositing: <code>true</code> 是否启用硬件加速</li>
<li>useTransition: <code>true</code> 是否使用CSS3的Transition属性</li>
<li>useTransform: <code>true</code> 是否使用CSS3的Transform属性</li>
<li>probeType: <code>1</code> 会截流,只有在滚动结束的时候派发一个 scroll 事件。<code>2</code>在手指 move 的时候也会实时派发 scroll 事件，不会截流。 <code>3</code>除了手指 move 的时候派发scroll事件，在 swipe（手指迅速滑动一小段距离）的情况下，列表会有一个长距离的滚动动画，这个滚动的动画过程中也会实时派发滚动事件</li>
</ul>
<h2 id="Events-事件"><a href="#Events-事件" class="headerlink" title="Events 事件"></a>Events 事件</h2><p>Example: </p>
<pre><code>let scroll = new BScroll(document.getElementById(&#39;wrapper&#39;),{
   probeType: 3
})

scroll.on(&#39;scroll&#39;, (pos) =&gt; {
  console.log(pos.x + &#39;~&#39; + pos.y)
  ...
})
</code></pre><p>Events 列表 </p>
<ul>
<li>beforeScrollStart - 滚动开始之前触发</li>
<li>scrollStart - 滚动开始时触发</li>
<li>scroll - 滚动时触发</li>
<li>scrollCancel - 取消滚动时触发</li>
<li>scrollEnd - 滚动结束时触发</li>
<li>touchend - 手指移开屏幕时触发</li>
<li>flick - 轻拂时触发</li>
<li>refresh - 当 better-scroll 刷新时触发</li>
<li>destroy - 销毁 better-scroll 实例时触发</li>
</ul>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul>
<li>scrollTo(x, y, time, easing)</li>
</ul>
<p>滚动到某个位置，x,y 代表坐标，time 表示动画时间，easing 表示缓动函数 </p>
<p>Example: </p>
<pre><code>let scroll = new BScroll(document.getElementById(&#39;wrapper&#39;))
scroll.scrollTo(0, 500)
...
</code></pre><ul>
<li>scrollToElement(el, time, offsetX, offsetY, easing)</li>
</ul>
<p>滚动到某个元素，el（必填）表示 dom 元素，time 表示动画时间，offsetX 和 offsetY 表示坐标偏移量，easing 表示缓动函数 </p>
<ul>
<li>refresh()</li>
</ul>
<p>强制 scroll 重新计算，当 better-scroll 中的元素发生变化的时候调用此方法。 </p>
<ul>
<li>getCurrentPage()</li>
</ul>
<p>当 snap 为 true 时，获取滚动的当前页，返回的对象结构为 {x, y, pageX, pageY}，其中 x,y 代表滚动横向和纵向的位置；pageX，pageY 表示横向和纵向的页面索引 </p>
<ul>
<li>goToPage(x, y, time, easing)</li>
</ul>
<p>当 snap 为 true，滚动到对应的页面，x 表示横向页面索引，y 表示纵向页面索引， time 表示动画，easing 表示缓动函数 </p>
<ul>
<li>enable()</li>
</ul>
<p>启用 better-scroll，默认开启 </p>
<ul>
<li>disable()</li>
</ul>
<p>禁用 better-scroll </p>
<ul>
<li>destroy()</li>
</ul>
<p>销毁 better-scroll，解绑事件 </p>
]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
    
    </summary>
    
      <category term="VueJs" scheme="https://wangyu1997.github.io/categories/VueJs/"/>
    
    
      <category term="better scroll" scheme="https://wangyu1997.github.io/tags/better-scroll/"/>
    
      <category term="vue" scheme="https://wangyu1997.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue实战</title>
    <link href="https://wangyu1997.github.io/2017/10/02/VueJs/Vue%E5%AE%9E%E6%88%98/"/>
    <id>https://wangyu1997.github.io/2017/10/02/VueJs/Vue实战/</id>
    <published>2017-10-01T17:43:11.000Z</published>
    <updated>2017-10-24T07:13:50.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a> 
<p>这个系统使用的技术栈为：Vue+Webpack+Element+Axios+vueRouter.系统是一个快餐店的POS系统，当然我们不可能实现一个完整POS系统的所有功能（业余时间我会开发完成并开源），我们在视频中只完成收银模块的制作。你在这个视频中会学习到很多实战的技巧，让你在真实的工作中得心应手，脱颖而出。 </p>
<p>如果你是一个Vue新手，你可能还不能完全掌握文章的内容，你需要一些Vue的初级知识和中级知识。如果你是新手是不是感到很无奈，幸运的是本站为你提供了全部的前置视频学习资源，你可以踏踏实实的学习。 </p>
<h3 id="学习前置课程："><a href="#学习前置课程：" class="headerlink" title="学习前置课程："></a>学习前置课程：</h3><p><strong>初级课程：</strong></p>
<ol>
<li><a href="https://link.juejin.im?target=http%3A%2F%2Fjspang.com%2F2017%2F02%2F23%2Fvue2_01%2F" target="_blank" rel="external">【第一季】Vue2.0视频教程-内部指令(共8集)</a></li>
<li><a href="https://link.juejin.im?target=http%3A%2F%2Fjspang.com%2F2017%2F03%2F14%2Fvue2_02%2F" target="_blank" rel="external">【第二季】Vue2.0视频教程-全局API(共9集)</a></li>
<li><a href="https://link.juejin.im?target=http%3A%2F%2Fjspang.com%2F2017%2F03%2F26%2Fvue3%2F" target="_blank" rel="external">【第三季】Vue2.0视频教程-选项（共6集）</a></li>
<li><a href="https://link.juejin.im?target=http%3A%2F%2Fjspang.com%2F2017%2F04%2F09%2Fvue2_4%2F" target="_blank" rel="external">【第四季】Vue2.0视频教程-实例和内置组件（共4集）</a></li>
</ol>
<p><strong>中级课程：</strong></p>
<ol>
<li><a href="https://link.juejin.im?target=http%3A%2F%2Fjspang.com%2F2017%2F04%2F10%2Fvue-cli%2F" target="_blank" rel="external">技术胖的Vue-cli 视频教程（共3集）</a></li>
<li><a href="https://link.juejin.im?target=http%3A%2F%2Fjspang.com%2F2017%2F04%2F13%2Fvue-router%2F" target="_blank" rel="external">技术胖的Vue-router视频教程（共11集）</a></li>
<li><a href="https://link.juejin.im?target=http%3A%2F%2Fjspang.com%2F2017%2F05%2F03%2Fvuex%2F" target="_blank" rel="external">技术胖的vuex视频教程（共6集）</a></li>
</ol>
<p>Mockplus是产品经理装逼使用的利器，但是真的很好用，作为一个已经工作的程序员必须舔产品经理的脸，所以你也要对Mockplus的使用有所了解，并会简单的使用。其实Mockplus就是一个线框图制作工具，能把我们的想法或者不太好用语言表达的地方，快速画出线框草图增加理解能力。 </p>
<h3 id="为什么选择快餐店POS系统？"><a href="#为什么选择快餐店POS系统？" class="headerlink" title="为什么选择快餐店POS系统？"></a>为什么选择快餐店POS系统？</h3><p>刚开始我想作一套以酒水商城为背景的手机端应用，但是我发现网上这样的应用太多了，什么仿饿了么，什么知乎，什么购物车都可以在网上找到，所以你完全可以Github网站中下载，自学掌握。我觉的既然作了这个实战，就要够酷够复杂，我下面列举了三个原因，大家可以看一下（你其实可以忽略前两点）。 </p>
<ul>
<li>这个收银界面足够复杂：我们采用三栏布局，每栏的交互操作都很有技术技巧，让你快速掌握复杂应用的开发。</li>
<li>用到的知识点多：用到实战中90%以上的知识点，让你把Vue的知识串联起来，快速成为单位中的技术牛人。</li>
<li>为了更好的和女神啪啪啪：京东-强东哥的女神愿望就是开奶茶店，我的女神愿望就是开个快餐店。</li>
</ul>
<h3 id="MockPlus软件下载："><a href="#MockPlus软件下载：" class="headerlink" title="MockPlus软件下载："></a>MockPlus软件下载：</h3><p>Mockplus是一款免费的软件，你可以随便下载：<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.mockplus.cn%2F" target="_blank" rel="external">www.mockplus.cn/</a> 。下载好后你需要注册一个账户，就可以正常使用了。 </p>
<p><img src="https://user-gold-cdn.xitu.io/2017/6/15/fcb4c4f46535eea5ef279118eec3ce60?imageView2/0/w/1280/h/960" alt=""></p>
<p>软件的基本需求分析和画的过程，请看视频，这里就不用文字描述了，去看视频吧。 </p>
<h3 id="项目框线图；"><a href="#项目框线图；" class="headerlink" title="项目框线图；"></a>项目框线图；</h3><p>下面是我们用Mockplus制作的应用框线图，虽然简单，但是已经把我脑海中快餐店Pos系统的大体样式画出来了。在作项目之前，一定要画出框线图，反复讨论需求和技术实现，这样能避免开发中的大范围修改，在实际工作当中非常重要。 </p>
<p><img src="https://user-gold-cdn.xitu.io/2017/6/15/5060628e6a2352003bd2ac33c04792b9?imageView2/0/w/1280/h/960" alt=""></p>
<p>我们采用Vue-cli进行快速搭建，如果你对Vue-cli还不了解，请观看下面的文章，大概30分钟可完全掌握Vue-cli。 </p>
<ol>
<li><a href="https://link.juejin.im?target=http%3A%2F%2Fjspang.com%2F2017%2F04%2F10%2Fvue-cli%2F" target="_blank" rel="external">技术胖的Vue-cli 视频教程（共3集）</a></li>
</ol>
<h3 id="搭建项目架构："><a href="#搭建项目架构：" class="headerlink" title="搭建项目架构："></a>搭建项目架构：</h3><p>项目采用Webpack+Vue-router的架构方式，开始安装（全部在windows系统上操作，我也没有mac电脑）。 </p>
<ol>
<li><p>按Win+R，然后在文本框中输入cmd，回车打开命令行，输入vue-cli安装命令：</p>
<p>mpm install vue-cli -g</p>
</li>
</ol>
<p>这里的-g代表全局安装。 </p>
<ol>
<li><p>在命令行中初始化项目，我们采用的是webpack模板，输入初始化命令：</p>
<p>vue init webpack AwesomePos</p>
</li>
</ol>
<p>这里的AwesmonePos是我的项目文件夹名称，你可以起一个自己喜欢的名称。安装时根据项目需要配置所需要的模块。这里有一个小技巧，就是在你已经提前建立好了文件夹的时候，我们也进入了文件夹，这时候我们可以省略这个文件夹名称。如下情况： </p>
<pre><code>mikdir AwesomePos
cd AwesomePos
vue init webpack
</code></pre><ol>
<li>在命令行中，进入项目目录，使用npm install 安装package.json里项目的依赖包。如果你网速较慢的话，可以使用淘宝镜像的cnpm来进行安装。</li>
<li>查看是否安装正确。在命令行中输入 npm run dev ，如果能在浏览器中正常打开页面，说明安装正确。</li>
</ol>
<p>到这里为止，我们的项目架构就建立好了，我们需要对Vue-cli给我们生成的文件进行一些必要的修改。 </p>
<h3 id="修改项目文件内容："><a href="#修改项目文件内容：" class="headerlink" title="修改项目文件内容："></a>修改项目文件内容：</h3><ol>
<li><p>修改根目录下的index.html文件，我们想写一些CSS样式，这样作是为了更好的布局，然后修改一下标题栏。让标题符合项目这里起名叫“AwesomePOS-快餐店管理系统”。index.html修改后内容如下。</p>
<p>   &lt;!DOCTYPE html&gt;<br>   <html></html></p>
<pre><code> &lt;head&gt;
   &lt;meta charset=&quot;utf-8&quot;&gt;
   &lt;title&gt;AwesomePOS-快餐管理系统&lt;/title&gt;
   &lt;link rel=&quot;stylesheet&quot; href=&quot;http://at.alicdn.com/t/font_wyhhdpv5lhvbzkt9.css&quot;&gt;
   &lt;style&gt;
     html,body,#app{height:100%;padding: 0;margin:0;}
   &lt;/style&gt;
 &lt;/head&gt;
 &lt;body &gt;
</code></pre></li>
</ol>
<pre><code>        &lt;div id=&quot;app&quot; &gt;&lt;/div&gt;
        &lt;!-- built files will be auto injected --&gt;

      &lt;/body&gt;

    &lt;/html&gt;
</code></pre><ol>
<li><p>新建Pos组件，这个相当于程序员的入口文件。在src/components/page/目录下新建Pos.vue文件。文件内容写出vue模板的架构就可以。</p>
   <template><br>     <div class="pos"><br>      Hello Pos Demo!<br>     </div><br>   </template>

<p>   <script><br>   export default {</p>
<pre><code> name: &#39;Pos&#39;
</code></pre><p>   }<br>   </script></p>
   <style scoped>

   </style>


</li>
</ol>
<ol>
<li><p>修改路由文件，项目根目录/src/router/index.js，让入口文件变成Pos组件。<br>先用import引入了Pos模板组件，然后修改routes里边的内容。如果你对Vue-router的知识还不了解，可以去看我以前的课程，这里就不作过多的讲解了。</p>
<p>import Vue from ‘vue’<br>import Router from ‘vue-router’<br>import Pos from ‘@/components/page/Pos’</p>
<p>Vue.use(Router)</p>
<p>export default new Router({<br> routes: [<br>   {</p>
<pre><code> path: &#39;/&#39;,
 name: &#39;Pos&#39;,
 component: Pos
</code></pre><p>   }<br> ]<br>})</p>
</li>
</ol>
<p>这时候看一下浏览器中的网页，如果显示出了Hello Pos Demo.我们就算成功搭建项目架构了。下节课我们确定一下项目中使用的图标。 </p>
<p>在开发中经常会遇到小图标的使用问题，小图标的使用可以让程序更美观和增加可用性。网上给程序加上小图标的方法有很多。曾经为了寻找一款使用简单，图标美观的图标库，我真的是到处搜索，直到遇到了IconFont，我觉的它能满足我的大部分要求。那在这里我推荐大家使用IconFont，这是阿里巴巴的矢量图标库。（这绝对不是广告，只是自己使用的一些感受） </p>
<p>挑选自己喜欢的图标 </p>
<p>Iconfont中有很多图标，我们可以像在超市逛街一样，挑选自己喜欢的商品，然后放入购物车。 </p>
<h3 id="挑选图标的过程（共6步）"><a href="#挑选图标的过程（共6步）" class="headerlink" title="挑选图标的过程（共6步）"></a>挑选图标的过程（共6步）</h3><ol>
<li>进入网站：Iconfont网址：[<a href="http://www.iconfont.cn][12" target="_blank" rel="external">http://www.iconfont.cn][12</a>]</li>
<li>点击网站上方的“官方图标库”，选择自己喜欢的图标。在这里我选择天猫的图标库。</li>
<li>选择好自己喜欢的图标，你可以有两个选择，下载代码 和 添加至项目。</li>
<li>我们这两选择添加至项目，然后新建项目，并输入名称。</li>
<li>项目添加好后，会自动给我们转入到我们项目库中。点击查看在线链接。</li>
<li>生产css引入的代码，生成后就可以在项目首页index.html引入了。</li>
</ol>
<pre><code>   [12]: http://www.iconfont.cn

 &lt;link rel=&quot;stylesheet&quot; href=&quot;http://at.alicdn.com/t/font_wyhhdpv5lhvbzkt9.css&quot;&gt;
</code></pre><h3 id="图标的使用："><a href="#图标的使用：" class="headerlink" title="图标的使用："></a>图标的使用：</h3><p>图标顺利引入到项目中，已经可以使用它们了，在“我的项目中”你会看到图标的font class值。可以直接复制代码粘贴，也可以自己写代码。 </p>
<pre><code>&lt;i class=&quot;icon iconfont icon-hanbao&quot;&gt;&lt;/i&gt;
</code></pre><p>这样在页面中就可以看到图标了。 </p>
<h3 id="添加更多图标："><a href="#添加更多图标：" class="headerlink" title="添加更多图标："></a>添加更多图标：</h3><p>如果在项目中觉的图标不够用了，需要添加更多图标。可以利用下面四步进行添加。 </p>
<ol>
<li>去Iconfont网站继续挑选，把相中的图标加入购物车中。</li>
<li>把购物车中的图标加入到项目中。</li>
<li>重新生成在线链接。（这部很重要）</li>
<li>在项目主页中(index.html)，更换css引入链接。</li>
</ol>
<p>实战项目开发的知识点就是很多，也很杂，但是这些都很实用，你也会快速成长，不要感觉和Vue无关就忽略，让我们共同努力，变成更好的自己。 </p>
<p>上节学习了inconFont的使用，可以在项目中加入漂亮的icon图标了。这节课我们要快速撸一个侧边栏组件出来。组件的作用就是在可以复用，想在那个页面使用都可以，并且像写html标签一样简单。 </p>
<h3 id="建立leftNav-vue文件："><a href="#建立leftNav-vue文件：" class="headerlink" title="建立leftNav.vue文件："></a>建立leftNav.vue文件：</h3><p>我们在src/components目录下，先新建一个common和page文件夹。 </p>
<ul>
<li>common文件夹用来放共用组件，下面写的leftNav.vue组件就放到这里。</li>
<li>page文件夹用来放我们的页面模板组件，页面的模板文件放到这里。</li>
</ul>
<p>在common文件夹下，新建leftNav.vue文件。 </p>
<p>开始动手写代码： </p>
<p>建立好文件后，我们先给components来个基本组件结构，你可以复制粘贴也可以手写。 </p>
<pre><code>&lt;template&gt;
  &lt;div class=&quot;left-nav&quot;&gt;

  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: &#39;leftNav&#39;,
  data () {
    return {
    }
  }
}
&lt;/script&gt;
&lt;style&gt;

&lt;/style&gt;
</code></pre><p>开始写html结构，我们用列表li来代表导航。菜单栏有收银、店铺、商品、会员、统计。我们编写的html结构如下 </p>
<pre><code> &lt;ul&gt;
        &lt;li&gt;
            &lt;i class=&quot;icon iconfont icon-wodezichan&quot;&gt;&lt;/i&gt;
            &lt;div&gt;收银&lt;/div&gt;
        &lt;/li&gt;

        &lt;li&gt;
            &lt;i class=&quot;icon iconfont icon-dianpu&quot;&gt;&lt;/i&gt;
            &lt;div&gt;店铺&lt;/div&gt;
        &lt;/li&gt;

        &lt;li&gt;
            &lt;i class=&quot;icon iconfont icon-hanbao&quot;&gt;&lt;/i&gt;
            &lt;div&gt;商品&lt;/div&gt;
        &lt;/li&gt;

         &lt;li&gt;
            &lt;i class=&quot;icon iconfont icon-huiyuanqia&quot;&gt;&lt;/i&gt;
            &lt;div&gt;会员&lt;/div&gt;
        &lt;/li&gt;


        &lt;li&gt;
            &lt;i class=&quot;icon iconfont icon-tongji&quot;&gt;&lt;/i&gt;
            &lt;div&gt;统计&lt;/div&gt;
        &lt;/li&gt;
&lt;/ul&gt;
</code></pre><p>注意：这里你也许和我使用的图标不一样，请自行改成你图标用的代码，不要无脑拷贝，图标会显示不出来。 </p>
<p>components（组件）基本结构写好后，开始动手写CSS样式，让我们的组件变的好看。 </p>
<pre><code>&lt;style&gt;
    .left-nav{
       color:#fff;
       font-size:10px;
       height:100%;
       background-color: #1D8ce0;
       float:left;
       width:5%;
    }
    .iconfont{
       font-size:24px;
    }
    .left-nav ul{
        padding:0px;
        margin: 0px;
    }
    .left-nav li{
        list-style: none;
        text-align: center;
        border-bottom:1px solid #20a0ff;
        padding:10px;
    }
&lt;/style&gt;
</code></pre><p>编写完CSS样式，这个组件算是大体写好了，以后根据需求我们会在组件里添加标签。但是现在还没有这个需求，所以暂时不添加。 </p>
<h3 id="把leftNav组件放到模板中"><a href="#把leftNav组件放到模板中" class="headerlink" title="把leftNav组件放到模板中"></a>把leftNav组件放到模板中</h3><p>先用import在App.vue中引入leftNav组件。 </p>
<pre><code>import leftNav from &#39;@/components/common/leftNav&#39;
</code></pre><p>引入后在vue的构造器里添加components属性，并放入我们的leftNav组件。 </p>
<pre><code>export default {
  name: &#39;app&#39;,
  components:{
    leftNav
  }
}
</code></pre><p>这样组件就算在也页面引入成功了，接下来我们就可以在区域里愉快的使用它（）。贴出引入使用全部代码，方便大家学习查看。 </p>
<pre><code>&lt;template&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;!--左侧导航--&gt;

        &lt;leftNav&gt;&lt;/leftNav&gt;

    &lt;!--操作区域--&gt;
    &lt;div class=&quot;main&quot;&gt;
      &lt;router-view&gt;&lt;/router-view&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import leftNav from &#39;@/components/common/leftNav&#39;
export default {
  name: &#39;app&#39;,
  components:{
    leftNav
  }
}
&lt;/script&gt;

&lt;style&gt;
#app {
  font-family: &#39;Microsoft YaHei&#39;,&#39;Avenir&#39;, Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-align: left;
  color: #2c3e50;
   height:100%;
}

.main{
  float:left;
  width:95%; 
  background-color: #EFF2F7;
  height:100%;
  overflow: auto;

}
&lt;/style&gt;
</code></pre><p>Element是一套为开发者、设计师和产品经理准备的基于Vue2.0的组件库，提供了配套设计资源，帮助你的网站快速成型。在项目中自己写组件虽然灵活，但是效率并不高效，所以要学会站在巨人的肩膀上干活，Element就是巨人的肩旁，也是现在国内比较成熟的以一套Vue的组件库。所以我决定 使用这个组件库开发项目。 </p>
<h3 id="npm安装"><a href="#npm安装" class="headerlink" title="npm安装"></a>npm安装</h3><p>这里使用npm的方式安装，它能更好地和webpack打包工具配合使用。 </p>
<pre><code>npm install element-ui --save
</code></pre><p>如果你网络状况不佳可以使用cnpm来进行安装。 </p>
<h3 id="完整引入项目"><a href="#完整引入项目" class="headerlink" title="完整引入项目"></a>完整引入项目</h3><p>在main.js中写入以下内容: </p>
<pre><code>import Vue from &#39;vue&#39;
import ElementUI from &#39;element-ui&#39;
import &#39;element-ui/lib/theme-default/index.css&#39;
import App from &#39;./App.vue&#39;

Vue.use(ElementUI)

new Vue({
  el: &#39;#app&#39;,
  render: h =&gt; h(App)
})
</code></pre><p>以上代码便完成了Element的引入。需要注意的是，样式文件需要单独引入。 </p>
<h3 id="用Element的el-row的布个局"><a href="#用Element的el-row的布个局" class="headerlink" title="用Element的el-row的布个局"></a>用Element的el-row的布个局</h3><p>安装好，先做个简单的布局小试牛刀，这里作两栏布局，Element支持用24栏的形式进行布局。 </p>
<p><strong>在Pos.vue里添加模版布局：</strong></p>
<pre><code>&lt;template&gt;
  &lt;div class=&quot;pos&quot;&gt;
    &lt;div&gt;
        &lt;el-row &gt;
            &lt;el-col :span=&#39;7&#39;&gt;
            我是订单栏
            &lt;/el-col&gt;
            &lt;!--商品展示--&gt;
            &lt;el-col :span=&quot;17&quot;&gt;
             我是产品栏
            &lt;/el-col&gt;
        &lt;/el-row&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: &#39;Pos&#39;,
  data () {
    return { 
    }
  }
}
&lt;/script&gt;
&lt;style scoped&gt;
&lt;/style&gt;
</code></pre><h3 id="解决100-高的问题"><a href="#解决100-高的问题" class="headerlink" title="解决100%高的问题"></a>解决100%高的问题</h3><p>在页面中使用了Element组件，这样他会自动给我们生产虚拟DOM，我们无法设置高度100%； </p>
<p>这时候可以利用javascript，来设置100%高度问题。先要给我们的标签上添加一个id，我们这里把ID设置为 </p>
<p>order-list。然后在vue构造器里使用mounted钩子函数来设置高度。 </p>
<pre><code>  mounted:function(){
      var orderHeight=document.body.clientHeight;
      document.getElementById(&quot;order-list&quot;).style.height=orderHeight+&#39;px&#39;;
  },
</code></pre><p>布局的基本架构，我们已经做好，剩下的就是一些细节。下节课我们将用一节课的时间制作大部分CSS样式内容。 </p>
<p>这节课我们将快速利用Element进行布局页面，这章视频中我会直接拷贝Style代码，因为我觉的你学Vue，那CSS也没有任何问题的，所以不耽误大家的宝贵事件。 </p>
<h3 id="el-tabs标签页组件"><a href="#el-tabs标签页组件" class="headerlink" title="el-tabs标签页组件"></a>el-tabs标签页组件</h3><p>用Element里提供的el-tabs组件可以快速制作我们的tabs标签页效果，具体使用方法可以到Element的官网查看API。 </p>
<p>基本用法很简单，可以直接在模板中引入标签，标签里边用来代表每个每个标签页。 </p>
<p>先看一个最简单的代码： </p>
<pre><code>&lt;el-tabs&gt;
      &lt;el-tab-pane label=&quot;点餐&quot;&gt;
       点餐   
      &lt;/el-tab-pane&gt;
      &lt;el-tab-pane label=&quot;挂单&quot;&gt;
      挂单
      &lt;/el-tab-pane&gt;
      &lt;el-tab-pane label=&quot;外卖&quot;&gt;
      外卖
     &lt;/el-tab-pane&gt;
&lt;/el-tabs&gt;
</code></pre><p>细心的小伙伴会看到每个里会有一个label属性，这个属性就是你标签页的标题。内容可以直接写在里。 </p>
<h3 id="el-table组件制作表格"><a href="#el-table组件制作表格" class="headerlink" title="el-table组件制作表格"></a>el-table组件制作表格</h3><p>需要在订单的tab标签页里放入表格，把点选的食品放入到待结账列表里,可以使用Element的内置组件el-table。如果你对el-table不了解， 可以去Element官网去查看一下。我这里不作太多的解释，先把代码贴过来，然后根据代码在讲解。 </p>
<pre><code>&lt;el-table :data=&quot;tableData&quot; border show-summary style=&quot;width: 100%&quot; &gt;

    &lt;el-table-column prop=&quot;goodsName&quot; label=&quot;商品&quot;  &gt;&lt;/el-table-column&gt;
    &lt;el-table-column prop=&quot;count&quot; label=&quot;量&quot; width=&quot;50&quot;&gt;&lt;/el-table-column&gt;
    &lt;el-table-column prop=&quot;price&quot; label=&quot;金额&quot; width=&quot;70&quot;&gt;&lt;/el-table-column&gt;
    &lt;el-table-column  label=&quot;操作&quot; width=&quot;100&quot; fixed=&quot;right&quot;&gt;
        &lt;template scope=&quot;scope&quot;&gt;
            &lt;el-button type=&quot;text&quot; size=&quot;small&quot;&gt;删除&lt;/el-button&gt;
            &lt;el-button type=&quot;text&quot; size=&quot;small&quot;&gt;增加&lt;/el-button&gt;

        &lt;/template&gt;
    &lt;/el-table-column&gt;
&lt;/el-table&gt;
</code></pre><p>这里我们采用了五列布表格， 在第1行中的:data是用来绑定数据源的， border代表表格有边框效果。在这视频里我会有详细的讲解。 </p>
<p>tableData中的数据源的值，为了布局方便，所以我们进行了写死，以后会改成动态添加的数据。 </p>
<pre><code> tableData: [{

          goodsName: &#39;可口可乐&#39;,
          price: 8,
          count:1
        }, {

          goodsName: &#39;香辣鸡腿堡&#39;,
          price: 15,
          count:1
        }, {

          goodsName: &#39;爱心薯条&#39;,
          price: 8,
          count:1
        }, {

          goodsName: &#39;甜筒&#39;,
          price: 8,
          count:1
        }]
</code></pre><p>你现在可以打开浏览器进行一下预览，看一下效果了。如果效果正常，我们可以继续往下编写了。 </p>
<h3 id="el-button-按钮组件"><a href="#el-button-按钮组件" class="headerlink" title="el-button 按钮组件"></a>el-button 按钮组件</h3><p>需要在点餐表格的下方放入三个功能性按钮，分别是挂单按钮、删除按钮、结账按钮。同样使用Element里的组件，进行快速写入。el-button 的type属性是设置按钮样式的，为了学些和区分我们这里用三个属性来设置按钮。 </p>
<pre><code>&lt;el-button type=&quot;warning&quot; &gt;挂单&lt;/el-button&gt;
&lt;el-button type=&quot;danger&quot; &gt;删除&lt;/el-button&gt;
&lt;el-button type=&quot;success&quot; &gt;结账&lt;/el-button&gt;
</code></pre><p>到这里我们左边最重要的订单操作区域就布局完成了，下节课我们布局右侧的商品布局。 </p>
<p>上节完成了左边订单栏的布局，这节我们还是利用Element完成大部分布局。 </p>
<p><img src="https://user-gold-cdn.xitu.io/2017/6/15/6ddcd9473d6c915981d98eec79f41aad?imageView2/0/w/1280/h/960" alt=""></p>
<p>这是完成布局的图片 </p>
<h3 id="常用商品区域布局："><a href="#常用商品区域布局：" class="headerlink" title="常用商品区域布局："></a>常用商品区域布局：</h3><p>在标签里增加一个层，然后在层内进行布局。因为里边的商品实际意义上是列表，所以用无序列表 </p>
<ul>
<li>来布局商品。贴出布局的html代码。</li>
<li><div class="often-goods"><br>    <div class="title">常用商品</div><br>    <div class="often-goods-list"><br><br>        <ul><br>            <li><br>                <span>香辣鸡腿堡</span><br>                <span class="o-price">￥15元</span><br>            </li><br><br>        </ul><br>    </div><br></div>


</li>
</ul>
<p>有了基本html结构后，需要增加一些css样式来美化页面： </p>
<pre><code> .title{
       height: 20px;
       border-bottom:1px solid #D3DCE6;
       background-color: #F9FAFC;
       padding:10px;
   }
   .often-goods-list ul li{
      list-style: none;
      float:left;
      border:1px solid #E5E9F2;
      padding:10px;
      margin:5px;
      background-color:#fff;
   }
  .o-price{
      color:#58B7FF; 
   }
</code></pre><p>现在页面变的漂亮了，我们这时候为了页面更逼近真实效果，我们在Vue的构造器里临时加一个数组，用作常用商品使用。声明的变量叫oftenGoods（真实项目不能这样起名字，这里只是练习使用）。 </p>
<pre><code> oftenGoods:[
          {
              goodsId:1,
              goodsName:&#39;香辣鸡腿堡&#39;,
              price:18
          }, {
              goodsId:2,
              goodsName:&#39;田园鸡腿堡&#39;,
              price:15
          }, {
              goodsId:3,
              goodsName:&#39;和风汉堡&#39;,
              price:15
          }, {
              goodsId:4,
              goodsName:&#39;快乐全家桶&#39;,
              price:80
          }, {
              goodsId:5,
              goodsName:&#39;脆皮炸鸡腿&#39;,
              price:10
          }, {
              goodsId:6,
              goodsName:&#39;魔法鸡块&#39;,
              price:20
          }, {
              goodsId:7,
              goodsName:&#39;可乐大杯&#39;,
              price:10
          }, {
              goodsId:8,
              goodsName:&#39;雪顶咖啡&#39;,
              price:18
          }, {
              goodsId:9,
              goodsName:&#39;大块鸡米花&#39;,
              price:15
          }, {
              goodsId:20,
              goodsName:&#39;香脆鸡柳&#39;,
              price:17
          }

      ]
</code></pre><p>有了数据，可以使用v-for循环来输出到html模板中。 </p>
<h3 id="商品分类布局："><a href="#商品分类布局：" class="headerlink" title="商品分类布局："></a>商品分类布局：</h3><p>这样我们商品的上半部分就布局完成了，现在需要布局下半部分，我们在下半部分先添加一个tabs的标签样式。 </p>
<pre><code>&lt;div class=&quot;goods-type&quot;&gt;

    &lt;el-tabs&gt;
        &lt;el-tab-pane label=&quot;汉堡&quot;&gt;
            汉堡
        &lt;/el-tab-pane&gt;
            &lt;el-tab-pane label=&quot;小食&quot;&gt;
            小食
        &lt;/el-tab-pane&gt;
        &lt;el-tab-pane label=&quot;饮料&quot;&gt;
            饮料
        &lt;/el-tab-pane&gt;
        &lt;el-tab-pane label=&quot;套餐&quot;&gt;
            套餐
        &lt;/el-tab-pane&gt;

    &lt;/el-tabs&gt;
&lt;/div&gt;
</code></pre><p>有上节课作tabs标签页的经验，这个变的异常简单。 </p>
<p>制作商品的无序列表： </p>
<pre><code>&lt;ul class=&#39;cookList&#39;&gt;
    &lt;li&gt;
        &lt;span class=&quot;foodImg&quot;&gt;&lt;img src=&quot;http://7xjyw1.com1.z0.glb.clouddn.com/pos001.jpg&quot; width=&quot;100%&quot;&gt;&lt;/span&gt;
        &lt;span class=&quot;foodName&quot;&gt;香辣鸡腿堡&lt;/span&gt;
        &lt;span class=&quot;foodPrice&quot;&gt;￥20.00元&lt;/span&gt;
    &lt;/li&gt;
&lt;/ul&gt;
</code></pre><p>对无序列表进行CSS样式编写： </p>
<pre><code>.cookList li{
       list-style: none;
       width:23%;
       border:1px solid #E5E9F2;
       height: auot;
       overflow: hidden;
       background-color:#fff;
       padding: 2px;
       float:left;
       margin: 2px;

   }
   .cookList li span{

        display: block;
        float:left;
   }
   .foodImg{
       width: 40%;
   }
   .foodName{
       font-size: 18px;
       padding-left: 10px;
       color:brown;

   }
   .foodPrice{
       font-size: 16px;
       padding-left: 10px;
       padding-top:10px;
   }
</code></pre><p>有了基本的样式，我们可以在Vue的构造器里添加汉堡类的数据。声明一个type0Goods的数据，数据格式如下。 </p>
<pre><code>    type0Goods:[
          {
              goodsId:1,
              goodsImg:&quot;http://7xjyw1.com1.z0.glb.clouddn.com/pos001.jpg&quot;,
              goodsName:&#39;香辣鸡腿堡&#39;,
              price:18
          }, {
              goodsId:2,
              goodsImg:&quot;http://7xjyw1.com1.z0.glb.clouddn.com/pos002.jpg&quot;,
              goodsName:&#39;田园鸡腿堡&#39;,
              price:15
          }, {
              goodsId:3,
              goodsImg:&quot;http://7xjyw1.com1.z0.glb.clouddn.com/pos004.jpg&quot;,
              goodsName:&#39;和风汉堡&#39;,
              price:15
          }, {
              goodsId:4,
               goodsImg:&quot;http://7xjyw1.com1.z0.glb.clouddn.com/pos003.jpg&quot;,
              goodsName:&#39;快乐全家桶&#39;,
              price:80
          }, {
              goodsId:5,
               goodsImg:&quot;http://7xjyw1.com1.z0.glb.clouddn.com/pos003.jpg&quot;,
              goodsName:&#39;脆皮炸鸡腿&#39;,
              price:10
          }, {
              goodsId:6,
               goodsImg:&quot;http://7xjyw1.com1.z0.glb.clouddn.com/pos004.jpg&quot;,
              goodsName:&#39;魔法鸡块&#39;,
              price:20
          }, {
              goodsId:7,
               goodsImg:&quot;http://7xjyw1.com1.z0.glb.clouddn.com/pos001.jpg&quot;,
              goodsName:&#39;可乐大杯&#39;,
              price:10
          }, {
              goodsId:8,
               goodsImg:&quot;http://7xjyw1.com1.z0.glb.clouddn.com/pos003.jpg&quot;,
              goodsName:&#39;雪顶咖啡&#39;,
              price:18
          }, {
              goodsId:9,
               goodsImg:&quot;http://7xjyw1.com1.z0.glb.clouddn.com/pos002.jpg&quot;,
              goodsName:&#39;大块鸡米花&#39;,
              price:15
          }, {
              goodsId:20,
               goodsImg:&quot;http://7xjyw1.com1.z0.glb.clouddn.com/pos002.jpg&quot;,
              goodsName:&#39;香脆鸡柳&#39;,
              price:17
          }

      ],
</code></pre><p>用v-for改造我们的无序列表： </p>
<pre><code>&lt;li v-for=&quot;goods in type0Goods&quot;&gt;
    &lt;span class=&quot;foodImg&quot;&gt;&lt;img :src=&quot;goods.goodsImg&quot; width=&quot;100%&quot;&gt;&lt;/span&gt;
    &lt;span class=&quot;foodName&quot;&gt;{{goods.goodsName}}&lt;/span&gt;
    &lt;span class=&quot;foodPrice&quot;&gt;￥{{goods.price}}元&lt;/span&gt;
&lt;/li&gt;
</code></pre><p>页面的基本布局我们已经制作完成，终于看起来像个收银界面了。但是现在的数据都是写死的，下节课我们将从后端用Axios拉去数据。 </p>
<p>上节课我们利用Elemnt已经把页面布局的差不多了，如果你觉的不够美观，可以自己再进行美化，因为课程的原因css细节我们这里就不深入美化了。这节课我们开始学习Axios的知识，并把商品数据从远端读取到页面上。学这节课时技术胖已经为大家准备好了后端数据，你们只要调用相应的页面就可以调取，在实际开发中，这些后台数据是需要后端程序员和你共同讨论制作的。我们现在只做前端，数据大家只要会调用即可。 </p>
<h3 id="安装Axios"><a href="#安装Axios" class="headerlink" title="安装Axios"></a>安装Axios</h3><p>我们直接使用npm install来进行安装。 </p>
<pre><code>npm install axios --save
</code></pre><p>由于axios是需要打包到生产环境中的，所以我们使用–save来进行安装。 </p>
<h3 id="引入Axios"><a href="#引入Axios" class="headerlink" title="引入Axios"></a>引入Axios</h3><p>我们在Pos.vue页面引入Axios，由于使用了npm来进行安装，所以这里不需要填写路径。 </p>
<pre><code>import axios from &#39;axios&#39;
</code></pre><h3 id="服务端拉取常用商品数据"><a href="#服务端拉取常用商品数据" class="headerlink" title="服务端拉取常用商品数据"></a>服务端拉取常用商品数据</h3><p>远端服务器地址：<a href="http://jspang.com/DemoApi/oftenGoods.php" target="_blank" rel="external">http://jspang.com/DemoApi/oftenGoods.php</a></p>
<p>（在实际项目中这个后台接口地址是后端程序员提供给你的，你可以随便调用这个接口，我已经放到服务器上了。） </p>
<p>可以先把地址放到地址栏访问一下，是可以正常访问的，并且输出了json格式的字符串，这就是我们需要的远端数据了。这里我们使用Axios的get 方式来获得数据。 </p>
<pre><code>  created(){
      axios.get(&#39;http://jspang.com/DemoApi/oftenGoods.php&#39;)
      .then(response=&gt;{
         console.log(response);
         this.oftenGoods=response.data;
      })
      .catch(error=&gt;{
          console.log(error);
          alert(&#39;网络错误，不能访问&#39;);
      })
  },
</code></pre><p>把axios的方法写到了created钩子函数中，我们使用了get 方法进行拉取数据，如果拉取成功用远端数据对oftenGoods进行赋值。 </p>
<p>拉取报错，一般有两种情况： </p>
<pre><code>1. 网络不通：网络状况不是很好，这可以在失败后隔5秒再次请求。
2. 报决绝访问：这种多是后端程序员设置了不允许跨域访问，需要你和后端程序员一起调试解决。
</code></pre><h3 id="拉取分类商品数据："><a href="#拉取分类商品数据：" class="headerlink" title="拉取分类商品数据："></a>拉取分类商品数据：</h3><p>远端服务器地址：<a href="http://jspang.com/DemoApi/typeGoods.php" target="_blank" rel="external">http://jspang.com/DemoApi/typeGoods.php</a></p>
<p>依然用Get进行拉取，拉取后先用consoe.log(response)查看一下数据结构，让后进行赋值。由于知识跟上边的很像，文字版我就不多描述了，详细可以查看视频教程。 </p>
<p>在这里贴出拉取和分配不同分类代码： </p>
<pre><code>       //读取分类商品列表
      axios.get(&#39;http://jspang.com/DemoApi/typeGoods.php&#39;)
      .then(response=&gt;{
         console.log(response);
         //this.oftenGoods=response.data;
         this.type0Goods=response.data[0];
         this.type1Goods=response.data[1];
         this.type2Goods=response.data[2];
         this.type3Goods=response.data[3];

      })
      .catch(error=&gt;{
          console.log(error);
          alert(&#39;网络错误，不能访问&#39;);
      })
</code></pre><p>html模板输出代码： </p>
<pre><code>&lt;ul class=&#39;cookList&#39;&gt;
     &lt;li v-for=&quot;goods in type3Goods&quot;&gt;
         &lt;span class=&quot;foodImg&quot;&gt;&lt;img :src=&quot;goods.goodsImg&quot; width=&quot;100%&quot;&gt;&lt;/span&gt;
         &lt;span class=&quot;foodName&quot;&gt;{{goods.goodsName}}&lt;/span&gt;
         &lt;span class=&quot;foodPrice&quot;&gt;￥{{goods.price}}元&lt;/span&gt;
      &lt;/li&gt;
&lt;/ul&gt;
</code></pre><p>在实际开发中类别也是循环出来的，这里为了教学演示，没有写的那么复杂，你只要明白了如何操作，以后你可以自己增加。就像我这个项目一样，在视频结束后，会慢慢写完善所有功能，最后送给女神，赢得女神芳心。 </p>
<p>下节课我们学习订单操作里需要的功能，比如点击商品，添加到左边的订单栏里，增加，删除商品，模拟订单提交到后台。如果下节课一节讲不完，我们就分成两节课来讲。 </p>
<p>经过上节课的学习，我们已经可以从后台取得数据了。这节课要完成的任务是实现页面左侧的订单列表页面的添加操作。本来我想一节课讲完的，但是内容还是比较多的，又不想让大家每节课学习很长时间，所以我把这个内容进行了划分。 </p>
<h3 id="添加商品到订单页面"><a href="#添加商品到订单页面" class="headerlink" title="添加商品到订单页面"></a>添加商品到订单页面</h3><p>我们在vue的构造器里加入methods方法，在methods方法里再加入addOrderList方法。这个方法的作用是点击右侧的商品，然后把商品添加到左边的列表里。 </p>
<p>addOrderList方法(也许你只看文字版无法理解，推荐查看视频)： </p>
<pre><code>methods:{
      //添加订单列表的方法
      addOrderList(goods){
            this.totalCount=0; //汇总数量清0
            this.totalMoney=0;
            let isHave=false;
            //判断是否这个商品已经存在于订单列表
            for (let i=0; i&lt;this.tableData.length;i++){
                console.log(this.tableData[i].goodsId);
                if(this.tableData[i].goodsId==goods.goodsId){
                    isHave=true; //存在
                }
            }
            //根据isHave的值判断订单列表中是否已经有此商品
            if(isHave){
                //存在就进行数量添加
                 let arr = this.tableData.filter(o =&gt;o.goodsId == goods.goodsId);
                 arr[0].count++;
                 //console.log(arr);
            }else{
                //不存在就推入数组
                let newGoods={goodsId:goods.goodsId,goodsName:goods.goodsName,price:goods.price,count:1};
                 this.tableData.push(newGoods);

            }

            //进行数量和价格的汇总计算
            this.tableData.forEach((element) =&gt; {
                this.totalCount+=element.count;
                this.totalMoney=this.totalMoney+(element.price*element.count);   
            });

      }
  }
</code></pre><p>在作这个方法的时候，在订单列表的下方又添加了订单的统计功能，其实也就两项：<strong>订单价格汇总</strong>和订单商品数量汇总。我们在data里声明的值是totalMoney和totalCount。 </p>
<p>写完这个方法后，我们还需要在我们的商品上绑定方法，来进行调用添加方法。 </p>
<pre><code> @click=&quot;addOrderList(goods)&quot;
</code></pre><p>这样在点击商品时订单列表就会根据我们的程序逻辑发生变化。 </p>
<h3 id="订单列表中的增加按钮"><a href="#订单列表中的增加按钮" class="headerlink" title="订单列表中的增加按钮"></a><strong>订单列表中的增加按钮</strong></h3><p>商品中绑定addOrderList方法是非常容易的，如果在订单列表中绑定是需要特殊处理一下的，需要用到template的scope值，让后进行绑定。 </p>
<pre><code>&lt;el-button type=&quot;text&quot; size=&quot;small&quot; @click=&quot;addOrderList(scope.row)&quot;&gt;增加&lt;/el-button&gt;
</code></pre><p>这节课我们把订单增加的操作制作完成了，下节课我们要制作订单商品的删除和订单的整体删除功能，最后模拟一下订单的结账功能。 </p>
<p>继续制作订单模块，这节课主要三个功能的制作，删除列表中的单个商品，删除列表中的全部商品，简单模拟结账。 </p>
<h3 id="删除单个商品"><a href="#删除单个商品" class="headerlink" title="删除单个商品"></a>删除单个商品</h3><p>在veu构造器methods属性里增加一个delSingleGoods方法，并接收goods对象为参数，用数组的filter可以轻松删除数组中单个的商品。 </p>
<pre><code>    //删除单个商品
      delSingleGoods(goods){
        console.log(goods);
        this.tableData=this.tableData.filter(o =&gt; o.goodsId !=goods.goodsId);

      },
</code></pre><p>现在可以npm run dev试一下了，会发现现在商品可以正确的删除了，但是统计的数量和金额是不正确的，我们需要写一些统计的代码。在下手之前你会发现在增加商品方法中也有类似统计的方法，既然两个功能很像，我们就重新写一个方法。 </p>
<pre><code>//汇总数量和金额
getAllMoney(){
    this.totalCount=0;
    this.totalMoney=0;
    if(this.tableData){
            this.tableData.forEach((element) =&gt; {
        this.totalCount+=element.count;
        this.totalMoney=this.totalMoney+(element.price*element.count);   
    });
    }

}
</code></pre><p>需要注意的是，以前我们是单独使用的，所以不用把totoalCount和totalMoney清零，但是做成公用方法了，记得清零。方法做好了，我们在需要的地方直接用this.getAllMoney()引用就可以了。 </p>
<p>功能做好了，我们还需要为删除按钮绑定事件： </p>
<pre><code>&lt;el-button type=&quot;text&quot; size=&quot;small&quot; @click=&quot;delSingleGoods(scope.row)&quot;&gt;删除&lt;/el-button&gt;
</code></pre><p>这样我们就把删除单个订单商品的功能做好了，我们可以测试调试一下。 </p>
<h3 id="删除全部订单商品"><a href="#删除全部订单商品" class="headerlink" title="删除全部订单商品"></a>删除全部订单商品</h3><p>这个功能其实很简单，只要把this.tableData清空就可以了，在methods属性中写一个delAllGoods的方法。 </p>
<pre><code>      //删除所有商品
        delAllGoods() {
            this.tableData = [];
            this.totalCount = 0;
            this.totalMoney = 0;
        },
</code></pre><p>有的小伙伴会好奇，你完全可以再次复用getAllMoney()方法进行汇总，为什么不用那？汇总方法里毕竟是有业务逻辑的，我们只做两个清零，这样消耗的资源更少，所以我们没有使用。 </p>
<h3 id="模拟结账"><a href="#模拟结账" class="headerlink" title="模拟结账"></a>模拟结账</h3><p>因为模拟结账需要Post数据到后台，我的服务器又不能提供这样的借口给大家，所以我只说制作思路，大家可以在自己的服务器上去实现。 </p>
<p>1、设置我们Aixos的Pos方法。 </p>
<p>2、接受返回值进行处理。 </p>
<p>3、如果成功，清空现有构造器里的tableData，totalMoney，totalCount数据。 </p>
<p>4、进行用户的友好提示。 </p>
<p>由于前两个步骤不能演示，所以这里我们只模拟3和4步。在methods里作一个结账方法，清空数据和进行友好提示。 </p>
<pre><code>checkout() {
    if (this.totalCount!=0) {
        this.tableData = [];
        this.totalCount = 0;
        this.totalMoney = 0;
        this.$message({
            message: &#39;结账成功，感谢你又为店里出了一份力!&#39;,
            type: &#39;success&#39;
        });

    }else{
        this.$message.error(&#39;不能空结。老板了解你急切的心情！&#39;);
    }

}
</code></pre><p>订单模块基本的功能就制作完成了，我希望大家都能动手练习一下，如果你不动手练习你永远学不会的。 </p>
<p>一直追看的小伙伴可能知道原来还有一节挂单功能的制作，但是在录制的过程中我发现90%的知识点都是重复的，不重复的知识点讲的还和Vue没有关系，是html5的localStorage操作，所以我去掉了这节。这节我们主要讲一下打包需要注意的事项和总结一下我们学习的知识。 </p>
<h3 id="打包注意事项："><a href="#打包注意事项：" class="headerlink" title="打包注意事项："></a>打包注意事项：</h3><p>1、把绝对路径改为相对路径 </p>
<p>我们打开config/index.js 会看到一个build属性，这里就我们打包的基本配置了。你在这里可以修改打包的目录，打包的文件名。最重要的是一定要把绝对目录改为相对目录。 </p>
<pre><code>assetsPublicPath:&#39;./&#39;
</code></pre><p>这样才能保证我们打包出去的项目可以正常预览。 </p>
<p>2、在命令行中用npm run build 进行打包。 </p>
<pre><code>npm run build
</code></pre><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
    
    </summary>
    
      <category term="VueJs" scheme="https://wangyu1997.github.io/categories/VueJs/"/>
    
    
      <category term="vue" scheme="https://wangyu1997.github.io/tags/vue/"/>
    
      <category term="实战" scheme="https://wangyu1997.github.io/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>AOP实战</title>
    <link href="https://wangyu1997.github.io/2017/10/01/JavaWeb/AOP%E5%AE%9E%E6%88%98/"/>
    <id>https://wangyu1997.github.io/2017/10/01/JavaWeb/AOP实战/</id>
    <published>2017-10-01T02:43:11.000Z</published>
    <updated>2017-10-24T06:31:06.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a> 
<p>接上一小节<a href="https://wangyu1997.github.io/2017/10/01/JavaWeb/AOP%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3/">彻底征服 Spring AOP 之 理论篇</a></p>
<h2 id="Spring-AOP-实战"><a href="#Spring-AOP-实战" class="headerlink" title="Spring AOP 实战"></a>Spring AOP 实战</h2><p>看了上面这么多的理论知识, 不知道大家有没有觉得枯燥哈. 不过不要急, 俗话说理论是实践的基础, 对 Spring AOP 有了基本的理论认识后, 我们来看一下下面几个具体的例子吧.<br>下面的几个例子是我在工作中所遇见的比较常用的 Spring AOP 的使用场景, 我精简了很多有干扰我们学习的注意力的细枝末节, 以力求整个例子的简洁性. </p>
<p>下面几个 Demo 的源码都可以在我的 <a href="https://github.com/yongshun/some_java_code" target="_blank" rel="external">Github</a> 上下载到. </p>
<h3 id="HTTP-接口鉴权"><a href="#HTTP-接口鉴权" class="headerlink" title="HTTP 接口鉴权"></a>HTTP 接口鉴权</h3><p>首先让我们来想象一下如下场景: 我们需要提供的 HTTP RESTful 服务, 这个服务会提供一些比较敏感的信息, 因此对于某些接口的调用会进行调用方权限的校验, 而某些不太敏感的接口则不设置权限, 或所需要的权限比较低(例如某些监控接口, 服务状态接口等).<br>实现这样的需求的方法有很多, 例如我们可以在每个 HTTP 接口方法中对服务请求的调用方进行权限的检查, 当调用方权限不符时, 方法返回错误. 当然这样做并无不可, 不过如果我们的 api 接口很多, 每个接口都进行这样的判断, 无疑有很多冗余的代码, 并且很有可能有某个粗心的家伙忘记了对调用者的权限进行验证, 这样就会造成潜在的 bug.<br>那么除了上面的所说的方法外, 还有没有别的比较优雅的方式来实现呢? 当然有啦, 不然我在这啰嗦半天干嘛呢, 它就是我们今天的主角: <code>AOP</code>. </p>
<p>让我们来提炼一下我们的需求: </p>
<ol>
<li><p>可以定制地为某些指定的 HTTP RESTful api 提供权限验证功能. </p>
</li>
<li><p>当调用方的权限不符时, 返回错误. </p>
</li>
</ol>
<p>根据上面所提出的需求, 我们可以进行如下设计: </p>
<ol>
<li><p>提供一个特殊的注解 <code>AuthChecker</code>, 这个是一个方法注解, 有此注解所标注的 Controller 需要进行调用方权限的认证. </p>
</li>
<li><p>利用 Spring AOP, 以 <strong>@annotation</strong> 切点标志符来匹配有注解 <code>AuthChecker</code> 所标注的 joinpoint. </p>
</li>
<li><p>在 advice 中, 简单地检查调用者请求中的 Cookie 中是否有我们指定的 token, 如果有, 则认为此调用者权限合法, 允许调用, 反之权限不合法, 范围错误. </p>
</li>
</ol>
<p>根据上面的设计, 我们来看一下具体的源码吧.<br>首先是 <code>AuthChecker</code> 注解的定义:<br><strong>AuthChecker.java:</strong></p>
<pre><code>@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface AuthChecker {
}
</code></pre><p><code>AuthChecker</code> 注解是一个方法注解, 它用于注解 RequestMapping 方法. </p>
<p>有了注解的定义, 那我们再来看一下 aspect 的实现吧:<br><strong>HttpAopAdviseDefine.java:</strong></p>
<pre><code>@Component
@Aspect
public class HttpAopAdviseDefine {

    // 定义一个 Pointcut, 使用 切点表达式函数 来描述对哪些 Join point 使用 advise.
    @Pointcut(&quot;@annotation(com.xys.demo1.AuthChecker)&quot;)
    public void pointcut() {
    }

    // 定义 advise
    @Around(&quot;pointcut()&quot;)
    public Object checkAuth(ProceedingJoinPoint joinPoint) throws Throwable {
        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes())
                .getRequest();

        // 检查用户所传递的 token 是否合法
        String token = getUserToken(request);
        if (!token.equalsIgnoreCase(&quot;123456&quot;)) {
            return &quot;错误, 权限不合法!&quot;;
        }

        return joinPoint.proceed();
    }

    private String getUserToken(HttpServletRequest request) {
        Cookie[] cookies = request.getCookies();
        if (cookies == null) {
            return &quot;&quot;;
        }
        for (Cookie cookie : cookies) {
            if (cookie.getName().equalsIgnoreCase(&quot;user_token&quot;)) {
                return cookie.getValue();
            }
        }
        return &quot;&quot;;
    }
}
</code></pre><p>在这个 aspect 中, 我们首先定义了一个 pointcut, 以 <strong>@annotation</strong> 切点标志符来匹配有注解 <code>AuthChecker</code> 所标注的 joinpoint, 即: </p>
<pre><code>// 定义一个 Pointcut, 使用 切点表达式函数 来描述对哪些 Join point 使用 advise.
@Pointcut(&quot;@annotation(com.xys.demo1.AuthChecker)&quot;)
public void pointcut() {
}
</code></pre><p>然后再定义一个 advice: </p>
<pre><code>// 定义 advise
@Around(&quot;pointcut()&quot;)
public Object checkAuth(ProceedingJoinPoint joinPoint) throws Throwable {
    HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes())
            .getRequest();

    // 检查用户所传递的 token 是否合法
    String token = getUserToken(request);
    if (!token.equalsIgnoreCase(&quot;123456&quot;)) {
        return &quot;错误, 权限不合法!&quot;;
    }

    return joinPoint.proceed();
}
</code></pre><p>当被 <code>AuthChecker</code> 注解所标注的方法调用前, 会执行我们的这个 advice, 而这个 advice 的处理逻辑很简单, 即从 HTTP 请求中获取名为 <code>user_token</code> 的 cookie 的值, 如果它的值是 <code>123456</code>, 则我们认为此 HTTP 请求合法, 进而调用 <code>joinPoint.proceed()</code> 将 HTTP 请求转交给相应的控制器处理; 而如果<code>user_token</code> cookie 的值不是 <code>123456</code>, 或为空, 则认为此 HTTP 请求非法, 返回错误. </p>
<p>接下来我们来写一个模拟的 HTTP 接口:<br><strong>DemoController.java:</strong></p>
<pre><code>@RestController
public class DemoController {
    @RequestMapping(&quot;/aop/http/alive&quot;)
    public String alive() {
        return &quot;服务一切正常&quot;;
    }

    @AuthChecker
    @RequestMapping(&quot;/aop/http/user_info&quot;)
    public String callSomeInterface() {
        return &quot;调用了 user_info 接口.&quot;;
    }
}
</code></pre><p>注意到上面我们提供了两个 HTTP 接口, 其中 接口 <strong>/aop/http/alive</strong> 是没有 <code>AuthChecker</code> 标注的, 而 <strong>/aop/http/user_info</strong> 接口则用到了 <code>@AuthChecker</code> 标注. 那么自然地, 当请求了 <strong>/aop/http/user_info</strong> 接口时, 就会触发我们所设置的权限校验逻辑. </p>
<p>接下来我们来验证一下, 我们所实现的功能是否有效吧.<br>首先在 Postman 中, 调用 <strong>/aop/http/alive</strong> 接口, 请求头中不加任何参数: </p>
<p>可以看到, 我们的 HTTP 请求完全没问题. </p>
<p>那么再来看一下请求 <strong>/aop/http/user_info</strong> 接口会怎样呢: </p>
<p>当我们请求 <strong>/aop/http/user_info</strong> 接口时, 服务返回一个权限异常的错误, 为什么会这样呢? 自然就是我们的权限认证系统起了作为: 当一个方法被调用并且这个方法有 <code>AuthChecker</code> 标注时, 那么首先会执行到我们的 <code>around advice</code>, 在这个 advice 中, 我们会校验 HTTP 请求的 cookie 字段中是否有携带 <code>user_token</code> 字段时, 如果没有, 则返回权限错误.<br>那么为了能够正常地调用 <strong>/aop/http/user_info</strong> 接口, 我们可以在 Cookie 中添加 <strong>user_token=123456</strong>, 这样我们可以愉快的玩耍了: </p>
<blockquote>
<p><code>注意</code>, Postman 默认是不支持 Cookie 的, 所以为了实现添加 Cookie 的功能, 我们需要安装 Postman 的 <code>interceptor</code> 插件. 安装方法可以看<a href="https://www.getpostman.com/docs/interceptor_cookies" target="_blank" rel="external">官网的文章</a></p>
</blockquote>
<h4 id="完整源码"><a href="#完整源码" class="headerlink" title="完整源码"></a>完整源码</h4><p><a href="https://github.com/yongshun/some_java_code/tree/master/SpringAOPDemo/src/main/java/com/xys/demo1" target="_blank" rel="external">HTTP 接口鉴权</a></p>
<h3 id="方法调用日志"><a href="#方法调用日志" class="headerlink" title="方法调用日志"></a>方法调用日志</h3><p>第二个 AOP 实例是记录一个方法调用的log. 这应该是一个很常见的功能了.<br>首先假设我们有如下需求: </p>
<ol>
<li><p>某个服务下的方法的调用需要有 log: 记录调用的参数以及返回结果. </p>
</li>
<li><p>当方法调用出异常时, 有特殊处理, 例如打印异常 log, 报警等. </p>
</li>
</ol>
<p>根据上面的需求, 我们可以使用 before advice 来在调用方法前打印调用的参数, 使用 after returning advice 在方法返回打印返回的结果. 而当方法调用失败后, 可以使用 after throwing advice 来做相应的处理.<br>那么我们来看一下 aspect 的实现: </p>
<pre><code>@Component
@Aspect
public class LogAopAdviseDefine {
    private Logger logger = LoggerFactory.getLogger(getClass());

    // 定义一个 Pointcut, 使用 切点表达式函数 来描述对哪些 Join point 使用 advise.
    @Pointcut(&quot;within(NeedLogService)&quot;)
    public void pointcut() {
    }

    // 定义 advise
    @Before(&quot;pointcut()&quot;)
    public void logMethodInvokeParam(JoinPoint joinPoint) {
        logger.info(&quot;---Before method {} invoke, param: {}---&quot;, joinPoint.getSignature().toShortString(), joinPoint.getArgs());
    }

    @AfterReturning(pointcut = &quot;pointcut()&quot;, returning = &quot;retVal&quot;)
    public void logMethodInvokeResult(JoinPoint joinPoint, Object retVal) {
        logger.info(&quot;---After method {} invoke, result: {}---&quot;, joinPoint.getSignature().toShortString(), joinPoint.getArgs());
    }

    @AfterThrowing(pointcut = &quot;pointcut()&quot;, throwing = &quot;exception&quot;)
    public void logMethodInvokeException(JoinPoint joinPoint, Exception exception) {
        logger.info(&quot;---method {} invoke exception: {}---&quot;, joinPoint.getSignature().toShortString(), exception.getMessage());
    }
}
</code></pre><p>第一步, 自然是定义一个 <code>pointcut</code>, 以 <strong>within</strong> 切点标志符来匹配类 <code>NeedLogService</code> 下的所有 joinpoint, 即: </p>
<pre><code>@Pointcut(&quot;within(NeedLogService)&quot;)
public void pointcut() {
}
</code></pre><p>接下来根据我们前面的设计, 我们分别定义了三个 advice, 第一个是一个 before advice: </p>
<pre><code>@Before(&quot;pointcut()&quot;)
public void logMethodInvokeParam(JoinPoint joinPoint) {
    logger.info(&quot;---Before method {} invoke, param: {}---&quot;, joinPoint.getSignature().toShortString(), joinPoint.getArgs());
}
</code></pre><p>它在一个符合要求的 joinpoint 方法调用前执行, 打印调用的方法名和调用的参数. </p>
<p>第二个是 after return advice: </p>
<pre><code>@AfterReturning(pointcut = &quot;pointcut()&quot;, returning = &quot;retVal&quot;)
public void logMethodInvokeResult(JoinPoint joinPoint, Object retVal) {
    logger.info(&quot;---After method {} invoke, result: {}---&quot;, joinPoint.getSignature().toShortString(), joinPoint.getArgs());
}
</code></pre><p>这个 advice 会在方法调用成功后打印出方法名还反的参数. </p>
<p>最后一个是 after throw advice: </p>
<pre><code>@AfterThrowing(pointcut = &quot;pointcut()&quot;, throwing = &quot;exception&quot;)
public void logMethodInvokeException(JoinPoint joinPoint, Exception exception) {
    logger.info(&quot;---method {} invoke exception: {}---&quot;, joinPoint.getSignature().toShortString(), exception.getMessage());
}
</code></pre><p>这个 advice 会在指定的 joinpoint 抛出异常时执行, 打印异常的信息. </p>
<p>接下来我们再写两个 Service 类:<br><strong>NeedLogService.java:</strong></p>
<pre><code>@Service
public class NeedLogService {
    private Logger logger = LoggerFactory.getLogger(getClass());
    private Random random = new Random(System.currentTimeMillis());

    public int logMethod(String someParam) {
        logger.info(&quot;---NeedLogService: logMethod invoked, param: {}---&quot;, someParam);
        return random.nextInt();
    }

    public void exceptionMethod() throws Exception {
        logger.info(&quot;---NeedLogService: exceptionMethod invoked---&quot;);
        throw new Exception(&quot;Something bad happened!&quot;);
    }
}
</code></pre><p><strong>NormalService.java:</strong></p>
<pre><code>@Service
public class NormalService {
    private Logger logger = LoggerFactory.getLogger(getClass());

    public void someMethod() {
        logger.info(&quot;---NormalService: someMethod invoked---&quot;);
    }
}
</code></pre><p>根据我们 pointcut 的规则, 类 NeedLogService 下的所有方法都会被织入 advice, 而类 NormalService 则不会. </p>
<p>最后我们分别调用这几个方法: </p>
<pre><code>@PostConstruct
public void test() {
    needLogService.logMethod(&quot;xys&quot;);
    try {
        needLogService.exceptionMethod();
    } catch (Exception e) {
        // Ignore
    }
    normalService.someMethod();
}
</code></pre><p>我们可以看到有如下输出: </p>
<pre><code>---Before method NeedLogService.logMethod(..) invoke, param: [xys]---
---NeedLogService: logMethod invoked, param: xys---
---After method NeedLogService.logMethod(..) invoke, result: [xys]---

---Before method NeedLogService.exceptionMethod() invoke, param: []---
---NeedLogService: exceptionMethod invoked---
---method NeedLogService.exceptionMethod() invoke exception: Something bad happened!---

---NormalService: someMethod invoked---
</code></pre><p>根据 log, 我们知道, NeedLogService.logMethod 执行的前后确实有 advice 执行了, 并且在 NeedLogService.exceptionMethod 抛出异常后, <code>logMethodInvokeException</code> 这个 advice 也被执行了. 而由于 pointcut 的匹配规则, 在 <code>NormalService</code> 类中的方法则不会织入 advice. </p>
<h4 id="完整源码-1"><a href="#完整源码-1" class="headerlink" title="完整源码"></a>完整源码</h4><p><a href="https://github.com/yongshun/some_java_code/tree/master/SpringAOPDemo/src/main/java/com/xys/demo2" target="_blank" rel="external">方法调用日志</a></p>
<h3 id="方法耗时统计"><a href="#方法耗时统计" class="headerlink" title="方法耗时统计"></a>方法耗时统计</h3><p>作为程序员, 我们都知道服务监控对于一个服务能够长期稳定运行的重要性, 因此很多公司都有自己内部的监控报警系统, 或者是使用一些开源的系统, 例如小米的 Falcon 监控系统. </p>
<p>那么在程序监控中, AOP 有哪些用武之地呢? 我们来假想一下如下场景: </p>
<blockquote>
<p>有一天, leader 对小王说, “小王啊, 你负责的那个服务不太稳定啊, 经常有超时发生! 你有对这些服务接口进行过耗时统计吗?”<br>耗时统计? 小王嘀咕了, 小声的回答到: “还没有加呢.”<br>leader: “你看着办吧, 我明天要看到各个时段的服务接口调用的耗时分布!”<br>小王这就犯难了, 虽然说计算一个方法的调用耗时并不是一个很难的事情, 但是整个服务有二十来个接口呢, 一个一个地添加统计代码, 那还不是要累死人了.<br>看着同事一个一个都下班回家了, 小王眉头更加紧了. 不过此时小王灵机一动: “噫, 有了!”.<br>小王想到了一个好方法, 立即动手, 吭哧吭哧地几分钟就搞定了. </p>
</blockquote>
<p>那么小王的解决方法是什么呢? 自然是我们的主角 <code>AOP</code> 啦. </p>
<p>首先让我们来提炼一下需求: </p>
<ol>
<li><p>为服务中的每个方法调用进行调用耗时记录. </p>
</li>
<li><p>将方法调用的时间戳, 方法名, 调用耗时上报到监控平台 </p>
</li>
</ol>
<p>有了需求, 自然设计实现就很简单了. 首先我们可以使用 around advice, 然后在方法调用前, 记录一下开始时间, 然后在方法调用结束后, 记录结束时间, 它们的时间差就是方法的调用耗时. </p>
<p>我们来看一下具体的 aspect 实现: </p>
<p><strong>ExpiredAopAdviseDefine.java:</strong></p>
<pre><code>@Component
@Aspect
public class ExpiredAopAdviseDefine {
    private Logger logger = LoggerFactory.getLogger(getClass());

    // 定义一个 Pointcut, 使用 切点表达式函数 来描述对哪些 Join point 使用 advise.
    @Pointcut(&quot;within(SomeService)&quot;)
    public void pointcut() {
    }

    // 定义 advise
    // 定义 advise
    @Around(&quot;pointcut()&quot;)
    public Object methodInvokeExpiredTime(ProceedingJoinPoint pjp) throws Throwable {
        StopWatch stopWatch = new StopWatch();
        stopWatch.start();
        // 开始
        Object retVal = pjp.proceed();
        stopWatch.stop();
        // 结束

        // 上报到公司监控平台
        reportToMonitorSystem(pjp.getSignature().toShortString(), stopWatch.getTotalTimeMillis());

        return retVal;
    }


    public void reportToMonitorSystem(String methodName, long expiredTime) {
        logger.info(&quot;---method {} invoked, expired time: {} ms---&quot;, methodName, expiredTime);
        //
    }
}
</code></pre><p>aspect 一开始定义了一个 <code>pointcut</code>, 匹配 <code>SomeService</code> 类下的所有的方法.<br>接着呢, 定义了一个 around advice: </p>
<pre><code>@Around(&quot;pointcut()&quot;)
public Object methodInvokeExpiredTime(ProceedingJoinPoint pjp) throws Throwable {
    StopWatch stopWatch = new StopWatch();
    stopWatch.start();
    // 开始
    Object retVal = pjp.proceed();
    stopWatch.stop();
    // 结束

    // 上报到公司监控平台
    reportToMonitorSystem(pjp.getSignature().toShortString(), stopWatch.getTotalTimeMillis());

    return retVal;
}
</code></pre><p>advice 中的代码也很简单, 它使用了 Spring 提供的 StopWatch 来统计一段代码的执行时间. 首先我们先调用 <strong>stopWatch.start()</strong> 开始计时, 然后通过 <code>pjp.proceed()</code> 来调用我们实际的服务方法, 当调用结束后, 通过 <strong>stopWatch.stop()</strong> 来结束计时. </p>
<p>接着我们来写一个简单的服务, 这个服务提供一个 <strong>someMethod</strong> 方法用于模拟一个耗时的方法调用:<br><strong>SomeService.java:</strong></p>
<pre><code>@Service
public class SomeService {
    private Logger logger = LoggerFactory.getLogger(getClass());
    private Random random = new Random(System.currentTimeMillis());

    public void someMethod() {
        logger.info(&quot;---SomeService: someMethod invoked---&quot;);
        try {
            // 模拟耗时任务
            Thread.sleep(random.nextInt(500));
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
</code></pre><p>这样当 <code>SomeService</code> 类下的方法调用时, 我们所提供的 advice 就会被执行, 因此就可以自动地为我们统计此方法的调用耗时, 并自动上报到监控系统中了.<br>看到 <code>AOP</code> 的威力了吧, 我们这里仅仅使用了寥寥数语就把一个需求完美地解决了, 并且还与原来的业务逻辑完全解耦, 扩展及其方便. </p>
<h4 id="完整源码-2"><a href="#完整源码-2" class="headerlink" title="完整源码"></a>完整源码</h4><p><a href="https://github.com/yongshun/some_java_code/tree/master/SpringAOPDemo/src/main/java/com/xys/demo3" target="_blank" rel="external">方法耗时统计</a></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过上面的几个简单例子, 我们对 <code>Spring AOP</code> 的使用应该有了一个更为深入的了解了. 其实 Spring AOP 的使用的地方不止这些, 例如 Spring 的 <code>声明式事务</code> 就是在 AOP 之上构建的. 读者朋友也可以根据自己的实际业务场景, 合理使用 Spring AOP, 发挥它的强大功能! </p>
<h2 id="End"><a href="#End" class="headerlink" title="End."></a>End.</h2>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
    
    </summary>
    
      <category term="JavaWeb" scheme="https://wangyu1997.github.io/categories/JavaWeb/"/>
    
    
      <category term="AOP" scheme="https://wangyu1997.github.io/tags/AOP/"/>
    
      <category term="javaweb" scheme="https://wangyu1997.github.io/tags/javaweb/"/>
    
      <category term="Spring" scheme="https://wangyu1997.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>AOP编程详解</title>
    <link href="https://wangyu1997.github.io/2017/10/01/JavaWeb/AOP%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3/"/>
    <id>https://wangyu1997.github.io/2017/10/01/JavaWeb/AOP编程详解/</id>
    <published>2017-10-01T02:43:11.000Z</published>
    <updated>2017-10-24T06:29:21.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a> 
<h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><p>其实, 接触了这么久的 AOP, 我感觉, AOP 给人难以理解的一个关键点是它的概念比较多, 而且坑爹的是, 这些概念经过了中文翻译后, 变得面目全非, 相同的一个术语, 在不同的翻译下, 含义总有着各种莫名其妙的差别. 鉴于此, 我在本章的开头, 着重为为大家介绍一个 Spring AOP 的各项术语的基本含义. 为了术语传达的准确性, 我在接下来的叙述中, 能使用英文术语的地方, 尽量使用英文. </p>
<h3 id="什么是-AOP"><a href="#什么是-AOP" class="headerlink" title="什么是 AOP"></a>什么是 AOP</h3><p>AOP(Aspect-Oriented Programming), 即 <strong>面向切面编程</strong>, 它与 OOP( Object-Oriented Programming, 面向对象编程) 相辅相成, 提供了与 OOP 不同的抽象软件结构的视角.<br>在 OOP 中, 我们以类(class)作为我们的基本单元, 而 AOP 中的基本单元是 <strong>Aspect(切面)</strong></p>
<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><h4 id="Aspect-切面"><a href="#Aspect-切面" class="headerlink" title="Aspect(切面)"></a>Aspect(切面)</h4><p><code>aspect</code> 由 <code>pointcount</code> 和 <code>advice</code> 组成, 它既包含了横切逻辑的定义, 也包括了连接点的定义. Spring AOP就是负责实施切面的框架, 它将切面所定义的横切逻辑织入到切面所指定的连接点中.<br>AOP的工作重心在于如何将增强织入目标对象的连接点上, 这里包含两个工作: </p>
<ol>
<li><p>如何通过 pointcut 和 advice 定位到特定的 joinpoint 上 </p>
</li>
<li><p>如何在 advice 中编写切面代码. </p>
</li>
</ol>
<p><strong>可以简单地认为, 使用 @Aspect 注解的类就是切面.</strong></p>
<h4 id="advice-增强"><a href="#advice-增强" class="headerlink" title="advice(增强)"></a>advice(增强)</h4><p>由 aspect 添加到特定的 join point(即满足 point cut 规则的 join point) 的一段代码.<br>许多 AOP框架, 包括 Spring AOP, 会将 advice 模拟为一个拦截器(interceptor), 并且在 join point 上维护多个 advice, 进行层层拦截.<br>例如 HTTP 鉴权的实现, 我们可以为每个使用 RequestMapping 标注的方法织入 advice, 当 HTTP 请求到来时, 首先进入到 advice 代码中, 在这里我们可以分析这个 HTTP 请求是否有相应的权限, 如果有, 则执行 Controller, 如果没有, 则抛出异常. 这里的 advice 就扮演着鉴权拦截器的角色了. </p>
<h4 id="连接点-join-point"><a href="#连接点-join-point" class="headerlink" title="连接点(join point)"></a>连接点(join point)</h4><blockquote>
<p>a point during the execution of a program, such as the execution of a method or the handling of an exception. In Spring AOP, a join point always represents a method execution. </p>
</blockquote>
<p>程序运行中的一些时间点, 例如一个方法的执行, 或者是一个异常的处理.<br><code>在 Spring AOP 中, join point 总是方法的执行点, 即只有方法连接点.</code></p>
<h4 id="切点-point-cut"><a href="#切点-point-cut" class="headerlink" title="切点(point cut)"></a>切点(point cut)</h4><p>匹配 join point 的谓词(a predicate that matches join points).<br>Advice 是和特定的 point cut 关联的, 并且在 point cut 相匹配的 join point 中执行.<br><code>在 Spring 中, 所有的方法都可以认为是 joinpoint, 但是我们并不希望在所有的方法上都添加 Advice, 而 pointcut 的作用就是提供一组规则(使用 AspectJ pointcut expression language 来描述) 来匹配joinpoint, 给满足规则的 joinpoint 添加 Advice.</code></p>
<h4 id="关于join-point-和-point-cut-的区别"><a href="#关于join-point-和-point-cut-的区别" class="headerlink" title="关于join point 和 point cut 的区别"></a>关于join point 和 point cut 的区别</h4><p>在 Spring AOP 中, 所有的方法执行都是 join point. 而 point cut 是一个描述信息, 它修饰的是 join point, 通过 point cut, 我们就可以确定哪些 join point 可以被织入 Advice. 因此 join point 和 point cut 本质上就是两个不同纬度上的东西.<br><code>advice 是在 join point 上执行的, 而 point cut 规定了哪些 join point 可以执行哪些 advice</code></p>
<h4 id="introduction"><a href="#introduction" class="headerlink" title="introduction"></a>introduction</h4><p>为一个类型添加额外的方法或字段. Spring AOP 允许我们为 <code>目标对象</code> 引入新的接口(和对应的实现). 例如我们可以使用 introduction 来为一个 bean 实现 IsModified 接口, 并以此来简化 caching 的实现. </p>
<h4 id="目标对象-Target"><a href="#目标对象-Target" class="headerlink" title="目标对象(Target)"></a>目标对象(Target)</h4><p>织入 advice 的目标对象. 目标对象也被称为 <code>advised object</code>.<br><code>因为 Spring AOP 使用运行时代理的方式来实现 aspect, 因此 adviced object 总是一个代理对象(proxied object)</code><br><code>注意, adviced object 指的不是原来的类, 而是织入 advice 后所产生的代理类.</code></p>
<h4 id="AOP-proxy"><a href="#AOP-proxy" class="headerlink" title="AOP proxy"></a>AOP proxy</h4><p>一个类被 AOP 织入 advice, 就会产生一个结果类, 它是融合了原类和增强逻辑的代理类.<br>在 Spring AOP 中, 一个 AOP 代理是一个 JDK 动态代理对象或 CGLIB 代理对象. </p>
<h4 id="织入-Weaving"><a href="#织入-Weaving" class="headerlink" title="织入(Weaving)"></a>织入(Weaving)</h4><p>将 aspect 和其他对象连接起来, 并创建 adviced object 的过程.<br>根据不同的实现技术, AOP织入有三种方式: </p>
<ul>
<li><p>编译器织入, 这要求有特殊的Java编译器. </p>
</li>
<li><p>类装载期织入, 这需要有特殊的类装载器. </p>
</li>
<li><p>动态代理织入, 在运行期为目标类添加增强(Advice)生成子类的方式.<br>Spring 采用动态代理织入, 而AspectJ采用编译器织入和类装载期织入. </p>
</li>
</ul>
<h3 id="advice-的类型"><a href="#advice-的类型" class="headerlink" title="advice 的类型"></a>advice 的类型</h3><ul>
<li><p>before advice, 在 join point 前被执行的 advice. 虽然 before advice 是在 join point 前被执行, 但是它并不能够阻止 join point 的执行, 除非发生了异常(即我们在 before advice 代码中, 不能人为地决定是否继续执行 join point 中的代码) </p>
</li>
<li><p>after return advice, 在一个 join point 正常返回后执行的 advice </p>
</li>
<li><p>after throwing advice, 当一个 join point 抛出异常后执行的 advice </p>
</li>
<li><p>after(final) advice, 无论一个 join point 是正常退出还是发生了异常, 都会被执行的 advice. </p>
</li>
<li><p>around advice, 在 join point 前和 joint point 退出后都执行的 advice. 这个是最常用的 advice. </p>
</li>
</ul>
<h3 id="关于-AOP-Proxy"><a href="#关于-AOP-Proxy" class="headerlink" title="关于 AOP Proxy"></a>关于 AOP Proxy</h3><p>Spring AOP 默认使用标准的 JDK 动态代理(dynamic proxy)技术来实现 AOP 代理, 通过它, 我们可以为任意的接口实现代理.<br><code>如果需要为一个类实现代理, 那么可以使用 CGLIB 代理.</code> 当一个业务逻辑对象没有实现接口时, 那么Spring AOP 就默认使用 CGLIB 来作为 AOP 代理了. 即如果我们需要为一个方法织入 advice, 但是这个方法不是一个接口所提供的方法, 则此时 Spring AOP 会使用 CGLIB 来实现动态代理. 鉴于此, Spring AOP 建议基于接口编程, 对接口进行 AOP 而不是类. </p>
<h2 id="彻底理解-aspect-join-point-point-cut-advice"><a href="#彻底理解-aspect-join-point-point-cut-advice" class="headerlink" title="彻底理解 aspect, join point, point cut, advice"></a>彻底理解 aspect, join point, point cut, advice</h2><p>看完了上面的理论部分知识, 我相信还是会有不少朋友感觉到 AOP 的概念还是很模糊, 对 AOP 中的各种概念理解的还不是很透彻. 其实这很正常, 因为 AOP 中的概念是在是太多了, 我当时也是花了老大劲才梳理清楚的.<br>下面我以一个简单的例子来比喻一下 AOP 中 aspect, jointpoint, pointcut 与 advice 之间的关系. </p>
<p>让我们来假设一下, 从前有一个叫爪哇的小县城, 在一个月黑风高的晚上, 这个县城中发生了命案. 作案的凶手十分狡猾, 现场没有留下什么有价值的线索. 不过万幸的是, 刚从隔壁回来的老王恰好在这时候无意中发现了凶手行凶的过程, 但是由于天色已晚, 加上凶手蒙着面, 老王并没有看清凶手的面目, 只知道凶手是个男性, 身高约七尺五寸. 爪哇县的县令根据老王的描述, 对守门的士兵下命令说: 凡是发现有身高七尺五寸的男性, 都要抓过来审问. 士兵当然不敢违背县令的命令, 只好把进出城的所有符合条件的人都抓了起来. </p>
<p>来让我们看一下上面的一个小故事和 AOP 到底有什么对应关系.<br>首先我们知道, 在 Spring AOP 中 join point 指代的是所有方法的执行点, 而 point cut 是一个描述信息, 它修饰的是 join point, 通过 point cut, 我们就可以确定哪些 join point 可以被织入 Advice. 对应到我们在上面举的例子, 我们可以做一个简单的类比, join point 就相当于 <strong>爪哇的小县城里的百姓</strong>, point cut 就相当于 <strong>老王所做的指控, 即凶手是个男性, 身高约七尺五寸</strong>, 而 advice 则是施加在符合老王所描述的嫌疑人的动作: <strong>抓过来审问</strong>.<br>为什么可以这样类比呢? </p>
<ul>
<li><p>join point –&gt; 爪哇的小县城里的百姓: 因为根据定义, join point 是所有可能被织入 advice 的候选的点, 在 Spring AOP中, 则可以认为所有方法执行点都是 join point. 而在我们上面的例子中, 命案发生在小县城中, 按理说在此县城中的所有人都有可能是嫌疑人. </p>
</li>
<li><p>point cut –&gt; 男性, 身高约七尺五寸: 我们知道, 所有的方法(joint point) 都可以织入 advice, 但是我们并不希望在所有方法上都织入 advice, 而 pointcut 的作用就是提供一组规则来匹配joinpoint, 给满足规则的 joinpoint 添加 advice. 同理, 对于县令来说, 他再昏庸, 也知道不能把县城中的所有百姓都抓起来审问, 而是根据<code>凶手是个男性, 身高约七尺五寸</code>, 把符合条件的人抓起来. 在这里 <code>凶手是个男性, 身高约七尺五寸</code> 就是一个修饰谓语, 它限定了凶手的范围, 满足此修饰规则的百姓都是嫌疑人, 都需要抓起来审问. </p>
</li>
<li><p>advice –&gt; 抓过来审问, advice 是一个动作, 即一段 Java 代码, 这段 Java 代码是作用于 point cut 所限定的那些 join point 上的. 同理, 对比到我们的例子中, <code>抓过来审问</code> 这个动作就是对作用于那些满足 <code>男性, 身高约七尺五寸</code> 的<code>爪哇的小县城里的百姓</code>. </p>
</li>
<li><p>aspect: aspect 是 point cut 与 advice 的组合, 因此在这里我们就可以类比: <strong>“根据老王的线索, 凡是发现有身高七尺五寸的男性, 都要抓过来审问”</strong> 这一整个动作可以被认为是一个 aspect. </p>
</li>
</ul>
<hr>
<p>或则我们也可以从语法的角度来简单类比一下. 我们在学英语时, 经常会接触什么 <code>定语</code>, <code>被动句</code> 之类的概念, 那么可以做一个不严谨的类比, 即 <code>joinpoint</code> 可以认为是一个 <code>宾语</code>, 而 <code>pointcut</code> 则可以类比为修饰 <code>joinpoint</code> 的定语, 那么整个 <code>aspect</code> 就可以描述为: <code>满足 pointcut 规则的 joinpoint 会被添加相应的 advice 操作.</code></p>
<h2 id="AspectJ-支持"><a href="#AspectJ-支持" class="headerlink" title="@AspectJ 支持"></a>@AspectJ 支持</h2><p><strong>@AspectJ</strong> 是一种使用 Java 注解来实现 AOP 的编码风格.<br>@AspectJ 风格的 AOP 是 AspectJ Project 在 AspectJ 5 中引入的, 并且 Spring 也支持@AspectJ 的 AOP 风格. </p>
<h3 id="使能-AspectJ-支持"><a href="#使能-AspectJ-支持" class="headerlink" title="使能 @AspectJ 支持"></a>使能 @AspectJ 支持</h3><p>@AspectJ 可以以 XML 的方式或以注解的方式来使能, 并且不论以哪种方式使能@ASpectJ, 我们都必须保证 aspectjweaver.jar 在 classpath 中. </p>
<h4 id="使用-Java-Configuration-方式使能-AspectJ"><a href="#使用-Java-Configuration-方式使能-AspectJ" class="headerlink" title="使用 Java Configuration 方式使能@AspectJ"></a>使用 Java Configuration 方式使能@AspectJ</h4><pre><code>@Configuration
@EnableAspectJAutoProxy
public class AppConfig {
}
</code></pre><h4 id="使用-XML-方式使能-AspectJ"><a href="#使用-XML-方式使能-AspectJ" class="headerlink" title="使用 XML 方式使能@AspectJ"></a>使用 XML 方式使能@AspectJ</h4><pre><code>&lt;aop:aspectj-autoproxy/&gt;
</code></pre><h3 id="定义-aspect-切面"><a href="#定义-aspect-切面" class="headerlink" title="定义 aspect(切面)"></a>定义 aspect(切面)</h3><p>当使用注解 <strong>@Aspect</strong> 标注一个 Bean 后, 那么 Spring 框架会自动收集这些 Bean, 并添加到 Spring AOP 中, 例如: </p>
<pre><code>@Component
@Aspect
public class MyTest {
}
</code></pre><p><code>注意, 仅仅使用@Aspect 注解, 并不能将一个 Java 对象转换为 Bean, 因此我们还需要使用类似 @Component 之类的注解.</code><br><code>注意, 如果一个 类被@Aspect 标注, 则这个类就不能是其他 aspect 的 **advised object** 了, 因为使用 @Aspect 后, 这个类就会被排除在 auto-proxying 机制之外.</code></p>
<h3 id="声明-pointcut"><a href="#声明-pointcut" class="headerlink" title="声明 pointcut"></a>声明 pointcut</h3><p>一个 pointcut 的声明由两部分组成: </p>
<ul>
<li><p>一个方法签名, 包括方法名和相关参数 </p>
</li>
<li><p>一个 pointcut 表达式, 用来指定哪些方法执行是我们感兴趣的(即因此可以织入 advice). </p>
</li>
</ul>
<p>在@AspectJ 风格的 AOP 中, 我们使用一个方法来描述 pointcut, 即: </p>
<pre><code>@Pointcut(&quot;execution(* com.xys.service.UserService.*(..))&quot;) // 切点表达式
private void dataAccessOperation() {} // 切点前面
</code></pre><p><code>这个方法必须无返回值.</code><br><code>这个方法本身就是 pointcut signature, pointcut 表达式使用@Pointcut 注解指定.</code><br>上面我们简单地定义了一个 pointcut, 这个 pointcut 所描述的是: 匹配所有在包 <strong>com.xys.service.UserService</strong> 下的所有方法的执行. </p>
<h4 id="切点标志符-designator"><a href="#切点标志符-designator" class="headerlink" title="切点标志符(designator)"></a>切点标志符(designator)</h4><p>AspectJ5 的切点表达式由标志符(designator)和操作参数组成. 如 “execution( _greetTo(..))” 的切点表达式, <strong>execution</strong> 就是 标志符, 而圆括号里的_ greetTo(..) 就是操作参数 </p>
<h5 id="execution"><a href="#execution" class="headerlink" title="execution"></a>execution</h5><p>匹配 join point 的执行, 例如 “execution(* hello(..))” 表示匹配所有目标类中的 hello() 方法. 这个是最基本的 pointcut 标志符. </p>
<h5 id="within"><a href="#within" class="headerlink" title="within"></a>within</h5><p>匹配特定包下的所有 join point, 例如 <code>within(com.xys.*)</code> 表示 com.xys 包中的所有连接点, 即包中的所有类的所有方法. 而 <code>within(com.xys.service.*Service)</code> 表示在 com.xys.service 包中所有以 Service 结尾的类的所有的连接点. </p>
<h5 id="this-与-target"><a href="#this-与-target" class="headerlink" title="this 与 target"></a>this 与 target</h5><p>this 的作用是匹配一个 bean, 这个 bean(Spring AOP proxy) 是一个给定类型的实例(instance of). 而 target 匹配的是一个目标对象(target object, 即需要织入 advice 的原始的类), 此对象是一个给定类型的实例(instance of). </p>
<h5 id="bean"><a href="#bean" class="headerlink" title="bean"></a>bean</h5><p>匹配 bean 名字为指定值的 bean 下的所有方法, 例如: </p>
<pre><code>bean(*Service) // 匹配名字后缀为 Service 的 bean 下的所有方法
bean(myService) // 匹配名字为 myService 的 bean 下的所有方法
</code></pre><h5 id="args"><a href="#args" class="headerlink" title="args"></a>args</h5><p>匹配参数满足要求的的方法.<br>例如: </p>
<pre><code>@Pointcut(&quot;within(com.xys.demo2.*)&quot;)
public void pointcut2() {
}

@Before(value = &quot;pointcut2()  &amp;&amp;  args(name)&quot;)
public void doSomething(String name) {
    logger.info(&quot;---page: {}---&quot;, name);
}

@Service
public class NormalService {
    private Logger logger = LoggerFactory.getLogger(getClass());

    public void someMethod() {
        logger.info(&quot;---NormalService: someMethod invoked---&quot;);
    }


    public String test(String name) {
        logger.info(&quot;---NormalService: test invoked---&quot;);
        return &quot;服务一切正常&quot;;
    }
}
</code></pre><p>当 NormalService.test 执行时, 则 advice <code>doSomething</code> 就会执行, test 方法的参数 name 就会传递到 <code>doSomething</code> 中. </p>
<p>常用例子: </p>
<pre><code>// 匹配只有一个参数 name 的方法
@Before(value = &quot;aspectMethod()  &amp;&amp;  args(name)&quot;)
public void doSomething(String name) {
}

// 匹配第一个参数为 name 的方法
@Before(value = &quot;aspectMethod()  &amp;&amp;  args(name, ..)&quot;)
public void doSomething(String name) {
}

// 匹配第二个参数为 name 的方法
Before(value = &quot;aspectMethod()  &amp;&amp;  args(*, name, ..)&quot;)
public void doSomething(String name) {
}
</code></pre><h5 id="annotation"><a href="#annotation" class="headerlink" title="@annotation"></a>@annotation</h5><p>匹配由指定注解所标注的方法, 例如: </p>
<pre><code>@Pointcut(&quot;@annotation(com.xys.demo1.AuthChecker)&quot;)
public void pointcut() {
}
</code></pre><p>则匹配由注解 <code>AuthChecker</code> 所标注的方法. </p>
<h4 id="常见的切点表达式"><a href="#常见的切点表达式" class="headerlink" title="常见的切点表达式"></a>常见的切点表达式</h4><h5 id="匹配方法签名"><a href="#匹配方法签名" class="headerlink" title="匹配方法签名"></a>匹配方法签名</h5><pre><code>// 匹配指定包中的所有的方法
execution(* com.xys.service.*(..))

// 匹配当前包中的指定类的所有方法
execution(* UserService.*(..))

// 匹配指定包中的所有 public 方法
execution(public * com.xys.service.*(..))

// 匹配指定包中的所有 public 方法, 并且返回值是 int 类型的方法
execution(public int com.xys.service.*(..))

// 匹配指定包中的所有 public 方法, 并且第一个参数是 String, 返回值是 int 类型的方法
execution(public int com.xys.service.*(String name, ..))
</code></pre><h5 id="匹配类型签名"><a href="#匹配类型签名" class="headerlink" title="匹配类型签名"></a>匹配类型签名</h5><pre><code>// 匹配指定包中的所有的方法, 但不包括子包
within(com.xys.service.*)

// 匹配指定包中的所有的方法, 包括子包
within(com.xys.service..*)

// 匹配当前包中的指定类中的方法
within(UserService)


// 匹配一个接口的所有实现类中的实现的方法
within(UserDao+)
</code></pre><h5 id="匹配-Bean-名字"><a href="#匹配-Bean-名字" class="headerlink" title="匹配 Bean 名字"></a>匹配 Bean 名字</h5><pre><code>// 匹配以指定名字结尾的 Bean 中的所有方法
bean(*Service)
</code></pre><h5 id="切点表达式组合"><a href="#切点表达式组合" class="headerlink" title="切点表达式组合"></a>切点表达式组合</h5><pre><code>// 匹配以 Service 或 ServiceImpl 结尾的 bean
bean(*Service || *ServiceImpl)

// 匹配名字以 Service 结尾, 并且在包 com.xys.service 中的 bean
bean(*Service) &amp;&amp; within(com.xys.service.*)
</code></pre><h3 id="声明-advice"><a href="#声明-advice" class="headerlink" title="声明 advice"></a>声明 advice</h3><p>advice 是和一个 pointcut 表达式关联在一起的, 并且会在匹配的 join point 的方法执行的前/后/周围 运行. <code>pointcut 表达式可以是简单的一个 pointcut 名字的引用, 或者是完整的 pointcut 表达式</code>.<br>下面我们以几个简单的 advice 为例子, 来看一下一个 advice 是如何声明的. </p>
<h4 id="Before-advice"><a href="#Before-advice" class="headerlink" title="Before advice"></a>Before advice</h4><pre><code>/**
 * @author xiongyongshun
 * @version 1.0
 * @created 16/9/9 13:13
 */
@Component
@Aspect
public class BeforeAspectTest {
    // 定义一个 Pointcut, 使用 切点表达式函数 来描述对哪些 Join point 使用 advise.
    @Pointcut(&quot;execution(* com.xys.service.UserService.*(..))&quot;)
    public void dataAccessOperation() {
    }
}

@Component
@Aspect
public class AdviseDefine {
    // 定义 advise
    @Before(&quot;com.xys.aspect.PointcutDefine.dataAccessOperation()&quot;)
    public void doBeforeAccessCheck(JoinPoint joinPoint) {
        System.out.println(&quot;*****Before advise, method: &quot; + joinPoint.getSignature().toShortString() + &quot; *****&quot;);
    }
}
</code></pre><p>这里, <strong>@Before</strong> 引用了一个 pointcut, 即 “com.xys.aspect.PointcutDefine.dataAccessOperation()” 是一个 pointcut 的名字.<br>如果我们在 advice 在内置 pointcut, 则可以: </p>
<pre><code>@Component
@Aspect
public class AdviseDefine {
    // 将 pointcut 和 advice 同时定义
    @Before(&quot;within(com.xys.service..*)&quot;)
    public void doAccessCheck(JoinPoint joinPoint) {
        System.out.println(&quot;*****doAccessCheck, Before advise, method: &quot; + joinPoint.getSignature().toShortString() + &quot; *****&quot;);
    }
}
</code></pre><h4 id="around-advice"><a href="#around-advice" class="headerlink" title="around advice"></a>around advice</h4><p>around advice 比较特别, 它可以在一个方法的之前之前和之后添加不同的操作, 并且甚至可以决定何时, 如何, 是否调用匹配到的方法. </p>
<pre><code>@Component
@Aspect
public class AdviseDefine {
    // 定义 advise
    @Around(&quot;com.xys.aspect.PointcutDefine.dataAccessOperation()&quot;)
    public Object doAroundAccessCheck(ProceedingJoinPoint pjp) throws Throwable {
        StopWatch stopWatch = new StopWatch();
        stopWatch.start();
        // 开始
        Object retVal = pjp.proceed();
        stopWatch.stop();
        // 结束
        System.out.println(&quot;invoke method: &quot; + pjp.getSignature().getName() + &quot;, elapsed time: &quot; + stopWatch.getTotalTimeMillis());
        return retVal;
    }
}
</code></pre><p>around advice 和前面的 before advice 差不多, 只是我们把注解 <strong>@Before</strong> 改为了 <strong>@Around</strong> 了. </p>
]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
    
    </summary>
    
      <category term="JavaWeb" scheme="https://wangyu1997.github.io/categories/JavaWeb/"/>
    
    
      <category term="AOP" scheme="https://wangyu1997.github.io/tags/AOP/"/>
    
      <category term="javaweb" scheme="https://wangyu1997.github.io/tags/javaweb/"/>
    
      <category term="Spring" scheme="https://wangyu1997.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>axios使用教程</title>
    <link href="https://wangyu1997.github.io/2017/09/28/VueJs/axios%E6%95%99%E7%A8%8B/"/>
    <id>https://wangyu1997.github.io/2017/09/28/VueJs/axios教程/</id>
    <published>2017-09-27T17:43:11.000Z</published>
    <updated>2017-10-24T07:13:53.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a> 
<h2 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h2><p>1、 利用npm安装<code>npm install axios --save</code><br>2、 利用bower安装<code>bower install axios --save</code><br>3、 直接利用cdn引入<code>&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;</code></p>
<h2 id="二、例子"><a href="#二、例子" class="headerlink" title="二、例子"></a>二、例子</h2><p>1、 发送一个<code>GET</code>请求 </p>
<pre><code>//通过给定的ID来发送请求
axios.get(&#39;/user?ID=12345&#39;)
  .then(function(response){
    console.log(response);
  })
  .catch(function(err){
    console.log(err);
  });
//以上请求也可以通过这种方式来发送
axios.get(&#39;/user&#39;,{
  params:{
    ID:12345
  }
})
.then(function(response){
  console.log(response);
})
.catch(function(err){
  console.log(err);
});
</code></pre><p>2、 发送一个<code>POST</code>请求 </p>
<pre><code>axios.post(&#39;/user&#39;,{
  firstName:&#39;Fred&#39;,
  lastName:&#39;Flintstone&#39;
})
.then(function(res){
  console.log(res);
})
.catch(function(err){
  console.log(err);
});
</code></pre><p>3、 一次性并发多个请求 </p>
<pre><code>function getUserAccount(){
  return axios.get(&#39;/user/12345&#39;);
}
function getUserPermissions(){
  return axios.get(&#39;/user/12345/permissions&#39;);
}
axios.all([getUserAccount(),getUserPermissions()])
  .then(axios.spread(function(acct,perms){
    //当这两个请求都完成的时候会触发这个函数，两个参数分别代表返回的结果
  }))
</code></pre><h2 id="三、axios的API"><a href="#三、axios的API" class="headerlink" title="三、axios的API"></a>三、axios的API</h2><h4 id="（一）-axios可以通过配置（config）来发送请求"><a href="#（一）-axios可以通过配置（config）来发送请求" class="headerlink" title="（一） axios可以通过配置（config）来发送请求"></a>（一） axios可以通过配置（<code>config</code>）来发送请求</h4><p>1、 <code>axios(config)</code></p>
<pre><code>//发送一个`POST`请求
axios({
    method:&quot;POST&quot;,
    url:&#39;/user/12345&#39;,
    data:{
        firstName:&quot;Fred&quot;,
        lastName:&quot;Flintstone&quot;
    }
});
</code></pre><p>2、 <code>axios(url[,config])</code></p>
<pre><code>//发送一个`GET`请求（默认的请求方式）
axios(&#39;/user/12345&#39;);
</code></pre><h4 id="（二）、-请求方式的别名，这里对所有已经支持的请求方式都提供了方便的别名"><a href="#（二）、-请求方式的别名，这里对所有已经支持的请求方式都提供了方便的别名" class="headerlink" title="（二）、 请求方式的别名，这里对所有已经支持的请求方式都提供了方便的别名"></a>（二）、 请求方式的别名，这里对所有已经支持的请求方式都提供了方便的别名</h4><pre><code>axios.request(config);

axios.get(url[,config]);

axios.delete(url[,config]);

axios.head(url[,config]);

axios.post(url[,data[,config]]);

axios.put(url[,data[,config]])

axios.patch(url[,data[,config]])
</code></pre><ul>
<li>注意：当我们在使用别名方法的时候，<code>url,method,data</code>这几个参数不需要在配置中声明</li>
</ul>
<h4 id="（三）、-并发请求（concurrency）-即是帮助处理并发请求的辅助函数"><a href="#（三）、-并发请求（concurrency）-即是帮助处理并发请求的辅助函数" class="headerlink" title="（三）、 并发请求（concurrency）,即是帮助处理并发请求的辅助函数"></a>（三）、 并发请求（concurrency）,即是帮助处理并发请求的辅助函数</h4><pre><code>//iterable是一个可以迭代的参数如数组等
axios.all(iterable)
//callback要等到所有请求都完成才会执行
axios.spread(callback)
</code></pre><h4 id="（四）、创建一个axios实例，并且可以自定义其配置"><a href="#（四）、创建一个axios实例，并且可以自定义其配置" class="headerlink" title="（四）、创建一个axios实例，并且可以自定义其配置"></a>（四）、创建一个<code>axios</code>实例，并且可以自定义其配置</h4><p>1、 <code>axios.create([config])</code></p>
<pre><code>var instance = axios.create({
  baseURL:&quot;https://some-domain.com/api/&quot;,
  timeout:1000,
  headers: {&#39;X-Custom-Header&#39;:&#39;foobar&#39;}
});
</code></pre><p>2、 实例的方法 </p>
<ul>
<li><p>一下是实例方法，注意已经定义的配置将和利用create创建的实例的配置合并</p>
<p>axios#request(config)</p>
<p>axios#get(url[,config])</p>
<p>axios#delete(url[,config])</p>
<p>axios#head(url[,config])</p>
<p>axios#post(url[,data[,config]])</p>
<p>axios#put(url[,data[,config]])</p>
<p>axios#patch(url[,data[,config]])</p>
</li>
</ul>
<h2 id="四、请求的配置（request-config）"><a href="#四、请求的配置（request-config）" class="headerlink" title="四、请求的配置（request config）"></a>四、请求的配置（request config）</h2><ul>
<li><p>以下就是请求的配置选项，只有<code>url</code>选项是必须的，如果<code>method</code>选项未定义，那么它默认是以<code>GET</code>的方式发出请求</p>
<p>{<br>  //<code>url</code>是请求的服务器地址<br>  url:’/user’,<br>  //<code>method</code>是请求资源的方式<br>  method:’get’//default<br>  //如果<code>url</code>不是绝对地址，那么<code>baseURL</code>将会加到<code>url</code>的前面<br>  //当<code>url</code>是相对地址的时候，设置<code>baseURL</code>会非常的方便<br>  baseURL:’<a href="https://some-domain.com/api/" target="_blank" rel="external">https://some-domain.com/api/</a>‘,<br>  //<code>transformRequest</code>选项允许我们在请求发送到服务器之前对请求的数据做出一些改动<br>  //该选项只适用于以下请求方式：<code>put/post/patch</code><br>  //数组里面的最后一个函数必须返回一个字符串、-一个<code>ArrayBuffer</code>或者<code>Stream</code><br>  transformRequest:[function(data){</p>
<pre><code>//在这里根据自己的需求改变数据
return data;
</code></pre><p>  }],<br>  //<code>transformResponse</code>选项允许我们在数据传送到<code>then/catch</code>方法之前对数据进行改动<br>  transformResponse:[function(data){</p>
<pre><code>//在这里根据自己的需求改变数据
return data;
</code></pre><p>  }],<br>  //<code>headers</code>选项是需要被发送的自定义请求头信息<br>  headers: {‘X-Requested-With’:’XMLHttpRequest’},<br>  //<code>params</code>选项是要随请求一起发送的请求参数—-一般链接在URL后面<br>  //他的类型必须是一个纯对象或者是URLSearchParams对象<br>  params: {</p>
<pre><code>ID:12345
</code></pre><p>  },<br>  //<code>paramsSerializer</code>是一个可选的函数，起作用是让参数（params）序列化<br>  //例如(<a href="https://www.npmjs.com/package/qs,http://api.jquery.com/jquery.param" target="_blank" rel="external">https://www.npmjs.com/package/qs,http://api.jquery.com/jquery.param</a>)<br>  paramsSerializer: function(params){</p>
<pre><code>return Qs.stringify(params,{arrayFormat:&#39;brackets&#39;})
</code></pre><p>  },<br>  //<code>data</code>选项是作为一个请求体而需要被发送的数据<br>  //该选项只适用于方法：<code>put/post/patch</code><br>  //当没有设置<code>transformRequest</code>选项时dada必须是以下几种类型之一<br>  //string/plain/object/ArrayBuffer/ArrayBufferView/URLSearchParams<br>  //仅仅浏览器：FormData/File/Bold<br>  //仅node:Stream<br>  data {</p>
<pre><code>firstName:&quot;Fred&quot;
</code></pre><p>  },<br>  //<code>timeout</code>选项定义了请求发出的延迟毫秒数<br>  //如果请求花费的时间超过延迟的时间，那么请求会被终止</p>
<p>  timeout:1000,<br>  //<code>withCredentails</code>选项表明了是否是跨域请求</p>
<p>  withCredentials:false,//default<br>  //<code>adapter</code>适配器选项允许自定义处理请求，这会使得测试变得方便<br>  //返回一个promise,并提供验证返回<br>  adapter: function(config){</p>
<pre><code>/*..........*/
</code></pre><p>  },<br>  //<code>auth</code>表明HTTP基础的认证应该被使用，并提供证书<br>  //这会设置一个authorization头（header）,并覆盖你在header设置的Authorization头信息<br>  auth: {</p>
<pre><code>username:&quot;zhangsan&quot;,
password: &quot;s00sdkf&quot;
</code></pre><p>  },<br>  //返回数据的格式<br>  //其可选项是arraybuffer,blob,document,json,text,stream<br>  responseType:’json’,//default<br>  //<br>  xsrfCookieName: ‘XSRF-TOKEN’,//default<br>  xsrfHeaderName:’X-XSRF-TOKEN’,//default<br>  //<code>onUploadProgress</code>上传进度事件<br>  onUploadProgress:function(progressEvent){</p>
<pre><code>//下载进度的事件
</code></pre><p>onDownloadProgress:function(progressEvent){<br>}<br>  },<br>  //相应内容的最大值<br>  maxContentLength:2000,<br>  //<code>validateStatus</code>定义了是否根据http相应状态码，来resolve或者reject promise<br>  //如果<code>validateStatus</code>返回true(或者设置为<code>null</code>或者<code>undefined</code>),那么promise的状态将会是resolved,否则其状态就是rejected<br>  validateStatus:function(status){</p>
<pre><code>return status &gt;= 200 &amp;&amp; status &lt;300;//default
</code></pre><p>  },<br>  //<code>maxRedirects</code>定义了在nodejs中重定向的最大数量<br>  maxRedirects: 5,//default<br>  //<code>httpAgent/httpsAgent</code>定义了当发送http/https请求要用到的自定义代理<br>  //keeyAlive在选项中没有被默认激活<br>  httpAgent: new http.Agent({keeyAlive:true}),<br>  httpsAgent: new https.Agent({keeyAlive:true}),<br>  //proxy定义了主机名字和端口号，<br>  //<code>auth</code>表明http基本认证应该与proxy代理链接，并提供证书<br>  //这将会设置一个<code>Proxy-Authorization</code> header,并且会覆盖掉已经存在的<code>Proxy-Authorization</code>  header<br>  proxy: {</p>
<pre><code>host:&#39;127.0.0.1&#39;,
port: 9000,
auth: {
  username:&#39;skda&#39;,
  password:&#39;radsd&#39;
}
</code></pre><p>  },<br>  //<code>cancelToken</code>定义了一个用于取消请求的cancel token<br>  //详见cancelation部分<br>  cancelToken: new cancelToken(function(cancel){</p>
<p>  })<br>}</p>
</li>
</ul>
<h2 id="五、请求返回的内容"><a href="#五、请求返回的内容" class="headerlink" title="五、请求返回的内容"></a>五、请求返回的内容</h2><pre><code>{

  data:{},
  status:200,
  //从服务器返回的http状态文本
  statusText:&#39;OK&#39;,
  //响应头信息
  headers: {},
  //`config`是在请求的时候的一些配置信息
  config: {}
}
</code></pre><ul>
<li><p>你可以这样来获取响应信息</p>
<p>axios.get(‘/user/12345’)<br>  .then(function(res){</p>
<pre><code>console.log(res.data);
console.log(res.status);
console.log(res.statusText);
console.log(res.headers);
console.log(res.config);
</code></pre><p>  })</p>
</li>
</ul>
<h2 id="六、默认配置"><a href="#六、默认配置" class="headerlink" title="六、默认配置"></a>六、默认配置</h2><ul>
<li>你可以设置默认配置，对所有请求都有效</li>
</ul>
<p>1、 全局默认配置 </p>
<pre><code>axios.defaults.baseURL = &#39;http://api.exmple.com&#39;;
axios.defaults.headers.common[&#39;Authorization&#39;] = AUTH_TOKEN;
axios.defaults.headers.post[&#39;content-Type&#39;] = &#39;appliction/x-www-form-urlencoded&#39;;
</code></pre><p>2、 自定义的实例默认设置 </p>
<pre><code>//当创建实例的时候配置默认配置
var instance = axios.create({
    baseURL: &#39;https://api.example.com&#39;
});

//当实例创建时候修改配置
instance.defaults.headers.common[&quot;Authorization&quot;] = AUTH_TOKEN;
</code></pre><p>3、 配置中的有优先级 </p>
<ul>
<li><p>config配置将会以优先级别来合并，顺序是lib/defauts.js中的默认配置，然后是实例中的默认配置，最后是请求中的config参数的配置，越往后等级越高，后面的会覆盖前面的例子。</p>
<p>//创建一个实例的时候会使用libray目录中的默认配置<br>//在这里timeout配置的值为0，来自于libray的默认值<br>var instance = axios.create();<br>//回覆盖掉library的默认值<br>//现在所有的请求都要等2.5S之后才会发出<br>instance.defaults.timeout = 2500;<br>//这里的timeout回覆盖之前的2.5S变成5s<br>instance.get(‘/longRequest’,{<br>  timeout: 5000<br>});</p>
</li>
</ul>
<h2 id="七、拦截器"><a href="#七、拦截器" class="headerlink" title="七、拦截器"></a>七、拦截器</h2><ul>
<li><p>你可以在请求、响应在到达<code>then/catch</code>之前拦截他们</p>
<p>//添加一个请求拦截器<br>axios.interceptors.request.use(function(config){<br>  //在请求发出之前进行一些操作<br>  return config;<br>},function(err){<br>  //Do something with request error<br>  return Promise.reject(error);<br>});<br>//添加一个响应拦截器<br>axios.interceptors.response.use(function(res){<br>  //在这里对返回的数据进行处理<br>  return res;<br>},function(err){<br>  //Do something with response error<br>  return Promise.reject(error);<br>})</p>
</li>
</ul>
<p>2、取消拦截器 </p>
<pre><code>var myInterceptor = axios.interceptor.request.use(function(){/*....*/});
axios.interceptors.request.eject(myInterceptor);
</code></pre><p>3、 给自定义的axios实例添加拦截器 </p>
<pre><code>var instance = axios.create();
instance.interceptors.request.use(function(){})
</code></pre><h2 id="八、错误处理"><a href="#八、错误处理" class="headerlink" title="八、错误处理"></a>八、错误处理</h2><pre><code>axios.get(&#39;/user/12345&#39;)
  .catch(function(error){
    if(error.response){
      //请求已经发出，但是服务器响应返回的状态吗不在2xx的范围内
      console.log(error.response.data);
      console.log(error.response.status);
      console.log(error.response.header);
    }else {
      //一些错误是在设置请求的时候触发
      console.log(&#39;Error&#39;,error.message);
    }
    console.log(error.config);
  });
</code></pre><h2 id="九、取消"><a href="#九、取消" class="headerlink" title="九、取消"></a>九、取消</h2><ul>
<li>你可以通过一个<code>cancel token</code>来取消一个请求</li>
</ul>
<ol>
<li><p>你可以通过<code>CancelToken.source</code>工厂函数来创建一个<code>cancel token</code></p>
<p>var CancelToken = axios.CancelToken;<br>var source = CancelToken.source();</p>
<p>axios.get(‘/user/12345’,{<br> cancelToken: source.token<br>}).catch(function(thrown){<br> if(axios.isCancel(thrown)){<br>   console.log(‘Request canceled’,thrown.message);<br> }else {<br>   //handle error<br> }<br>});</p>
<p>//取消请求（信息的参数可以设置的）<br>source.cance(“操作被用户取消”);</p>
</li>
</ol>
<ol>
<li><p>你可以给cancelToken构造函数传递一个executor function来创建一个cancel token:</p>
<p>var cancelToken = axios.CancelToken;<br>var cance;<br>axios.get(‘/user/12345’,{<br> cancelToken: new CancelToken(function(c){<br>   //这个executor函数接受一个cancel function作为参数<br>   cancel = c;<br> })<br>})<br>//取消请求<br>cancel();</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
    
    </summary>
    
      <category term="VueJs" scheme="https://wangyu1997.github.io/categories/VueJs/"/>
    
    
      <category term="axios" scheme="https://wangyu1997.github.io/tags/axios/"/>
    
      <category term="fronted" scheme="https://wangyu1997.github.io/tags/fronted/"/>
    
      <category term="vuejs" scheme="https://wangyu1997.github.io/tags/vuejs/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate annotation主键生成策略</title>
    <link href="https://wangyu1997.github.io/2017/09/20/JavaWeb/Hibernate%E6%B3%A8%E8%A7%A3%E4%B8%BB%E9%94%AE%E7%AD%96%E7%95%A5/"/>
    <id>https://wangyu1997.github.io/2017/09/20/JavaWeb/Hibernate注解主键策略/</id>
    <published>2017-09-19T17:43:11.000Z</published>
    <updated>2017-09-28T10:22:26.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a> 
<p>Hibernate 默认总共支持 13 种生成策略 :  </p>
<ol>
<li><p>increment        2.  identity        3. sequence </p>
</li>
<li><p>hilo                  5. seqhilo         6. uuid </p>
</li>
<li><p>uuid.hex          8. guid             9. native </p>
</li>
<li><p>assigned       11. select         12. foreign        13. sequence-identity </p>
</li>
</ol>
<p>下面介绍几个较为常用的策略 :  </p>
<p>① identity [ 自然递增 ] </p>
<p> 支持 DB2，MySQL，SQL Server，Sybase 和HypersonicSQL 数据库， 用于为 long 或 short 或 int 类型生成唯一标识。它依赖于底层不同的数据库，与 Hibernate 和 程序员无关。 </p>
<p>注解示例 :  </p>
<p>@Id </p>
<p>@GenericGenerator(name = “idGenerator”, strategy = “identity”) </p>
<p>@GeneratedValue(generator = “idGenerator”) </p>
<p>② sequence [ 序列 ] </p>
<p>支持 Oracle，DB2，PostgreSql，SAPDb 等数据库，用于为 long 或 short 或 int 类型生成唯一标识。它需要底层数据库的支持， 并由数据库来维护这个 sequence 序列。 </p>
<p>注解示例 :  </p>
<p>@Id </p>
<p>@GenericGenerator(name = “idGenerator”, strategy = “sequence”, parameters = {@Parameter(name = “sequence”,value=”seq_name”)}) </p>
<p>@GeneratedValue(generator = “idGenerator”) </p>
<p>注意 : 该策略要求设定序列名，否则 hibernate 将无法找到，这将引致抛出异常 : </p>
<p>org.hibernate.exception.SQLGrammarException: could not get next sequence value </p>
<p>③ native </p>
<p>需底层数据库的支持，对于 MySQL，SQL Server 采用 identity 的生成策略，对于 Oracle，则采用 sequence 策略。 </p>
<p>注解示例 : </p>
<p>@Id </p>
<p>@GenericGenerator(name = “idGenerator”, strategy = “native”) </p>
<p>@GeneratedValue(generator = “idGenerator”) </p>
<p>④ increment [ 自然递增 ] </p>
<p>与 identity 策略不同的是，该策略不依赖于底层数据库，而依赖于 hibernate 本身，用于为 long 或 short 或 int 类型生成唯一标识。 </p>
<p>主键计数器是由 hibernate 的一个实例来维护，每次自增量为 1，但在集群下不能使用该策略，否则将引起主键冲突的情况，该策略适用于所有关系型数据库使用。 </p>
<p>注解示例 : </p>
<p>@Id </p>
<p>@GenericGenerator(name = “idGenerator”, strategy = “increment”) </p>
<p>@GeneratedValue(generator = “idGenerator”) </p>
<p>⑤ uuid [ 32位16进制数的字符串 ] </p>
<p>采用128位UUID算法生成主键，能够保证网络环境下的主键唯一性，也就能够保证在不同数据库及不同服务器下主键的唯一性。 </p>
<p>uuid 最终被编码成一个32位16进制数的字符串，占用的存储空间较大。用于为 String 类型生成唯一标识，适用于所有关系型数据库。 </p>
<p>注解示例 : </p>
<p>@Id </p>
<p>@GenericGenerator(name = “idGenerator”, strategy = “uuid”) </p>
<p>@GeneratedValue(generator = “idGenerator”) </p>
<p>⑤ assigned [ 手工分配主键ID值 ] </p>
<p>该策略要求程序员必须自己维护和管理主键，当有数据需要存储时，程序员必须自己为该数据分配指定一个主键ID值，如果该数据没有被分配主键ID值或分配的值存在重复，则该数据都将无法被持久化且会引起异常的抛出。 </p>
<p>注解示例 : </p>
<p>@Id </p>
<p>@GenericGenerator(name = “idGenerator”, strategy = “assigned”) </p>
<p>@GeneratedValue(generator = “idGenerator”) </p>
]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
    
    </summary>
    
      <category term="JavaWeb" scheme="https://wangyu1997.github.io/categories/JavaWeb/"/>
    
    
      <category term="javaweb" scheme="https://wangyu1997.github.io/tags/javaweb/"/>
    
      <category term="hibernate" scheme="https://wangyu1997.github.io/tags/hibernate/"/>
    
      <category term="annotation" scheme="https://wangyu1997.github.io/tags/annotation/"/>
    
      <category term="primary key" scheme="https://wangyu1997.github.io/tags/primary-key/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate annotation映射详解</title>
    <link href="https://wangyu1997.github.io/2017/09/20/JavaWeb/Hibernate%20annotation%E6%98%A0%E5%B0%84%E8%AF%A6%E8%A7%A3/"/>
    <id>https://wangyu1997.github.io/2017/09/20/JavaWeb/Hibernate annotation映射详解/</id>
    <published>2017-09-19T17:43:11.000Z</published>
    <updated>2017-09-19T18:09:53.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a> 
<p>基于xml的配置： </p>
<p>实体+实体.hbm.xml+hibernate.cfg.xml </p>
<p>基于annotation的配置： </p>
<p>实体+hibernate.cfg.xml </p>
<p>如下：  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/2551166-e06b86942fd9ea74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">  </p>
<p>实体  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/2551166-19bd8dd7a07a959b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">  </p>
<p>hibernate.cfg.xml </p>
<hr>
<hr>
<hr>
<h2 id="OneToMany的双向配置："><a href="#OneToMany的双向配置：" class="headerlink" title="OneToMany的双向配置："></a>OneToMany的双向配置：</h2><p><img src="http://upload-images.jianshu.io/upload_images/2551166-36c774089c039f32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">  </p>
<p>one </p>
<p>其中的注解配置是： </p>
<p>@Entity </p>
<p>@Table(name=”t_classroom”) </p>
<p>@Id  </p>
<p>@GeneratedValue </p>
<p>@OneToMany(mappedBy =”classroom”)//指定由对端来维护关系  </p>
<p>@LazyCollection(LazyCollectionOption.EXTRA)//相当于lazy=exta让其智能化 </p>
<p><img src="http://upload-images.jianshu.io/upload_images/2551166-16b3d90ecfc605b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">  </p>
<p>Many  </p>
<p>其中的注解配置是：  </p>
<p>@Entity  </p>
<p>@Table(name=”t_student”) </p>
<p>@Id  </p>
<p>@GeneratedValue </p>
<p>@ManyToOne(fetch = FetchType.LAZY)//启用延迟加载策略  </p>
<p>@JoinColumn(name=”cid”)//指定由这一端来维护关系，不让它生成中间表 </p>
<hr>
<hr>
<hr>
<h2 id="OneToOne的双向配置："><a href="#OneToOne的双向配置：" class="headerlink" title="OneToOne的双向配置："></a>OneToOne的双向配置：</h2><p><img src="http://upload-images.jianshu.io/upload_images/2551166-ba07e93237457d99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">  </p>
<p>不维护关系的一方  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/2551166-e9c7b3c319a62c15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">  </p>
<p>维护关系的一方  </p>
<p>其中的注解配置为： </p>
<p>@Entity  </p>
<p>@Table(name=”t_idcard”) </p>
<p>@Id </p>
<p>@GeneratedValue </p>
<p>@OneToOne(mappedBy =”person”)//指定不由这端来维护关系，由对端来维护关系  </p>
<p>其中的注解配置为： </p>
<p>@Entity  </p>
<p>@Table(name=”t_idcard”)  </p>
<p>@Id  </p>
<p>@GeneratedValue </p>
<p>@OneToOne  </p>
<p>@JoinColumn(name =”pid”)//指定由这一端来维护关系 </p>
<hr>
<hr>
<hr>
<h2 id="ManyToMany双向配置："><a href="#ManyToMany双向配置：" class="headerlink" title="ManyToMany双向配置："></a>ManyToMany双向配置：</h2><p><img src="http://upload-images.jianshu.io/upload_images/2551166-50973cd6b727aa6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">  </p>
<p>不维护关系的一方  </p>
<p>其中的注解配置： </p>
<p>@Entity  </p>
<p>@Table(name=”t_admin”) </p>
<p>@Id  </p>
<p>@GeneratedValue </p>
<p>@ManyToMany(mappedBy =”admins”)//指明不维护关系  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/2551166-0f8eb127be92c852.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">  </p>
<p>维护关系的一方  </p>
<p>@Entity </p>
<p>@Table(name=”t_admin”) </p>
<p>@Id </p>
<p>@GeneratedValue </p>
<p>@ManyToMany  </p>
<p>@JoinTable(name=”t_role_admin”,joinColumns = {@JoinColumn(name=”rid”)}, </p>
<p>inverseJoinColumns = {@JoinColumn(name =”aid”)}) </p>
<p>//指定生成的中间表的属性 </p>
<hr>
<hr>
<hr>
<p>两个ManyToOne代替ManyToMany </p>
<p><img src="http://upload-images.jianshu.io/upload_images/2551166-08ea281104079442.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">  </p>
<p>teacher </p>
<p>配置文件是： </p>
<p>@Entity  </p>
<p>@Table(name=”t_teacher_course”) </p>
<p>@Id </p>
<p>@GeneratedValue </p>
<p>@OneToMany(mappedBy =”teacher”) </p>
<p>@LazyCollection(LazyCollectionOption.EXTRA) </p>
<p><img src="http://upload-images.jianshu.io/upload_images/2551166-cba89369b945f443.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">  </p>
<p>course </p>
<p>配置文件时：  </p>
<p>@Entity  </p>
<p>@Table(name=”t_teacher_course”) </p>
<p>@Id </p>
<p>@GeneratedValue </p>
<p>@OneToMany(mappedBy =”teacher”) </p>
<p>@LazyCollection(LazyCollectionOption.EXTRA) </p>
<p><img src="http://upload-images.jianshu.io/upload_images/2551166-10dc02cb2bc9577c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">  </p>
<p>teachercourse </p>
<p>配置文件时：  </p>
<p>@Entity  </p>
<p>@Table(name=”t_teacher_course”) </p>
<p>@Id </p>
<p>@GeneratedValue </p>
<p>@ManyToOne  </p>
<p>@JoinColumn(name=”tid”) </p>
<p>@ManyToOne  </p>
<p>@JoinColumn(name=”cid”) </p>
]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
    
    </summary>
    
      <category term="JavaWeb" scheme="https://wangyu1997.github.io/categories/JavaWeb/"/>
    
    
      <category term="javaweb" scheme="https://wangyu1997.github.io/tags/javaweb/"/>
    
      <category term="hibernate" scheme="https://wangyu1997.github.io/tags/hibernate/"/>
    
      <category term="annotation" scheme="https://wangyu1997.github.io/tags/annotation/"/>
    
      <category term="reflect" scheme="https://wangyu1997.github.io/tags/reflect/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 14.04 配置iptables防火墙</title>
    <link href="https://wangyu1997.github.io/2017/08/22/%E9%82%A3%E4%BA%9B%E5%B9%B4%E5%80%92%E8%85%BE%E8%BF%87%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8/Ubuntu%E9%85%8D%E7%BD%AE%E9%98%B2%E7%81%AB%E5%A2%99/"/>
    <id>https://wangyu1997.github.io/2017/08/22/那些年倒腾过的服务器/Ubuntu配置防火墙/</id>
    <published>2017-08-22T12:43:11.000Z</published>
    <updated>2017-09-19T17:36:54.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a> 
<blockquote>
<p>Ubuntu默认安装是没有开启任何防火墙的，为了服务器的安全，建议大家安装启用防火墙设置，这里推荐使用iptables防火墙.如果mysql启本地使用,可以不用打开3306端口. </p>
</blockquote>
<p><code># whereis iptables</code> #查看系统是否安装防火墙可以看到: </p>
<pre><code>iptables: /sbin/iptables /usr/share/iptables /usr/share/man/man8/iptables.8.gz #表示已经安装iptables
apt-get install iptables #如果默认没有安装，请运行此命令安装防火墙
</code></pre><p><code># iptables -L</code> #查看防火墙配置信息，显示如下: </p>
<pre><code>Chain INPUT (policy ACCEPT)
target prot opt source destination
Chain FORWARD (policy ACCEPT)
target prot opt source destination
Chain OUTPUT (policy ACCEPT)
target prot opt source destination
</code></pre><p><code># vi /etc/iptables.rules</code></p>
<p>添加以下内容(备注:80是指web服务器端口,3306是指MySQL数据库链接端口,22是指SSH远程管理端口.) </p>
<pre><code>*filter
:INPUT DROP [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
:syn-flood - [0:0]
-A INPUT -i lo -j ACCEPT
-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT
-A INPUT -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT
-A INPUT -p tcp -m state --state NEW -m tcp --dport 80 -j ACCEPT
-A INPUT -p tcp -m state --state NEW -m tcp --dport 443 -j ACCEPT
-A INPUT -p icmp -m limit --limit 100/sec --limit-burst 100 -j ACCEPT
-A INPUT -p icmp -m limit --limit 1/s --limit-burst 10 -j ACCEPT
-A INPUT -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -j syn-flood
-A INPUT -j REJECT --reject-with icmp-host-prohibited
-A syn-flood -p tcp -m limit --limit 3/sec --limit-burst 6 -j RETURN
-A syn-flood -j REJECT --reject-with icmp-port-unreachable
COMMIT
</code></pre><p><code># iptables-restore &lt; /etc/iptables.rules</code> #使防火墙规则生效 </p>
<p><code># vi /etc/network/if-pre-up.d/iptables</code> #创建文件，添加以下内容，使防火墙开机启动 </p>
<pre><code>#!/bin/bash
iptables-restore &lt; /etc/iptables.rules
</code></pre><p><code># chmod +x /etc/network/if-pre-up.d/iptables</code> #添加执行权限 </p>
<p><code># iptables -L -n</code>查看规则是否生效. </p>
]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
    
    </summary>
    
      <category term="那些年倒腾过的服务器" scheme="https://wangyu1997.github.io/categories/%E9%82%A3%E4%BA%9B%E5%B9%B4%E5%80%92%E8%85%BE%E8%BF%87%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="iptables" scheme="https://wangyu1997.github.io/tags/iptables/"/>
    
  </entry>
  
  <entry>
    <title>Swift中你应该知道的一些有用的tips</title>
    <link href="https://wangyu1997.github.io/2017/08/03/iOS/Swift%E4%B8%AD%E6%9C%89%E7%94%A8%E7%9A%84tips/"/>
    <id>https://wangyu1997.github.io/2017/08/03/iOS/Swift中有用的tips/</id>
    <published>2017-08-03T12:43:11.000Z</published>
    <updated>2017-09-19T17:37:55.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a>                           
<p>本文主要的知识点有： </p>
<ul>
<li>@noescape和@autoclosure</li>
<li>内联lazy属性</li>
<li>函数柯里化</li>
<li>可变参数</li>
<li>dynamic关键字</li>
<li>一些特殊的字面量</li>
<li>循环标签</li>
</ul>
<h2 id="noescape和-autoclosure"><a href="#noescape和-autoclosure" class="headerlink" title="@noescape和@autoclosure"></a>@noescape和@autoclosure</h2><p>关于这两个关键字的含义，在我此前的文章——<a href="http://www.jianshu.com/p/f9ba4c41d9c7" target="_blank" rel="external">第六章——函数(自动闭包和内存)</a>中已经有详细的解释，这里就简单总结概括一下： </p>
<ul>
<li>@noescape：这个关键字告诉编译器，参数闭包只能在函数内部使用。它不能被赋值给临时变量，不能异步调用，也不能作为未标记为@noescape的参数传递给其他函数。总之您可以放心，它无法在这个函数作用域之外使用。 </li>
</ul>
<p>除了安全性上的保证，swift还会为标记为@noescape的参数做一些优化，闭包内访问类的成员时您还可以省去<code>self.</code>的语法。 </p>
<ul>
<li>@autoclosure：这个关键字将表达式封装成闭包，优点在于延迟了表达式的执行，缺点是如果滥用会导致代码可读性降低。 </li>
</ul>
<h2 id="内联lazy属性"><a href="#内联lazy属性" class="headerlink" title="内联lazy属性"></a>内联lazy属性</h2><p>标记为lazy的属性在对象初始化时不会被创建，它直到第一次被访问时才会创建，通常情况下它是这样实现的： </p>
<pre><code>class PersonOld {
    lazy var expensiveObject: ExpensiveObject = {
        return self.createExpensiveObject()    // 传统实现方式
    }()

    private func createExpensiveObject() -&gt; ExpensiveObject {
        return ExpensiveObject()
    }
}
</code></pre><p>lazy属性本质上是一个闭包，闭包中的表达式只会调用一次。需要强调的是，虽然这个闭包中捕获了<code>self</code>，但是这样做并不会导致循环引用，猜测是Swift自动把<code>self</code>标记为unowned了。 </p>
<p>这样的写法其实可以进行简化，简化后的实现如下： </p>
<pre><code>class Person {
    lazy var expensiveObject: ExpensiveObject = self.createExpensiveObject()

    private func createExpensiveObject() -&gt; ExpensiveObject {
        return ExpensiveObject()
    }
}
</code></pre><h2 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h2><p>函数柯里化也是一个老生常谈的问题了，我的这篇文章——<a href="http://www.jianshu.com/p/b2d21b85a387" target="_blank" rel="external">第六章——函数（函数的便捷性）</a>对其有比较详细的解释。 </p>
<p>简单来说，柯里化函数处理一个参数，然后返回一个函数处理剩下来的所有参数。直观上来看，它避免了很多括号的嵌套，提高了代码的简洁性和可读性，比如这个函数： </p>
<pre><code>func fourChainedFunctions(a: Int) -&gt; (Int -&gt; (Int -&gt; (Int -&gt; Int))) {
    return { b in
        return { c in
            return { d in
                return a + b + c + d
            }
        }
    }
}
fourChainedFunctions(1)(2)(3)(4)
</code></pre><p>对比一下它的柯里化版本： </p>
<pre><code>func fourChainedFunctions(a: Int)(b: Int)(c: Int)(d: Int) -&gt; Int {
    return a + b + c + d
}
</code></pre><p>不过在 Swift 3.0 中，这种柯里化语法会被移除，你需要使用之前完整的函数声明。感谢 <a href="http://www.jianshu.com/users/88a056103c02/latest_articles" target="_blank" rel="external">@没故事的卓同学</a> 指出。 </p>
<p>您可以在<a href="https://github.com/apple/swift-evolution" target="_blank" rel="external">Swift Programming Language Evolution</a>中查看更多细节： </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1171077-9bca1d7f34b2916d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">  </p>
<p>或者您也可以点击这篇文章查看更多细节——<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0002-remove-currying.md" target="_blank" rel="external">Removing currying func declaration syntax</a></p>
<h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>如果在参数类型后面加上三个”.”，表示参数的数量是可变的，如果您有过Java编程的经验，对此应该会比较熟悉： </p>
<pre><code>func printEverythingWithAKrakenEmojiInBetween(objectsToPrint: Any...) {
    for object in objectsToPrint {
        print(&quot;\(object)🐙&quot;)
    }
}
printEverythingWithAKrakenEmojiInBetween(&quot;Hey&quot;, &quot;Look&quot;, &quot;At&quot;, &quot;Me&quot;, &quot;!&quot;)
</code></pre><p>此时，参数可以当做<code>SequenceType</code>类型来使用，也就是说可以使用<code>for in</code>语法遍历其中的每一个参数。 </p>
<p>可变参数并不是什么罕见的语法，比如<code>print</code>函数就是用了可变参数，更多详细的分析请移步：<a href="http://www.jianshu.com/p/abb55919c453" target="_blank" rel="external">你其实真的不懂print(“Hello,world”)</a></p>
<h2 id="dynamic关键字"><a href="#dynamic关键字" class="headerlink" title="dynamic关键字"></a>dynamic关键字</h2><p>如果您有过OC的开发经验，那一定会对OC中@dynamic关键字比较熟悉，它告诉编译器不要为属性合成getter和setter方法。 </p>
<p>Swift中也有dynamic关键字，它可以用于修饰变量或函数，它的意思也与OC完全不同。它告诉编译器使用动态分发而不是静态分发。OC区别于其他语言的一个特点在于它的动态性，任何方法调用实际上都是消息分发，而Swift则尽可能做到静态分发。 </p>
<p>因此，标记为dynamic的变量/函数会隐式的加上@objc关键字，它会使用OC的runtime机制。 </p>
<p>虽然静态分发在效率上可能更好，不过一些app分析统计的库需要依赖动态分发的特性，动态的添加一些统计代码，这一点在Swift的静态分发机制下很难完成。这种情况下，虽然使用dynamic关键字会牺牲因为使用静态分发而获得的一些性能优化，但也依然是值得的。 </p>
<pre><code>class Kraken {
    dynamic var imADynamicallyDispatchedString: String

    dynamic func imADynamicallyDispatchedFunction() {
        //Hooray for dynamic dispatch!
    }
}
</code></pre><p>使用动态分发，您可以更好的与OC中runtime的一些特性（如CoreData，KVC/KVO）进行交互，不过如果您不能确定变量或函数会被动态的修改、添加或使用了Method-Swizzle，那么就不应该使用dynamic关键字，否则有可能程序崩溃。 </p>
<h2 id="特殊的字面量"><a href="#特殊的字面量" class="headerlink" title="特殊的字面量"></a>特殊的字面量</h2><p>在开发或调试过程中如果能用好下面这四个字面量，将会起到事半功倍的效果： </p>
<ul>
<li><strong>FILE</strong>：当前代码在那个文件中</li>
<li><strong>FUNCTION</strong>：当前代码在该文件的那个函数中</li>
<li><strong>LINE</strong>：当前代码在该文件的第多少行</li>
<li><strong>COLUMN</strong>：当前代码在改行的多少列</li>
</ul>
<p>举个实际例子，您可以在demo中运行体验一番： </p>
<pre><code>func specialLitertalExpression() {
    print(__FILE__)
    print(__FUNCTION__)
    print(__LINE__)
    print(__COLUMN__)   // 输出结果为11，因为有4个空格，print是五个字符，还有一个左括号。
}
</code></pre><p>一般情况下最常用的字面量是<code>__FUNCTION__</code>，它可以很容易让程序员明白自己调用的方法的方法名。 </p>
<h2 id="循环标签"><a href="#循环标签" class="headerlink" title="循环标签"></a>循环标签</h2><p>通常意义上的循环标签主要是<code>continue</code>和<code>break</code>，不过swift在此基础上做了一些拓展，比如下面这段代码： </p>
<pre><code>let firstNames = [&quot;Neil&quot;,&quot;Kt&quot;,&quot;Bob&quot;]
let lastNames = [&quot;Zhou&quot;,&quot;Zhang&quot;,&quot;Wang&quot;,&quot;Li&quot;]
for firstName in firstNames {
    var isFound = false
    for lastName in lastNames {
        if firstName == &quot;Kt&quot; &amp;&amp; lastName == &quot;Zhang&quot; {
            isFound = true
            break
        }
        print(firstName + &quot; &quot; + lastName)
    }

    if isFound {
        break
    }
}
</code></pre><p>目的是希望找到分别在两个数组中找到字符串”Kt”和”Zhang”，在此之前会打印所有遍历到的字符。 </p>
<p>在结束内层循环后，我希望外层循环也随之立刻停止，为了实现这个功能，我不得不引入了<code>isFound</code>参数。然而实际上我需要的只是可以指定停止哪个循环而已： </p>
<pre><code>outsideloop: for firstName in firstNames {
    innerloop: for lastName in lastNames {
        if firstName == &quot;Kt&quot; &amp;&amp; lastName == &quot;Zhang&quot; {
            break outsideloop    //人为指定break外层循环
        }
        print(firstName + &quot; &quot; + lastName)
    }
}
</code></pre><p>以上两段代码等价，可以看到使用了循环标签后，代码明显简洁了很多。 </p>
]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
    
    </summary>
    
      <category term="iOS" scheme="https://wangyu1997.github.io/categories/iOS/"/>
    
    
      <category term="swift" scheme="https://wangyu1997.github.io/tags/swift/"/>
    
      <category term="tips" scheme="https://wangyu1997.github.io/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>利用 Django REST framework 编写 RESTful API</title>
    <link href="https://wangyu1997.github.io/2017/07/26/Python/%20Django%20REST%20framework/"/>
    <id>https://wangyu1997.github.io/2017/07/26/Python/ Django REST framework/</id>
    <published>2017-07-26T13:43:11.000Z</published>
    <updated>2017-09-19T17:56:31.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a>                           
<p>最近在玩 Django，不得不说 rest_framework 真乃一大神器，可以轻易的甚至自动化的搞定很多事情，比如：</p>
<ul>
<li>自动生成符合 RESTful 规范的 API<ul>
<li>支持 OPTION、HEAD、POST、GET、PATCH、PUT、DELETE</li>
<li>根据 <code>Content-Type</code> 来动态的返回数据类型（如 text、json）</li>
</ul>
</li>
<li>生成 browserable 的交互页面（自动为 API 生成非常友好的浏览器页面）</li>
<li>非常细粒度的权限管理（可以细粒度到 field 级别）</li>
</ul>
<p>_示意图_</p>
<p><img src="http://7s1ruy.com1.z0.glb.clouddn.com/srceen_shot%202015-07-20%20%E4%B8%8B%E5%8D%889.36.48.png" alt="技术分享"></p>
<hr>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code>$ pip install djangorestframework
$ pip install markdown
</code></pre><hr>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Django Rest framework 的流程大概是这样的 </p>
<p><img src="http://7s1ruy.com1.z0.glb.clouddn.com/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%9A%84%E8%A1%A8%E5%8D%95.jpg" alt="技术分享"></p>
<ol>
<li>建立 Models</li>
<li>依靠 Serialiers 将数据库取出的数据 Parse 为 API 的数据（可用于返回给客户端，也可用于浏览器显示）</li>
<li>ViewSet 是一个 views 的集合，根据客户端的请求（GET、POST等），返回 Serialiers 处理的数据<ul>
<li>权限 Premissions 也在这一步做处理</li>
</ul>
</li>
<li>ViewSet 可在 Routers 进行注册，注册后会显示在 Api Root 页上</li>
<li>在 urls 里注册 ViewSet 生成的 view，指定监听的 url</li>
</ol>
<p>希望全面细致了解的人请移步去看官方文档，我这里就不一步步的细说了，而是分块来进行介绍 </p>
<hr>
<h2 id="准备工作-amp-Models"><a href="#准备工作-amp-Models" class="headerlink" title="准备工作 &amp; Models"></a>准备工作 &amp; Models</h2><p>让我们来写个小项目练练手 </p>
<ol>
<li>先用 <code>manage.py startproject rest</code> 来生成一个项目</li>
<li>再用 <code>manage.py createsuperuser</code> 创建用户（后面权限管理会用到）</li>
<li>初始化数据库 <code>manage.py migrate</code></li>
</ol>
<p>然后当然是编写 models，为了展示 rest_framework 的强大之处，我给 models 定义了一个自定义的 field </p>
<pre><code># myproject/myapp/models.py


#! /usr/bin/env python
# -*- coding: utf-8
from __future__ import unicode_literals, absolute_import
import cPickle as pickle

from django.db import models
from django.contrib.auth.models import User


class SerializedField(models.TextField):

    &quot;&quot;&quot;序列化域
    用 pickle 来实现存储 Python 对象
    &quot;&quot;&quot;
    __metaclass__ = models.SubfieldBase  # 必须指定该 metaclass 才能使用 to_python

    def validate(self, val):
        raise isinstance(val, basestring)

    def to_python(self, val):
        &quot;&quot;&quot;从数据库中取出字符串，解析为 python 对象&quot;&quot;&quot;
        if val and isinstance(val, unicode):
            return pickle.loads(val.encode(‘utf-8‘))

        return val

    def get_prep_value(self, val):
        &quot;&quot;&quot;将 python object 存入数据库&quot;&quot;&quot;
        return pickle.dumps(val)


class MyModel(models.Model):

    created_at = models.DateTimeField(auto_now_add=True)
    # 注意这里建立了一个外键
    owner = models.ForeignKey(User, related_name=‘mymodels‘)
    field = models.CharField(max_length=100)
    options = SerializedField(max_length=1000, default={})
</code></pre><hr>
<h2 id="Serializers"><a href="#Serializers" class="headerlink" title="Serializers"></a>Serializers</h2><p>定义好了 Models，我们可以开始写 Serializers，这个相当于 Django 的 Form </p>
<pre><code># myproject/myapp/serializers.py

#! /usr/bin/env python
# -*- coding: utf-8
from __future__ import unicode_literals, absolute_import
import json

from django.contrib.auth.models import User
from rest_framework import serializers

from ..models import MyModel
from .fields import MyCustField


class MyCustField(serializers.CharField):
    &quot;&quot;&quot;为 Model 中的自定义域额外写的自定义 Serializer Field&quot;&quot;&quot;

    def to_representation(self, obj):
        &quot;&quot;&quot;将从 Model 取出的数据 parse 给 Api&quot;&quot;&quot;
        return obj

    def to_internal_value(self, data):
        &quot;&quot;&quot;将客户端传来的 json 数据 parse 给 Model&quot;&quot;&quot;
        return json.loads(data.encode(‘utf-8‘))


class UserSerializer(serializers.ModelSerializer):

    class Meta:
        model = User  # 定义关联的 Model
        fields = (‘id‘, ‘username‘, ‘mymodels‘)  # 指定返回的 fields

    # 这句话的作用是为 MyModel 中的外键建立超链接，依赖于 urls 中的 name 参数
    # 不想要这个功能的话完全可以注释掉
    mymodels = serializers.HyperlinkedRelatedField(
        many=True, queryset=MyModel.objects.all(),
        view_name=‘model-detail‘
    )


class MySerializer(serializers.ModelSerializer):

    options = MyCustField(
        max_length=1000, style={‘base_template‘: ‘textarea.html‘},
    )

    class Meta:
        model = MyModel
        fields = (‘id‘, ‘owner‘, ‘field‘, ‘options‘)
        read_only_fields = (‘owner‘,)  # 指定只读的 field

    def create(self, validated_data):
        &quot;&quot;&quot;响应 POST 请求&quot;&quot;&quot;
        # 自动为用户提交的 model 添加 owner
        validated_data[‘owner‘] = self.context[‘request‘].user
        return MyModel.objects.create(**validated_data)

    def update(self, instance, validated_data):
        &quot;&quot;&quot;响应 PUT 请求&quot;&quot;&quot;
        instance.field = validated_data.get(‘field‘, instance.field)
        instance.save()
        return instance
</code></pre><hr>
<h2 id="ViewSet"><a href="#ViewSet" class="headerlink" title="ViewSet"></a>ViewSet</h2><p>定义好了 Serializers，就可以开始写 viewset 了 </p>
<p>其实 viewset 反而是最简单的部分，rest_framework 原生提供了四种 ViewSet </p>
<ul>
<li><code>ViewSet</code></li>
<li><code>GenericViewSet</code><ul>
<li>继承于 <code>GenericAPIView</code></li>
</ul>
</li>
<li><code>ModelViewSet</code><ul>
<li>自身提供了六种方法</li>
<li><code>list</code></li>
<li><code>create</code></li>
<li><code>retrieve</code></li>
<li><code>update</code></li>
<li><code>partial_update</code></li>
<li><code>destroy</code></li>
</ul>
</li>
<li><code>ReadOnlyModelViewSet</code></li>
</ul>
<p>我比较喜欢用 <code>ModelViewSet</code>，然后再用 Premissions 来管理权限 </p>
<pre><code># myproject/myapp/views.py

#! /usr/bin/env python
# -*- coding: utf-8
from __future__ import unicode_literals, absolute_import

from django.contrib.auth.models import User
from rest_framework import permissions, viewsets, renderers
from rest_framework.decorators import (
    permission_classes, detail_route
)
from rest_framework.response import Response

from .serializers import MySerializer, UserSerializer
from .models import MyModel


class UserViewSet(viewsets.ModelViewSet):
    queryset = User.objects.all()
    serializer_class = UserSerializer
    # 指定权限，下面马上讲到
    permission_classes = (permissions.IsAuthenticated,)


class ModelViewSet(viewsets.ModelViewSet):
    queryset = MyModel.objects.all()
    serializer_class = MySerializer
    permission_classes = (permissions.IsAuthenticatedOrReadOnly,)

    @detail_route(renderer_classes=[renderers.StaticHTMLRenderer])
    def plaintext(self, request, *args, **kwargs):
        &quot;&quot;&quot;自定义 Api 方法&quot;&quot;&quot;
        model = self.get_object()
        return Response(repr(model))
</code></pre><p>我在 ModelViewSet 中自定义了方法 plaintext，rest_framework 中对于自定义的 viewset 方法提供了两种装饰器 </p>
<ul>
<li><code>list_route</code></li>
<li><code>detail_route</code></li>
</ul>
<p>区别就是 <code>list_route</code> 的参数不包含 <code>pk</code>（对应 list），而 <code>detail_route</code> 包含<code>pk</code>（对应 retrieve） </p>
<p>看一段代码就懂了 </p>
<pre><code>@list_route(methods=[‘post‘, ‘delete‘])
def custom_handler(self, request):
    pass


@detail_route(methods=[‘get‘])
def custom_handler(self, request, pk=None):
    pass
</code></pre><hr>
<h2 id="Filters"><a href="#Filters" class="headerlink" title="Filters"></a>Filters</h2><p>前面根据 serializers 和 viewset 我们已经可以很好的提供数据接口和展示了。但是有时候我们需要通过 url参数 来对数据进行一些排序或过滤的操作，为此，rest-framwork 提供了 filters 来满足这一需求。 </p>
<h3 id="全局filter"><a href="#全局filter" class="headerlink" title="全局filter"></a>全局filter</h3><p>可以在 settings 里指定应用到全局的 filter： </p>
<pre><code>REST_FRAMEWORK = {
    ‘DEFAULT_FILTER_BACKENDS‘: (‘rest_framework.filters.DjangoFilterBackend‘,)
}
</code></pre><h3 id="viewset-的-filter"><a href="#viewset-的-filter" class="headerlink" title="viewset 的 filter"></a>viewset 的 filter</h3><p>也可以为 viewset 分别指定 filter，方法就是在定义 viewset 的时候定义一个名为<code>filter_backend</code> 的类变量： </p>
<pre><code>class UserListView(generics.ListAPIView):
    queryset = User.objects.all()
    serializer = UserSerializer
    filter_backends = (filters.DjangoFilterBackend,)
</code></pre><h3 id="默认的-filter"><a href="#默认的-filter" class="headerlink" title="默认的 filter"></a>默认的 filter</h3><p>rest-framework 提供了几个原生的 filter： </p>
<ul>
<li><p>SearchFilter</p>
<p>filter_backends = (filters.SearchFilter,)<br>search_fields = (‘username‘, ‘email‘)  # 指定搜索的域</p>
</li>
</ul>
<p>请求 <code>http://example.com/api/users?search=russell</code>。 </p>
<ul>
<li><p>OrderingFilter</p>
<p>filter_backends = (filters.OrderingFilter,)<br>ordering_fields = (‘username‘, ‘email‘)</p>
</li>
</ul>
<p>请求 <code>http://example.com/api/users?ordering=account,-username</code>。 </p>
<h3 id="自定义-filter"><a href="#自定义-filter" class="headerlink" title="自定义 filter"></a>自定义 filter</h3><p>自定义 filter 非常简单，只需要定义 <code>filter_queryset(self, request, queryset, view)</code> 方法，并返回一个 queryset 即可。 </p>
<p>直接贴一个我写的例子： </p>
<pre><code>class NodenameFilter(filters.BaseFilterBackend):

    &quot;&quot;&quot;根据 nodename 来删选
      [nodename]: NeiWang
    &quot;&quot;&quot;

    def filter_queryset(self, request, queryset, view):
        nodename = request.QUERY_PARAMS.get(‘nodename‘)
        if nodename:
            return queryset.filter(nodename=nodename)
        else:
            return queryset
</code></pre><p>如果参数匹配有误，想要抛出异常的话，也可以自定义 APIError，举个例子： </p>
<pre><code>from rest_framework.exceptions import APIException


class FilterError(APIException):
    status_code = 406
    default_detail = ‘Query arguments error!‘
</code></pre><p>然后在 viewset 里直接抛出 <code>raise FilterError</code> 即可。 </p>
<hr>
<h2 id="Premissions"><a href="#Premissions" class="headerlink" title="Premissions"></a>Premissions</h2><p>顾名思义就是权限管理，用来给 ViewSet 设置权限，使用 premissions 可以方便的设置不同级别的权限： </p>
<ul>
<li>全局权限控制</li>
<li>ViewSet 的权限控制</li>
<li>Method 的权限</li>
<li>Object 的权限</li>
</ul>
<p>被 premission 拦截的请求会有如下的返回结果： </p>
<ul>
<li>当用户已登录，但是被 premissions 限制，会返回 <code>HTTP 403 Forbidden</code></li>
<li>当用户未登录，被 premissions 限制会返回 <code>HTTP 401 Unauthorized</code></li>
</ul>
<h3 id="默认的权限"><a href="#默认的权限" class="headerlink" title="默认的权限"></a>默认的权限</h3><p>rest_framework 中提供了七种权限 </p>
<ul>
<li><code>AllowAny</code> # 无限制</li>
<li><code>IsAuthenticated</code> # 登陆用户</li>
<li><code>IsAdminUser</code> # Admin 用户</li>
<li><code>IsAuthenticatedOrReadOnly</code> # 非登录用户只读</li>
<li><code>DjangoModelPermissions</code> # 以下都是根据 Django 的 ModelPremissions</li>
<li><code>DjangoModelPermissionsOrAnonReadOnly</code></li>
<li><code>DjangoObjectPermissions</code></li>
</ul>
<h3 id="全局权限控制"><a href="#全局权限控制" class="headerlink" title="全局权限控制"></a>全局权限控制</h3><p>在 settings.py 中可以设置全局默认权限 </p>
<pre><code># settings.py

REST_FRAMEWORK = {
    ‘DEFAULT_PERMISSION_CLASSES‘: (
        ‘rest_framework.permissions.AllowAny‘,
    ),
}
</code></pre><h3 id="ViewSet-的权限"><a href="#ViewSet-的权限" class="headerlink" title="ViewSet 的权限"></a>ViewSet 的权限</h3><p>可以设置 <code>permission_classes</code> 的类属性来给 viewset 设定权限，restframework 会检查元组内的每一个 premission，必须要全部通过才行。 </p>
<pre><code>class UserViewSet(viewsets.ReadOnlyModelViewSet):
    queryset = User.objects.all()
    serializer_class = UserSerializer
    # 设置权限，是一个元组
    permission_classes = (permissions.IsAuthenticated,)
</code></pre><h3 id="自定义权限"><a href="#自定义权限" class="headerlink" title="自定义权限"></a>自定义权限</h3><p>Premissions 可以非常方便的定制，比如我就自己写了一个只允许 owner 编辑的权限 </p>
<pre><code># myproject/myapp/premissions.py

#! /usr/bin/env python
# -*- coding: utf-8
from __future__ import unicode_literals, absolute_import

from rest_framework import permissions


class IsOwnerOrReadOnly(permissions.BasePermission):

    def has_permission(self, request, view):
        &quot;&quot;&quot;针对每一次请求的权限检查&quot;&quot;&quot;
        if request.method in permissions.SAFE_METHODS:
            return True

    def has_object_permission(self, request, view, obj):
        &quot;&quot;&quot;针对数据库条目的权限检查，返回 True 表示允许&quot;&quot;&quot;
        # 允许访问只读方法
        if request.method in permissions.SAFE_METHODS:
            return True

        # 非安全方法需要检查用户是否是 owner
        return obj.owner == request.user
</code></pre><hr>
<h2 id="urls-amp-routers"><a href="#urls-amp-routers" class="headerlink" title="urls &amp; routers"></a>urls &amp; routers</h2><pre><code># myproject/myapp/urls.py

#! /usr/bin/env python
# -*- coding: utf-8
from __future__ import unicode_literals, absolute_import

from django.conf.urls import url, patterns, include
from rest_framework.routers import DefaultRouter

from . import views


# as_view 方法生成 view
# 可以非常方便的指定 `{Http Method: View Method}`
user_detail = views.UserViewSet.as_view({‘get‘: ‘retrieve‘})
user_list = views.UserViewSet.as_view({‘get‘: ‘list‘, ‘post‘: ‘create‘})

# plaintext 是我的自定义方法，也可以非常方便的指定
modal_plain = views.ModelViewSet.as_view({‘get‘: ‘plaintext‘})
model_detail = views.ModelViewSet.as_view({‘get‘: ‘retrieve‘, ‘post‘: ‘create‘})
model_list = views.ModelViewSet.as_view({‘get‘: ‘list‘, ‘post‘: ‘create‘})

# router 的作用就是自动生成 Api Root 页面
router = DefaultRouter()
router.register(r‘models‘, views.ModelViewSet)
router.register(r‘users‘, views.UserViewSet)


# 不要忘了把 views 注册到 urls 中
urlpatterns = patterns(
    ‘‘,
    url(r‘^‘, include(router.urls)),  # Api Root
    url(r‘^api-auth/‘, include(‘rest_framework.urls‘, namespace=‘rest_framework‘)),
    url(r‘^models/(?P&lt;pk&gt;[0-9]+)/$‘, model_detail, name=‘model-detail‘),
    url(r‘^models/(?P&lt;pk&gt;[0-9]+)/plain/$‘, modal_plain, name=‘model-plain‘),
    url(r‘^models/$‘, model_list, name=‘model-list‘),
    url(r‘^users/$‘, user_list, name=‘user-list‘),
    url(r‘^users/(?P&lt;pk&gt;[0-9]+)/$‘, user_detail, name=‘user-detail‘),
)
</code></pre><hr>
<p>时间仓促，就介绍这些，以后有空再介绍一下在 Django 用 JWT 作为身份凭证。下面是一些效果图 </p>
<ul>
<li>Api Root</li>
</ul>
<p><img src="http://7s1ruy.com1.z0.glb.clouddn.com/srceen_shot%202015-07-20%20%E4%B8%8B%E5%8D%8810.47.10.png" alt="技术分享"></p>
<ul>
<li>Users</li>
</ul>
<p><img src="http://7s1ruy.com1.z0.glb.clouddn.com/srceen_shot%202015-07-20%20%E4%B8%8B%E5%8D%8810.48.50.png" alt="技术分享"></p>
<hr>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
    
    </summary>
    
      <category term="Python" scheme="https://wangyu1997.github.io/categories/Python/"/>
    
    
      <category term="Django REST framework" scheme="https://wangyu1997.github.io/tags/Django-REST-framework/"/>
    
  </entry>
  
  <entry>
    <title>跟着 Github 学习 Restful HTTP API 设计</title>
    <link href="https://wangyu1997.github.io/2017/07/26/Python/Restful%20HTTP%20API%20/"/>
    <id>https://wangyu1997.github.io/2017/07/26/Python/Restful HTTP API /</id>
    <published>2017-07-26T12:43:11.000Z</published>
    <updated>2017-07-26T05:32:35.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a> 
<p>近几年提供 <code>HTTP API</code> 服务的公司越来越多，许多公司都把 API 作为产品重要的一部分，作为服务提供出去。而微服务的兴起，也让企业内部开始重视和频繁使用 HTTP API 。好的 <code>HTTP API</code> 设计容易理解、符合 RFC 标准、提供使用者便利的功能，其中经常被拿来作为教科书典范的当属 <a href="https://developer.github.com/v3/" target="_blank" rel="external">Github API</a>。这篇文章就通过 <code>Github API</code> 总结了一些非常好的设计原则，可以作为以后要编写 HTTP API 的参考。 </p>
<p>注意：这篇文章只讨论设计原则，不是强制要求（API 设计者可以根据实际情况实现部分内容，甚至实现出和某些原则相反的内容），也不会给出实现的思路和细节。 </p>
<h2 id="1-使用-HTTPS"><a href="#1-使用-HTTPS" class="headerlink" title="1. 使用 HTTPS"></a>1. 使用 HTTPS</h2><p>这个和 Restful API 本身没有很大的关系，但是对于增加网站的安全是非常重要的。特别如果你提供的是公开 API，用户的信息泄露或者被攻击会严重影响网站的信誉。 </p>
<p>NOTE：不要让非SSL的url访问重定向到SSL的url。 </p>
<h2 id="2-API-地址和版本"><a href="#2-API-地址和版本" class="headerlink" title="2. API 地址和版本"></a>2. API 地址和版本</h2><p>在 <code>url</code> 中指定 API 的版本是个很好地做法。如果 API 变化比较大，可以把 API 设计为子域名，比如 <code>https://api.github.com/v3</code>；也可以简单地把版本放在路径中，比如 <code>https://example.com/api/v1</code>。 </p>
<h2 id="3-schema"><a href="#3-schema" class="headerlink" title="3. schema"></a>3. schema</h2><p>对于响应返回的格式，JSON 因为它的可读性、紧凑性以及多种语言支持等优点，成为了 HTTP API 最常用的返回格式。因此，最好采用 JSON 作为返回内容的格式。如果用户需要其他格式，比如 <code>xml</code>，应该在请求头部 <code>Accept</code> 中指定。对于不支持的格式，服务端需要返回正确的 status code，并给出详细的说明。 </p>
<h2 id="4-以资源为中心的-URL-设计"><a href="#4-以资源为中心的-URL-设计" class="headerlink" title="4. 以资源为中心的 URL 设计"></a>4. 以资源为中心的 URL 设计</h2><p>资源是 <code>Restful API</code> 的核心元素，所有的操作都是针对特定资源进行的。而资源就是 <code>URL</code>（Uniform Resoure Locator）表示的，所以简洁、清晰、结构化的 URL 设计是至关重要的。Github 可以说是这方面的典范，下面我们就拿 <code>repository</code> 来说明。 </p>
<pre><code>/users/:username/repos
/users/:org/repos
/repos/:owner/:repo
/repos/:owner/:repo/tags
/repos/:owner/:repo/branches/:branch
</code></pre><p>我们可以看到几个特性： </p>
<ul>
<li>资源分为单个文档和集合，尽量使用复数来表示资源，单个资源通过添加 id 或者 name 等来表示</li>
<li>一个资源可以有多个不同的 URL</li>
<li>资源可以嵌套，通过类似目录路径的方式来表示，以体现它们之间的关系</li>
</ul>
<p><strong>NOTE</strong>: 根据RFC3986定义，URL是大小写敏感的。所以为了避免歧义，尽量使用小写字母。 </p>
<h2 id="5-使用正确的-Method"><a href="#5-使用正确的-Method" class="headerlink" title="5. 使用正确的 Method"></a>5. 使用正确的 Method</h2><p>有了资源的 URL 设计，所有针对资源的操作都是使用 HTTP 方法指定的。比较常用的方法有： </p>
<p>Verb描述</p>
<p>HEAD<br>只获取某个资源的头部信息。比如只想了解某个文件的大小，某个资源的修改日期等 </p>
<p>GET<br>获取资源 </p>
<p>POST<br>创建资源 </p>
<p>PATCH<br>更新资源的部分属性。因为 PATCH 比较新，而且规范比较复杂，所以真正实现的比较少，一般都是用 POST 替代 </p>
<p>PUT<br>替换资源，客户端需要提供新建资源的所有属性。如果新内容为空，要设置 <code>Content-Length</code> 为 0，以区别错误信息 </p>
<p>DELETE<br>删除资源 </p>
<p>比如： </p>
<pre><code>GET /repos/:owner/:repo/issues
GET /repos/:owner/:repo/issues/:number
POST /repos/:owner/:repo/issues
PATCH /repos/:owner/:repo/issues/:number
DELETE /repos/:owner/:repo
</code></pre><p>NOTE：更新和创建操作应该返回最新的资源，来通知用户资源的情况；删除资源一般不会返回内容。 </p>
<h3 id="不符合-CRUD-的情况"><a href="#不符合-CRUD-的情况" class="headerlink" title="不符合 CRUD 的情况"></a>不符合 CRUD 的情况</h3><p>在实际资源操作中，总会有一些不符合 <code>CRUD</code>（Create-Read-Update-Delete） 的情况，一般有几种处理方法。 </p>
<h4 id="使用-POST"><a href="#使用-POST" class="headerlink" title="使用 POST"></a>使用 POST</h4><p>为需要的动作增加一个 endpoint，使用 POST 来执行动作，比如 <code>POST /resend</code> 重新发送邮件。 </p>
<h4 id="增加控制参数"><a href="#增加控制参数" class="headerlink" title="增加控制参数"></a>增加控制参数</h4><p>添加动作相关的参数，通过修改参数来控制动作。比如一个博客网站，会有把写好的文章“发布”的功能，可以用上面的 <code>POST /articles/{:id}/publish</code> 方法，也可以在文章中增加 <code>published:boolean</code> 字段，发布的时候就是更新该字段 <code>PUT /articles/{:id}?published=true</code></p>
<h4 id="把动作转换成资源"><a href="#把动作转换成资源" class="headerlink" title="把动作转换成资源"></a>把动作转换成资源</h4><p>把动作转换成可以执行 <code>CRUD</code> 操作的资源， github 就是用了这种方法。 </p>
<p>比如“喜欢”一个 gist，就增加一个 <code>/gists/:id/star</code> 子资源，然后对其进行操作：“喜欢”使用 <code>PUT /gists/:id/star</code>，“取消喜欢”使用 <code>DELETE /gists/:id/star</code> 。 </p>
<p>另外一个例子是 <code>Fork</code>，这也是一个动作，但是在 gist 下面增加 <code>forks</code>资源，就能把动作变成 <code>CRUD</code> 兼容的：<code>POST /gists/:id/forks</code> 可以执行用户 fork 的动作。 </p>
<h2 id="6-Query-让查询更自由"><a href="#6-Query-让查询更自由" class="headerlink" title="6. Query 让查询更自由"></a>6. Query 让查询更自由</h2><p>比如查询某个 repo 下面 issues 的时候，可以通过以下参数来控制返回哪些结果： </p>
<ul>
<li>state：issue 的状态，可以是 <code>open</code>，<code>closed</code>，<code>all</code></li>
<li>since：在指定时间点之后更新过的才会返回</li>
<li>assignee：被 assign 给某个 user 的 issues</li>
<li>sort：选择排序的值，可以是 <code>created</code>、<code>updated</code>、<code>comments</code></li>
<li>direction：排序的方向，升序（asc）还是降序（desc）</li>
<li>……</li>
</ul>
<h2 id="7-分页-Pagination"><a href="#7-分页-Pagination" class="headerlink" title="7. 分页 Pagination"></a>7. 分页 Pagination</h2><p>当返回某个资源的列表时，如果要返回的数目特别多，比如 github 的 <code>/users</code>，就需要使用分页分批次按照需要来返回特定数量的结果。 </p>
<p>分页的实现会用到上面提到的 url query，通过两个参数来控制要返回的资源结果： </p>
<ul>
<li>per_page：每页返回多少资源，如果没提供会使用预设的默认值；这个数量也是有一个最大值，不然用户把它设置成一个非常大的值（比如 <code>99999999</code>）也失去了设计的初衷</li>
<li>page：要获取哪一页的资源，默认是第一页</li>
</ul>
<p>返回的资源列表为 <code>[(page-1)*per_page, page*per_page)</code>。github API 文档中还提到一个很好的点，相关的分页信息还可以存放到 <code>Link</code> 头部，这样客户端可以直接得到诸如<code>下一页</code>、<code>最后一页</code>、<code>上一页</code>等内容的 url 地址，而不是自己手动去计算和拼接。 </p>
<h2 id="8-选择合适的状态码"><a href="#8-选择合适的状态码" class="headerlink" title="8. 选择合适的状态码"></a>8. 选择合适的状态码</h2><p>HTTP 应答中，需要带一个很重要的字段：<code>status code</code>。它说明了请求的大致情况，是否正常完成、需要进一步处理、出现了什么错误，对于客户端非常重要。状态码都是三位的整数，大概分成了几个区间： </p>
<ul>
<li><code>2XX</code>：请求正常处理并返回</li>
<li><code>3XX</code>：重定向，请求的资源位置发生变化</li>
<li><code>4XX</code>：客户端发送的请求有错误</li>
<li><code>5XX</code>：服务器端错误</li>
</ul>
<p>在 HTTP API 设计中，经常用到的状态码以及它们的意义如下表： </p>
<p>状态码Label解释</p>
<p>200<br>OK<br>请求成功接收并处理，一般响应中都会有 body </p>
<p>201<br>Created<br>请求已完成，并导致了一个或者多个资源被创建，最常用在 POST 创建资源的时候 </p>
<p>202<br>Accepted<br>请求已经接收并开始处理，但是处理还没有完成。一般用在异步处理的情况，响应 body 中应该告诉客户端去哪里查看任务的状态 </p>
<p>204<br>No Content<br>请求已经处理完成，但是没有信息要返回，经常用在 PUT 更新资源的时候（客户端提供资源的所有属性，因此不需要服务端返回）。如果有重要的 metadata，可以放到头部返回 </p>
<p>301<br>Moved Permanently<br>请求的资源已经永久性地移动到另外一个地方，后续所有的请求都应该直接访问新地址。服务端会把新地址写在 <code>Location</code> 头部字段，方便客户端使用。允许客户端把 POST 请求修改为 GET。 </p>
<p>304<br>Not Modified<br>请求的资源和之前的版本一样，没有发生改变。用来缓存资源，和条件性请求（conditional request）一起出现 </p>
<p>307<br>Temporary Redirect<br>目标资源暂时性地移动到新的地址，客户端需要去新地址进行操作，但是<strong>不能</strong>修改请求的方法。 </p>
<p>308<br>Permanent Redirect<br>和 301 类似，除了客户端<strong>不能</strong>修改原请求的方法 </p>
<p>400<br>Bad Request<br>客户端发送的请求有错误（请求语法错误，body 数据格式有误，body 缺少必须的字段等），导致服务端无法处理 </p>
<p>401<br>Unauthorized<br>请求的资源需要认证，客户端没有提供认证信息或者认证信息不正确 </p>
<p>403<br>Forbidden<br>服务器端接收到并理解客户端的请求，但是客户端的权限不足。比如，普通用户想操作只有管理员才有权限的资源。 </p>
<p>404<br>Not Found<br>客户端要访问的资源不存在，链接失效或者客户端伪造 URL 的时候回遇到这个情况 </p>
<p>405<br>Method Not Allowed<br>服务端接收到了请求，而且要访问的资源也存在，但是不支持对应的方法。服务端<strong>必须</strong>返回 <code>Allow</code> 头部，告诉客户端哪些方法是允许的 </p>
<p>415<br>Unsupported Media Type<br>服务端不支持客户端请求的资源格式，一般是因为客户端在 <code>Content-Type</code> 或者 <code>Content-Encoding</code> 中申明了希望的返回格式，但是服务端没有实现。比如，客户端希望收到 <code>xml</code>返回，但是服务端支持 <code>Json</code></p>
<p>429<br>Too Many Requests<br>客户端在规定的时间里发送了太多请求，在进行限流的时候会用到 </p>
<p>500<br>Internal Server Error<br>服务器内部错误，导致无法完成请求的内容 </p>
<p>503<br>Service Unavailable<br>服务器因为负载过高或者维护，暂时无法提供服务。服务器端应该返回 <code>Retry-After</code> 头部，告诉客户端过一段时间再来重试 </p>
<p>上面这些状态码覆盖了 API 设计中大部分的情况，如果对某个状态码不清楚或者希望查看更完整的列表，可以参考 <a href="https://httpstatuses.com/" target="_blank" rel="external">HTTP Status Code</a> 这个网站，或者 <a href="https://tools.ietf.org/html/rfc7231#section-6" target="_blank" rel="external">RFC7231 Response Status Codes</a> 的内容。 </p>
<h2 id="9-错误处理：给出详细的信息"><a href="#9-错误处理：给出详细的信息" class="headerlink" title="9. 错误处理：给出详细的信息"></a>9. 错误处理：给出详细的信息</h2><p>如果出错的话，在 response body 中通过 <code>message</code> 给出明确的信息。 </p>
<p>比如客户端发送的请求有错误，一般会返回 <code>4XX Bad Request</code> 结果。这个结果很模糊，给出错误 message 的话，能更好地让客户端知道具体哪里有问题，进行快速修改。 </p>
<ul>
<li>如果请求的 JSON 数据无法解析，会返回 <code>Problems parsing JSON</code></li>
<li>如果缺少必要的 filed，会返回 <code>422 Unprocessable Entity</code>，除了 message 之外，还通过 <code>errors</code> 给出了哪些 field 缺少了，能够方便调用方快速排错</li>
</ul>
<p>基本的思路就是尽可能提供更准确的错误信息：比如数据不是正确的 json，缺少必要的字段，字段的值不符合规定…… 而不是直接说“请求错误”之类的信息。 </p>
<h2 id="10-验证和授权"><a href="#10-验证和授权" class="headerlink" title="10. 验证和授权"></a>10. 验证和授权</h2><p>一般来说，让任何人随意访问公开的 API 是不好的做法。验证和授权是两件事情： </p>
<ul>
<li>验证（Authentication）是为了确定用户是其申明的身份，比如提供账户的密码。不然的话，任何人伪造成其他身份（比如其他用户或者管理员）是非常危险的</li>
<li>授权（Authorization）是为了保证用户有对请求资源特定操作的权限。比如用户的私人信息只能自己能访问，其他人无法看到；有些特殊的操作只能管理员可以操作，其他用户有只读的权限等等</li>
</ul>
<p>如果没有通过验证（提供的用户名和密码不匹配，token 不正确等），需要返回 <a href="https://httpstatuses.com/401" target="_blank" rel="external"><strong>401 Unauthorized</strong></a>状态码，并在 body 中说明具体的错误信息；而没有被授权访问的资源操作，需要返回 <a href="https://httpstatuses.com/403" target="_blank" rel="external"><strong>403 Forbidden</strong></a> 状态码，还有详细的错误信息。 </p>
<p><strong>NOTE</strong>：Github API 对某些用户未被授权访问的资源操作返回 <a href="https://httpstatuses.com/404" target="_blank" rel="external"><strong>404 Not Found</strong></a>，目的是为了防止私有资源的泄露（比如黑客可以自动化试探用户的私有资源，返回 403 的话，就等于告诉黑客用户有这些私有的资源）。 </p>
<h2 id="11-限流-rate-limit"><a href="#11-限流-rate-limit" class="headerlink" title="11. 限流 rate limit"></a>11. 限流 rate limit</h2><p>如果对访问的次数不加控制，很可能会造成 API 被滥用，甚至被 <a href="https://en.wikipedia.org/wiki/Denial-of-service_attack" target="_blank" rel="external">DDos 攻击</a>。根据使用者不同的身份对其进行限流，可以防止这些情况，减少服务器的压力。 </p>
<p>对用户的请求限流之后，要有方法告诉用户它的请求使用情况，<code>Github API</code> 使用的三个相关的头部： </p>
<ul>
<li><code>X-RateLimit-Limit</code>: 用户每个小时允许发送请求的最大值</li>
<li><code>X-RateLimit-Remaining</code>：当前时间窗口剩下的可用请求数目</li>
<li><code>X-RateLimit-Rest</code>: 时间窗口重置的时候，到这个时间点可用的请求数量就会变成 <code>X-RateLimit-Limit</code> 的值</li>
</ul>
<p>如果允许没有登录的用户使用 API（可以让用户试用），可以把 <code>X-RateLimit-Limit</code> 的值设置得很小，比如 Github 使用的 <code>60</code>。没有登录的用户是按照请求的 IP 来确定的，而登录的用户按照认证后的信息来确定身份。 </p>
<p>对于超过流量的请求，可以返回 <a href="https://httpstatuses.com/429" target="_blank" rel="external"><strong>429 Too many requests</strong></a> 状态码，并附带错误信息。而 <code>Github API</code> 返回的是 <a href="https://httpstatuses.com/403" target="_blank" rel="external"><strong>403 Forbidden</strong></a>，虽然没有 <code>429</code> 更准确，也是可以理解的。 </p>
<p>Github 更进一步，提供了不影响当然 <code>RateLimit</code> 的请求查看当前 <code>RateLimit</code> 的接口 <a href="https://developer.github.com/v3/rate_limit/" target="_blank" rel="external"><strong>GET /rate_limit</strong></a>。 </p>
<h2 id="12-Hypermedia-API"><a href="#12-Hypermedia-API" class="headerlink" title="12. Hypermedia API"></a>12. Hypermedia API</h2><p>Restful API 的设计最好做到 Hypermedia：在返回结果中提供相关资源的链接。这种设计也被称为 <a href="http://en.wikipedia.org/wiki/HATEOAS" target="_blank" rel="external">HATEOAS</a>。这样做的好处是，用户可以根据返回结果就能得到后续操作需要访问的地址。 </p>
<p>比如访问 <a href="https://api.github.com/" target="_blank" rel="external">api.github.com</a>，就可以看到 Github API 支持的资源操作。 </p>
<h2 id="13-编写优秀的文档"><a href="#13-编写优秀的文档" class="headerlink" title="13. 编写优秀的文档"></a>13. 编写优秀的文档</h2><p>API 最终是给人使用的，不管是公司内部，还是公开的 API 都是一样。即使我们遵循了上面提到的所有规范，设计的 API 非常优雅，用户还是不知道怎么使用我们的 API。最后一步，但非常重要的一步是：为你的 API 编写优秀的文档。 </p>
<p>对每个请求以及返回的参数给出说明，最好给出一个详细而完整地示例，提醒用户需要注意的地方……反正目标就是用户可以根据你的文档就能直接使用 API，而不是要发邮件给你，或者跑到你的座位上问你一堆问题。 </p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://developer.github.com/v3/" target="_blank" rel="external">Github API v3</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html" target="_blank" rel="external">RESTful API 设计指南</a></li>
<li><a href="http://wangwei.info/about-rest-api/" target="_blank" rel="external">REST接口设计规范</a></li>
<li><a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm" target="_blank" rel="external">Restful API 首次被提出的论文：Architectural Styles and the Design of Network-based Software Architectures</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
    
    </summary>
    
      <category term="Python" scheme="https://wangyu1997.github.io/categories/Python/"/>
    
    
      <category term="Restful Framework" scheme="https://wangyu1997.github.io/tags/Restful-Framework/"/>
    
  </entry>
  
</feed>
