<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[docker django+mysql开发环境]]></title>
      <url>/2017/07/05/django+mysql/</url>
      <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a> 
<p>使用docker来搭建开发环境不仅能够跟我们主机的已有的各种软件配置隔离，而且也能够很方便地分发给别人，从而使团队能够在统一的开发环境下快速开始开发、测试和部署。本文采用Docker的docker-compose来搭建python2.7+django1.7.5+mysql的web开发环境，希望可以给需要的同学参考。 </p>
<h2 id="1、项目目录"><a href="#1、项目目录" class="headerlink" title="1、项目目录"></a>1、项目目录</h2><p>创建工程目录mysite </p>
<pre><code>yhc@yhc-E540:~/workspaces/docker$ mkdir mysite &amp;&amp; cd mysite
</code></pre><p>创建以下2个目录（这里为方便放置各个文件，可以根据需要自己组织，后面配置文件做相应修改即可） </p>
<pre><code>yhc@yhc-E540:~/workspaces/docker/mysite$ mkdir db mysite
</code></pre><h2 id="2、配置文件"><a href="#2、配置文件" class="headerlink" title="2、配置文件"></a>2、配置文件</h2><p>（1）Dockerfile </p>
<p>Dockerfile包含创建镜像所需要的全部指令。在项目根目录下创建<code>Dockerfile</code>文件，其内容如下： </p>
<pre><code>FROM python:2.7
ENV PYTHONUNBUFFERED 1
RUN mkdir /code
RUN mkdir /code/db
WORKDIR /code
ADD ./mysite/requirements.txt /code/
RUN pip install -r requirements.txt
ADD . /code/
</code></pre><p>第1行的<code>FROM</code>指令表示新的镜像将基于python:2.7的镜像来构建<br>第2行的<code>ENV</code>为环境变量（PYTHONUNBUFFERED见<a href="https://docs.python.org/2/using/cmdline.html" target="_blank" rel="external">这里</a>）<br>第3行的<code>RUN</code>指令表示在镜像内新建/code目录<br>第4行指定指定RUN、CMD与ENTRYPOINT命令的工作目录<br>第5行是将<code>./mysite/requirements.txt</code>文件添加到刚才新建的code目录中<br>第6行运行<code>pip</code>安装所需的软件 </p>
<p>Dockerfile详细可以参见《<a href="http://yuedu.baidu.com/ebook/d817967416fc700abb68fca1" target="_blank" rel="external">Docker入门实战</a>》<br>以及<a href="http://docs.docker.com/reference/builder/" target="_blank" rel="external">官方参考</a></p>
<p>（2）docker-compose.yml </p>
<p>之前的Dockerfile定义了一个应用，而使用compose，可以在一个文件里，定义多容器的应用。该YAML配置语言，用于描述和组装多容器的分布式应用。在项目根目录创建<code>docker-compose.yml</code>文件，其内容如下： </p>
<pre><code>db:
  image: mysql
  expose:
    - &quot;3306&quot;
  volumes:
    - ./db:/var/lib/mysql
  environment:
    - MYSQL_DATABASE=mysitedb
    - MYSQL_ROOT_PASSWORD=11111111  

web:
  build: .
  command: python ./mysite/manage.py runserver 0.0.0.0:8000
  volumes:
    - .:/code
  ports:
    - &quot;8000:8000&quot;
  links:
    - db
</code></pre><p>db标签：<br>images表示使用mysql镜像<br>expose表示暴露端口3306，但不发布到宿主机上<br>volume表示挂载宿主机的路径作为卷，冒号左边为宿主机路径，右边为镜像内路径<br>environment为环境变量，每个容器都有自己定义的环境变量，具体查看<a href="https://github.com/docker-library/docs" target="_blank" rel="external">镜像手册</a>中的mysql </p>
<p>web标签：<br>build指定建立Dockerfile路径<br>command将覆盖默认的命令<br>ports指定主机开放的端口<br>links指向其他容器中的服务 </p>
<p>更多该配置文件参见<a href="http://docs.docker.com/compose/yml/" target="_blank" rel="external">这里</a></p>
<p>（3）requirements.txt </p>
<p>在子目录mysite下<code>requirements.txt</code>文件，该文件内容如下: </p>
<pre><code>django==1.7.5
MySQL-python
</code></pre><h2 id="3、构建镜像"><a href="#3、构建镜像" class="headerlink" title="3、构建镜像"></a>3、构建镜像</h2><p>在项目根目录执行以下命令 </p>
<pre><code>yhc@yhc-E540:~/workspaces/docker/mysite$ docker-compose build
db uses an image, skipping
Building web...
Step 0 : FROM python:2.7
 ---&gt; d833e0b23482
Step 1 : ENV PYTHONUNBUFFERED 1
 ---&gt; Using cache
 ---&gt; df633fc1ab0e
Step 2 : RUN mkdir /code
 ---&gt; Using cache
 ---&gt; 49bb20e37bfc
Step 3 : WORKDIR /code
 ---&gt; Using cache
 ---&gt; f84fca46a343
Step 4 : ADD ./mysite/requirements.txt /code/
 ---&gt; e8f756bed13e
Removing intermediate container 91e677d50cd4
Step 5 : RUN pip install -r requirements.txt
 ---&gt; Running in 7eb86e071025
Collecting django==1.7.5 (from -r requirements.txt (line 1))
  Downloading Django-1.7.5-py2.py3-none-any.whl (7.4MB)
Collecting MySQL-python (from -r requirements.txt (line 2))
  Downloading MySQL-python-1.2.5.zip (108kB)
Installing collected packages: django, MySQL-python
  Running setup.py install for MySQL-python
Successfully installed MySQL-python-1.2.5 django-1.7.5
 ---&gt; 3e5c9b891397
Removing intermediate container 7eb86e071025
Step 6 : ADD . /code/
 ---&gt; 251dea7e2af2
Removing intermediate container b4b0c2b08538
Successfully built 251dea7e2af2
</code></pre><p>如果本地没有python和mysql镜像的话下载需要多等待一些时间。完成之后就构建好了python+django+mysql的镜像。 </p>
<h2 id="4、创建django工程"><a href="#4、创建django工程" class="headerlink" title="4、创建django工程"></a>4、创建django工程</h2><p>执行以下命令 </p>
<pre><code>yhc@yhc-E540:~/workspaces/docker/mysite$ docker-compose run web django-admin.py startproject mysite ./mysite
Starting dockermysite_db_1...
</code></pre><p>完成之后就在子目录mysite下创建了一个新的django工程<br>因为在镜像内是以root权限创建的，所以宿主机中对工程文件无法进行更改，这里修改一下权限 </p>
<pre><code>yhc@yhc-E540:~/workspaces/docker/mysite$ sudo chmod -R 777 mysite/
</code></pre><p>修改<code>setttings.py</code>文件中数据库配置 </p>
<pre><code>DATABASES = {
    &#39;default&#39;: {
        &#39;ENGINE&#39;: &#39;django.db.backends.mysql&#39;,
        &#39;NAME&#39;: &#39;mysitedb&#39;,
        &#39;USER&#39;: &#39;root&#39;,
        &#39;PASSWORD&#39;: &#39;11111111&#39;,
        &#39;HOST&#39;: &#39;db&#39;,
        &#39;PORT&#39;: 3306,
    }
}
</code></pre><h2 id="5、运行"><a href="#5、运行" class="headerlink" title="5、运行"></a>5、运行</h2><pre><code>yhc@yhc-E540:~/workspaces/docker/mysite$ docker-compose up
</code></pre><p>![这里写图片描述][6]</p>
<p>   [6]: <a href="http://img.blog.csdn.net/20150513192620732" target="_blank" rel="external">http://img.blog.csdn.net/20150513192620732</a> ()</p>
<p>浏览器地址栏中输入：<a href="http://127.0.0.1:8000/" target="_blank" rel="external">http://127.0.0.1:8000/</a><br>可以看到成功运行 </p>
<p>![这里写图片描述][8]</p>
<p>   [8]: <a href="http://img.blog.csdn.net/20150513192443902" target="_blank" rel="external">http://img.blog.csdn.net/20150513192443902</a> ()</p>
<h2 id="6、打包镜像"><a href="#6、打包镜像" class="headerlink" title="6、打包镜像"></a>6、打包镜像</h2><p>（1）查看镜像 </p>
<pre><code>yhc@yhc-E540:~/workspaces/docker/mysite$ docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
mysite_web          latest              251dea7e2af2        8 minutes ago       783 MB
python              2.7                 d833e0b23482        13 days ago         747.9 MB
postgres            latest              b733b00eb1ae        13 days ago         213.9 MB
mysql               latest              56f320bd6adc        3 weeks ago         282.9 MB
</code></pre><p>（2）打包 </p>
<pre><code>yhc@yhc-E540:~/workspaces/docker/mysite$ docker save -o docker-mysite-image.tar.gz mysite_web
yhc@yhc-E540:~/workspaces/docker/mysite$ ls
db  docker-compose.yml  Dockerfile  docker-mysite-image.tar.gz  mysite
</code></pre><p>最后目录如下所示 </p>
<pre><code>yhc@yhc-E540:~/workspaces/docker/mysite$ tree
.
├── db
│   ├── auto.cnf
│   ├── ibdata1
│   ├── ib_logfile0
│   ├── ib_logfile1
│   ├── mysitedb [error opening dir]
│   ├── mysql [error opening dir]
│   └── performance_schema [error opening dir]
├── docker-compose.yml
├── Dockerfile
├── docker-mysite-image.tar.gz
└── mysite
    ├── manage.py
    ├── mysite
    │   ├── __init__.py
    │   ├── __init__.pyc
    │   ├── settings.py
    │   ├── settings.pyc
    │   ├── urls.py
    │   ├── urls.pyc
    │   ├── wsgi.py
    │   └── wsgi.pyc
    └── requirements.txt

6 directories, 17 files
</code></pre><h2 id="7、加载镜像"><a href="#7、加载镜像" class="headerlink" title="7、加载镜像"></a>7、加载镜像</h2><p>​镜像打包好后就可以分发给别的其他的开发人员，只需要加载镜像即可。<br>这里在本机进行测试镜像的加载，首先将原来的镜像删除了 </p>
<pre><code>yhc@yhc-E540:~/workspaces/docker/mysite$ docker rmi -f mysite_web
Untagged: mysite_web:latest
Deleted: 251dea7e2af26522b9e74612163972cb0aca2ec071e7b1696d815097db105770
Deleted: 3e5c9b8913971f90b4c94e8b0e04ed4dc2a09da6261fe0a9b3dffa7b0392ce92
Deleted: e8f756bed13e2172a8f522b93728f6aca75795bec0bb032ba154003f4a15b440
</code></pre><p>运行看看 </p>
<pre><code>yhc@yhc-E540:~/workspaces/docker/mysite$ docker-compose up
Recreating mysite_db_1...
Recreating mysite_web_1...
No such image: mysite_web:latest (tag: latest)
</code></pre><p>发现无法运行了<br>​接下来加载镜像 </p>
<pre><code>yhc@yhc-E540:~/workspaces/docker/mysite$ docker load -i docker-mysite-image.tar.gz
</code></pre><p>​再次运行 </p>
<pre><code>yhc@yhc-E540:~/workspaces/docker/mysite$ docker-compose up
</code></pre><p>​ok没问题了～ </p>
<h2 id="8、其他"><a href="#8、其他" class="headerlink" title="8、其他"></a>8、其他</h2><p>还可以运行python shell，命令如下： </p>
<pre><code>yhc@yhc-E540:~/workspaces/docker/mysite$ docker-compose run web mysite/manage.py shell
</code></pre><p>注意按照自己目录结构修改manage.py的位置 </p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> django </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基于docker的django开发环境搭建]]></title>
      <url>/2017/07/02/docker%20django%E7%8E%AF%E5%A2%83/</url>
      <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a> 
<p>本文主要是作为官方<a href="https://docs.docker.com/compose/django/" target="_blank" rel="external">Quickstart: Compose and Django</a>的导读，如果你当下还没了解过Docker，但想知道如何利用Docker来管理自己本地的开发环境，并统一开发和测试的环境,那你可以参考以下内容。 </p>
<h3 id="需求："><a href="#需求：" class="headerlink" title="需求："></a>需求：</h3><p>使用Docker搭建Django开发环境，即本地只需要有python代码即可。 </p>
<h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识:"></a>预备知识:</h3><p>Docker作为容器，和传统虚拟机是不一样的，如下图所示，它是基于Docker Engine的一个容器，且在这一层次上是相互隔离的，而传统虚拟化则是要虚拟化整个系统，因此理论上Docker容器可以更有效的利用资源，你可以很容易在本地环境搭建多服务的复杂系统环境。本篇以一台web服务器及一台数据库服务器为例，当然也可以搭建更复杂的，比如加入一台redis机器等等。  </p>
<p><img src="https://yeasy.gitbooks.io/docker_practice/content/_images/docker.png" alt="Docker%u7ED3%u6784">  </p>
<p>Docker结构 </p>
<p>更多Docker介绍可以看开源版本的<a href="https://yeasy.gitbooks.io/docker_practice/content/introduction/what.html" target="_blank" rel="external">《Docker 从入门到实践》</a>， 内容可能已经有点老，但是基本上还是作为参考。<br>更多，等新，等详细的解释看官方介绍<a href="https://www.docker.com/what-container" target="_blank" rel="external">What is a Cantainer</a></p>
<p><strong>容器</strong>是基于一个<strong>镜像</strong>(image)建立的，比如本地有一个ubuntu的镜像，我们可以基于该镜像去新建多个容器实例，而它们之间可以做到互联，与本地机器的文件共享等。从而可以达到前文提到的，快速在本地搭建一个多服务器的复杂环境。<br>用户可以很方便地对容器进行启动、停止、删除等操作。一个基本的容器启动例子如下，它在启动一个容器后，打印一条Hello world </p>
<pre><code>sudo docker run ubuntu:14.04 /bin/echo &#39;Hello world&#39;
</code></pre><p>镜像被<strong><a href="https://yeasy.gitbooks.io/docker_practice/content/repository/" target="_blank" rel="external">仓库</a></strong>统一管理，Docker官方有自己的仓库Docker Hub，国内可以使用阿里云的镜像仓库，我用的是阿里的，需要在阿里后台生成自己的私有地址，然后在Docker中配置。从镜像仓库获取镜像到本地后，就可以基于镜像新建容器使用了。<br>当然也可以搭建自己的私有仓库，在团队或公司内部使用。 </p>
<p><strong>镜像定制</strong>，当仓库中的官方镜像无法满足需求时，就需要自定义镜像，所有的自定义镜像都可以上传到仓库中，共享给其他用户。Docker镜像的定制主要通过Dockerfile指令文件实现，在指令文件中实现自己的需求即可，比如使用COPY命令将本机文件复制到容器中等。 </p>
<p>[Docker Compose][6]，安装最新的Docker，默认已经包含这个工具，主要用于定义及启动多容器的场景(当前例子基于此工具)，它需要一个docker-compose.yml文件来配置需要启动的容器及相关配置，然后就可以用下述语句新建及启动配置文件中的多容器 </p>
<pre><code>   [6]: https://docs.docker.com/compose/
</code></pre><p>docker-compose up</p>
<p>docker-compose.yml实例： </p>
<pre><code>version: &#39;2&#39;
 services:
   db:  //数据库容器
     image: postgres
   web:  //web服务器容器
     build: .
     command: python manage.py runserver 0.0.0.0:8000
     volumes:   //挂载本地机器文件夹
       - .:/code
     ports:
       - &quot;8000:8000&quot;
     depends_on:
       - db
</code></pre><h3 id="搭建Django开发环境："><a href="#搭建Django开发环境：" class="headerlink" title="搭建Django开发环境："></a>搭建Django开发环境：</h3><p><strong>Step 1</strong>: Define the project components </p>
<p>这个步骤主要是定义project的内容，这里的“project”指我们要搭建的基于Docker的Django开发环境，具体会包含Docker容器配置文件Dockerfile，Django环境需要的requirements.txt配置，docker-compose.yml配置 </p>
<p>Dockerfile 实例： </p>
<pre><code> FROM python:2.7   注：基础镜像
 ENV PYTHONUNBUFFERED 1
 RUN mkdir /code
 WORKDIR /code     注：切换工作上下文
 ADD requirements.txt /code/    
 RUN pip install -r requirements.txt 注：安装python依赖
 ADD . /code/
</code></pre><p><strong>Step 2</strong>：Create a Django project </p>
<p>官方例子是用docker-compose命令运行web服务器(docker-compose.yml配置了web和db两个容器)，然后调用django-admn新建Django项目，由于挂在了本地目录到容器内部，因此当前命令生成的django项目文件能在本地机器目录直接访问。 </p>
<pre><code> docker-compose run web django-admin.py startproject composeexample .
</code></pre><p>注意，此时的web容器已经包含django环境了，因为在web容器的Dockerfile文件配置了python环境搭建的命令，如下所示： </p>
<pre><code>RUN pip install -r requirements.txt
</code></pre><p>对于实际工作项目，我们只需在对应的本地机器目录(即运行docker-compose命令的上下文目录)准备好项目代码即可 </p>
<pre><code> $ ls -l
 drwxr-xr-x 2 root   root   composeexample   注：该项目文件可以是实际工作代码文件夹
 -rw-rw-r-- 1 user   user   docker-compose.yml
 -rw-rw-r-- 1 user   user   Dockerfile
 -rwxr-xr-x 1 root   root   manage.py
 -rw-rw-r-- 1 user   user   requirements.txt
</code></pre><p><strong>Step 3</strong>：Connect the database </p>
<p>这里主要就是设置Django框架下的settings.py文件，注意HOST名字使用 </p>
<pre><code>DATABASES = {
     &#39;default&#39;: {
         &#39;ENGINE&#39;: &#39;django.db.backends.postgresql&#39;,
         &#39;NAME&#39;: &#39;postgres&#39;,
         &#39;USER&#39;: &#39;postgres&#39;,
         &#39;HOST&#39;: &#39;db&#39;,  //另一个容器的名字
         &#39;PORT&#39;: 5432,
     }
 }
</code></pre><p>最后就是再次使用docker-compose新建并启动多个容器 </p>
<pre><code>$ docker-compose up
</code></pre><p><img src="https://docs.docker.com/compose/images/django-it-worked.png" alt="Django%u9875%u9762">  </p>
<p>Django页面 </p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> django </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MarkDown 语法入门]]></title>
      <url>/2017/07/01/MarkDown%20%E8%AF%AD%E6%B3%95%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a> 
<h4 id="导语："><a href="#导语：" class="headerlink" title="导语："></a>导语：</h4><blockquote>
<p><a href="http://zh.wikipedia.org/wiki/Markdown" target="_blank" rel="external">Markdown</a> 是一种轻量级的<strong>「标记语言」</strong>，它的优点很多，目前也被越来越多的写作爱好者，撰稿者广泛使用。看到这里请不要被<strong>「标记」</strong>、<strong>「语言」</strong>所迷惑，Markdown 的语法十分简单。常用的标记符号也不超过十个，这种相对于更为复杂的 HTML 标记语言来说，Markdown 可谓是十分轻量的，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。 </p>
</blockquote>
<p><img src="http://ww3.sinaimg.cn/large/6aee7dbbjw1eqft66xcg3j21kw12mdub.jpg" alt="Ulysses for Mac">  </p>
<p><a href="http://www.ulyssesapp.com" target="_blank" rel="external">Ulysses for Mac</a></p>
<h2 id="一，认识-Markdown"><a href="#一，认识-Markdown" class="headerlink" title="一，认识 Markdown"></a>一，认识 Markdown</h2><p>在刚才的导语里提到，Markdown 是一种用来写作的轻量级<strong>「标记语言」</strong>，它用简洁的语法代替排版，而不像一般我们用的字处理软件 _Word_ 或 _Pages_ 有大量的排版、字体设置。它使我们专心于码字，用「标记」语法，来代替常见的排版格式。例如此文从内容到格式，甚至插图，键盘就可以通通搞定了。目前来看，支持 Markdown 语法的编辑器有很多，包括很多网站（例如<a href="http://jianshu.io" target="_blank" rel="external">简书</a>）也支持了 Markdown 的文字录入。Markdown 从写作到完成，导出格式随心所欲，你可以导出 HTML 格式的文件用来网站发布，也可以十分方便的导出 PDF 格式，这种格式写出的简历更能得到 HR 的好感。甚至可以利用 <a href="http://www.getcloudapp.com" target="_blank" rel="external">CloudApp</a> 这种云服务工具直接上传至网页用来分享你的文章，全球最大的轻博客平台 <a href="http://te1ee.tumblr.com" target="_blank" rel="external">Tumblr</a>，也支持 Mou 这类 Markdown 工具的直接上传。 </p>
<h3 id="Markdown-官方文档"><a href="#Markdown-官方文档" class="headerlink" title="Markdown 官方文档"></a>Markdown 官方文档</h3><blockquote>
<p>这里可以看到官方的 Markdown 语法规则文档，当然，<strong>后文我也会用自己的方式阐述这些语法的具体用法</strong>。 </p>
<ul>
<li><a href="http://daringfireball.net/projects/markdown/syntax" target="_blank" rel="external">_创始人 John Gruber 的 Markdown 语法说明_</a></li>
<li><a href="http://wowubuntu.com/markdown/#list" target="_blank" rel="external">_Markdown 中文版语法说明_</a></li>
</ul>
</blockquote>
<h3 id="使用-Markdown-的优点"><a href="#使用-Markdown-的优点" class="headerlink" title="使用 Markdown 的优点"></a>使用 Markdown 的优点</h3><ul>
<li>专注你的文字内容而不是排版样式，安心写作。</li>
<li>轻松的导出 HTML、PDF 和本身的 .md 文件。</li>
<li>纯文本内容，兼容所有的文本编辑器与字处理软件。</li>
<li>随时修改你的文章版本，不必像字处理软件生成若干文件版本导致混乱。</li>
<li>可读、直观、学习成本低。</li>
</ul>
<h3 id="使用-Markdown-的误区"><a href="#使用-Markdown-的误区" class="headerlink" title="使用 Markdown 的误区"></a>使用 Markdown 的误区</h3><blockquote>
<p>_We believe that writing is about content, about what you want to say – not about fancy formatting._<br>我们坚信写作写的是内容，所思所想，而不是花样格式。<br>— _Ulysses for Mac_</p>
</blockquote>
<ul>
<li>Markdown 旨在简洁、高效，也由于 Markdown 的易读易写，人们用不同的编程语言实现了多个版本的解析器和生成器，这就导致了目前不同的 Markdown 工具集成了不同的功能（基础功能大致相同），例如流程图与时序图，复杂表格与复杂公式的呈现，虽然功能的丰富并没有什么本质的缺点，但终归有些背离初衷，何况在编写的过程中很费神，不如使用专业的工具撰写来的更有效率，所以如果你需实现复杂功能，专业的图形界面工具会更加方便。<strong>当然，如果你对折腾这些不同客户端对 Markdown 的定制所带来高阶功能感到愉悦的话，那也是无可厚非的。</strong></li>
</ul>
<p><img src="http://ww2.sinaimg.cn/large/6aee7dbbgw1eq320claw3j21kw0kjdpc.jpg" alt="flowchart.js on Github（使用 Markdown 绘制流程图）">  </p>
<p><a href="https://github.com/adrai/flowchart.js" target="_blank" rel="external">flowchart.js on Github（使用 Markdown 绘制流程图）</a></p>
<h3 id="我该用什么工具？"><a href="#我该用什么工具？" class="headerlink" title="我该用什么工具？"></a>我该用什么工具？</h3><p><img src="http://mouapp.com/Mou_128.png" alt="Mou for Mac">  </p>
<p>Mou for Mac </p>
<ul>
<li>在 Mac OS X 上，我强烈建议你用 <a href="http://mouapp.com" target="_blank" rel="external">Mou</a> 这款免费且十分好用的 Markdown 编辑器，它支持<strong>实时预览</strong>，既左边是你编辑 Markdown 语言，右边会实时的生成预览效果。不仅如此，Mou 还有一些有趣的偏好设置（_Preference_），例如主题（_Themes_）与样式（_CSS_），它们可以配置出定制化的文本编辑效果与导出效果，如果你对自带的主题与样式不满意还可以到 <a href="https://github.com/search?utf8=%E2%9C%93&amp;q=Mou" target="_blank" rel="external">GitHub</a> 上搜索其它爱好者为 Mou 编写的更多主题样式，导入的方式可以在偏好设置的 Themes 或 CSS 选项中 选择 reload。</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/6aee7dbbgw1effcq2gx92j210j0ustj7.jpg" alt="Mou 的编写与预览窗口">  </p>
<p>Mou 的编写与预览窗口 </p>
<p>如果你从事文字工作，我强烈建议你购买 _<a href="http://www.ulyssesapp.com" target="_blank" rel="external">Ulysses for Mac</a>_，这款软件入围了苹果 Mac App Store 的 _The Best of 2013_。它支持更多的写作格式、多文档的支持。Mou，iA writer 这些软件都是基于单文档的管理方式，而 Ulysses 支持 Folder、Filter 的管理，一个 Folder 里面可以创建多个 Sheet，Sheet 之间也可以进行 Combine 处理。 </p>
<p><img src="http://ww1.sinaimg.cn/large/6aee7dbbjw1eqgrj7suqoj217a0aiq4u.jpg" alt="Mac 上一些 Markdown 编辑器">  </p>
<p>Mac 上一些 Markdown 编辑器 </p>
<ul>
<li>由于笔者很少接触 Windows，Windows 下的 Markdown 没有过多涉猎，经朋友介绍，有两款还算不错，一款叫做 <a href="http://www.markdownpad.com" target="_blank" rel="external">MarkdownPad</a> ，另一款叫做 <a href="http://code52.org/DownmarkerWPF/" target="_blank" rel="external">MarkPad</a>。 </li>
</ul>
<ul>
<li><p>iOS 端很多 app 早已经支持了 Markdown 录入，例如 Drafts，Day One，iA writer 等，另外 Ulysses for iPad 现在已经上架，可以说是 iOS 平台最好的编辑器了。 </p>
</li>
<li><p>在 Web端，我强烈推荐<a href="http://jianshu.io" target="_blank" rel="external">简书</a>这款产品，上面有无数热爱文字的人在不停的创造，分享。在 Web 端使用 Markdown 没有比简书更舒服的地方了，同样支持左右两栏的实时预览，字体优雅，简洁。 </p>
</li>
</ul>
<p><img src="http://ww2.sinaimg.cn/large/6aee7dbbgw1effdkfijo1j21220nigth.jpg" alt="简书的编辑预览模式">  </p>
<p>简书的编辑预览模式 </p>
<h2 id="二，Markdown-语法的简要规则"><a href="#二，Markdown-语法的简要规则" class="headerlink" title="二，Markdown 语法的简要规则"></a>二，Markdown 语法的简要规则</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p><img src="http://ww1.sinaimg.cn/large/6aee7dbbgw1effeaclhiyj20eh09cwez.jpg" alt="标题">  </p>
<p>标题 </p>
<p>标题是每篇文章都需要也是最常用的格式，在 Markdown 中，如果一段文字被定义为标题，只要在这段文字前加 <code>#</code> 号即可。 </p>
<p><code># 一级标题</code></p>
<p><code>## 二级标题</code></p>
<p><code>### 三级标题</code></p>
<p>以此类推，总共六级标题，建议在井号后加一个空格，这是最标准的 Markdown 语法。 </p>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>熟悉 HTML 的同学肯定知道有序列表与无序列表的区别，在 Markdown 下，列表的显示只需要在文字前加上 <code>-</code> 或 <code>*</code> 即可变为无序列表，有序列表则直接在文字前加<code>1.</code> <code>2.</code> <code>3.</code> 符号要和文字之间加上一个字符的空格。 </p>
<p><img src="http://ww4.sinaimg.cn/large/6aee7dbbgw1effew5aftij20d80bz3yw.jpg" alt="无序列表与有序列表">  </p>
<p>无序列表与有序列表 </p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>如果你需要引用一小段别处的句子，那么就要用引用的格式。 </p>
<blockquote>
<p>例如这样 </p>
</blockquote>
<p>只需要在文本前加入 <code>&gt;</code> 这种尖括号（大于号）即可 </p>
<p><img src="http://ww3.sinaimg.cn/large/6aee7dbbgw1effezhonxlj20e009c3yu.jpg" alt="引用">  </p>
<p>引用 </p>
<h3 id="图片与链接"><a href="#图片与链接" class="headerlink" title="图片与链接"></a>图片与链接</h3><p>插入链接与插入图片的语法很像，区别在一个 <code>!</code>号 </p>
<p>图片为：<code>![](){ImgCap}{/ImgCap}</code></p>
<p>链接为：<code>[]()</code></p>
<p>插入图片的地址需要图床，这里推荐<a href="http://weibotuchuang.sinaapp.com" target="_blank" rel="external">围脖图床修复计划</a> 与 <a href="http://www.getcloudapp.com" target="_blank" rel="external">CloudApp</a> 的服务，生成URL地址即可。 </p>
<p><img src="http://ww2.sinaimg.cn/large/6aee7dbbgw1efffa67voyj20ix0ctq3n.jpg" alt="URL 与图片">  </p>
<p>URL 与图片 </p>
<h3 id="粗体与斜体"><a href="#粗体与斜体" class="headerlink" title="粗体与斜体"></a>粗体与斜体</h3><p>Markdown 的粗体和斜体也非常简单，用两个 <code>*</code> 包含一段文本就是粗体的语法，用一个 <code>*</code> 包含一段文本就是斜体的语法。 </p>
<p>例如：<strong>这里是粗体</strong> _这里是斜体_</p>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>表格是我觉得 Markdown 比较累人的地方，例子如下： </p>
<pre><code>| Tables        | Are           | Cool  |
| ------------- |:-------------:| -----:|
| col 3 is      | right-aligned | $1600 |
| col 2 is      | centered      |   $12 |
| zebra stripes | are neat      |    $1 |
</code></pre><p>这种语法生成的表格如下： </p>
<p>TablesAreCool</p>
<p>col 3 is<br>right-aligned<br>$1600 </p>
<p>col 2 is<br>centered<br>$12 </p>
<p>zebra stripes<br>are neat<br>$1 </p>
<h3 id="代码框"><a href="#代码框" class="headerlink" title="代码框"></a>代码框</h3><p>如果你是个程序猿，需要在文章里优雅的引用代码框，在 Markdown下实现也非常简单，只需要用两个 ` 把中间的代码包裹起来。图例： </p>
<p><img src="http://ww3.sinaimg.cn/large/6aee7dbbgw1effg1lsa97j20lt0a8dgs.jpg" alt="">  </p>
<p>使用 <code>tab</code> 键即可缩进。 </p>
<h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>分割线的语法只需要三个 <code>*</code> 号，例如： </p>
<hr>
<blockquote>
<p>到这里，Markdown 的基本语法在日常的使用中基本就没什么大问题了，只要多加练习，配合好用的工具，写起东西来肯定会行云流水。更多的语法规则，其实 Mou 的 Help 文档栗子很好，当你第一次使用 Mou 时，就会显示该文档。可以用来对用的查找和学习。 </p>
</blockquote>
<p><img src="http://ww3.sinaimg.cn/large/6aee7dbbgw1effgmnpgqlj210j0us44j.jpg" alt="">  </p>
<h2 id="三，相关推荐"><a href="#三，相关推荐" class="headerlink" title="三，相关推荐:"></a><strong>三，相关推荐</strong>:</h2><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a><strong>工具</strong></h3><p>_图床工具用来上传图片获取 URL 地址_</p>
<ul>
<li><a href="http://droplr.com" target="_blank" rel="external">Droplr</a></li>
<li><a href="http://www.getcloudapp.com" target="_blank" rel="external">Cloudapp</a></li>
<li><a href="https://itunes.apple.com/cn/app/yi-xiang/id672522335?mt=12&amp;uo=4" target="_blank" rel="external">ezShare for Mac</a></li>
<li><a href="http://weibotuchuang.sinaapp.com" target="_blank" rel="external">围脖图床修复计划</a></li>
</ul>
<p>_在线好用的Markdown工具，为印象笔记而生_</p>
<ul>
<li><a href="http://maxiang.info" target="_blank" rel="external">马克飞象，专为印象笔记打造的Markdown编辑器，非常推荐</a></li>
</ul>
<h3 id="相关文章阅读："><a href="#相关文章阅读：" class="headerlink" title="相关文章阅读："></a><strong>相关文章阅读</strong>：</h3><ul>
<li><a href="http://jianshu.io/p/qqgjln" target="_blank" rel="external">为什么作家应该用 Markdown 保存自己的文稿</a></li>
</ul>
<ul>
<li><a href="http://www.yangzhiping.com/tech/r-markdown-knitr.html" target="_blank" rel="external">Markdown写作浅谈</a></li>
</ul>
<ul>
<li><a href="http://www.appinn.com/markdown-tools/" target="_blank" rel="external">Markdown 工具补完</a></li>
<li><a href="http://jianshu.io/p/63HYZ6" target="_blank" rel="external">Drafts + Scriptogr.am + Dropbox 打造移动端 Markdown 风格博客</a></li>
<li><a href="http://www.ituring.com.cn/article/23" target="_blank" rel="external">图灵社区，怎样使用Markdown</a></li>
<li><a href="http://news.cnblogs.com/n/139649/" target="_blank" rel="external">为什么我们要学习Markdown的三个理由</a></li>
<li><a href="http://ibuick.me/?p=4093" target="_blank" rel="external">Markdown 语法写作入门指南 by ibuick</a></li>
</ul>
<hr>
]]></content>
      
        <categories>
            
            <category> 杂记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用Vultr搭建ShadowSocks教程]]></title>
      <url>/2017/07/01/vultr%E6%90%AD%E5%BB%BAss/</url>
      <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a> 
<h2 id="使用Vultr搭建ShadowSocks教程"><a href="#使用Vultr搭建ShadowSocks教程" class="headerlink" title="使用Vultr搭建ShadowSocks教程"></a>使用Vultr搭建ShadowSocks教程</h2><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>本地发起连接请求，由远程服务器响应后然后将我们需要的数据返回到本地。 </p>
<p>最低消费 </p>
<p>  2.5美元/月 </p>
<h2 id="网速自测"><a href="#网速自测" class="headerlink" title="网速自测"></a>网速自测</h2><p>经过我个人测试后选择的Dallas节点，浏览youtube视频，网速能达到1MB/s<br>，玩美服lol的延迟是200ms-250ms，这个速度已经很不错了，具体分析参考<a href="http://www.vpnps.com/usa_vpn_ping.html" target="_blank" rel="external">《国内连接美国VPN延迟(PING)多少算正常？》</a>。 </p>
<p>PS：浏览其他人的博客都推荐的是LosAngeles节点，具体的自己通过测试后拿主意吧，懒得测试就选洛杉矶节点吧。 </p>
<p>了解更多，请戳<a href="https://www.v2ex.com/t/276585" target="_blank" rel="external">Vultr 节点哪个比较快？</a></p>
<h2 id="知识储备"><a href="#知识储备" class="headerlink" title="知识储备"></a>知识储备</h2><ol>
<li>懂Linux最好，不懂就按照下面操作来吧</li>
<li>肯折腾</li>
<li>懂英语，不懂的话…搭建SS（Shadow Socks）干吗？</li>
</ol>
<h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><h3 id="购买服务器"><a href="#购买服务器" class="headerlink" title="购买服务器"></a>购买服务器</h3><ol>
<li>打开<a href="http://www.vultr.com/?ref=7123587" target="_blank" rel="external">链接1：我的夏季促销推广链接</a>，无效的话尝试 <a href="http://www.vultr.com/?ref=7123587" target="_blank" rel="external">链接2：我的普通推广链接</a>。<br>这两个都指向官网，信不过我的自己去百度搜索vultr官网。【更多信息见最后的Vlutr服务器链接详细说明】 </li>
</ol>
<ol>
<li><p>注册账号并验证邮箱。 </p>
</li>
<li><p>测试速度或直接选择洛杉矶节点，<a href="https://www.vultr.com/faq/" target="_blank" rel="external">测试节点网速请戳我并拉到页面最下面</a>。如果感觉不满意，去试试其他的服务器提供商比如搬瓦工等等，个人感觉vultr还可以。</p>
</li>
<li>充值，点击左侧的Billing，最低五美元，这一步因人而异。我个人选择使用Paypal支付的$5。</li>
<li>搭建服务器，点击左侧的Servers，依次选择Server Location——你测试的最快的或者洛杉矶；Server Type——Cent OS7 x64（这个我可以提供技术支持，本文基于CentOS 7 x64）或其他你懂的；Server Size——只是搭建ss，选第一个就够了($5/mon)；其他的选填。然后点击右下角的Deploy Now。稍等片刻，服务器就可以装好了。</li>
<li>装好后，你可以看到如下界面：</li>
</ol>
<p><img src="https://static.oschina.net/uploads/img/201703/04105521_mL6K.png" alt=""></p>
<p>servers </p>
<p>点击可以查看服务器的相关信息： </p>
<p><img src="https://static.oschina.net/uploads/img/201703/04105521_SgBL.png" alt=""></p>
<p>server information </p>
<p>接下来操作需要的信息是IP Address，Username和Password。这个页面不要关，一会直接复制粘贴相关信息。 </p>
<h3 id="远程连接服务器"><a href="#远程连接服务器" class="headerlink" title="远程连接服务器"></a>远程连接服务器</h3><blockquote>
<p>方法①点击刚才的网页的右上角的五个按钮最左边的View Console进行操作。 </p>
<p>方法②下载Xshell进行操作，建议后者，方面使用（主要是支持复制粘贴）管理。 </p>
</blockquote>
<p>以Xshell为例。 </p>
<ol>
<li>下载安装Xshell。</li>
<li>安装完成后新建会话（Alt+N）。依次填写图中信息。<br>名称可以是Vultr或者其他，协议选择SSH，主机填写之前的IP Address，端口号选择22。</li>
</ol>
<p><img src="https://static.oschina.net/uploads/img/201703/04105522_g2pw.png" alt=""></p>
<p>连接 </p>
<p>点击左侧的用户身份验证，填写信息。方法选择Password，用户名为之前的Username（一般都是root），密码为之前的Password（这个建议直接复制粘贴过来，系统给的有点复杂） </p>
<p><img src="https://static.oschina.net/uploads/img/201703/04105522_X2Iw.png" alt=""></p>
<p>用户身份验证 </p>
<p>填写完之后点击确定。然后点击连接。出现其他提示的话选择接受就可以了。这时你就可以看到一个命令控制台了。这时就算连接成功了。 </p>
<h3 id="搭建-Shadowsocks-服务"><a href="#搭建-Shadowsocks-服务" class="headerlink" title="搭建 Shadowsocks 服务"></a>搭建 Shadowsocks 服务</h3><h4 id="安装组件"><a href="#安装组件" class="headerlink" title="安装组件"></a>安装组件</h4><pre><code>$ yum install m2crypto python-setuptools
$ easy_install pip
$ pip install shadowsocks
</code></pre><h4 id="安装完成后配置服务器参数"><a href="#安装完成后配置服务器参数" class="headerlink" title="安装完成后配置服务器参数"></a>安装完成后配置服务器参数</h4><pre><code>$ vi  /etc/shadowsocks.json
</code></pre><p>写入如下配置: </p>
<pre><code>{
    &quot;server&quot;:&quot;0.0.0.0&quot;,
    &quot;server_port&quot;:443,
    &quot;local_address&quot;: &quot;127.0.0.1&quot;,
    &quot;local_port&quot;:1080,
    &quot;password&quot;:&quot;123456&quot;,
    &quot;timeout&quot;:300,
    &quot;method&quot;:&quot;aes-256-cfb&quot;,
    &quot;fast_open&quot;: false
}
</code></pre><p>多端口的如下： </p>
<pre><code>{
    &quot;server&quot;:&quot;0.0.0.0&quot;,
    &quot;local_address&quot;: &quot;127.0.0.1&quot;,
    &quot;local_port&quot;:1080,
    &quot;port_password&quot;: {
         &quot;443&quot;: &quot;443&quot;,
         &quot;8888&quot;: &quot;8888&quot;
     },
    &quot;timeout&quot;:300,
    &quot;method&quot;:&quot;aes-256-cfb&quot;,
    &quot;fast_open&quot;: false
}
</code></pre><p>其中server字段与local_address填写之前的IP Address。password是自己用于连接这个shadow socks的密码，自定义就好。<br>其他的不需要更改。 </p>
<p>然后保存退出。 </p>
<p>vi 的命令: 按 “i” 进入编辑模式，编辑后按 “esc” 退出编辑模式， 输入 “:wq” 保存退出vi。 </p>
<h3 id="配置防火墙"><a href="#配置防火墙" class="headerlink" title="配置防火墙"></a>配置防火墙</h3><p>这一步主要是为了提高系统安全性。 </p>
<pre><code># 安装防火墙
$ yum install firewalld
# 启动防火墙
$ systemctl start firewalld
</code></pre><h4 id="开启防火墙相应的端口"><a href="#开启防火墙相应的端口" class="headerlink" title="开启防火墙相应的端口"></a>开启防火墙相应的端口</h4><p>方法一(推荐) </p>
<pre><code># 端口号是你自己设置的端口
$ firewall-cmd --permanent --zone=public --add-port=443/tcp
$ firewall-cmd --reload
</code></pre><p>方法二（麻烦，没必要） </p>
<p>新建文件ss.xml </p>
<pre><code>$ vi /usr/lib/firewalld/services/ss.xml
</code></pre><p>粘贴下面的代码 </p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;service&gt;
  &lt;short&gt;SS&lt;/short&gt;
  &lt;description&gt;Shadowsocks port
  &lt;/description&gt;
  &lt;port protocol=&quot;tcp&quot; port=&quot;443&quot;/&gt;
&lt;/service&gt;
</code></pre><p>保存退出。 </p>
<p>开启端口，重启firewalld 服务，下面的ss是上述的文件的名字，区分大小写 </p>
<pre><code>$ firewall-cmd --permanent --add-service=ss
$ firewall-cmd --reload
</code></pre><h3 id="启动-Shadowsocks-服务"><a href="#启动-Shadowsocks-服务" class="headerlink" title="启动 Shadowsocks 服务"></a>启动 Shadowsocks 服务</h3><pre><code>$ ssserver -c /etc/shadowsocks.json
</code></pre><p>如果想干点其他的实现后台运行，使用 </p>
<pre><code>$ nohup ssserver -c /etc/shadowsocks.json &amp;
</code></pre><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p>这样服务器就搭建好了。<a href="http://ssspeed.net/cms/help" target="_blank" rel="external">全平台的连接方法戳我</a>。 </p>
<h3 id="PC连接"><a href="#PC连接" class="headerlink" title="PC连接"></a>PC连接</h3><p>下载Shadow Socks客户端。<a href="http://ssspeed.net/index/download" target="_blank" rel="external">SS加速器客户端下载</a><br>选择适合的版本，下载并解压运行。 </p>
<p>填写信息:服务器地址，端口号，密码，加密方式与代理端口默认即可 </p>
<p><img src="https://static.oschina.net/uploads/img/201703/04105522_sfWq.png" alt=""></p>
<p>SS信息填写 </p>
<p>填写完之后点击确定，然后到托盘中右键选择开启”启用系统代理”。 </p>
<h3 id="iOS连接"><a href="#iOS连接" class="headerlink" title="iOS连接"></a>iOS连接</h3><p>在App Store下载Wingy。 </p>
<p>填写信息:服务器，端口，密码，代理模式，加密方式默认即可。 </p>
<p><img src="https://static.oschina.net/uploads/img/201703/04105522_WJOl.png" alt=""></p>
<p>Wingy信息填写 </p>
<h3 id="MacOS连接"><a href="#MacOS连接" class="headerlink" title="MacOS连接"></a>MacOS连接</h3><p><a href="http://ssspeed.net/cms/22" target="_blank" rel="external">官方教程</a></p>
<h3 id="Android连接"><a href="#Android连接" class="headerlink" title="Android连接"></a>Android连接</h3><p><a href="http://ssspeed.net/cms/26" target="_blank" rel="external">官方教程</a></p>
<h2 id="国外站点"><a href="#国外站点" class="headerlink" title="国外站点"></a>国外站点</h2><p><a href="http://www.google.com/" target="_blank" rel="external">Google</a></p>
<p><a href="http://www.youtube.com/" target="_blank" rel="external">Youtube</a></p>
<p><a href="http://www.facebook.com/" target="_blank" rel="external">Facebook</a></p>
<p>如果以上没有问题的话，这时候你就可以畅游外面的世界了。点击上述链接测试吧。 </p>
<h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><p>_本文原创来自：<a href="https://www.vultrclub.com/174.html_" target="_blank" rel="external">https://www.vultrclub.com/174.html_</a></p>
<p>一般而言，服务器本身的速度是决定我们项目打开速度、下载速度的关键，但是我们也可以借助第三方软件工具等提高加速效果，比如我们肯定很多人都熟悉的锐速、Net-Speeder可以双倍发包流量，可以减少超时和提高下载速度。这不在前一段时间，来自大名鼎鼎的谷歌发布开源<a href="https://www.vultrclub.com/tag/google-bbr/" target="_blank" rel="external">Google BBR</a>工具，可以提高发包数据量，起到加速作用。 </p>
<p>这里，我们也在<a href="https://www.vultrclub.com/" target="_blank" rel="external">Vultr VPS</a>中安装Google BBR工具，因为是支持KVM和XEN架构的，我们的VULTR都是KVM架构所以肯定支持，但是由于内核的问题，我们需要调试和安装必备的内核和组件才 可以使用，我们一起安装试试吧。 </p>
<p>第一、准备工作 </p>
<p>这里我选择使用Vultr美国洛杉矶机房5美金月付方案，系统采用CENTOS7 64BIT。很多人要问为什么不选择速度较好的日本机房，因为日本机房虽然目前用NTT线路，PING速度看着还可以，但是稳定性不行，所以我不选择，尤其是晚上速度很差。 </p>
<p>第二、查看当前核心 </p>
<p>uname -r </p>
<p>这里我们看到当前CENTOS7核心是3.10.0-514.2.2.el7.x86_64，这个核心是不可以安装BBR的。 </p>
<p>第三、更新内核 </p>
<p>rpm –import <a href="https://www.elrepo.org/RPM-GPG-KEY-elrepo.org" target="_blank" rel="external">https://www.elrepo.org/RPM-GPG-KEY-elrepo.org</a> </p>
<p>rpm -Uvh <a href="http://www.elrepo.org/elrepo-release-7.0-2.el7.elrepo.noarch.rpm" target="_blank" rel="external">http://www.elrepo.org/elrepo-release-7.0-2.el7.elrepo.noarch.rpm</a> </p>
<p>安装4.9.0内核 </p>
<p>yum –enablerepo=elrepo-kernel install kernel-ml -y </p>
<p>我们要知道，BBR目前只支持4.9.0内核，其他内核是不行的，需要更换内核才可以。 </p>
<p>第四、检查内核是否更新 </p>
<p>rpm -qa | grep kernel </p>
<p>我们看到了有4.9.0内核，需要启动才可以。 </p>
<p>grub2-set-default 1 </p>
<p>然后重启 </p>
<p>shutdown -r now </p>
<p>第五、检查是否生效 </p>
<p>uname -r </p>
<p>检查当前内核是不是4.9.4-1.el7.elrepo.x86_64. </p>
<p>看来内核是搞定了，我们那就开始安装BBR了。 </p>
<p>第六、安装Google BBR </p>
<p>echo ‘net.core.default_qdisc=fq’ | sudo tee -a /etc/sysctl.conf </p>
<p>echo ‘net.ipv4.tcp_congestion_control=bbr’ | sudo tee -a /etc/sysctl.conf </p>
<p>sysctl -p </p>
<p>第七、检查BBR是否成功 </p>
<p>sysctl net.ipv4.tcp_available_congestion_control </p>
<p>执行命令，看看是否是提示”net.ipv4.tcp_available_congestion_control = bbr cubic reno” </p>
<p>sysctl -n net.ipv4.tcp_congestion_control </p>
<p>执行命令，是否提示bbr </p>
<p>lsmod | grep bbr </p>
<p>执行命令，是否看到BBR提示。 </p>
<p>能看到上面提示，就说明BBR安装成功。后面，我们再去安装需要的工具，比如SS或者其他项目，速度上是有明显提升的。 </p>
]]></content>
      
        <categories>
            
            <category> 那些年倒腾过的服务器 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> shadowsocks </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Centos搭建LNMP环境]]></title>
      <url>/2017/06/21/Centos%20LNMP/</url>
      <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a> 
<p><strong>1. 安装关联库</strong></p>
<pre><code># mkdir -p /data/tgz
# cd /data/tgz
# yum install wget
# yum install pcre
# yum install openssl*
# yum install tar
# yum -y install gcc gcc-c++ autoconf libjpeg libjpeg-devel libpng libpng-devel freetype freetype-devel libxml2 libxml2-devel zlib zlib-devel glibc glibc-devel glib2 glib2-devel bzip2 bzip2-devel ncurses ncurses-devel curl curl-devel e2fsprogs e2fsprogs-devel krb5 krb5-devel libidn libidn-devel openssl openssl-devel openldap openldap-devel nss_ldap openldap-clients openldap-servers make gd gd2 gd-devel gd2-devel

# ulimit -SHn 65535
# wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.36.tar.gz
# tar zxvf pcre-8.36.tar.gz
# cd pcre-8.36
# ./configure --prefix=/data/apps/pcre
# make &amp;&amp; make install
# cd ../
</code></pre><p><strong>  
</strong></p>
<p><strong>2. 安装nginx</strong>  </p>
<pre><code># /usr/sbin/groupadd nginx
# /usr/sbin/useradd -g nginx nginx

# wget http://nginx.org/download/nginx-1.7.9.tar.gz
# tar zxvf nginx-1.7.9.tar.gz
# cd nginx-1.7.9
# ./configure --user=nginx --group=nginx --prefix=/data/apps/nginx --with-http_stub_status_module --with-http_ssl_module --with-pcre=/data/tgz/pcre-8.36 --with-http_realip_module --with-http_image_filter_module
# make &amp;&amp; make install
# cd ../
</code></pre><p><strong>  
</strong></p>
<p><strong>3. 安装MySQL</strong></p>
<pre><code># /usr/sbin/groupadd mysql
# /usr/sbin/useradd -g mysql mysql

# wget http://dev.mysql.com/get/Downloads/MySQL-5.6/mysql-5.6.25-linux-glibc2.5-x86_64.tar.gz
# tar zxvf mysql-5.6.22-linux-glibc2.5-x86_64.tar.gz
# mv mysql-5.6.22-linux-glibc2.5-x86_64 /data/apps/mysql
</code></pre><p><strong>    配置运行MySQL</strong></p>
<pre><code>1）创建数据库存放目录  


# mkdir -p /data/data/mysql/data
# mkdir -p /data/data/mysql/binlog/
# mkdir -p /data/data/mysql/relaylog/
# chown -R mysql:mysql /data/data/mysql/
# yum install libaio


2）创建mysql配置文件  


# vi /etc/my.cnf


    输入以下内容

[client]
port    = 3306
socket  = /tmp/mysql.sock

[mysqld]
character-set-server = utf8
replicate-ignore-db = mysql
replicate-ignore-db = test
replicate-ignore-db = information_schema
user    = mysql
port    = 3306
socket  = /tmp/mysql.sock
basedir = /data/apps/mysql
datadir = /data/data/mysql/data
log-error = /data/data/mysql/mysql_error.log
pid-file = /data/data/mysql/mysql.pid
open_files_limit    = 10240
back_log = 600
max_connections = 5000
max_connect_errors = 6000
external-locking = FALSE
max_allowed_packet = 32M
sort_buffer_size = 1M
join_buffer_size = 1M
thread_cache_size = 300
#thread_concurrency = 8
query_cache_size = 512M
query_cache_limit = 2M
query_cache_min_res_unit = 2k
default-storage-engine = MyISAM
thread_stack = 192K
transaction_isolation = READ-COMMITTED
tmp_table_size = 246M
max_heap_table_size = 246M
long_query_time = 3
log-slave-updates
log-bin = /data/data/mysql/binlog/binlog
binlog_cache_size = 4M
binlog_format = MIXED
max_binlog_cache_size = 8M
max_binlog_size = 1G
relay-log-index = /data/data/mysql/relaylog/relaylog
relay-log-info-file = /data/data/mysql/relaylog/relaylog
relay-log = /data/data/mysql/relaylog/relaylog
expire_logs_days = 30
key_buffer_size = 256M
read_buffer_size = 1M
read_rnd_buffer_size = 16M
bulk_insert_buffer_size = 64M
myisam_sort_buffer_size = 128M
myisam_max_sort_file_size = 10G
myisam_repair_threads = 1
myisam_recover

interactive_timeout = 120
wait_timeout = 120

skip-name-resolve
#master-connect-retry = 10
slave-skip-errors = 1032,1062,126,1114,1146,1048,1396

server-id = 1

innodb_additional_mem_pool_size = 16M
innodb_buffer_pool_size = 512M
innodb_data_file_path = ibdata1:256M:autoextend
innodb_file_io_threads = 4
innodb_thread_concurrency = 8
innodb_flush_log_at_trx_commit = 2
innodb_log_buffer_size = 16M
innodb_log_file_size = 128M
innodb_log_files_in_group = 3
innodb_max_dirty_pages_pct = 90
innodb_lock_wait_timeout = 120
innodb_file_per_table = 0

slow-query-log-file = /data/data/mysql/slow.log
long_query_time = 10

[mysqldump]
quick
max_allowed_packet = 32M


3）以mysql用户帐号的身份建立数据表 

# /data/apps/mysql/scripts/mysql_install_db --basedir=/data/apps/mysql --datadir=/data/data/mysql/data --user=mysql
# sed -i &quot;s#/usr/local/mysql#/data/apps/mysql#g&quot; /data/apps/mysql/bin/mysqld_safe


4）创建mysql启动，重启，停止shell脚本  


# vi /data/apps/mysql/mysql


    输入以下内容（这里的用户名admin和密码12345678接下来的步骤会创建）

#!/bin/sh

mysql_port=3306
mysql_username=&quot;admin&quot;
mysql_password=&quot;12345678&quot;

function_start_mysql()
{
    printf &quot;Starting MySQL...\n&quot;
    /bin/sh /data/apps/mysql/bin/mysqld_safe --defaults-file=/etc/my.cnf 2&gt;&amp;1 &gt; /dev/null &amp;
}

function_stop_mysql()
{
    printf &quot;Stoping MySQL...\n&quot;
    /data/apps/mysql/bin/mysqladmin -u ${mysql_username} -p${mysql_password} -S /tmp/mysql.sock shutdown
}

function_restart_mysql()
{
    printf &quot;Restarting MySQL...\n&quot;
    function_stop_mysql
    sleep 5
    function_start_mysql
}

function_kill_mysql()
{
    kill -9 $(ps -ef | grep &#39;bin/mysqld_safe&#39; | grep ${mysql_port} | awk &#39;{printf $2}&#39;)
    kill -9 $(ps -ef | grep &#39;libexec/mysqld&#39; | grep ${mysql_port} | awk &#39;{printf $2}&#39;)
}

if [ &quot;$1&quot; = &quot;start&quot; ]; then
    function_start_mysql
elif [ &quot;$1&quot; = &quot;stop&quot; ]; then
    function_stop_mysql
elif [ &quot;$1&quot; = &quot;restart&quot; ]; then
function_restart_mysql
elif [ &quot;$1&quot; = &quot;kill&quot; ]; then
function_kill_mysql
else
    printf &quot;Usage: /data/data/mysql/mysql {start|stop|restart|kill}\n&quot;
fi


5）赋予shell脚本可执行权限  


# chmod +x /data/apps/mysql/mysql


6）启动MySQL  


# /data/apps/mysql/mysql start


7）通过命令行登录管理MySQL服务器（提示输入密码时直接回车） 

# /data/apps/mysql/bin/mysql -uroot -p -S /tmp/mysql.sock


8）输入以下SQL语句，创建一个具有root权限的用户（admin）和密码（12345678） 

&gt; GRANT ALL PRIVILEGES ON *.* TO &#39;admin&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;12345678&#39;;
&gt; GRANT ALL PRIVILEGES ON *.* TO &#39;admin&#39;@&#39;127.0.0.1&#39; IDENTIFIED BY &#39;12345678&#39;;
&gt; quit
</code></pre><p>![blob.png][2]</p>
<p>   [2]: <a href="http://www.vckai.com/static/up/image/20150101/1420523394.png" target="_blank" rel="external">http://www.vckai.com/static/up/image/20150101/1420523394.png</a> ()</p>
<pre><code>9）（可选）重启/停止MySQL 

# /data/apps/mysql/mysql restart
# /data/apps/mysql/mysql stop
</code></pre><p><strong>  
</strong></p>
<p><strong>4. 编译安装PHP依赖库</strong>  </p>
<pre><code># mkdir -p /data/apps/libs/

# wget http://www.ijg.org/files/jpegsrc.v9.tar.gz   
# tar zxvf jpegsrc.v9.tar.gz
# cd jpeg-9/
# ./configure --prefix=/data/apps/libs --enable-shared --enable-static
# make &amp;&amp; make install
# cd ../

# wget http://prdownloads.sourceforge.net/libpng/libpng-1.6.2.tar.gz
# tar zxvf libpng-1.6.2.tar.gz
# cd libpng-1.6.2/
# ./configure --prefix=/data/apps/libs
# make &amp;&amp; make install
# cd ../

# wget http://download.savannah.gnu.org/releases/freetype/freetype-2.4.12.tar.gz
# tar zxvf freetype-2.4.12.tar.gz
# cd freetype-2.4.12/
# ./configure --prefix=/data/apps/libs
# make &amp;&amp; make install
# cd ../


# wget --content-disposition &quot;http://downloads.sourceforge.net/mhash/mhash-0.9.9.9.tar.gz?big_mirror=0&quot;
# wget --content-disposition &quot;http://downloads.sourceforge.net/mcrypt/libmcrypt-2.5.8.tar.gz?big_mirror=0&quot;
# wget --content-disposition &quot;http://downloads.sourceforge.net/mcrypt/mcrypt-2.6.8.tar.gz?big_mirror=0&quot;

# tar zxvf libmcrypt-2.5.8.tar.gz
# cd libmcrypt-2.5.8/
# ./configure --prefix=/data/apps/libs
# make &amp;&amp; make install
# cd libltdl/
# ./configure --prefix=/data/apps/libs --enable-ltdl-install
# make &amp;&amp; make install
# cd ../../

# tar zxvf mhash-0.9.9.9.tar.gz
# cd mhash-0.9.9.9/
# ./configure --prefix=/data/apps/libs
# make &amp;&amp; make install
# cd ../

# vi /etc/ld.so.conf


    在文件末尾添加以下内容  


/data/apps/libs/lib


    重新加载该文件，使其即刻生效  


# ldconfig


# tar zxvf mcrypt-2.6.8.tar.gz
# cd mcrypt-2.6.8/
# export LDFLAGS=&quot;-L/data/apps/libs/lib -L/usr/lib&quot;
# export CFLAGS=&quot;-I/data/apps/libs/include -I/usr/include&quot;
# touch malloc.h
# ./configure --prefix=/data/apps/libs --with-libmcrypt-prefix=/data/apps/libs
# make &amp;&amp; make install
# cd ../
</code></pre><p><strong>  
</strong></p>
<p><strong>5. 安装PHP</strong>  </p>
<pre><code># wget --content-disposition http://cn2.php.net/get/php-5.6.4.tar.gz/from/this/mirror
# tar zxvf php-5.6.4.tar.gz
# cd php-5.6.4/
# export LIBS=&quot;-lm -ltermcap -lresolv&quot;
# export DYLD_LIBRARY_PATH=&quot;/data/apps/mysql/lib/:/lib/:/usr/lib/:/usr/local/lib:/lib64/:/usr/lib64/:/usr/local/lib64&quot;
# export LD_LIBRARY_PATH=&quot;/data/apps/mysql/lib/:/lib/:/usr/lib/:/usr/local/lib:/lib64/:/usr/lib64/:/usr/local/lib64&quot;
# ./configure --prefix=/data/apps/php --with-config-file-path=/data/apps/php/etc --with-mysql=/data/apps/mysql --with-mysqli=/data/apps/mysql/bin/mysql_config --with-iconv-dir --with-freetype-dir=/data/apps/libs --with-jpeg-dir=/data/apps/libs --with-png-dir=/data/apps/libs --with-zlib --with-libxml-dir=/usr --enable-xml --disable-rpath --enable-bcmath --enable-shmop --enable-sysvsem --enable-inline-optimization --with-curl --enable-mbregex --enable-fpm --enable-mbstring --with-mcrypt=/data/apps/libs --with-gd --enable-gd-native-ttf --with-openssl --with-mhash --enable-pcntl --enable-sockets --with-xmlrpc --enable-zip --enable-soap --enable-opcache --with-pdo-mysql --enable-maintainer-zts
# make &amp;&amp; make install
# cp php.ini-development /data/apps/php/etc/php.ini
# cd ../
</code></pre><p><strong>  
</strong></p>
<p><strong>6. 安装PHP扩展</strong></p>
<pre><code># wget http://ftp.gnu.org/gnu/autoconf/autoconf-latest.tar.gz
# tar zxvf autoconf-latest.tar.gz
# cd autoconf-2.69/
# ./configure --prefix=/data/apps/libs
# make &amp;&amp; make install
# cd ../

# wget http://pecl.php.net/get/memcache-2.2.7.tgz
# tar zxvf memcache-2.2.7.tgz
# cd memcache-2.2.7/
# export PHP_AUTOCONF=&quot;/data/apps/libs/bin/autoconf&quot;
# export PHP_AUTOHEADER=&quot;/data/apps/libs/bin/autoheader&quot;
# /data/apps/php/bin/phpize
# ./configure --with-php-config=/data/apps/php/bin/php-config
# make &amp;&amp; make install
# cd ../
</code></pre><p>![blob.png][3]</p>
<p>   [3]: <a href="http://www.vckai.com/static/up/image/20150101/1420527473.png" target="_blank" rel="external">http://www.vckai.com/static/up/image/20150101/1420527473.png</a> ()</p>
<pre><code>1）php.ini配置文件中添加memcache扩展  


# vi /data/apps/php/etc/php.ini


    在文件末尾添加以下内容  


extension_dir=&quot;/data/apps/php/lib/php/extensions/no-debug-zts-20131226/&quot;
extension=memcache.so
</code></pre><p><strong>7. 启动nginx+php</strong></p>
<pre><code>mysql的启动就不在这里多说，可参考上面。  


1）调整nginx配置文件(这里只是最简单的可运行php的nginx的配置,详细的自行)**  
</code></pre><p>**</p>
<pre><code># mv /data/apps/nginx/conf/nginx.conf /data/apps/nginx/conf/nginx.conf.default
# vi /data/apps/nginx/conf/nginx.conf


    输入以下内容  


user  nginx;
worker_processes  1;

events {
    worker_connections  1024;
}

http {
    include       mime.types;
    default_type  application/octet-stream;

    sendfile        on;

    keepalive_timeout  65;

    server {
        listen       80;
        server_name  localhost;
        root /data/www;

        location / {
            index  index.html index.htm index.php;
        }

        location ~ \.php$ {
            fastcgi_pass   127.0.0.1:9000;
            fastcgi_index  index.php;
            include        fastcgi.conf;
        }
    }
}


2）创建web目录 

# mkdir -p /data/www
# chown -R nginx:nginx /data/www


3）启动nginx  


# /data/apps/nginx/sbin/nginx


4）启动php-fpm  


# /data/apps/php/sbin/php-fpm
</code></pre><p>OK，现在已经安装完成了，可以在浏览器中输入<a href="http://localhost" target="_blank" rel="external">http://localhost</a>访问你的网站了！ </p>
]]></content>
      
        <categories>
            
            <category> 那些年倒腾过的服务器 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> lnmp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Alamofire 中文使用指南]]></title>
      <url>/2017/06/14/Alamofire%20%E4%B8%AD%E6%96%87%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
      <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><hr>
<p>Alamofire 4.0 是 Alamofire 最新的一个大版本更新, 一个基于 Swift 的 iOS, tvOS, macOS, watchOS 的 HTTP 网络库. 作为一个大版本更新, 就像语义上那样, 4.0 的 API 引入了一些破坏性修改. </p>
<p>这篇导引旨在帮助大家从 Alamofire 3.x 平滑过渡到最新版本, 同时也解释一下新的设计和结构, 以及功能上的更新.<br><a id="more"></a> </p>
<h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><ul>
<li><p>iOS 8.0+, macOS 10.10.0+, tvOS 9.0+ 以及 watchOS 2.0+ </p>
</li>
<li><p>Xcode 8.1+ </p>
</li>
<li><p>Swift 3.0+ </p>
</li>
</ul>
<p>那些想要在 iOS 8 或者 macOS 10.9 使用 Alamofire 的, 请使用 3.x 版本的最新 release(同时支持 Swift 2.2以及2.3) </p>
<h2 id="升级的好处"><a href="#升级的好处" class="headerlink" title="升级的好处"></a>升级的好处</h2><ul>
<li><strong>完美适配 Swift 3:</strong> 跟进了新的 <a href="https://swift.org/documentation/api-design-guidelines/" target="_blank" rel="external">API 设计规范</a>. </li>
</ul>
<ul>
<li><strong>新的错误处理系统:</strong> 根据提案 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0112-nserror-bridging.md" target="_blank" rel="external">SE-0112</a> 里的新模式, 新增了 <code>AFError</code> 类型. </li>
</ul>
<ul>
<li><p><strong>新的 <code>RequestAdapter</code> 协议:</strong> 可以在初始化 <code>Request</code> 的时候进行快速便捷的适配, 例如在请求头里加入 <code>Authorization</code></p>
</li>
<li><p><strong>新的 <code>RequestRetrier</code> 协议:</strong> 可以检测并且重试失败的 <code>Request</code>, 甚至可以自己根据一系列需求去构建一套验证的解决方案( OAuth1, OAuth2, xAuth, Basic Auth 之类的). </p>
</li>
<li><p><strong>新的 <code>Parameter Encoding</code> 协议:</strong> 取代掉之前的 <code>ParameterEncoding</code> 枚举, 允许你更简单的拓展和自定义, 并且在错误时抛出异常, 而不是简单的返回一个元组. </p>
</li>
<li><p><strong>新的请求类型:</strong> 包括 <code>DataRequest</code>, <code>DownloadRequest</code>, <code>UploadRequest</code> 和 <code>StreamRequest</code>, 实现了特定的进度, 验证和序列化的 API 以及各自的 <code>Request</code> 类型. </p>
</li>
<li><p><strong>新的进度 API:</strong> 包括 <code>downloadProgress</code> 和 <code>uploadProgress</code>, 支持 <code>progress</code> 和 <code>Int64</code> 类型, 并且会在指定的线程运行, 默认为主线程. </p>
</li>
<li><p><strong>更强大的数据验证:</strong> 在验证失败的时候, 包括 <code>data</code> 或者 <code>temporaryURL</code> 和 <code>destinationURL</code> 都可以使用内联的闭包去转化服务器返回的错误信息 </p>
</li>
<li><p><strong>新的下载地址处理:</strong> 你可以获得完整的控制权, 而不是像之前那样只是提供一个 <code>destinationURL</code>, 还得创建临时文件夹, 删掉之前的文件. </p>
</li>
<li><p><strong>新的 <code>Response</code> 类型:</strong> 统一 response 的 API, 并且为所有下载任务提供 <code>temporaryURL</code> 和 <code>downloadURL</code>, 以及其它新平台上的任务属性. </p>
</li>
</ul>
<h2 id="API-破坏性的修改"><a href="#API-破坏性的修改" class="headerlink" title="API 破坏性的修改"></a>API 破坏性的修改</h2><p>Alamofire 4 跟进了 Swift 3 里所有的修改, 包括 <a href="https://swift.org/documentation/api-design-guidelines/" target="_blank" rel="external">API 设计规范</a>. 因此, 几乎所有 Alamofire 的 API 都进行了一定程度的修改. 我们没办法把这些修改全部在文档里列出来, 所以我们会把最常用的那些 API 列出来, 然后告诉大家这些 API 进行了哪些修改, 而不是指望那些有时帮倒忙的编译错误提示. </p>
<h3 id="命名空间的修改"><a href="#命名空间的修改" class="headerlink" title="命名空间的修改"></a>命名空间的修改</h3><p>一些常用的类移到了全局命名空间成为一级类, 让他们更容易使用. </p>
<ul>
<li><p><code>Manager</code> 改为 <code>SessionManager</code></p>
</li>
<li><p><code>Request.TaskDelegate</code> 改为 <code>TaskDelegate</code></p>
</li>
<li><p><code>Request.DataTaskDelegate</code> 改为 <code>DataTaskDelegate</code></p>
</li>
<li><p><code>Request.DownloadTaskDelegate</code> 改为 <code>DownloadTaskDelegate</code></p>
</li>
<li><p><code>Request.UploadTaskDelegate</code> 改为 <code>UploadTaskDelegate</code></p>
</li>
</ul>
<p>我们也重新调整了文件结构和组织模式, 帮助更好的跟进代码. 我们希望这可以让更多用户去了解内部结构和 Alamofire 的具体实现. 只是就是力量. </p>
<h3 id="生成请求"><a href="#生成请求" class="headerlink" title="生成请求"></a>生成请求</h3><p>生成请求是 Alamofire 里最主要的操作, 这里有 3.x 以及 4 的等效代码对比. </p>
<h4 id="Data-Request-Simple-with-URL-string"><a href="#Data-Request-Simple-with-URL-string" class="headerlink" title="Data Request - Simple with URL string"></a>Data Request - Simple with URL string</h4><pre><code>// Alamofire 3
Alamofire.request(.GET, urlString).response { request, response, data, error in
    print(request)
    print(response)
    print(data)
    print(error)
}

// Alamofire 4
Alamofire.request(urlString).response { response in // 默认为 `.get` 方法
    debugPrint(response)
}
</code></pre><h4 id="Data-Request-Complex-with-URL-string"><a href="#Data-Request-Complex-with-URL-string" class="headerlink" title="Data Request - Complex with URL string"></a>Data Request - Complex with URL string</h4><pre><code>// Alamofire 3
let parameters: [String: AnyObject] = [&quot;foo&quot;: &quot;bar&quot;]

Alamofire.request(.GET, urlString, parameters: parameters, encoding: .JSON)
        .progress { bytesRead, totalBytesRead, totalBytesExpectedToRead in
                print(&quot;Bytes: \(bytesRead), Total Bytes: \(totalBytesRead), Total Bytes Expected: \(totalBytesExpectedToRead)&quot;)
        }
        .validate { request, response in
                // 自定义的校验闭包 (访问不到服务器返回的数据)
            return .success
        }
    .responseJSON { response in
                debugPrint(response)
        }

// Alamofire 4
let parameters: Parameters = [&quot;foo&quot;: &quot;bar&quot;]

Alamofire.request(urlString, method: .get, parameters: parameters, encoding: JSONEncoding.default)
        .downloadProgress(queue: DispatchQueue.global(qos: .utility)) { progress in
                print(&quot;进度: \(progress.fractionCompleted)&quot;)
        }
        .validate { request, response, data in
                // 自定义的校验闭包, 现在加上了 `data` 参数(允许你提前转换数据以便在必要时挖掘到错误信息)
            return .success
        }
    .responseJSON { response in
                debugPrint(response)
        }
</code></pre><h4 id="Download-Request-Simple-With-URL-string"><a href="#Download-Request-Simple-With-URL-string" class="headerlink" title="Download Request - Simple With URL string"></a>Download Request - Simple With URL string</h4><pre><code>// Alamofire 3
let destination = DownloadRequest.suggestedDownloadDestination()

Alamofire.download(.GET, urlString, destination: destination).response { request, response, data, error in
      // fileURL 在哪, 怎么获取?
    print(request)
    print(response)
    print(data)
    print(error)
}

// Alamofire 4
let destination = DownloadRequest.suggestedDownloadDestination()

Alamofire.download(urlString, to: destination).response { response in // 默认为 `.get` 方法
    print(response.request)
    print(response.response)
        print(response.temporaryURL)
        print(response.destinationURL)
    print(response.error)
}
</code></pre><h4 id="Download-Request-Simple-With-URLRequest"><a href="#Download-Request-Simple-With-URLRequest" class="headerlink" title="Download Request - Simple With URLRequest"></a>Download Request - Simple With URLRequest</h4><pre><code>// Alamofire 3
let destination = DownloadRequest.suggestedDownloadDestination()

Alamofire.download(urlRequest, destination: destination).validate().responseData { response in
      // fileURL 在哪里, 太难获取了
        debugPrint(response)
}

// Alamofire 4
Alamofire.download(urlRequest, to: destination).validate().responseData { response in
        debugPrint(response)
        print(response.temporaryURL)
        print(response.destinationURL)
}
</code></pre><h4 id="Download-Request-Complex-With-URL-String"><a href="#Download-Request-Complex-With-URL-String" class="headerlink" title="Download Request - Complex With URL String"></a>Download Request - Complex With URL String</h4><pre><code>// Alamofire 3
let fileURL: NSURL
let destination: Request.DownloadFileDestination = { _, _ in fileURL }
let parameters: [String: AnyObject] = [&quot;foo&quot;: &quot;bar&quot;]

Alamofire.download(.GET, urlString, parameters: parameters, encoding: .JSON, to: destination)
        .progress { bytesRead, totalBytesRead, totalBytesExpectedToRead in
                print(&quot;Bytes: \(bytesRead), Total Bytes: \(totalBytesRead), Total Bytes Expected: \(totalBytesExpectedToRead)&quot;)
        }
        .validate { request, response in
                // 自定义的校验实现(获取不到临时下载位置和目标下载位置)
            return .success
        }
        .responseJSON { response in
                print(fileURL) // 只有在闭包捕获了的情况才能获取到, 不够理想
                debugPrint(response)
        }

// Alamofire 4
let fileURL: URL
let destination: DownloadRequest.DownloadFileDestination = { _, _ in
        return (fileURL, [.createIntermediateDirectories, .removePreviousFile])
}
let parameters: Parameters = [&quot;foo&quot;: &quot;bar&quot;]

Alamofire.download(urlString, method: .get, parameters: parameters, encoding: JSONEncoding.default, to: destination)
        .downloadProgress(queue: DispatchQueue.global(qos: .utility)) { progress in
                print(&quot;进度: \(progress.fractionCompleted)&quot;)
        }
        .validate { request, response, temporaryURL, destinationURL in
                // 自定义的校验闭包, 现在包含了 fileURL (必要时可以获取到错误信息)
            return .success
        }
        .responseJSON { response in
                debugPrint(response)
                print(response.temporaryURL)
                print(response.destinationURL)
        }
</code></pre><h4 id="Upload-Request-Simple-With-URL-string"><a href="#Upload-Request-Simple-With-URL-string" class="headerlink" title="Upload Request - Simple With URL string"></a>Upload Request - Simple With URL string</h4><pre><code>// Alamofire 3
Alamofire.upload(.POST, urlString, data: data).response { request, response, data, error in
    print(request)
    print(response)
    print(data)
    print(error)
}

// Alamofire 4
Alamofire.upload(data, to: urlString).response { response in // 默认为 `.post` 方法
    debugPrint(response)
}
</code></pre><h4 id="Upload-Request-Simple-With-URLRequest"><a href="#Upload-Request-Simple-With-URLRequest" class="headerlink" title="Upload Request - Simple With URLRequest"></a>Upload Request - Simple With URLRequest</h4><pre><code>// Alamofire 3
Alamofire.upload(urlRequest, file: fileURL).validate().responseData { response in
        debugPrint(response)
}

// Alamofire 4
Alamofire.upload(fileURL, with: urlRequest).validate().responseData { response in
        debugPrint(response)
}
</code></pre><h4 id="Upload-Request-Complex-With-URL-string"><a href="#Upload-Request-Complex-With-URL-string" class="headerlink" title="Upload Request - Complex With URL string"></a>Upload Request - Complex With URL string</h4><pre><code>// Alamofire 3
Alamofire.upload(.PUT, urlString, file: fileURL)
        .progress { bytes, totalBytes, totalBytesExpected in
                // 这里的进度是上传还是下载的?
                print(&quot;Bytes: \(bytesRead), Total Bytes: \(totalBytesRead), Total Bytes Expected: \(totalBytesExpectedToRead)&quot;)
        }
        .validate { request, response in
                // 自定义的校验实现(获取不到服务端的数据)
            return .success
        }
        .responseJSON { response in
                debugPrint(response)
        }

// Alamofire 4
Alamofire.upload(fileURL, to: urlString, method: .put)
        .uploadProgress(queue: DispatchQueue.global(qos: .utility)) { progress in
                print(&quot;上传进度: \(progress.fractionCompleted)&quot;)
        }
        .downloadProgress { progress in // 默认在主队列调用
                print(&quot;下载进度: \(progress.fractionCompleted)&quot;)
        }
        .validate { request, response, data in
                // 自定义的校验闭包, 现在加上了 `data` 参数(允许你提前转换数据以便在必要时挖掘到错误信息)
            return .success
        }
    .responseJSON { response in
                debugPrint(response)
        }
</code></pre><p>就像你看到的, 有很多 API 破坏性的修改, 但常用的 API 还是沿用了原来的设计, 但现在能够通过一行代码去生成更多更复杂的请求, 保持秩序的同时更加简洁. </p>
<h3 id="URLStringConvertible-协议"><a href="#URLStringConvertible-协议" class="headerlink" title="URLStringConvertible 协议"></a>URLStringConvertible 协议</h3><p><code>URLStringConvertible</code> 协议有两个很小的改变. </p>
<h4 id="URLConvertible"><a href="#URLConvertible" class="headerlink" title="URLConvertible"></a>URLConvertible</h4><p>第一个没什么了不起的”大”改变就是 <code>URLStringConvertible</code> 已经被重命名为 <code>URLConvertible</code>. 在 3.x 里, <code>URLStringConvertible</code> 的定义是这样子的: </p>
<pre><code>public protocol URLStringConvertible {
    var URLString: String { get }
}
</code></pre><p>现在在 Alamofire 4 里, <code>URLConvertible</code> 协议是这样定义的: </p>
<pre><code>public protocol URLConvertible {
    func asURL() throws -&gt; URL
}
</code></pre><p>就像你看到的, <code>URLString</code> 属性完全去掉了, 然后换成了可能会抛出异常的 <code>asURL</code> 方法. 为了解释这样做的原因, 我们先回顾一下. </p>
<p>Alamofire 一个最最常见的问题就是用户忘了对 URL 进行百分号编码, 导致 Alamofire 崩溃掉. 直到现在, 我们(Alamofire 团队)的态度都是 Alamofire 就是这么设计的, 而你的 URL 必须遵守 <a href="https://tools.ietf.org/html/rfc2396" target="_blank" rel="external">RFC 2396 协议</a>. 但这对于社区来说并不那么好, 因为我们更希望 Alamofire 告诉我们的 URL 是不合法的而不是直接 crash 掉. </p>
<p>现在, 回到新的 <code>URLConvertible</code> 协议. Alamofire 之所以不能安全地处理不合规范的 URL 字符串, 事实上是因为 <code>URLStringConvertible</code> 安全性的缺失. Alamofire 不可能知道你是怎么造出一个不合法的 URL. 所以, 如果 <code>URL</code> 不能通通过 <code>URLConvertible</code> 被创建的话, 一个 <code>AFError.invalidURL</code> 的异常就会被抛出. </p>
<p>这个修改(以及其它很多修改都)可以让 Alamofire 安全地处理不合理的 URL, 并且会在回调里抛出异常. </p>
<h4 id="URLRequest-Conformance"><a href="#URLRequest-Conformance" class="headerlink" title="URLRequest Conformance"></a>URLRequest Conformance</h4><p><code>URLRequest</code> 不再遵守 <code>URLStringConvertible</code>, 现在是 <code>URLConvertible</code>. 但这也只是之前版本的一个延展而已, 并不那么重要. 不过这很可能会让 Alamofire 的 API 产生歧义. 因此, <code>URLRequest</code> 不再遵守 <code>URLStringConvertible</code>. </p>
<p>这意味着你不能在代码里像这样子做了: </p>
<pre><code>let urlRequest = URLRequest(url: URL(string: &quot;https://httpbin.org/get&quot;)!)
let urlString = urlRequest.urlString
</code></pre><p>在 Alamofire 4里, 你应该这么做: </p>
<pre><code>let urlRequest = URLRequest(url: URL(string: &quot;https://httpbin.org/get&quot;)!)
let urlString = urlRequest.url?.absoluteString
</code></pre><blockquote>
<p>查看 <a href="https://github.com/Alamofire/Alamofire/pull/1505" target="_blank" rel="external">PR-1505</a> 以获取更多信息. </p>
</blockquote>
<h3 id="URLRequestConvertible"><a href="#URLRequestConvertible" class="headerlink" title="URLRequestConvertible"></a>URLRequestConvertible</h3><p>在 3.x 里, <code>URLRequestConvertible</code> 也会产生相同的歧义问题, 之前的 <code>URLRequestConvertible</code> 是这么定义的: </p>
<pre><code>public protocol URLRequestConvertible {
    var URLRequest: URLRequest { get }
}
</code></pre><p>现在, 在 Alamofire 4 里, 变成了这样子: </p>
<pre><code>public protocol URLRequestConvertible {
    func asURLRequest() throws -&gt; URLRequest
}
</code></pre><p>就像看到的这样, <code>URLRequest</code> 属性被替换成了 <code>asURLRequest</code> 方法, 并且在生成 <code>URLRequest</code> 失败时会抛出异常. </p>
<p>这影响最大的可能是采用了 <code>Router</code> (路由)设计的你, 如果你用了 <code>Router</code>, 那你就不得不去改变, 但会变得更好! 你需要去实现 <code>asURLRequest</code> 方法, 在必要的时候会抛出异常. 你不再需要强制解包数据和参数, 或者在 do-catch 里构建一个 <code>ParameterEncoding</code>. 现在 <code>Router</code> 抛出的任何错误都可以由 Alamofire 帮你处理掉. </p>
<blockquote>
<p>查看 <a href="https://github.com/Alamofire/Alamofire/pull/1505" target="_blank" rel="external">PR-1505</a> 以获取更多信息. </p>
</blockquote>
<h2 id="新功能"><a href="#新功能" class="headerlink" title="新功能"></a>新功能</h2><h3 id="Request-Adapter-请求适配器"><a href="#Request-Adapter-请求适配器" class="headerlink" title="Request Adapter (请求适配器)"></a>Request Adapter (请求适配器)</h3><p><code>RequestAdapter</code> 协议是 Alamofire 4 里的全新功能. </p>
<pre><code>public protocol RequestAdapter {
    func adapt(_ urlRequest: URLRequest) throws -&gt; URLRequest
}
</code></pre><p>它可以让每一个 <code>SessionManager</code> 生成的 <code>Request</code> 都在生成之前被解析并且按照规则适配. 一个使用适配器很典型的场景就是给请求添加一个 <code>Authorization</code> 的请求头. </p>
<pre><code>class AccessTokenAdapter: RequestAdapter {
    private let accessToken: String

    init(accessToken: String) {
        self.accessToken = accessToken
    }

    func adapt(_ urlRequest: URLRequest) throws -&gt; URLRequest {
        var urlRequest = urlRequest

        if urlRequest.urlString.hasPrefix(&quot;https://httpbin.org&quot;) {
            urlRequest.setValue(&quot;Bearer &quot; + accessToken, forHTTPHeaderField: &quot;Authorization&quot;)
        }

        return urlRequest
    }
}

let sessionManager = SessionManager()
sessionManager.adapter = AccessTokenAdapter(accessToken: &quot;1234&quot;)

sessionManager.request(&quot;https://httpbin.org/get&quot;)
</code></pre><p>如果一个 <code>Error</code> 在适配过程中产生的话, 它会逐层抛出, 最后传递到 <code>Request</code> 的请求回调里. </p>
<blockquote>
<p>查看 <a href="https://github.com/Alamofire/Alamofire/pull/1450" target="_blank" rel="external">PR-1450</a> 获取更多信息. </p>
</blockquote>
<h3 id="Request-Retrier-请求重连"><a href="#Request-Retrier-请求重连" class="headerlink" title="Request Retrier (请求重连)"></a>Request Retrier (请求重连)</h3><p><code>RequestRetrier</code> 是 Alamofire 4 的另一个全新协议. </p>
<pre><code>public typealias RequestRetryCompletion = (_ shouldRetry: Bool, _ timeDelay: TimeInterval) -&gt; Void

public protocol RequestRetrier {
    func should(_ manager: SessionManager, retry request: Request, with error: Error, completion: @escaping RequestRetryCompletion)
}
</code></pre><p>它可以在 <code>Request</code> 遇到 <code>Error</code>的时候, 在指定的延迟之后重新发起. </p>
<pre><code>class OAuth2Handler: RequestAdapter, RequestRetrier {
    public func should(_ manager: SessionManager, retry request: Request, with error: Error, completion: RequestRetryCompletion) {
        if let response = request.task.response as? HTTPURLResponse, response.statusCode == 401 {
            completion(true, 1.0) // 1秒后重试
        } else {
            completion(false, 0.0) // 不重连
        }
    }
}

let sessionManager = SessionManager()
sessionManager.retrier = OAuth2Handler()

sessionManager.request(urlString).responseJSON { response in
    debugPrint(response)
}
</code></pre><p>重连器可以让你在检测到 <code>Request</code> 完成并且完成所有 <code>Validation</code> 检测之后再考虑是否重试. 当 <code>RequestAdapter</code> 和 <code>RequestRetrier</code> 一起使用的时候, 你可以给 OAuth1, OAuth2, Basic Auth 创建一套持续更新的校验系统(credential refresh systems), 甚至是快速重试的策略. 可能性是无限的. 想要获取更多关于这个话题的信息和例子, 请查看 README. </p>
<blockquote>
<p>译者注: 这里没太能理解作者的意思, 翻译得不好, 直接放原文:<br>When using both the <code>RequestAdapter</code> and <code>RequestRetrier</code> protocols together, you can create credential refresh systems for OAuth1, OAuth2, Basic Auth and even exponential backoff retry policies. </p>
<p>查看 <a href="https://github.com/Alamofire/Alamofire/pull/1391" target="_blank" rel="external">PR-1391</a> 以及 <a href="https://github.com/Alamofire/Alamofire/pull/1450" target="_blank" rel="external">PR-1450</a> 获取更多信息. </p>
</blockquote>
<h3 id="Task-Metrics"><a href="#Task-Metrics" class="headerlink" title="Task Metrics"></a>Task Metrics</h3><p>在 iOS, tvOS 10 和 macOS 10.12 里, 苹果引入了新的 [URLSessionTaskMetrics][13] API, task metrics 包含了一些 request 和 response 的统计信息, API 跟 Alamofire 的 <code>Timeline</code> 很像, 但提供了许多 Alamofire 里获取不到的统计信息. 我们对这些新的 API 特别兴奋, 但把这些全部都暴露到每一个 <code>Response</code> 类型里意味着这并不容易使用. </p>
<pre><code>   [13]: https://developer.apple.com/reference/foundation/urlsessiontaskmetrics
</code></pre><p>Alamofire.request(urlString).response { response in<br>            debugPrint(response.metrics)<br>    }</p>
<p>有一点很重要的是, 这些 API 只有在 iOS 和 tvOS 10+ 和 macOS 10.12+上才能使用. 所以它是依赖于运行设备的, 你可能需要做可行性检查. </p>
<pre><code>Alamofire.request(urlString).response { response in
    if #available(iOS 10.0, *) {
                debugPrint(response.metrics)
    }
}
</code></pre><blockquote>
<p>查看 <a href="https://github.com/Alamofire/Alamofire/pull/1492" target="_blank" rel="external">PR-1492</a> 获取更多信息. </p>
</blockquote>
<h2 id="Updated-Features-更新的功能"><a href="#Updated-Features-更新的功能" class="headerlink" title="Updated Features 更新的功能"></a>Updated Features 更新的功能</h2><p>Alamofire 4 加强了现有的功能并且加入了很多新功能. 这一章节主要是大概地过一遍功能的更新和使用方式. 如果想要获取更多相关信息, 请点进链接查看相关的 pull request. </p>
<h3 id="Errors-异常"><a href="#Errors-异常" class="headerlink" title="Errors 异常"></a>Errors 异常</h3><p>Alamofire 4 加入了全新的异常系统, 采用了提案 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0112-nserror-bridging.md" target="_blank" rel="external">SE-0112</a> 里提出的新模式. 新的异常系统主要围绕 <code>AFError</code>, 一个继承了 <code>Error</code> 的枚举类型, 包含四个主要的 case. </p>
<ul>
<li><p><code>.invalidURL(url: URLConvertible)</code> - 创建 <code>URL</code> 失败的时候返回一个 <code>URLConvertible</code> 类型的值 </p>
</li>
<li><p><code>.parameterEncodingFailed(reason: ParameterEncodingFailureReason)</code> - 当其中一个参数编码出错的时候就会抛出错误并返回 </p>
</li>
<li><p><code>.multipartEncodingFailed(reason: MultipartEncodingFailureReason)</code> - multipart 编码出错就会抛出错误并返回 </p>
</li>
<li><p><code>.responseValidationFailed(reason: ResponseValidationFailureReason)</code> - 当调用 <code>validate()</code> 抛出错误时捕获然后抛出到外部. </p>
</li>
<li><p><code>.responseSerializationFailed(reason: ResponseSerializationFailureReason)</code> - 返回的数据序列化出错时会抛出异常并返回. </p>
</li>
</ul>
<p>每一个 case 都包含了特定的异常理由, 并且异常理由又是另一个带有具体错误信息的枚举类型. 这会让 Alamofire 更容易识别出错误的来源和原因. </p>
<pre><code>Alamofire.request(urlString).responseJSON { response in
    guard case let .failure(error) = response.result else { return }

    if let error = error as? AFError {
        switch error {
        case .invalidURL(let url):
            print(&quot;无效 URL: \(url) - \(error.localizedDescription)&quot;)
        case .parameterEncodingFailed(let reason):
            print(&quot;参数编码失败: \(error.localizedDescription)&quot;)
            print(&quot;失败理由: \(reason)&quot;)
        case .multipartEncodingFailed(let reason):
            print(&quot;Multipart encoding 失败: \(error.localizedDescription)&quot;)
            print(&quot;失败理由: \(reason)&quot;)
        case .responseValidationFailed(let reason):
            print(&quot;Response 校验失败: \(error.localizedDescription)&quot;)
            print(&quot;失败理由: \(reason)&quot;)

            switch reason {
            case .dataFileNil, .dataFileReadFailed:
                print(&quot;无法读取下载文件&quot;)
            case .missingContentType(let acceptableContentTypes):
                print(&quot;文件类型不明: \(acceptableContentTypes)&quot;)
            case .unacceptableContentType(let acceptableContentTypes, let responseContentType):
                print(&quot;文件类型: \(responseContentType) 无法读取: \(acceptableContentTypes)&quot;)
            case .unacceptableStatusCode(let code):
                print(&quot;请求返回状态码出错: \(code)&quot;)
            }
        case .responseSerializationFailed(let reason):
            print(&quot;请求返回内容序列化失败: \(error.localizedDescription)&quot;)
            print(&quot;失败理由: \(reason)&quot;)
        }

        print(&quot;错误: \(error.underlyingError)&quot;)
    } else if let error = error as? URLError {
        print(&quot;URL 错误: \(error)&quot;)
    } else {
        print(&quot;未知错误: \(error)&quot;)
    }
}
</code></pre><p>新的设计给你的处理方式更多的自由, 可以在你需要的时候深入到最具体的 error. 这也会让原本要四处应对 <code>NSError</code> 的开发者更加轻松地完成工作. 在 Alamofire 里通过使用自定义的 <code>Error</code> 类型, 我们可以看到 <code>Result</code> 和 <code>Response</code> 的泛型参数缩减到了只有一个, 简化了返回数据序列化的逻辑. </p>
<blockquote>
<p>查看 <a href="https://github.com/Alamofire/Alamofire/pull/1419" target="_blank" rel="external">PR-1419</a> 获取更多信息. </p>
</blockquote>
<h3 id="Parameter-Encoding-Protocol-参数编码的协议"><a href="#Parameter-Encoding-Protocol-参数编码的协议" class="headerlink" title="Parameter Encoding Protocol 参数编码的协议"></a>Parameter Encoding Protocol 参数编码的协议</h3><p><code>ParameterEncoding</code> 枚举类型在过去两年很好地解决了问题. 但我们在 Alamofire 4 里想要定位的时候却感觉到了一些局限. </p>
<ul>
<li><p><code>.url</code> 总让人有点迷惑, 因为它是一个 HTTP 协议定义的地址 </p>
</li>
<li><p><code>.urlEncodedInURL</code> 跟 <code>.url</code> 总是会混淆起来, 让人分不清它们行为的区别 </p>
</li>
<li><p><code>.JSON</code> 和 <code>.PropertyList</code> 编码不能自定义编码格式或者写入的方式 </p>
</li>
<li><p><code>.Custom</code> 编码对于用户来说太难掌握 </p>
</li>
</ul>
<p>因为这些原因, 我们决定在 Alamofire 4 把这个枚举去掉! 现在, <code>ParameterEncoding</code> 变成了一个协议, 加入了 <code>Parameters</code> 的类型别名去创建你的参数字典, 并且通过遵守这个协议建立了三个编码结构体 <code>URLEncoding</code>, <code>JSONEncoding</code> 和 <code>PropertyList</code>. </p>
<pre><code>public typealias Parameters = [String: Any]

public protocol ParameterEncoding {
    func encode(_ urlRequest: URLRequestConvertible, with parameters: Parameters?) throws -&gt; URLRequest
}
</code></pre><h4 id="URL-Encoding-参数编码"><a href="#URL-Encoding-参数编码" class="headerlink" title="URL Encoding (参数编码)"></a>URL Encoding (参数编码)</h4><p>新的 <code>URLEncoding</code> 结构体包含了一个 <code>Destination</code> 枚举, 支持三种类型的目标编码 </p>
<ul>
<li><p><code>.methodDependent</code> - 对于 <code>GET</code>, <code>HEAD</code> 和 <code>DELETE</code> 方法使用 query 字符串, 而别的 HTTP 方法则会编码为 HTTP body. </p>
</li>
<li><p><code>.queryString</code> - 设置或者往现有的 queryString 里增加内容 </p>
</li>
<li><p><code>.httpBody</code> - 设置请求的 HTTP body 内容 </p>
</li>
</ul>
<p>这些目标编码格式会让你更容易控制 <code>URLRequest</code> 的参数编码方式. 创建请求依旧使用和之前一样的方式, 不管编码的形式怎样, 都会保持与之前一样的默认行为. </p>
<pre><code>let parameters: Parameters = [&quot;foo&quot;: &quot;bar&quot;]

Alamofire.request(urlString, parameters: parameters) // Encoding =&gt; URLEncoding(destination: .methodDependent)
Alamofire.request(urlString, parameters: parameters, encoding: URLEncoding(destination: .queryString))
Alamofire.request(urlString, parameters: parameters, encoding: URLEncoding(destination: .httpBody))

// Static convenience properties (we&#39;d like to encourage everyone to use this more concise form)
// 便利的静态属性 (我们想鼓励大家使用这种更简洁的形式)
Alamofire.request(urlString, parameters: parameters, encoding: URLEncoding.default)
Alamofire.request(urlString, parameters: parameters, encoding: URLEncoding.queryString)
Alamofire.request(urlString, parameters: parameters, encoding: URLEncoding.httpBody)
</code></pre><h4 id="JSON-Encoding-JSON-编码"><a href="#JSON-Encoding-JSON-编码" class="headerlink" title="JSON Encoding (JSON 编码)"></a>JSON Encoding (JSON 编码)</h4><p>新的 <code>JSONEncoding</code> 结构体开放了让你自定义 JSON 写入形式的接口. </p>
<pre><code>let parameters: Parameters = [&quot;foo&quot;: &quot;bar&quot;]

Alamofire.request(urlString, parameters: parameters, encoding: JSONEncoding(options: []))
Alamofire.request(urlString, parameters: parameters, encoding: JSONEncoding(options: .prettyPrinted))

// Static convenience properties (we&#39;d like to encourage everyone to use this more concise form)
// 便利的静态属性 (我们想鼓励大家使用这种更简洁的形式)
Alamofire.request(urlString, parameters: parameters, encoding: JSONEncoding.default)
Alamofire.request(urlString, parameters: parameters, encoding: JSONEncoding.prettyPrinted)
</code></pre><h4 id="Property-List-Encoding-属性列表编码"><a href="#Property-List-Encoding-属性列表编码" class="headerlink" title="Property List Encoding (属性列表编码)"></a>Property List Encoding (属性列表编码)</h4><p>新的 <code>PropertyListEncoding</code> 结构体允许自定义 plist 的格式和写入选项 </p>
<pre><code>let parameters: Parameters = [&quot;foo&quot;: &quot;bar&quot;]

Alamofire.request(urlString, parameters: parameters, encoding: PropertyListEncoding(format: .xml, options: 0))
Alamofire.request(urlString, parameters: parameters, encoding: PropertyListEncoding(format: .binary, options: 0))

// Static convenience properties (we&#39;d like to encourage everyone to use this more concise form)
// 便利的静态属性 (我们想鼓励大家使用这种更简洁的形式)
Alamofire.request(urlString, parameters: parameters, encoding: PropertyListEncoding.xml)
Alamofire.request(urlString, parameters: parameters, encoding: PropertyListEncoding.binary)
</code></pre><h4 id="Custom-Encoding-自定义编码"><a href="#Custom-Encoding-自定义编码" class="headerlink" title="Custom Encoding 自定义编码"></a>Custom Encoding 自定义编码</h4><p>建立一个自定义的 <code>ParameterEncoding</code> 只要遵守这个协议建立类型即可. 想要获取更多相关例子, 请查看下面的 README </p>
<blockquote>
<p>查看 <a href="https://github.com/Alamofire/Alamofire/pull/1465" target="_blank" rel="external">PR-1465</a> 获取更多信息 </p>
</blockquote>
<h3 id="Request-Subclasses-Request-的子类"><a href="#Request-Subclasses-Request-的子类" class="headerlink" title="Request Subclasses (Request 的子类)"></a>Request Subclasses (Request 的子类)</h3><p>在 Alamofire 4, <code>request</code>, <code>download</code>, <code>upload</code> 和 <code>stream</code> 的 API 不会再返回 <code>Request</code>, 他们会返回特定的 <code>Request</code> 子类. 有下面几个引导我们做出这个改变的现实原因和社区的疑问: </p>
<ul>
<li><p><strong>Progress:</strong> <code>progress</code> 方法的行为会在 upload 请求里会很容易让人迷惑. </p>
<ul>
<li><p><code>progress</code> 在一个 upload 请求里返回的是什么? 上传的进度? 还是返回内容的下载进度? </p>
</li>
<li><p>如果都返回, 那我们怎么区分他们, 在什么时候能知道是到底返回的是哪一个? </p>
</li>
</ul>
</li>
<li><p><strong>Response Serializers:</strong> 返回内容的序列化是为了 data 和 upload 请求设计的, donwload 和 stream 请求并不需要序列化. </p>
<ul>
<li><p>你要怎么才能在下载完成时获取到文件的地址? </p>
</li>
<li><p><code>responseData</code>, <code>responseString</code> 和 <code>responseJSON</code> 对于一个 donwload 请求来说意味着什么? stream 请求呢? </p>
</li>
</ul>
</li>
</ul>
<p>Alamofire 4 现在有四个 <code>Request</code> 的子类, 并且每个字类都有一些特有的 API. 这样就可以让每一个子类能够通过建立 extension 来定制特定类型的请求. </p>
<pre><code>open class Request {
    // 包含了共有的属性, 验证, 和状态方法
    // 遵守 CustomStringConvertible 和 CustomDebugStringConvertible
}

open class DataRequest: Request {
    // 包含了数据流(不要跟 StreamRequest 混淆)和下载进度的方法
}

open class DownloadRequest: Request {
    // 包含了下载位置和选项, 已下载的数据以及进度方法
}

open class UploadRequest: DataRequest {
        // 继承了所有 DataRequest 的方法, 并且包含了上传进度的方法
}

open class StreamRequest: Request {
        // 只继承了 Request, 目前暂时没有任何自定义的 API
}
</code></pre><p>通过这样的切分, Alamofire 现在可以为每一个类型的请求自定义相关的 API. 这会覆盖到所有可能的需求, 但让我们花点时间来仔细了解一下这会如何改变进度汇报和下载地址. </p>
<blockquote>
<p>查看 <a href="https://github.com/Alamofire/Alamofire/pull/1455" target="_blank" rel="external">PR-1455</a> 获取更多信息 </p>
</blockquote>
<h4 id="Download-and-Upload-Progress-下载和上传你进度"><a href="#Download-and-Upload-Progress-下载和上传你进度" class="headerlink" title="Download and Upload Progress (下载和上传你进度)"></a>Download and Upload Progress (下载和上传你进度)</h4><p>Data, download 和 upload 请求的进度汇报系统完全重新设计了一遍. 每一个请求类型都包含有一个闭包, 每当进度更新的时候, 就会调用闭包并且传入 <code>Progress</code> 类型的参数. 这个闭包会在指定的队列被调用, 默认为主队列. </p>
<p><strong>Data Request 进度</strong></p>
<pre><code>Alamofire.request(urlString)
    .downloadProgress { progress in
        // 默认在主队列调用
        print(&quot;下载进度: \(progress.fractionCompleted)&quot;)
    }
    .responseJSON { response in
        debugPrint(response)
    }
</code></pre><p><strong>Download Request 进度</strong></p>
<pre><code>Alamofire.download(urlString, to: destination)
    .downloadProgress(queue: DispatchQueue.global(qos: .utility)) { progress in
        // 在 .utility 队列里调用
        print(&quot;下载进度: \(progress.fractionCompleted)&quot;)
    }
    .responseJSON { response in
        debugPrint(response)
    }
</code></pre><p><strong>Upload Request 进度</strong></p>
<pre><code>Alamofire.upload(data, to: urlString, withMethod: .post)
    .uploadProgress { progress in
        // 默认在主队列调用
        print(&quot;上传进度: \(progress.fractionCompleted)&quot;)
    }
    .downloadProgress { progress in
        // 默认在主队列调用
        print(&quot;下载进度: \(progress.fractionCompleted)&quot;)
    }
    .responseData { response in
        debugPrint(response)
    }
</code></pre><p>现在很容易就可以区分开 upload request 里的上传和下载进度. </p>
<blockquote>
<p>查看 <a href="https://github.com/Alamofire/Alamofire/pull/1455" target="_blank" rel="external">PR-1455</a> 获取更多信息. </p>
</blockquote>
<h4 id="Download-File-Destinations-文件下载地址"><a href="#Download-File-Destinations-文件下载地址" class="headerlink" title="Download File Destinations 文件下载地址"></a>Download File Destinations 文件下载地址</h4><p>在 Alamofire 3.x, 顺利完成的 download requests 总是会在 <code>destination</code> 回调里把临时文件移动到最终目标文件夹里. 这很方便, 但也同时带来了几个限制: </p>
<ul>
<li><p><code>Forced</code> - API 强制你去提供一个 destination 闭包来移动文件, 即使你验证过后不想移动文件了. </p>
</li>
<li><p><code>Limiting</code> - 没有任何方式可以去调整文件系统移动文件的优先级别. </p>
<ul>
<li><p>如果你需要在移动到目标文件夹之前删掉之前存在的文件呢? </p>
</li>
<li><p>如果你需要在移动临时文件之前创建目录呢? </p>
</li>
</ul>
</li>
</ul>
<p>这些限制都会在 Alamofire 4 里都不复存在. 首先是 optional 的 destination 闭包. 现在, <code>destination</code> 默认为 nil, 意味着文件系统不会移动文件, 并且会返回临时文件的 URL. </p>
<pre><code>Alamofire.download(urlString).responseData { response in
    print(&quot;临时文件的 URL: \(response.temporaryURL)&quot;)
}
</code></pre><blockquote>
<p>我们将会恢复 <code>DownloadResponse</code> 类型, 更多详细信息请查看 Reponse Serializers 章节. </p>
</blockquote>
<h4 id="Download-Options-下载选项"><a href="#Download-Options-下载选项" class="headerlink" title="Download Options 下载选项"></a>Download Options 下载选项</h4><p>另外一个主要的改变是 destination 闭包里面加上了下载选项, 让你可以进行更多文件系统操作. 为了达到目的, 我们建立了一个 <code>DownloadOptions</code> 类型并且添加到 <code>DownloadFileDestination</code> 闭包里. </p>
<pre><code>public typealias DownloadFileDestination = (
    _ temporaryURL: URL,
    _ response: HTTPURLResponse)
    -&gt; (destinationURL: URL, options: DownloadOptions)
</code></pre><p>现阶段支持的两个 <code>DownloadOptions</code> 是: </p>
<ul>
<li><p><code>.createIntermediateDirectories</code> - 如果有指定的下载地址的话, 会为下载地址创建相应的目录 </p>
</li>
<li><p><code>.removePreviousFile</code> - 如果有指定的下载地址的话, 会自动替代掉同名文件 </p>
</li>
</ul>
<p>这两个选项可以像下面这样用: </p>
<pre><code>let destination: DownloadRequest.DownloadFileDestination = { _, _ in
    return (fileURL, [.removePreviousFile, .createIntermediateDirectories])
}

Alamofire.download(urlString, to: destination).response { response in
    debugPrint(response)
}
</code></pre><p>如果一个异常在文件系统操作时抛出的话, <code>DownloadResponse</code> 的 <code>error</code> 就会是 <code>URLError</code> 类型. </p>
<blockquote>
<p>查看 <a href="https://github.com/Alamofire/Alamofire/pull/1462" target="_blank" rel="external">PR-1462</a> 获取更多信息. </p>
</blockquote>
<h3 id="Response-Validation-数据验证"><a href="#Response-Validation-数据验证" class="headerlink" title="Response Validation 数据验证"></a>Response Validation 数据验证</h3><p>在 Alamofire 4 里有几个可以加强数据验证系统的地方. 包括了: </p>
<ul>
<li><p><code>Validation</code> 回调闭包里传入的 <code>data</code></p>
</li>
<li><p><code>Request</code> 子类可以自定义数据验证系统, 例如 download 请求里的 <code>temporaryURL</code> 和 <code>destinationURL</code> 暴露到了回调闭包里 </p>
</li>
</ul>
<p>通过继承 <code>Request</code>, 每一个 <code>Request</code> 的子类都可以自定义一套数据验证的闭包(typealias)和请求的 API. </p>
<h4 id="Data-Request-数据请求"><a href="#Data-Request-数据请求" class="headerlink" title="Data Request 数据请求"></a>Data Request 数据请求</h4><p><code>DataRequest</code> (<code>UploadRequest</code> 的父类)暴露出来的 <code>Validation</code> 目前是这样定义的: </p>
<pre><code>extension DataRequest {
    public typealias Validation = (URLRequest?, HTTPURLResponse, Data?) -&gt; ValidationResult
}
</code></pre><p>直接在闭包里把 <code>Data?</code> 暴露出来, 你就不需要再给 <code>Request</code> 增加一个 extension 去访问这个属性了. 现在你可以直接这样子做: </p>
<pre><code>Alamofire.request(urlString)
    .validate { request, response, data in
        guard let data = data else { return .failure(customError) }

        // 1) 验证返回的数据保证接下来的操作不会出错
        // 2) 如果验证失败, 你可以把错误信息返回出去, 甚至加上自定义的 error

        return .success
    }
    .response { response in
        debugPrint(response)
    }
</code></pre><h4 id="Download-Request-下载请求"><a href="#Download-Request-下载请求" class="headerlink" title="Download Request 下载请求"></a>Download Request 下载请求</h4><p><code>DownloadRequest</code> 里的 <code>Validation</code> 闭包跟 <code>DataRequest</code> 里的很像, 但为了下载任务做了更多的定制. </p>
<pre><code>extension DownloadRequest {
        public typealias Validation = (
            _ request: URLRequest?,
            _ response: HTTPURLResponse,
            _ temporaryURL: URL?,
            _ destinationURL: URL?)
            -&gt; ValidationResult
}
</code></pre><p><code>temporaryURL</code> 和 <code>destinationURL</code> 参数现在让你可以在闭包内直接获取到服务器返回的数据. 这可以让你校验下载好的文件, 在有需要的时候可以抛出一个自定义的错误. </p>
<pre><code>Alamofire.download(urlString)
    .validate { request, response, temporaryURL, destinationURL in
        guard let fileURL = temporaryURL else { return .failure(customError) }

        do {
            let _ = try Data(contentsOf: fileURL)
            return .success
        } catch {
            return .failure(customError)
        }
    }
    .response { response in
        debugPrint(response)
    }
</code></pre><p>通过直接在闭包里暴露服务器返回的数据, 这里面的所有异常都可以在 <code>Validation</code> 闭包里捕获到, 并且可以自定义错误信息. 如果这里获取到的信息和 response 序列化回调里一样的话, response 可以用来处理错误信息而不是简单地把逻辑赋值过来. 具体的例子, 请查看下面的 README. </p>
<blockquote>
<p>查看 <a href="https://github.com/Alamofire/Alamofire/pull/1461" target="_blank" rel="external">PR-1461</a> 获取更多信息. </p>
</blockquote>
<h3 id="Response-Serializers-返回数据序列化"><a href="#Response-Serializers-返回数据序列化" class="headerlink" title="Response Serializers 返回数据序列化"></a>Response Serializers 返回数据序列化</h3><p>Alamofire 3.x 里的序列化系统有这么几个限制: </p>
<ul>
<li><p>序列化的 API 可以用在 download 和 stream 请求里, 但却会导致未知的行为发生 </p>
<ul>
<li><p>怎么在下载成功时获取到文件 URL? </p>
</li>
<li><p><code>responseData</code>, <code>responseString</code> 或者 <code>responseJSON</code> 会在 donwload 请求里产生怎样的行为? stream 请求呢? </p>
</li>
</ul>
</li>
<li><p><code>response</code> API 返回四个参数而不是封装到一个 <code>Response</code> 类型里. </p>
<ul>
<li><p>最大的问题是 API 任何改变都会导致前面行为的变化. </p>
</li>
<li><p>在序列化和反序列化的 API 之间切换会让人迷惑, 同时导致难以 debug 的编译错误. </p>
</li>
</ul>
</li>
</ul>
<p>就像你看到的, Alamofire 3.x 的这一套序列化系统有这么多限制. 所以, 在 Alamofire 4里, <code>Request</code> 类型首先被切分到各个子类里, 这么做给自定义序列化方式, 和自定义 API 留下了空间. 在我们更深入了解序列化方式之前, 我们先了解一下新的 <code>Response</code> 类型 </p>
<h4 id="Default-Data-Response"><a href="#Default-Data-Response" class="headerlink" title="Default Data Response"></a>Default Data Response</h4><p><code>DefaultDataResponse</code> 代表了未被序列化的服务器返回数据. Alamofire 没有做任何处理过的, 只是纯粹地从 <code>SessionDelegate</code> 里获取信息并且包装在一个结构体里面返回. </p>
<pre><code>public struct DefaultDataResponse {
    public let request: URLRequest?
    public let response: HTTPURLResponse?
    public let data: Data?
    public let error: Error?
    public var metrics: URLSessionTaskMetrics? { return _metrics as? URLSessionTaskMetrics }
}
</code></pre><p>下面是你会获得 <code>DataRequest.response</code> 的一种返回. </p>
<pre><code>Alamofire.request(urlString).response { response in
    debugPrint(response)
}

Alamofire.upload(file, to: urlString).response { response in
    debugPrint(response)
}
</code></pre><h4 id="Data-Response"><a href="#Data-Response" class="headerlink" title="Data Response"></a>Data Response</h4><p>泛型 <code>DataResponse</code> 类型跟 Alamofire 3.x 里的 <code>Response</code> 一样, 但内部重构并且包含了新的 <code>metrics</code> 变量. </p>
<pre><code>public struct DataResponse&lt;Value&gt; {
    public let request: URLRequest?
    public let response: HTTPURLResponse?
    public let data: Data?
    public let result: Result&lt;Value&gt;
    public let timeline: Timeline
        public var metrics: URLSessionTaskMetrics? { return _metrics as? URLSessionTaskMetrics }
}
</code></pre><p>使用 <code>DataRequest</code> 和 <code>UploadRequest</code>, 你可以像之前(3.x)那样使用 response 序列化的 API </p>
<pre><code>Alamofire.request(urlString).responseJSON { response in
    debugPrint(response)
    print(response.result.isSuccess)
}

Alamofire.upload(fileURL, to: urlString).responseData { response in
    debugPrint(response)
    print(response.result.isSuccess)
}
</code></pre><h4 id="Default-Download-Response-默认下载请求的-Response-类型"><a href="#Default-Download-Response-默认下载请求的-Response-类型" class="headerlink" title="Default Download Response 默认下载请求的 Response 类型"></a>Default Download Response 默认下载请求的 Response 类型</h4><p>因为 donwload 请求跟 data 和 upload 请求很不一样, 所以 Alamofire 4 包含了自定义的 donwload <code>Response</code> 类型. <code>DefaultDownloadResponse</code> 类型代表未序列化的返回数据, 包含了所有 <code>SessionDelegate</code> 信息的结构体. </p>
<pre><code>public struct DefaultDownloadResponse {
    public let request: URLRequest?
    public let response: HTTPURLResponse?
    public let temporaryURL: URL?
    public let destinationURL: URL?
    public let resumeData: Data?
    public let error: Error?
        public var metrics: URLSessionTaskMetrics? { return _metrics as? URLSessionTaskMetrics }
}
</code></pre><p><code>DefaultDownloadResponse</code> 类型在使用新的 <code>DownloadRequest.response</code> API 时就会被返回. </p>
<pre><code>Alamofire.download(urlString).response { response in
    debugPrint(response)
    print(response.temporaryURL)
}
</code></pre><h4 id="Download-Response"><a href="#Download-Response" class="headerlink" title="Download Response"></a>Download Response</h4><p>新的泛型 <code>DownloadResponse</code> 跟 <code>DataResponse</code> 很像, 但包含了 download 请求特有的信息. <code>DownloadResponse</code> 类型在使用 <code>DownloadRequest</code> 时就会被返回. 这些新的 API 同样也适用于 <code>DataRequest</code>, 一样能够获取临时目录的 url 和目标目录的 url. </p>
<pre><code>Alamofire.download(urlString, to: destination)
    .responseData { response in
        debugPrint(response)
    }
    .responseString { response in
        debugPrint(response)
    }
    .responseJSON { response in
        debugPrint(response)
    }
    .responsePropertyList { response in
        debugPrint(response)
    }
</code></pre><p>新的序列化 API 让文件下载和序列化更加容易完成. </p>
<h4 id="Custom-Response-Serializers-自定义序列化"><a href="#Custom-Response-Serializers-自定义序列化" class="headerlink" title="Custom Response Serializers 自定义序列化"></a>Custom Response Serializers 自定义序列化</h4><p>如果你已经创建了自定义的序列化, 你也许会想要拓展支持 data 和 download 请求, 就像我们在 Alamofire 序列化 API 里面做的一样.. 如果你决定这么做, 可以仔细看一下 Alamofire 怎么在几种 <code>Request</code> 类型里共享序列化方法, 然后把实现写到 <code>Request</code> 里就可以了. 这可以让我们 DRY up 逻辑并且避免重复的代码.(Don’t repeat yourself) </p>
<blockquote>
<p>查看 <a href="https://github.com/Alamofire/Alamofire/pull/1457" target="_blank" rel="external">PR-1457</a> 获取更多信息. </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Alamofire </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[七牛云储存]]></title>
      <url>/2017/06/14/%E4%B8%83%E7%89%9B%E4%BA%91%E5%82%A8%E5%AD%98/</url>
      <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a> 
<ul>
<li><p>初始化<br>一般情况下直接使用默认设置，不用单独配置。 可以配置超时时长、分片上传阀值等。</p>
<p>Configuration config = new Configuration.Builder()</p>
<pre><code>                .chunkSize(256 * 1024)  //分片上传时，每片的大小。 默认 256K
                .putThreshhold(512 * 1024)  // 启用分片上传阀值。默认 512K
                .connectTimeout(10) // 链接超时。默认 10秒
                .responseTimeout(60) // 服务器响应超时。默认 60秒
                .recorder(recorder)  // recorder 分片上传时，已上传片记录器。默认 null
                .recorder(recorder, keyGen)  // keyGen 分片上传时，生成标识符，用于片记录器区分是那个文件的上传记录
                .zone(Zone.zone0) // 设置区域，指定不同区域的上传域名、备用域名、备用IP。默认 Zone.zone0
                .build()
</code></pre><p>// 重用 uploadManager。一般地，只需要创建一个 uploadManager 对象<br>UploadManager uploadManager = new UploadManager(config)</p>
</li>
<li><p>上传文件<br>七牛上传文件主要用到两个方法：<br>一、 UploadManager.put(data, key, token, handler, options);</p>
<p> /**</p>
<ul>
<li><p>UploadManager.put参数说明：<br><em>
</em>@data                  byte[]/String/File    数据，可以是byte数组，文件路径，文件。<br><em>@key                   String                保存在服务器上的资源唯一标识。请参考键值对。
</em>@token                 String                服务器分配的token。<br><em>@completionHandler     UpCompletionHandler   上传回调函数，必填。
</em>@options               UploadOptions         如果需要进度通知、crc校验、中途取消、指定mimeType则需要填写相应字段，详见UploadOptions参数说明。</p>
<pre><code> */
</code></pre><p>二、 UploadOptions(params, mimeType, checkCrc, progressHandler, cancellationSignal);</p>
</li>
</ul>
</li>
</ul>
<pre><code>    /**
     * UploadOptions参数说明：
     * 
     *参数                   类型                   说明
     *params               Map&lt;String, String&gt;  自定义变量，key必须以 x: 开始。
     *mimeType             String               指定文件的mimeType。
     *checkCrc             boolean              是否验证上传文件。
     *progressHandler      UpProgressHandler    上传进度回调。
     *cancellationSignal   UpCancellationSignal 取消上传，当isCancelled()返回true时，不再执行更多上传。
     */
</code></pre><h4 id="现在就比较清楚了"><a href="#现在就比较清楚了" class="headerlink" title="现在就比较清楚了"></a>现在就比较清楚了</h4><p>下面主要是各种上传姿势了  </p>
<ul>
<li>简单上传 </li>
</ul>
<pre><code>UploadManager uploadManager = new UploadManager();
data = &lt;File对象、或 文件路径、或 字节数组&gt;
String key = &lt;指定七牛服务上的文件名，或 null&gt;;
String token = &lt;从服务端SDK获取&gt;;
uploadManager.put(data, key, token,
 /**
  * UpCompletionHandler参数说明
  * 
  *@key        即uploadManager.put(file, key, ...)方法指定的key。
  *@info       http请求的状态信息等，可记入日志。isOK()返回 true表示上传成功。
  *@response   七牛反馈的信息。可从中解析保存在七牛服务的key等信息，具体字段取决于上传策略的设置。
  */
new UpCompletionHandler() {
    @Override
    public void complete(String key, ResponseInfo info, JSONObject res) {

        Log.i(&quot;qiniu&quot;, key + &quot;,\r\n &quot; + info + &quot;,\r\n &quot; + res);
    }
}, null);
</code></pre><ul>
<li>记录上传进度</li>
</ul>
<pre><code>    private void uploadProgress() {

        uploadManager.put(data, key, token, handler,
                new UploadOptions(null, null, false,
                        new UpProgressHandler() {
                            /**
                             * @param key      即uploadManager.put(file, key, ...)方法指定的key
                             * @param percent  进度
                             */
                            public void progress(String key, double percent) {
                                Log.i(&quot;qiniu&quot;, key + &quot;: &quot; + percent);
                            }
                        }, null));

    }
</code></pre><ul>
<li>取消上传<br>内部代码会检测UpCancellationSignal##isCancelled()的返回值，当其返回true时，将停止上传。 可外部维护一个变量isCancelled，当点击取消按钮时，设置isCancelled = true;。如：</li>
</ul>
<pre><code>private volatile boolean isCancelled = false;

uploadManager.put(data, key, token,handler,
    new UploadOptions(null, null, false, progressHandler,
        new UpCancellationSignal(){
            public boolean isCancelled(){
                return isCancelled;
            }
        }));



private void cancell() {
    isCancelled = true;
}
</code></pre><ul>
<li>记录断点</li>
</ul>
<p>分片上传中，可将各个已上传的块记录下来，再次上传时，已上传的部分不用再次上传。 断点记录类需实现 com.qiniu.android.storage.Recorder 接口。已提供保存到文件的 FileRecorder 实现。 </p>
<pre><code>String dirPath = &lt;断点记录文件保存的文件夹位置&gt;
Recorder recorder = new FileRecorder(dirPath);




KeyGenerator keyGen = new KeyGenerator(){
    public String gen(String key, File file){


        return key + &quot;_._&quot; + new StringBuffer(file.getAbsolutePath()).reverse();
    }
};





Configuration config = new Configuration.Builder()


                    .recorder(recorder, keyGen)  
                    .build();

UploadManager uploadManager = new UploadManager(config);

uploadManager.put(data, key, ...)
</code></pre><h3 id="初始化设置和上传文件的基本用法就记录到这啦！"><a href="#初始化设置和上传文件的基本用法就记录到这啦！" class="headerlink" title="初始化设置和上传文件的基本用法就记录到这啦！"></a>初始化设置和上传文件的基本用法就记录到这啦！</h3>]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> qiniu </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[UIPopoverPresentationController]]></title>
      <url>/2017/06/12/UIPopoverPresentationController/</url>
      <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a>
<p>UIPopoverPresentationController 是 iOS8 后新增的，相当于pad端的UIPopOverController，以后我们也可以在iPhone上使用popOver啦。自己写了一个小demo，大概了熟悉了一下用法。后面有开发需求时会详细补充。<br>首先要知道一点是，我们并不需要创建一个UIPopoverPresentationController，他相当于UIViewController的属性，因此我们只需要创建UIViewController即可。<br>举个例子：假设我们要在 ViewController窗体弹窗，弹窗为FirstViewController（kind of UIViewController）我们用两种方式来实现<br>1、在self.view上创建一个button，给button添加弹窗事件；<br>2、在导航栏添加barButtonItem，给其添加弹窗时间。<br>弹窗事件：</p>
<pre><code class="swift">1、button
[objc] view plain copy
- (void)buttonClick  
{  
    FirstViewController *firstVC = [[FirstViewController alloc] init];  
    firstVC.modalPresentationStyle = UIModalPresentationPopover;  
    firstVC.popoverPresentationController.sourceView = popOverButton;  //rect参数是以view的左上角为坐标原点（0，0）  
    firstVC.popoverPresentationController.sourceRect = popOverButton.bounds; //指定箭头所指区域的矩形框范围（位置和尺寸），以view的左上角为坐标原点  
    firstVC.popoverPresentationController.permittedArrowDirections = UIPopoverArrowDirectionUp; //箭头方向  
    firstVC.popoverPresentationController.delegate = self;  
    firstVC.preferredContentSize = CGSizeMake(100, 200);  
    [self presentViewController:firstVC animated:YES completion:nil];  
}  

2、barButtonItem
[objc] view plain copy
- (void)rightBarButtonItemClick  
{  
    FirstViewController *firstVC = [[FirstViewController alloc]init];  
    firstVC.modalPresentationStyle = UIModalPresentationPopover;  
    /** 
     *  由于导航上的控件没有指定frame，无法设置sourceView和sourceRect，用下面的。 
     */  
    firstVC.popoverPresentationController.barButtonItem = self.navigationItem.rightBarButtonItem;  
    firstVC.popoverPresentationController.permittedArrowDirections = UIPopoverArrowDirectionUp;  
    firstVC.popoverPresentationController.delegate = self;  
    firstVC.preferredContentSize = CGSizeMake(100, 200);  
    [self presentViewController:firstVC animated:YES completion:nil];  
//    firstVC.popoverPresentationController.passthroughViews = nil;  
}  
注意几点：
1、遵守代理：UIPopoverPresentationControllerDelegate
2、在phone端必须要适配设备，要设置下面代理方法：
[objc] view plain copy
/* For iOS8.0, the only supported adaptive presentation styles are UIModalPresentationFullScreen and UIModalPresentationOverFullScreen. */  
- (UIModalPresentationStyle)adaptivePresentationStyleForPresentationController:(UIPresentationController *)controller;  
-
</code></pre>
<p>iPhone下默认是UIModalPresentationFullScreen，需要手动设置为UIModalPresentationNone，否则，是普通的present全屏显示，没有弹窗效果。iPad不需要。<br>3、其他设置根据需求翻相关文档即可。<br>demo：<a href="https://github.com/Lynnll/UIPopOverLearning.git" target="_blank" rel="external">https://github.com/Lynnll/UIPopOverLearning.git</a></p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> popover </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Alamofire 4.0 Migration Guide]]></title>
      <url>/2017/06/12/Alamofire/</url>
      <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a> 
<h1 id="Alamofire-4-0-Migration-Guide"><a href="#Alamofire-4-0-Migration-Guide" class="headerlink" title="Alamofire 4.0 Migration Guide"></a>Alamofire 4.0 Migration Guide</h1><p>Alamofire 4.0 is the latest major release of Alamofire, an HTTP networking library for iOS, tvOS, macOS and watchOS written in Swift. As a major release, following Semantic Versioning conventions, 4.0 introduces API-breaking changes.</p>
<p>This guide is provided in order to ease the transition of existing applications using Alamofire 3.x to the latest APIs, as well as explain the design and structure of new and updated functionality.</p>
<ul>
<li><a href="#requirements">Requirements</a></li>
<li><a href="#benefits-of-upgrading">Benefits of Upgrading</a></li>
<li><a href="#breaking-api-changes">Breaking API Changes</a><ul>
<li><a href="#namespace-changes">Namespace Changes</a></li>
<li><a href="#making-requests">Making Requests</a></li>
<li><a href="#urlstringconvertible">URLStringConvertible</a></li>
<li><a href="#urlrequestconvertible">URLRequestConvertible</a></li>
</ul>
</li>
<li><a href="#new-features">New Features</a><ul>
<li><a href="#request-adapter">Request Adapter</a></li>
<li><a href="#request-retrier">Request Retrier</a></li>
<li><a href="#task-metrics">Task Metrics</a></li>
</ul>
</li>
<li><a href="#updated-features">Updated Features</a><ul>
<li><a href="#errors">Errors</a></li>
<li><a href="#parameter-encoding-protocol">Parameter Encoding Protocol</a></li>
<li><a href="#request-subclasses">Request Subclasses</a></li>
<li><a href="#response-validation">Response Validation</a></li>
<li><a href="#response-serializers">Response Serializers</a></li>
</ul>
</li>
</ul>
<h2 id="Requirements"><a href="#Requirements" class="headerlink" title="Requirements"></a>Requirements</h2><ul>
<li>iOS 8.0+, macOS 10.10.0+, tvOS 9.0+ and watchOS 2.0+</li>
<li>Xcode 8.1+</li>
<li>Swift 3.0+</li>
</ul>
<p>For those of you that would like to use Alamofire on iOS 8 or macOS 10.9, please use the latest tagged 3.x release which supports both Swift 2.2 and 2.3.</p>
<h2 id="Benefits-of-Upgrading"><a href="#Benefits-of-Upgrading" class="headerlink" title="Benefits of Upgrading"></a>Benefits of Upgrading</h2><ul>
<li><strong>Complete Swift 3 Compatibility:</strong> includes the full adoption of the new <a href="https://swift.org/documentation/api-design-guidelines/" target="_blank" rel="external">API Design Guidelines</a>.</li>
<li><strong>New Error System:</strong> uses a new <code>AFError</code> type to adhere to the new pattern proposed in <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0112-nserror-bridging.md" target="_blank" rel="external">SE-0112</a>.</li>
<li><strong>New RequestAdapter Protocol:</strong> allows inspection and adaptation of every <code>URLRequest</code> before instantiating a <code>Request</code> allowing for easy modification of properties like the <code>Authorization</code> header.</li>
<li><strong>New RequestRetrier Protocol:</strong> allows you to inspect and retry any failed <code>Request</code> if necessary allowing you to build custom authentication solutions (OAuth1, OAuth2, xAuth, Basic Auth, etc.) around a set of requests.</li>
<li><strong>New Parameter Encoding Protocol:</strong> replaces the <code>ParameterEncoding</code> enumeration allowing for easier extension and customization and also throws errors on failure instead of returning a tuple.</li>
<li><strong>New Request Types:</strong> include <code>DataRequest</code>, <code>DownloadRequest</code>, <code>UploadRequest</code> and <code>StreamRequest</code> that implement specialized progress, validation and serialization APIs and behaviors per <code>Request</code> type.</li>
<li><strong>New Progress APIs:</strong> include <code>downloadProgress</code> and <code>uploadProgress</code> APIs supporting both <code>Progress</code> and <code>Int64</code> types and called on a specified dispatch queue defaulting to <code>.main</code>.</li>
<li><strong>Enhanced Response Validation:</strong> now includes the <code>data</code> or <code>temporaryURL</code> and <code>destinationURL</code> allowing inline closures to parse the server data for error messages if validation failed.</li>
<li><strong>New Download Destinations:</strong> allow you to have full control over the move operation on the file system by disabling it, removing a previous file and creating intermediate directories.</li>
<li><strong>New Response Types:</strong> unify response API signatures and expose <code>temporaryURL</code> and <code>downloadURL</code> properties for downloads and the all new task metrics on newer platforms.</li>
</ul>
<hr>
<h2 id="Breaking-API-Changes"><a href="#Breaking-API-Changes" class="headerlink" title="Breaking API Changes"></a>Breaking API Changes</h2><p>Alamofire 4 has fully adopted all the new Swift 3 changes and conventions, including the new <a href="https://swift.org/documentation/api-design-guidelines/" target="_blank" rel="external">API Design Guidelines</a>. Because of this, almost every API in Alamofire has been modified in some way. We can’t possibly document every single change, so we’re going to attempt to identify the most common APIs and how they have changed to help you through those sometimes less than helpful compiler errors.</p>
<h3 id="Namespace-Changes"><a href="#Namespace-Changes" class="headerlink" title="Namespace Changes"></a>Namespace Changes</h3><p>Some of the common classes have been moved into the global namespace to make them a bit easier to work with and to make them first class types.</p>
<ul>
<li><code>Manager</code> is now <code>SessionManager</code></li>
<li><code>Request.TaskDelegate</code> is now <code>TaskDelegate</code></li>
<li><code>Request.DataTaskDelegate</code> is now <code>DataTaskDelegate</code></li>
<li><code>Request.DownloadTaskDelegate</code> is now <code>DownloadTaskDelegate</code></li>
<li><code>Request.UploadTaskDelegate</code> is now <code>UploadTaskDelegate</code></li>
</ul>
<p>We’ve also reorganized the file structure and organization patterns significantly to make it easier to follow the code. We hope that this will encourage more users to get to know the internal structure and implementation of Alamofire. Knowledge is power.</p>
<h3 id="Making-Requests"><a href="#Making-Requests" class="headerlink" title="Making Requests"></a>Making Requests</h3><p>Since making requests is certainly the most common operation in Alamofire, here are some examples of Alamofire 3.x requests compared to their new equivalents in Alamofire 4.</p>
<h4 id="Data-Request-Simple-with-URL-string"><a href="#Data-Request-Simple-with-URL-string" class="headerlink" title="Data Request - Simple with URL string"></a>Data Request - Simple with URL string</h4><pre><code class="swift">// Alamofire 3
Alamofire.request(.GET, urlString).response { request, response, data, error in
    print(request)
    print(response)
    print(data)
    print(error)
}

// Alamofire 4
Alamofire.request(urlString).response { response in // method defaults to `.get`
    debugPrint(response)
}
</code></pre>
<h4 id="Data-Request-Complex-with-URL-string"><a href="#Data-Request-Complex-with-URL-string" class="headerlink" title="Data Request - Complex with URL string"></a>Data Request - Complex with URL string</h4><pre><code class="swift">// Alamofire 3
let parameters: [String: AnyObject] = [&quot;foo&quot;: &quot;bar&quot;]

Alamofire.request(.GET, urlString, parameters: parameters, encoding: .JSON)
    .progress { bytesRead, totalBytesRead, totalBytesExpectedToRead in
        print(&quot;Bytes: \(bytesRead), Total Bytes: \(totalBytesRead), Total Bytes Expected: \(totalBytesExpectedToRead)&quot;)
    }
    .validate { request, response in
        // Custom evaluation closure (no access to server data)
        return .success
    }
    .responseJSON { response in
        debugPrint(response)
    }

// Alamofire 4
let parameters: Parameters = [&quot;foo&quot;: &quot;bar&quot;]

Alamofire.request(urlString, method: .get, parameters: parameters, encoding: JSONEncoding.default)
    .downloadProgress(queue: DispatchQueue.global(qos: .utility)) { progress in
        print(&quot;Progress: \(progress.fractionCompleted)&quot;)
    }
    .validate { request, response, data in
        // Custom evaluation closure now includes data (allows you to parse data to dig out error messages if necessary)
        return .success
    }
    .responseJSON { response in
        debugPrint(response)
    }
</code></pre>
<h4 id="Download-Request-Simple-with-URL-string"><a href="#Download-Request-Simple-with-URL-string" class="headerlink" title="Download Request - Simple with URL string"></a>Download Request - Simple with URL string</h4><pre><code class="swift">// Alamofire 3
let destination = DownloadRequest.suggestedDownloadDestination()

Alamofire.download(.GET, urlString, destination: destination).response { request, response, data, error in
    // What is fileURL...not easy to get
    print(request)
    print(response)
    print(data)
    print(error)
}

// Alamofire 4
let destination = DownloadRequest.suggestedDownloadDestination()

Alamofire.download(urlString, to: destination).response { response in // method defaults to `.get`
    print(response.request)
    print(response.response)
    print(response.temporaryURL)
    print(response.destinationURL)
    print(response.error)
}
</code></pre>
<h4 id="Download-Request-Simple-with-URL-request"><a href="#Download-Request-Simple-with-URL-request" class="headerlink" title="Download Request - Simple with URL request"></a>Download Request - Simple with URL request</h4><pre><code class="swift">// Alamofire 3
let destination = DownloadRequest.suggestedDownloadDestination()

Alamofire.download(urlRequest, destination: destination).validate().responseData { response in
    // What is fileURL...not easy to get
    debugPrint(response)
}

// Alamofire 4
Alamofire.download(urlRequest, to: destination).validate().responseData { response in
    debugPrint(response)
    print(response.temporaryURL)
    print(response.destinationURL)
}
</code></pre>
<h4 id="Download-Request-Complex-with-URL-string"><a href="#Download-Request-Complex-with-URL-string" class="headerlink" title="Download Request - Complex with URL string"></a>Download Request - Complex with URL string</h4><pre><code class="swift">// Alamofire 3
let fileURL: NSURL
let destination: Request.DownloadFileDestination = { _, _ in fileURL }
let parameters: [String: AnyObject] = [&quot;foo&quot;: &quot;bar&quot;]

Alamofire.download(.GET, urlString, parameters: parameters, encoding: .JSON, to: destination)
    .progress { bytesRead, totalBytesRead, totalBytesExpectedToRead in
        print(&quot;Bytes: \(bytesRead), Total Bytes: \(totalBytesRead), Total Bytes Expected: \(totalBytesExpectedToRead)&quot;)
    }
    .validate { request, response in
        // Custom evaluation implementation (no access to temporary or destination URLs)
        return .success
    }
    .responseJSON { response in
        print(fileURL) // Only accessible if captured in closure scope, not ideal
        debugPrint(response)
    }

// Alamofire 4
let fileURL: URL
let destination: DownloadRequest.DownloadFileDestination = { _, _ in 
    return (fileURL, [.createIntermediateDirectories, .removePreviousFile]) 
}
let parameters: Parameters = [&quot;foo&quot;: &quot;bar&quot;]

Alamofire.download(urlString, method: .get, parameters: parameters, encoding: JSONEncoding.default, to: destination)
    .downloadProgress(queue: DispatchQueue.global(qos: .utility)) { progress in
        print(&quot;Progress: \(progress.fractionCompleted)&quot;)
    }
    .validate { request, response, temporaryURL, destinationURL in
        // Custom evaluation closure now includes file URLs (allows you to parse out error messages if necessary)
        return .success
    }
    .responseJSON { response in
        debugPrint(response)
        print(response.temporaryURL)
        print(response.destinationURL)
    }
</code></pre>
<h4 id="Upload-Request-Simple-with-URL-string"><a href="#Upload-Request-Simple-with-URL-string" class="headerlink" title="Upload Request - Simple with URL string"></a>Upload Request - Simple with URL string</h4><pre><code class="swift">// Alamofire 3
Alamofire.upload(.POST, urlString, data: data).response { request, response, data, error in
    print(request)
    print(response)
    print(data)
    print(error)
}

// Alamofire 4
Alamofire.upload(data, to: urlString).response { response in // method defaults to `.post`
    debugPrint(response)
}
</code></pre>
<h4 id="Upload-Request-Simple-with-URL-request"><a href="#Upload-Request-Simple-with-URL-request" class="headerlink" title="Upload Request - Simple with URL request"></a>Upload Request - Simple with URL request</h4><pre><code class="swift">// Alamofire 3
Alamofire.upload(urlRequest, file: fileURL).validate().responseData { response in
    debugPrint(response)
}

// Alamofire 4
Alamofire.upload(fileURL, with: urlRequest).validate().responseData { response in
    debugPrint(response)
}
</code></pre>
<h4 id="Upload-Request-Complex-with-URL-string"><a href="#Upload-Request-Complex-with-URL-string" class="headerlink" title="Upload Request - Complex with URL string"></a>Upload Request - Complex with URL string</h4><pre><code class="swift">// Alamofire 3
Alamofire.upload(.PUT, urlString, file: fileURL)
    .progress { bytes, totalBytes, totalBytesExpected in
        // Are these for upload or for downloading the response?
        print(&quot;Bytes: \(bytesRead), Total Bytes: \(totalBytesRead), Total Bytes Expected: \(totalBytesExpectedToRead)&quot;)
    }
    .validate { request, response in
        // Custom evaluation implementation (no access to server data)
        return .success
    }
    .responseJSON { response in
        debugPrint(response)
    }

// Alamofire 4
Alamofire.upload(fileURL, to: urlString, method: .put)
    .uploadProgress(queue: DispatchQueue.global(qos: .utility)) { progress in
        print(&quot;Upload Progress: \(progress.fractionCompleted)&quot;)
    }
    .downloadProgress { progress in // called on main queue by default
        print(&quot;Download Progress: \(progress.fractionCompleted)&quot;)
    }
    .validate { request, response, data in
        // Custom evaluation closure now includes data (allows you to parse data to dig out error messages if necessary)
        return .success
    }
    .responseJSON { response in
        debugPrint(response)
    }
</code></pre>
<p>As you can see, there are many breaking API changes, but the common APIs still adhere to the original design goals of being able to make complex requests through a single line of code in a concise, well defined manner.</p>
<h3 id="URLStringConvertible"><a href="#URLStringConvertible" class="headerlink" title="URLStringConvertible"></a>URLStringConvertible</h3><p>There are two changes to the <code>URLStringConvertible</code> protocol that are worth noting.</p>
<h4 id="URLConvertible"><a href="#URLConvertible" class="headerlink" title="URLConvertible"></a>URLConvertible</h4><p>The first MAJOR change worth noting on the <code>URLStringConvertible</code> is that it has been renamed to <code>URLConvertible</code>. In Alamofire 3.x, the <code>URLStringConvertible</code> was defined as:</p>
<pre><code class="swift">public protocol URLStringConvertible {
    var URLString: String { get }
}
</code></pre>
<p>Now in Alamofire 4, the <code>URLConvertible</code> protocol is defined as:</p>
<pre><code class="swift">public protocol URLConvertible {
    func asURL() throws -&gt; URL
}
</code></pre>
<p>As you can see, the <code>URLString</code> property is completely gone and replaced by a new <code>asURL</code> method that throws. To explain, let’s first backup.</p>
<p>A VERY common problem in Alamofire is that users forget to percent escape their URL strings and Alamofire will crash. Up until now, we (the Alamofire team) have taken the stance that this is how Alamofire is designed and your URLs need to conform to <a href="https://tools.ietf.org/html/rfc2396" target="_blank" rel="external">RFC 2396</a>. This is certainly not ideal for the community because we all would rather have Alamofire tell us that our URL was invalid rather than having it crash.</p>
<p>Now, back to the new <code>URLConvertible</code> protocol. The reason Alamofire was not previously able to safely handle invalid URL strings was, in fact, due to the lack of safety on <code>URLStringConvertible</code>. It’s not possible for Alamofire to know how to intelligently make an invalid URL string valid. Therefore, if the <code>URL</code> is unable to be created from the <code>URLConvertible</code>, an <code>AFError.invalidURL</code> error is thrown.</p>
<p>This change (along with many others) allows Alamofire to safely handle invalid URLs and report the error back in the response handlers.</p>
<h4 id="URLRequest-Conformance"><a href="#URLRequest-Conformance" class="headerlink" title="URLRequest Conformance"></a>URLRequest Conformance</h4><p>The <code>URLRequest</code> no longer conforms to the <code>URLStringConvertible</code>, now <code>URLConvertible</code> protocol. This was always a bit of a stretch in the previous versions of Alamofire and wasn’t really necessary. It also had a high potential to introduce ambiguity into many Alamofire APIs. Because of these reasons, <code>URLRequest</code> no longer conforms to <code>URLStringConvertible</code> (now <code>URLConvertible</code>).</p>
<p>What this means in code is that you can no longer do the following:</p>
<pre><code class="swift">let urlRequest = URLRequest(url: URL(string: &quot;https://httpbin.org/get&quot;)!)
let urlString = urlRequest.urlString
</code></pre>
<p>Instead, in Alamofire 4, you now have to do the following:</p>
<pre><code class="swift">let urlRequest = URLRequest(url: URL(string: &quot;https://httpbin.org/get&quot;)!)
let urlString = urlRequest.url?.absoluteString
</code></pre>
<blockquote>
<p>See <a href="https://github.com/Alamofire/Alamofire/pull/1505" target="_blank" rel="external">PR-1505</a> for more info.</p>
</blockquote>
<h3 id="URLRequestConvertible"><a href="#URLRequestConvertible" class="headerlink" title="URLRequestConvertible"></a>URLRequestConvertible</h3><p>The <code>URLRequestConvertible</code> was susceptible to the same safety issues concerns as the <code>URLStringConvertible</code> in Alamofire 3.x. In Alamofire 3, the <code>URLRequestConvertible</code> was:</p>
<pre><code class="swift">public protocol URLRequestConvertible {
    var URLRequest: URLRequest { get }
}
</code></pre>
<p>Now, in Alamofire 4, it is:</p>
<pre><code class="swift">public protocol URLRequestConvertible {
    func asURLRequest() throws -&gt; URLRequest
}
</code></pre>
<p>As you can see, the <code>URLRequest</code> property has been replaced by an <code>asURLRequest</code> method that throws when encountering an error generating the <code>URLRequest</code>.</p>
<p>The most likely place this will affect your code is in the <code>Router</code> design pattern. If you have a <code>Router</code>, it’s going to have to change, but for the better! You will now implement the <code>asURLRequest</code> method instead of the property which gives you the ability to throw an error if necessary. You no longer have to force unwrap unsafe data or parameters or wrap <code>ParameterEncoding</code> in a do-catch. Any error encountered in a <code>Router</code> can now be automatically handled by Alamofire.</p>
<blockquote>
<p>See <a href="https://github.com/Alamofire/Alamofire/pull/1505" target="_blank" rel="external">PR-1505</a> for more info.</p>
</blockquote>
<hr>
<h2 id="New-Features"><a href="#New-Features" class="headerlink" title="New Features"></a>New Features</h2><h3 id="Request-Adapter"><a href="#Request-Adapter" class="headerlink" title="Request Adapter"></a>Request Adapter</h3><p>The <code>RequestAdapter</code> protocol is a completely new feature in Alamofire 4. </p>
<pre><code class="swift">public protocol RequestAdapter {
    func adapt(_ urlRequest: URLRequest) throws -&gt; URLRequest
}
</code></pre>
<p>It allows each <code>Request</code> made on a <code>SessionManager</code> to be inspected and adapted before being created. One very specific way to use an adapter is to append an <code>Authorization</code> header to requests behind a certain type of authentication.</p>
<pre><code class="swift">class AccessTokenAdapter: RequestAdapter {
    private let accessToken: String

    init(accessToken: String) {
        self.accessToken = accessToken
    }

    func adapt(_ urlRequest: URLRequest) throws -&gt; URLRequest {
        var urlRequest = urlRequest

        if urlRequest.urlString.hasPrefix(&quot;https://httpbin.org&quot;) {
            urlRequest.setValue(&quot;Bearer &quot; + accessToken, forHTTPHeaderField: &quot;Authorization&quot;)
        }

        return urlRequest
    }
}

let sessionManager = SessionManager()
sessionManager.adapter = AccessTokenAdapter(accessToken: &quot;1234&quot;)

sessionManager.request(&quot;https://httpbin.org/get&quot;)
</code></pre>
<p>If an <code>Error</code> occurs during the adaptation process, it should be thrown and will be delivered in the response handler of the <code>Request</code>.</p>
<blockquote>
<p>See <a href="https://github.com/Alamofire/Alamofire/pull/1450" target="_blank" rel="external">PR-1450</a> for more info.</p>
</blockquote>
<h3 id="Request-Retrier"><a href="#Request-Retrier" class="headerlink" title="Request Retrier"></a>Request Retrier</h3><p>The <code>RequestRetrier</code> is another brand new Alamofire 4 protocol. </p>
<pre><code class="swift">public typealias RequestRetryCompletion = (_ shouldRetry: Bool, _ timeDelay: TimeInterval) -&gt; Void

public protocol RequestRetrier {
    func should(_ manager: SessionManager, retry request: Request, with error: Error, completion: @escaping RequestRetryCompletion)
}
</code></pre>
<p>It allows a <code>Request</code> that encountered an <code>Error</code> while being executed to be retried with an optional delay if specified.</p>
<pre><code class="swift">class OAuth2Handler: RequestAdapter, RequestRetrier {
    public func should(_ manager: SessionManager, retry request: Request, with error: Error, completion: RequestRetryCompletion) {
        if let response = request.task.response as? HTTPURLResponse, response.statusCode == 401 {
            completion(true, 1.0) // retry after 1 second
        } else {
            completion(false, 0.0) // don&#39;t retry
        }
    }
}

let sessionManager = SessionManager()
sessionManager.retrier = OAuth2Handler()

sessionManager.request(urlString).responseJSON { response in
    debugPrint(response)
}
</code></pre>
<p>The retrier allows you to inspect the <code>Request</code> after it has completed and run all <code>Validation</code> closures to determine whether it should be retried. When using both the <code>RequestAdapter</code> and <code>RequestRetrier</code> protocols together, you can create credential refresh systems for OAuth1, OAuth2, Basic Auth and even exponential backoff retry policies. The possibilities are endless. For more information and examples on this topic, please refer to the README.</p>
<blockquote>
<p>See <a href="https://github.com/Alamofire/Alamofire/pull/1391" target="_blank" rel="external">PR-1391</a> and <a href="https://github.com/Alamofire/Alamofire/pull/1450" target="_blank" rel="external">PR-1450</a> for more info.</p>
</blockquote>
<h3 id="Task-Metrics"><a href="#Task-Metrics" class="headerlink" title="Task Metrics"></a>Task Metrics</h3><p>In iOS and tvOS 10 and macOS 10.12, Apple introduced the new <a href="https://developer.apple.com/reference/foundation/urlsessiontaskmetrics" target="_blank" rel="external">URLSessionTaskMetrics</a> APIs. The task metrics encapsulate some fantastic statistical information about the request and response execution. The API is very similar to Alamofire’s <code>Timeline</code>, but provide many more statistics that Alamofire was unable to compute. We’re really excited about these APIs and have exposed them on each <code>Response</code> type meaning they couldn’t be easier to use.</p>
<pre><code class="swift">Alamofire.request(urlString).response { response in
    debugPrint(response.metrics)
}
</code></pre>
<p>It’s important to note that these APIs are only available on iOS and tvOS 10+ and macOS 10.12+. Therefore, depending on your deployment target, you may need to use these inside availability checks:</p>
<pre><code class="swift">Alamofire.request(urlString).response { response in
    if #available(iOS 10.0, *) {
        debugPrint(response.metrics)
    }
}
</code></pre>
<blockquote>
<p>See <a href="https://github.com/Alamofire/Alamofire/pull/1492" target="_blank" rel="external">PR-1492</a> for more info.</p>
</blockquote>
<hr>
<h2 id="Updated-Features"><a href="#Updated-Features" class="headerlink" title="Updated Features"></a>Updated Features</h2><p>Alamofire 4 contains many new features and enhancements on existing ones. This section is designed to give a brief overview of the features and demonstrate their uses. For more information on each each, please refer to the linked pull request.</p>
<h3 id="Errors"><a href="#Errors" class="headerlink" title="Errors"></a>Errors</h3><p>Alamofire 4 contains a completely new error system that adopts the new pattern proposed in <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0112-nserror-bridging.md" target="_blank" rel="external">SE-0112</a>. At the heart of the new error system is <code>AFError</code>, a new <code>Error</code> type enumeration backed by five main cases.</p>
<ul>
<li><code>.invalidURL(url: URLConvertible)</code> - Returned when a <code>URLConvertible</code> type fails to create a valid <code>URL</code>.</li>
<li><code>.parameterEncodingFailed(reason: ParameterEncodingFailureReason)</code> - Returned when a parameter encoding object throws an error during the encoding process.</li>
<li><code>.multipartEncodingFailed(reason: MultipartEncodingFailureReason)</code> - Returned when some step in the multipart encoding process fails. </li>
<li><code>.responseValidationFailed(reason: ResponseValidationFailureReason)</code> - Returned when a <code>validate()</code> call fails.</li>
<li><code>.responseSerializationFailed(reason: ResponseSerializationFailureReason)</code> - Returned when a response serializer encounters an error in the serialization process.</li>
</ul>
<p>Each case contains a specific failure reason which is another nested enumeration with multiple cases that contain additional information about the exact type of error that occurred. What this ultimately means is that is is much easier in Alamofire to identify where an error came from and what to do about it.</p>
<pre><code class="swift">Alamofire.request(urlString).responseJSON { response in
    guard case let .failure(error) = response.result else { return }

    if let error = error as? AFError {
        switch error {
        case .invalidURL(let url):
            print(&quot;Invalid URL: \(url) - \(error.localizedDescription)&quot;)
        case .parameterEncodingFailed(let reason):
            print(&quot;Parameter encoding failed: \(error.localizedDescription)&quot;)
            print(&quot;Failure Reason: \(reason)&quot;)
        case .multipartEncodingFailed(let reason):
            print(&quot;Multipart encoding failed: \(error.localizedDescription)&quot;)
            print(&quot;Failure Reason: \(reason)&quot;)
        case .responseValidationFailed(let reason):
            print(&quot;Response validation failed: \(error.localizedDescription)&quot;)
            print(&quot;Failure Reason: \(reason)&quot;)

            switch reason {
            case .dataFileNil, .dataFileReadFailed:
                print(&quot;Downloaded file could not be read&quot;)
            case .missingContentType(let acceptableContentTypes):
                print(&quot;Content Type Missing: \(acceptableContentTypes)&quot;)
            case .unacceptableContentType(let acceptableContentTypes, let responseContentType):
                print(&quot;Response content type: \(responseContentType) was unacceptable: \(acceptableContentTypes)&quot;)
            case .unacceptableStatusCode(let code):
                print(&quot;Response status code was unacceptable: \(code)&quot;)
            }
        case .responseSerializationFailed(let reason):
            print(&quot;Response serialization failed: \(error.localizedDescription)&quot;)
            print(&quot;Failure Reason: \(reason)&quot;)
        }

        print(&quot;Underlying error: \(error.underlyingError)&quot;)
    } else if let error = error as? URLError {
        print(&quot;URLError occurred: \(error)&quot;)
    } else {
        print(&quot;Unknown error: \(error)&quot;)
    }
}
</code></pre>
<p>This new design allows you to drill down into errors as deep as you may need to in order to figure out the best way to proceed. It also frees developers from the burden of having to deal with <code>NSError</code> types everywhere. By switching to our own custom <code>Error</code> type in Alamofire, we’ve been able to simplify the <code>Result</code> and <code>Response</code> generic types to only require a single generic parameter. This simplifies the response serialization logic.</p>
<blockquote>
<p>See <a href="https://github.com/Alamofire/Alamofire/pull/1419" target="_blank" rel="external">PR-1419</a> for more info.</p>
</blockquote>
<h3 id="Parameter-Encoding-Protocol"><a href="#Parameter-Encoding-Protocol" class="headerlink" title="Parameter Encoding Protocol"></a>Parameter Encoding Protocol</h3><p>The <code>ParameterEncoding</code> enumeration has served us well for over two years at this point. However, it had some limitations that we wanted to address in Alamofire 4.</p>
<ul>
<li>The <code>.url</code> case has always been a bit confusing since it selects a destination based on the HTTP method.</li>
<li>The <code>.urlEncodedInURL</code> case has always been an eye sore to work around the behavior of the <code>.url</code> case.</li>
<li><code>.JSON</code> and <code>.PropertyList</code> encoding could not accept formatting or writing options.</li>
<li>The <code>.Custom</code> encoding was a bit difficult for users to get the hang of.</li>
</ul>
<p>Because of these reasons, we decided to eliminate the enumeration altogether in Alamofire 4! Now, <code>ParameterEncoding</code> is a protocol backed by three concrete <code>URLEncoding</code>, <code>JSONEncoding</code> and <code>PropertyList</code> encoding structs with a new <code>Parameters</code> typealias for creating your parameter dictionaries.</p>
<pre><code class="swift">public typealias Parameters = [String: Any]

public protocol ParameterEncoding {
    func encode(_ urlRequest: URLRequestConvertible, with parameters: Parameters?) throws -&gt; URLRequest
}
</code></pre>
<h4 id="URL-Encoding"><a href="#URL-Encoding" class="headerlink" title="URL Encoding"></a>URL Encoding</h4><p>The new <code>URLEncoding</code> struct contains a <code>Destination</code> enumeration supporting three types of destinations:</p>
<ul>
<li><code>.methodDependent</code> - Applies encoded query string result to existing query string for <code>GET</code>, <code>HEAD</code> and <code>DELETE</code> requests and sets as the HTTP body for requests with any other HTTP method.</li>
<li><code>.queryString</code> - Sets or appends encoded query string result to existing query string.</li>
<li><code>.httpBody</code> - Sets encoded query string result as the HTTP body of the URL request.</li>
</ul>
<p>These destinations make it much easier to control where the parameters are encoded onto the <code>URLRequest</code>. Creating requests still uses the same signature as before in regards to parameter encoding and also has the same default behavior.</p>
<pre><code class="swift">let parameters: Parameters = [&quot;foo&quot;: &quot;bar&quot;]

Alamofire.request(urlString, parameters: parameters) // Encoding =&gt; URLEncoding(destination: .methodDependent)
Alamofire.request(urlString, parameters: parameters, encoding: URLEncoding(destination: .queryString))
Alamofire.request(urlString, parameters: parameters, encoding: URLEncoding(destination: .httpBody))

// Static convenience properties (we&#39;d like to encourage everyone to use this more concise form)
Alamofire.request(urlString, parameters: parameters, encoding: URLEncoding.default)
Alamofire.request(urlString, parameters: parameters, encoding: URLEncoding.queryString)
Alamofire.request(urlString, parameters: parameters, encoding: URLEncoding.httpBody)
</code></pre>
<h4 id="JSON-Encoding"><a href="#JSON-Encoding" class="headerlink" title="JSON Encoding"></a>JSON Encoding</h4><p>The new <code>JSONEncoding</code> struct exposes the ability to customize the JSON writing options.</p>
<pre><code class="swift">let parameters: Parameters = [&quot;foo&quot;: &quot;bar&quot;]

Alamofire.request(urlString, parameters: parameters, encoding: JSONEncoding(options: []))
Alamofire.request(urlString, parameters: parameters, encoding: JSONEncoding(options: .prettyPrinted))

// Static convenience properties (we&#39;d like to encourage everyone to use this more concise form)
Alamofire.request(urlString, parameters: parameters, encoding: JSONEncoding.default)
Alamofire.request(urlString, parameters: parameters, encoding: JSONEncoding.prettyPrinted)
</code></pre>
<h4 id="Property-List-Encoding"><a href="#Property-List-Encoding" class="headerlink" title="Property List Encoding"></a>Property List Encoding</h4><p>The new <code>PropertyListEncoding</code> struct allows customizing the plist format and write options.</p>
<pre><code class="swift">let parameters: Parameters = [&quot;foo&quot;: &quot;bar&quot;]

Alamofire.request(urlString, parameters: parameters, encoding: PropertyListEncoding(format: .xml, options: 0))
Alamofire.request(urlString, parameters: parameters, encoding: PropertyListEncoding(format: .binary, options: 0))

// Static convenience properties (we&#39;d like to encourage everyone to use this more concise form)
Alamofire.request(urlString, parameters: parameters, encoding: PropertyListEncoding.xml)
Alamofire.request(urlString, parameters: parameters, encoding: PropertyListEncoding.binary)
</code></pre>
<h4 id="Custom-Encoding"><a href="#Custom-Encoding" class="headerlink" title="Custom Encoding"></a>Custom Encoding</h4><p>Creating a custom custom <code>ParameterEncoding</code> is now as simple as implementing the protocol. For more examples on how to do this, please refer to the README.</p>
<blockquote>
<p>See <a href="https://github.com/Alamofire/Alamofire/pull/1465" target="_blank" rel="external">PR-1465</a> for more info.</p>
</blockquote>
<h3 id="Request-Subclasses"><a href="#Request-Subclasses" class="headerlink" title="Request Subclasses"></a>Request Subclasses</h3><p>In Alamofire 4, the <code>request</code>, <code>download</code>, <code>upload</code> and <code>stream</code> APIs no longer return a <code>Request</code>. Instead, they return a specific type of <code>Request</code> subclass. There were several motivating factors and community questions that led us to making this change:</p>
<ul>
<li><strong>Progress:</strong> The behavior of the <code>progress</code> method was confusing for upload requests.<ul>
<li>What does <code>progress</code> report on an upload <code>Request</code>? The progress of the upload? The progress of the response download?</li>
<li>If it reports both, how do you know if or when it switches?</li>
</ul>
</li>
<li><strong>Response Serializers:</strong> The response serializers were designed for data and upload requests, not download or stream requests.<ul>
<li>How do you access the fileURL when a download is complete?</li>
<li>What would <code>responseData</code>, <code>responseString</code> or <code>responseJSON</code> do for a download request? Stream request?</li>
</ul>
</li>
</ul>
<p>At a high level, Alamofire 4 now has four <code>Request</code> subclasses that each support their own custom chained APIs. This allows each subclass to create extensions tailored to that specific type of request.</p>
<pre><code class="swift">open class Request {
    // Contains common properties, authentication and state methods as well as
    // CustomStringConvertible and CustomDebugStringConvertible conformance
}

open class DataRequest: Request {
    // Contains stream (not to be confused with StreamRequest) and download progress methods.
}

open class DownloadRequest: Request {
    // Contains download destination and options, resume data and download progress methods.
}

open class UploadRequest: DataRequest {
    // Inherits all DataRequest APIs and also contains upload progress methods.
}

open class StreamRequest: Request {
    // Only inherits Request APIs, there are no other custom APIs at this time.
}
</code></pre>
<p>By making this split, Alamofire 4 was able to create customized chaining APIs for each type of <code>Request</code>. This opened up all sorts of possibilities, but let’s take a moment to focus on what this change means in terms of progress reporting and download destinations.</p>
<blockquote>
<p>See <a href="https://github.com/Alamofire/Alamofire/pull/1455" target="_blank" rel="external">PR-1455</a> for more info.</p>
</blockquote>
<h4 id="Download-and-Upload-Progress"><a href="#Download-and-Upload-Progress" class="headerlink" title="Download and Upload Progress"></a>Download and Upload Progress</h4><p>The progress reporting system for data, download and upload requests has been completely redesigned. Each request type contains progress APIs for executing a closure during each progress update by returning the underlying <code>Progress</code> instance. The closure will be called on the specified queue that defaults to main.</p>
<p><strong>Data Request Progress</strong></p>
<pre><code class="swift">Alamofire.request(urlString)
    .downloadProgress { progress in
        // Called on main dispatch queue by default
        print(&quot;Download progress: \(progress.fractionCompleted)&quot;)
    }
    .responseJSON { response in
        debugPrint(response)
    }
</code></pre>
<p><strong>Download Request Progress</strong></p>
<pre><code class="swift">Alamofire.download(urlString, to: destination)
    .downloadProgress(queue: DispatchQueue.global(qos: .utility)) { progress in
        // Called on utility dispatch queue
        print(&quot;Download progress: \(progress.fractionCompleted)&quot;)
    }
    .responseJSON { response in
        debugPrint(response)
    }
</code></pre>
<p><strong>Upload Request Progress</strong></p>
<pre><code class="swift">Alamofire.upload(data, to: urlString, withMethod: .post)
    .uploadProgress { progress in
        // Called on main dispatch queue by default
        print(&quot;Upload progress: \(progress.fractionCompleted)&quot;)
    }
    .downloadProgress { progress in
        // Called on main dispatch queue by default
        print(&quot;Download progress: \(progress.fractionCompleted)&quot;)
    }
    .responseData { response in
        debugPrint(response)
    }
</code></pre>
<p>It’s now easy to differentiate between upload and download progress for upload requests.</p>
<blockquote>
<p>See <a href="https://github.com/Alamofire/Alamofire/pull/1455" target="_blank" rel="external">PR-1455</a> for more info.</p>
</blockquote>
<h4 id="Download-File-Destinations"><a href="#Download-File-Destinations" class="headerlink" title="Download File Destinations"></a>Download File Destinations</h4><p>In Alamofire 3.x, successful download requests would always move the temporary file to a final destination URL provided by the <code>destination</code> closure. While this was a nice convenience, it had several limitations:</p>
<ul>
<li><code>Forced</code> - The API forces you to provide a destination closure to move the file even if you have a valid use case for not moving it.</li>
<li><code>Limiting</code> - There was no way to adjust the file system prior to moving the file.<ul>
<li>What if you need to delete a pre-existing file at the destination URL before moving the temporary file?</li>
<li>What if you need to create intermediate directories to the destination URL before moving the temporary file?</li>
</ul>
</li>
</ul>
<p>These limitations led to several enhancements in Alamofire 4. The first of which is the optionality of the destination closure. Now, by default, the <code>destination</code> closure is <code>nil</code> which means the file is not moved anywhere on the file system and the temporary URL is returned.</p>
<pre><code class="swift">Alamofire.download(urlString).responseData { response in
    print(&quot;Temporary URL: \(response.temporaryURL)&quot;)
}
</code></pre>
<blockquote>
<p>We’ll cover the <code>DownloadResponse</code> type in more detail in the <a href="#response-serializers">Response Serializers</a> section.</p>
</blockquote>
<h4 id="Download-Options"><a href="#Download-Options" class="headerlink" title="Download Options"></a>Download Options</h4><p>The other major change made was to add download options to the destination closure allowing more file system control over the move operation. To accomplish this, the <code>DownloadOptions</code> type was created and added to the <code>DownloadFileDestination</code> closure.</p>
<pre><code class="swift">public typealias DownloadFileDestination = (
    _ temporaryURL: URL,
    _ response: HTTPURLResponse)
    -&gt; (destinationURL: URL, options: DownloadOptions)
</code></pre>
<p>The two currently supported <code>DownloadOptions</code> are:</p>
<ul>
<li><code>.createIntermediateDirectories</code> - Creates intermediate directories for the destination URL if specified.</li>
<li><code>.removePreviousFile</code> - Removes a previous file from the destination URL if specified.</li>
</ul>
<p>They can then be used as follows:</p>
<pre><code class="swift">let destination: DownloadRequest.DownloadFileDestination = { _, _ in 
    return (fileURL, [.removePreviousFile, .createIntermediateDirectories]) 
}

Alamofire.download(urlString, to: destination).response { response in
    debugPrint(response)
}
</code></pre>
<p>If an error occurs during the file system operations, the <code>error</code> on the <code>DownloadResponse</code> will be of type <code>URLError</code>.</p>
<blockquote>
<p>See <a href="https://github.com/Alamofire/Alamofire/pull/1462" target="_blank" rel="external">PR-1462</a> for more info.</p>
</blockquote>
<h3 id="Response-Validation"><a href="#Response-Validation" class="headerlink" title="Response Validation"></a>Response Validation</h3><p>There were several opportunity areas for improving the response validation system in Alamofire 4. These areas included:</p>
<ul>
<li>Exposing the underlying <code>data</code> to the <code>Validation</code> closure.</li>
<li>Custom validation between different <code>Request</code> subclasses types allowing <code>temporaryURL</code> and <code>destinationURL</code> to be exposed for download requests.</li>
</ul>
<p>By creating <code>Request</code> subclasses, the validation closure typealias and request APIs were able to be tailored to each request type.</p>
<h4 id="Data-Request"><a href="#Data-Request" class="headerlink" title="Data Request"></a>Data Request</h4><p>The <code>Validation</code> closure exposed on the <code>DataRequest</code> (inherited by <code>UploadRequest</code>) is now as follows:</p>
<pre><code class="swift">extension DataRequest {
    public typealias Validation = (URLRequest?, HTTPURLResponse, Data?) -&gt; ValidationResult
}
</code></pre>
<p>By exposing the <code>Data?</code> property directly in the closure, you no longer have to write an extension on <code>Request</code> to access it. Now you can do something like this:</p>
<pre><code class="swift">Alamofire.request(urlString)
    .validate { request, response, data in
        guard let data = data else { return .failure(customError) }

        // 1) Validate the response to make sure everything looks good
        // 2) If validation fails, you can now parse the error message out of the
        //    data if necessary and add that to your custom error if you wish.

        return .success
    }
    .response { response in
        debugPrint(response)
    }
</code></pre>
<h4 id="Download-Request"><a href="#Download-Request" class="headerlink" title="Download Request"></a>Download Request</h4><p>The <code>Validation</code> closure on the <code>DownloadRequest</code> is very similar to the <code>DataRequest</code> API, but tailored more to downloads.</p>
<pre><code class="swift">extension DownloadRequest {
    public typealias Validation = (
        _ request: URLRequest?, 
        _ response: HTTPURLResponse, 
        _ temporaryURL: URL?, 
        _ destinationURL: URL?) 
        -&gt; ValidationResult
}
</code></pre>
<p>The <code>temporaryURL</code> and <code>destinationURL</code> parameters now allow you access the data returned by the server directly in an inline closure. This allows you to inspect the data inside the file if you’ve determined you need to in order to create a custom error.</p>
<pre><code class="swift">Alamofire.download(urlString)
    .validate { request, response, temporaryURL, destinationURL in
        guard let fileURL = temporaryURL else { return .failure(customError) }

        do {
            let _ = try Data(contentsOf: fileURL)
            return .success
        } catch {
            return .failure(customError)
        }
    }
    .response { response in
        debugPrint(response)
    }
</code></pre>
<p>By exposing the underlying server data directly to the inline closures, error messages embedded in those responses can be parsed out inside the <code>Validation</code> closure to create a custom error including the server error message. If the payload is the same schema as used in a response serializer closure, the response serializer could be called to parse out the error message rather than duplicating the logic. For an example of how to do this, please refer to the README.</p>
<blockquote>
<p>See <a href="https://github.com/Alamofire/Alamofire/pull/1461" target="_blank" rel="external">PR-1461</a> for more info.</p>
</blockquote>
<h3 id="Response-Serializers"><a href="#Response-Serializers" class="headerlink" title="Response Serializers"></a>Response Serializers</h3><p>The response serialization system in Alamofire 3.x had several pretty severe limitations:</p>
<ul>
<li>Response serialization APIs could be applied to download and stream requests but resulted in undefined behavior.<ul>
<li>How do you access the fileURL when a download is complete?</li>
<li>What would <code>responseData</code>, <code>responseString</code> or <code>responseJSON</code> do when chained onto a download request? A stream request?</li>
</ul>
</li>
<li>The <code>response</code> API returned 4 parameters instead of an encapsulating <code>Response</code> type.<ul>
<li>The biggest issue here is that any change to that API could not be done in a backwards compatible manner.</li>
<li>Created confusion when switching between the serialized and unserialized APIs which led to difficult to debug compiler errors.</li>
</ul>
</li>
</ul>
<p>As you can see, there were some very strong limitations to this system in Alamofire 3.x. Therefore, in Alamofire 4, the <code>Request</code> type was first broken down into subclasses, which opened up the opportunity to create customized response serializers and APIs for specific types of requests. Before getting to far into response serializers, we should first walk through the new <code>Response</code> types.</p>
<h4 id="Default-Data-Response"><a href="#Default-Data-Response" class="headerlink" title="Default Data Response"></a>Default Data Response</h4><p>The <code>DefaultDataResponse</code> represents an unserialized server response. There’s no Alamofire processing that happens, it just collects all the response information from the <code>SessionDelegate</code> APIs and returns it in a simple struct.</p>
<pre><code class="swift">public struct DefaultDataResponse {
    public let request: URLRequest?
    public let response: HTTPURLResponse?
    public let data: Data?
    public let error: Error?
    public var metrics: URLSessionTaskMetrics? { return _metrics as? URLSessionTaskMetrics }
}
</code></pre>
<p>This is the type of response you will get back from the <code>DataRequest.response</code> API.</p>
<pre><code class="swift">Alamofire.request(urlString).response { response in
    debugPrint(response)
}

Alamofire.upload(file, to: urlString).response { response in
    debugPrint(response)
}
</code></pre>
<h4 id="Data-Response"><a href="#Data-Response" class="headerlink" title="Data Response"></a>Data Response</h4><p>The generic <code>DataResponse</code> type is the same as the generic <code>Response</code> in Alamofire 3.x, but refactored and contains the new <code>metrics</code> property.</p>
<pre><code class="swift">public struct DataResponse&lt;Value&gt; {
    public let request: URLRequest?
    public let response: HTTPURLResponse?
    public let data: Data?
    public let result: Result&lt;Value&gt;
    public let timeline: Timeline
    public var metrics: URLSessionTaskMetrics? { return _metrics as? URLSessionTaskMetrics }
}
</code></pre>
<p>You still have access to the same response serialization APIs as before on the <code>DataRequest</code> and <code>UploadRequest</code> types.</p>
<pre><code class="swift">Alamofire.request(urlString).responseJSON { response in
    debugPrint(response)
    print(response.result.isSuccess)
}

Alamofire.upload(fileURL, to: urlString).responseData { response in
    debugPrint(response)
    print(response.result.isSuccess)
}
</code></pre>
<h4 id="Default-Download-Response"><a href="#Default-Download-Response" class="headerlink" title="Default Download Response"></a>Default Download Response</h4><p>Since downloads work differently than data and upload requests, Alamofire 4 contains custom download <code>Response</code> types tailored to their behavior. The <code>DefaultDownloadResponse</code> type represents an unserialized server response for a <code>DownloadRequest</code> that collects all the <code>SessionDelegate</code> information into a simple struct.</p>
<pre><code class="swift">public struct DefaultDownloadResponse {
    public let request: URLRequest?
    public let response: HTTPURLResponse?
    public let temporaryURL: URL?
    public let destinationURL: URL?
    public let resumeData: Data?
    public let error: Error?
    public var metrics: URLSessionTaskMetrics? { return _metrics as? URLSessionTaskMetrics }
}
</code></pre>
<p>The <code>DefaultDownloadResponse</code> type is returned when using the new <code>DownloadRequest.response</code> API.</p>
<pre><code class="swift">Alamofire.download(urlString).response { response in
    debugPrint(response)
    print(response.temporaryURL)
}
</code></pre>
<h4 id="Download-Response"><a href="#Download-Response" class="headerlink" title="Download Response"></a>Download Response</h4><p>The new generic <code>DownloadResponse</code> type is similar to the generic <code>DataResponse</code> type, but contains information tailored to download requests. The <code>DownloadResponse</code> type is returned when one of four new APIs exposed on the <code>DownloadRequest</code> type. These new APIs match the <code>DataRequest</code> ones, and provide the same functionality by loading the data from the underlying temporary or destination URL.</p>
<pre><code class="swift">Alamofire.download(urlString, to: destination)
    .responseData { response in
        debugPrint(response)
    }
    .responseString { response in
        debugPrint(response)
    }
    .responseJSON { response in
        debugPrint(response)
    }
    .responsePropertyList { response in
        debugPrint(response)
    }
</code></pre>
<p>These new response serialization APIs make it MUCH easier to download a request to a file and serialize the response all in a single call.</p>
<h4 id="Custom-Response-Serializers"><a href="#Custom-Response-Serializers" class="headerlink" title="Custom Response Serializers"></a>Custom Response Serializers</h4><p>If you have created your own custom response serializers, you may want to extend support across both data and download requests similar to what we’ve done with the Alamofire response serializers. If you do decide to do this, take a close look at how Alamofire shares the response serializer implementation between both request types by moving the implementation to the <code>Request</code>. This allowed us to DRY up our logic to avoid duplication between types.</p>
<blockquote>
<p>See <a href="https://github.com/Alamofire/Alamofire/pull/1457" target="_blank" rel="external">PR-1457</a> for more info.</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Alamofire </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[内存管理]]></title>
      <url>/2017/06/12/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a> 
<p><strong>1. 物理地址和逻辑地址</strong></p>
<p><strong>物理地址</strong>：加载到内存地址寄存器中的地址，内存单元的真正地址。在前端总线上传输的内存地址都是物理内存地址，编号从0开始一直到可用物理内存的最高端。这些数字被北桥(Nortbridge chip)映射到实际的内存条上。物理地址是明确的、最终用在总线上的编号，不必转换，不必分页，也没有特权级检查(no translation, no paging, no privilege checks)。 </p>
<p><strong>逻辑地址</strong>：CPU所生成的地址。逻辑地址是内部和编程使用的、并不唯一。例如，你在进行C语言指针编程中，可以读取指针变量本身值(&amp;操作)，实际上这个值就是逻辑地址，它是相对于你当前进程数据段的地址（偏移地址），不和绝对物理地址相干。 </p>
<p>为什么会有这两种地址？ </p>
<p>个人觉的原因在于逻辑地址分配更加灵活，可以允许不唯一，看起来也较为直观，例如，一段代码中分配数组，逻辑地址上是连续的，然而在物理地址上，这个数组所占用的页可能分散开来，物理地址上就是不连续的，这样对程序的可理解性上有影响。另外，有了逻辑地址这个概念，才能使用虚拟内存技术。 </p>
<p><strong>2. </strong>Paging，分页内存管理方案 </p>
<p>(1) 分页的最大作用就在于：使得进程的物理地址空间可以是非连续的。 </p>
<p>物理内存被划分为一小块一小块，每块被称为帧(Frame)。分配内存时，帧是分配时的最小单位，最少也要给一帧。在逻辑内存中，与帧对应的概念就是页(Page)。 </p>
<p>逻辑地址的表示方式是：前部分是页码后部分是页偏移。 </p>
<p>例如，已知逻辑空间地址为2^m个字节（也就是说逻辑地址的长度是m位），已知页大小是2^n字节。那么一共可以有2^(m-n)个页。因此页码部分会占m-n位，之后的n位，用来存储页偏移。 </p>
<p>举个例子， 页大小为4B，而逻辑内存为32B（8页），逻辑地址0的页号为0，页号0对应帧5，因此逻辑地址映射为物理地址5<em>4+0=20。逻辑地址3映射物理地址5</em>4+3=23。逻辑地址13(4*3+1，页号为3，偏移为1，因此帧号为2)，映射到物理地址9。 </p>
<p><img src="http://images.cnitblog.com/blog/48332/201311/12230204-439af747b09c4d9b9fc18cf69f531141.png" alt=""></p>
<p>采用分页技术不会产生外部碎片(内存都被划分为帧)，但可能产生内部碎片(帧已经是最小单元，因此帧内部可能有空间没有用到)。 </p>
<p>按概率计算下来，每个进程平均可有半个帧大小的内部碎片。 </p>
<p>(2) 页表的硬件实现 </p>
<p>上一小节中写到页表是逻辑地址转化到物理地址的关键所在。那么页表如何存储？ </p>
<p>每个操作系统都有自己的方法来保存页表。绝大多数都会为每个进程分配一个页表。现在由于页表都比较大，所以放在内存中(以往是放在一组专用寄存器里)，其指针存在进程控制块(PCB)里，当进程被调度程序选中投入运行时，系统将其页表指针从进程控制块中取出并送入用户寄存器中。随后可以根据此首地址访问页表。 </p>
<p>页表的存储方式是<strong>TLB(Translation look-aside buffer, 翻译后备缓冲器)</strong>+内存。TLB实际上是一组硬件缓冲所关联的快速内存。若没有TBL，操作系统需要两次内存访问来完成逻辑地址到物理地址的转换，访问页表算一次，在页表中查找算一次。TLB中存储页表中的一小部分条目，条目以键值对方式存储。 </p>
<p><img src="http://images.cnitblog.com/blog/48332/201311/13090353-a81e30238dea4811b9b5382d3eeb0427.png" alt=""></p>
<p>(3) 页表的数据结构 </p>
<p>a. </p>
<p>现有的笔记本电脑，内存地址空间一般为2^32字节以上。对于具有32位逻辑地址空间的计算机系统，如果系统的页大小为4KB(2^12B)，那么页表可以拥有2^(32-12)个，也就是一百多万个条目，假设每个条目占有4B，那每个进程都需要4MB的物理地址空间来存放页表本身。而且，页表本身需要分配在连续内存中。 </p>
<p>为此，<strong>Hierarchical Paging(层次化分页)</strong>被提出，实际上就是将页号分为两部分，第一部分作为索引，第二部分作为页号的偏移。 </p>
<p>以一个4kb页大小的32位系统为例。一个逻辑地址被分为20位的页码和12位的页偏移。因为要对页表进行再分页，所以该页号可分为10位的页码和10位的页偏移。这样一个逻辑地址就表示如下形式： </p>
<p><img src="http://images.cnitblog.com/blog/48332/201311/13090739-306c82d13f914d7197a114eeae246ab5.png" alt=""></p>
<p>地址转换过程如下： </p>
<p><img src="http://images.cnitblog.com/blog/48332/201311/13091011-3f2922b4ed65405b8ccc65b9737fa014.png" alt=""></p>
<p>地址由外向内转换，因此此方法也被称为<strong>forward-mapped page table(向前映射表)</strong>。 </p>
<p>b. Hashed Page Tables 哈希页表 </p>
<p>处理超过32位地址空间的常用方法是使用<strong>hashed page table(哈希页表)</strong>，并以虚拟页码作为哈希值。哈希页表的每一条目都包括一个链表的元素，这些元素哈希成同一位置。每个元素有三个域：虚拟页码，所映射的帧号，指向链表中下一个元素的指针。 </p>
<p>个人看来，哈希页表的地址转换方式，实际上是<strong>Chaining(链接)</strong>方式，也就是一种哈希函数的溢出处理方式(另一种溢出处理方式叫做Open Addressing，开放寻址)，具体过程如下： </p>
<p>逻辑地址需要大于32bit的地址空间来表示，但是操作系统仍只有32bit来表示地址。此时人们便想到虚拟页地址，虚拟地址可以在32bit表示范围之内，然后利用哈希函数完成逻辑地址到虚拟地址的映射，由于虚拟地址更少，哈希函数会出现溢出，这里使用Chaining来解决溢出。 </p>
<p>逻辑地址中的页号(下图中的p)经过哈希函数的计算，算出虚拟地址中的页号，根据虚拟页号可以在哈希表中以O(1)方式寻址，用p与链表中的每一个元素的第一个域相比较。如果匹配，那么相应的帧号就用来形成物理地址。如果不匹配，就对链表中的下一个节点进行比较，以寻找一个匹配的页号。 </p>
<p><img src="http://images.cnitblog.com/blog/48332/201311/13104212-e3957ec532234cbab06e42ac4d1b5311.png" alt=""></p>
<p>c. Inverted page table 反向页表 </p>
<p>时间关系，这段暂时略过。 </p>
<p><strong>3. Segmentation，分段内存管理方案</strong></p>
<p>采用分页内存管理有一个不可避免的问题：用户视角的内存和实际内存的分离。设想一段main函数代码，里面包含Sqrt函数的调用。按照编写者的理解，这段代码运行时，操作系统应该分配内存给：符号表(编译时使用)，栈(存放局部变量与函数参数值)，Sqrt代码段，主函数代码段等。这样，编写者就可以方便地指出：”函数sqrt内存模块的第五条指令”，来定位一个元素。而实际上，由于采用Paging的管理方式，所有的一切都只是散落在物理内存中的各个帧上，并不是以编写者的理解来划分模块。 </p>
<p><img src="http://images.cnitblog.com/blog/48332/201311/13105648-d82857a6bb2a46e38469058978e92f8b.png" alt=""></p>
<p>Segmentation的内存管理方式可以支持这种思路。逻辑地址空间由一组段组成。每个段都有名字和长度。地址指定了段名称和段内偏移。因此用户通过两个量来指定地址：段名称和偏移。段是编号的，通过段号而非段名称来引用。因此逻辑地址由有序对构成： </p>
<p> <segment-number,offset>(&lt;段号s, 段内偏移d&gt;) </segment-number,offset></p>
<p>段偏移d因该在0和段界限之间，如果合法，那么就与基地址相加而得到所需字节在物理内存中的地址。因此段表是一组基地址和界限寄存器对。 </p>
<p><img src="http://images.cnitblog.com/blog/48332/201311/13112137-0cac9e80dbfc4bc7b9e8aa9ae664087c.png" alt=""></p>
<p>例如下图，有5个段，编号0~4，例如段2为400B开始于位置4300，对段2第53字节的引用映射成位置4300+53=4353。而段0字节1222的引用则会触发地址错误，因为该段的仅为1000B长(界限为1000)。 </p>
<p><img src="http://images.cnitblog.com/blog/48332/201311/13112441-167f767f7e1546a5ab123abbd4fad1e2.png" alt=""></p>
<p><strong>4. 合并分段和分页的管理方案</strong></p>
<p>在现有的Intel兼容计算机(x86)上，采用的内存管理方案是分段和分页合并的管理方案。 </p>
<p>在这个方案中，逻辑地址，如前一节中所说，是由一个段标识符加上一个指定段内相对地址的偏移量，表示为 [段标识符：段内偏移量]。 </p>
<p>这样的逻辑地址转换的过程是怎样呢？如下图所示： </p>
<p><img src="http://images.cnitblog.com/blog/48332/201311/15110509-3e98d0a333644e01952e7675ee2dbb71.png" alt=""></p>
<p>当CPU要执行一条引用了内存地址的指令时，转换过程就开始了。第一步是把逻辑地址转换成<strong>线性地址</strong>。但是，为什么不跳过这一步，而让软件直接使用线性地址（或物理地址呢？）原因主要是因为：</p>
<p>(1) Intel的更新是渐进式而非革命式，新的处理器需要兼容和保留过往的设置。具体的原因，博文Memory Translation and Segmentation (<a href="http://blog.csdn.net/drshenlei/article/details/4261909" target="_blank" rel="external">http://blog.csdn.net/drshenlei/article/details/4261909</a>) 中讲的较为清楚。</p>
<p>(2) 如上节所说，采用段内存管理，可以跟方便地进行地址保护(同一类型的地址逻辑地址在一起)。 </p>
<p>下面讲逻辑地址到线性地址的部分。 </p>
<p>在IBM OS/2 32位版本的操作系统，和Intel 386的环境下。操作系统采用的内存分配方式就是分段和分页合并的方式。 </p>
<p>逻辑地址的实际上是一对&lt;选择符，偏移&gt;。 </p>
<p>选择符的内容如下： </p>
<p><img src="http://images.cnitblog.com/blog/48332/201311/15225957-67836817299c459db5405bbc75f15be0.jpg" alt=""></p>
<p>从左开始，13位是索引(或者称为段号)，通过这个索引，可以定位到<strong>段描述符(segment descriptor)</strong>，而段描述符是可以真正记载了有关一个段的位置和大小信息， 以及访问控制的状态信息。段描述符一般由8个字节组成。由于8B较大，而Intel为了保持向后兼容，将段寄存器仍然规定为16-bit(尽管每个段寄存器事实上有一个64-bit长的不可见部分，但对于程序员来说，段寄存器就是16-bit的)，那么很明显，我们无法通过16-bit长度的段寄存器来直接引用64-bit的段描述符。因此在逻辑地址中，只用13bit记录其索引。而真正的段描述符，被放于数组之中。 </p>
<p>这个内存中的数组就叫做<strong>GDT(Global Descriptor Table，全局描述表)</strong>，Intel的设计者门提供了一个寄存器GDTR用来存放GDT的入口地址。程序员将GDT设定在内存中某个位置之后，可以通过LGDT指令将GDT的入口地址装入此寄存器，从此以后，CPU就根据此寄存器中的内容作为GDT的入口来访问GDT了。 </p>
<p>除了GDT之外，还有<strong>LDT(Local Descriptor **</strong>Table，本地描述表)**，但与GDT不同的是，LDT在系统中可以存在多个，每个进程可以拥有自己的LDT。LDT的内存地址在LDTR寄存器中。 </p>
<p>在之前图中的TI位，就是用来表示此索引所指向的段描述符是存于全局描述表中，还是本地描述表中。=0，表示用GDT，=1表示用LDT。 </p>
<p>RPL位，占2bit，是保护信息位，还没有仔细了解过这一块，暂时先不写。 </p>
<p>找到，段描述符后，加上偏移量，便是线性地址。转换过程如下： </p>
<p><img src="http://images.cnitblog.com/blog/48332/201311/15232144-4db8ba86c9564fcab7bab1c90bd9bf10.jpg" alt=""></p>
<p>在Intel 386的环境下，线性地址转换为物理地址的过程，和第二节分页式内存管理中，层次分页中，逻辑地址转换为物理地址的方法类似。如下图。 </p>
<p><img src="http://images.cnitblog.com/blog/48332/201311/15232858-b7f7f3c854a84da2b409e1a6bbe2211d.jpg" alt=""></p>
<p>Intel 80386的地址转换全过程如下图： </p>
<p><img src="http://images.cnitblog.com/blog/48332/201311/15224432-4c36b374c6db48898a6922b98c577313.png" alt=""></p>
<p>内存管理部分是操作系统的核心功能之一，这次将理论部分整理出来，一是为了复习，二也是为了提纲挈领地为深入学习操作系统做准备。 </p>
]]></content>
      
        <categories>
            
            <category> 操作系统 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> cpu </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS动画中的枚举UIViewAnimationOptions]]></title>
      <url>/2017/06/11/UIViewAnimationOptions/</url>
      <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a>
<p>首先这个枚举属于UIViewAnimation。我们经常使用的函数是 <code>[UIView animateWithDuration: animations:^{} completion:^(BOOL finished) {}];</code><br>和<code>[UIView animateWithDuration: animations:^{}];</code>如果动画稍微复杂点，例如需要组合等等就可能用到这个函数：<code>[UIView animateWithDuration: delay: options: animations: completion:^(BOOL finished) {}];</code>刚开始接触的朋友看到一堆枚举可能就觉得烦，尤其是苹果那混乱的动画框架东一坨，西一坨。又是Quartz2D，又是核心动画跟臭袜子一样……没关系，捡回来接着穿。</p>
<p>　　以上方法中的options一项需要传入一个枚举，这个枚举大概控制的是这几个要素：当前动画嵌套中的动画执行随时间的快慢种类（先快后慢等..）。动画要一直重复吗。如果我使用转场动画那么我用哪种转场效果。还有子动画嵌套在父动画中时我们如何对待父动画中的相同选项等等..</p>
<p>　正文：</p>
<pre><code>UIViewAnimationOptionLayoutSubviews            //提交动画的时候布局子控件，表示子控件将和父控件一同动画。

UIViewAnimationOptionAllowUserInteraction      //动画时允许用户交流，比如触摸

UIViewAnimationOptionBeginFromCurrentState     //从当前状态开始动画

UIViewAnimationOptionRepeat                    //动画无限重复

UIViewAnimationOptionAutoreverse               //执行动画回路,前提是设置动画无限重复

UIViewAnimationOptionOverrideInheritedDuration //忽略外层动画嵌套的执行时间

UIViewAnimationOptionOverrideInheritedCurve    //忽略外层动画嵌套的时间变化曲线

UIViewAnimationOptionAllowAnimatedContent      //通过改变属性和重绘实现动画效果，如果key没有提交动画将使用快照

UIViewAnimationOptionShowHideTransitionViews   //用显隐的方式替代添加移除图层的动画效果

UIViewAnimationOptionOverrideInheritedOptions  //忽略嵌套继承的选项
</code></pre><p>   //时间函数曲线相关</p>
<pre><code>UIViewAnimationOptionCurveEaseInOut            //时间曲线函数，由慢到快

UIViewAnimationOptionCurveEaseIn               //时间曲线函数，由慢到特别快

UIViewAnimationOptionCurveEaseOut              //时间曲线函数，由快到慢

UIViewAnimationOptionCurveLinear               //时间曲线函数，匀速
</code></pre><p>   //转场动画相关的</p>
<pre><code>UIViewAnimationOptionTransitionNone            //无转场动画

UIViewAnimationOptionTransitionFlipFromLeft    //转场从左翻转

UIViewAnimationOptionTransitionFlipFromRight   //转场从右翻转

UIViewAnimationOptionTransitionCurlUp          //上卷转场

UIViewAnimationOptionTransitionCurlDown        //下卷转场

UIViewAnimationOptionTransitionCrossDissolve   //转场交叉消失

UIViewAnimationOptionTransitionFlipFromTop     //转场从上翻转

UIViewAnimationOptionTransitionFlipFromBottom  //转场从下翻转
</code></pre><p>　 浅略理解，待友人的指正。</p>
<p>　补充：关于最后一组转场动画它一般是用在这个方法中的：</p>
<p>　　　　<code>[UIView transitionFromView: toView: duration: options: completion:^(BOOL finished) {}];</code></p>
<p>　该方法效果是插入一面视图移除一面视图，期间可以使用一些转场动画效果。</p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> UIViewAnimationOptions </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LDA Algorithm]]></title>
      <url>/2017/05/26/LDA/</url>
      <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h3 id="线性判别分析LDA原理总结"><a href="#线性判别分析LDA原理总结" class="headerlink" title="线性判别分析LDA原理总结"></a><center>线性判别分析LDA原理总结</center></h3><p>　　　　线性判别分析（Linear Discriminant Analysis, 以下简称LDA）,一种经典的降维方法。LDA在模式识别领域（比如人脸识别，舰艇识别等图形图像识别领域）中有非常广泛的应用，因此我们有必要了解下它的算法原理。</p>
<p>　　　　在学习LDA之前，有必要将其自然语言处理领域的LDA区别开来，在自然语言处理领域， LDA是隐含狄利克雷分布（Latent Dirichlet Allocation，简称LDA），他是一种处理文档的主题模型。我们本文只讨论线性判别分析，因此后面所有的LDA均指线性判别分析。</p>
<ol>
<li>LDA的思想</li>
</ol>
<p>　　　　LDA是一种监督学习的降维技术，也就是说它的数据集的每个样本是有类别输出的。这点和PCA不同。PCA是不考虑样本类别输出的无监督降维技术。LDA的思想可以用一句话概括，就是“投影后类内方差最小，类间方差最大”。什么意思呢？ 我们要将数据在低维度上进行投影，投影后希望每一种类别数据的投影点尽可能的接近，而不同类别的数据的类别中心之间的距离尽可能的大。</p>
<center><br><img src="http://oq5d32gij.bkt.clouddn.com/14958087329231.jpg" alt=""><br></center>

<p>　　　　可能还是有点抽象，我们先看看最简单的情况。假设我们有两类数据 分别为红色和蓝色，如下图所示，这些数据特征是二维的，我们希望将这些数据投影到一维的一条直线，让每一种类别数据的投影点尽可能的接近，而红色和蓝色数据中心之间的距离尽可能的大。</p>
<p>　　　　上图中提供了两种投影方式，哪一种能更好的满足我们的标准呢？从直观上可以看出，右图要比左图的投影效果好，因为右图的黑色数据和蓝色数据各个较为集中，且类别之间的距离明显。左图则在边界处数据混杂。以上就是LDA的主要思想了，当然在实际应用中，我们的数据是多个类别的，我们的原始数据一般也是超过二维的，投影后的也一般不是直线，而是一个低维的超平面。</p>
<p>　　　　在我们将上面直观的内容转化为可以度量的问题之前，我们先了解些必要的数学基础知识，这些在后面讲解具体LDA原理时会用到。</p>
<ol>
<li>瑞利商（Rayleigh quotient）与广义瑞利商（genralized Rayleigh quotient）<br>   我们首先来看看瑞利商的定义。瑞利商是指这样的函数$R(A,x)$:<br>$$R(A,x)=\frac{x^HAx}{x^Hx}$$<br>　　　　其中x为非零向量，而A为n×n的Hermitan矩阵。所谓的Hermitan矩阵就是满足共轭转置矩阵和自己相等的矩阵，即$A^H=A$。如果我们的矩阵A是实矩阵，则满足$A^H=A$的矩阵即为Hermitan矩阵。</li>
</ol>
<p>　　　　瑞利商$R(A,x)$有一个非常重要的性质，即它的最大值等于矩阵A最大的特征值，而最小值等于矩阵A的最小的特征值，也就是满足<br>$$\lambda_{min}≤\frac{x^HAx}{x^Hx}≤\lambda_{max}$$<br>　　　　具体的证明这里就不给出了。当向量x是标准正交基时，即满足$x^Hx=1$时，瑞利商退化为：$R(A,x)=x^HAx$，这个形式在谱聚类和PCA中都有出现。</p>
<p>　　　　以上就是瑞利商的内容，现在我们再看看广义瑞利商。广义瑞利商是指这样的函数$R(A,B,x)$:<br>$$R(A,x)=\frac{x^HAx}{x^HBx}$$<br>　　　　其中x为非零向量，而A,B为n×n的Hermitan矩阵。B为正定矩阵。它的最大值和最小值是什么呢？其实我们只要通过将其通过标准化就可以转化为瑞利商的格式。我们令$x′=B^{−1/2}x$,则分母转化为：<br>$$x^HBx=x′^H(B^{−1/2})^HBB^{−1/2}x′=x′^HB^{−1/2}BB^{−1/2}x′=x′^Hx′$$<br>　　　　而分子转化为：<br>$$x^HAx=x′^HB^{−1/2}AB^{−1/2}x′$$<br>　　　　此时我们的$R(A,B,x)$转化为$R(A,B,x′)$:<br>$$R(A,B,x′)=\frac{x′^HB^{−1/2}AB^{−1/2}x′}{x′^Hx′}$$<br>　　　　利用前面的瑞利商的性质，我们可以很快的知道，$R(A,B,x)$的最大值为矩阵$B^{−1/2}AB^{−1/2}$的最大特征值，或者说矩阵$B^{−1}A$的最大特征值，而最小值为矩阵$B^{−1}A$的最小特征值。这里使用了一个的技巧，即对矩阵进行标准化。</p>
<ol>
<li>二类LDA原理</li>
</ol>
<p>　　　　现在我们回到LDA的原理上，我们在第一节说讲到了LDA希望投影后希望同一种类别数据的投影点尽可能的接近，而不同类别的数据的类别中心之间的距离尽可能的大，但是这只是一个感官的度量。现在我们首先从比较简单的二类LDA入手，严谨的分析LDA的原理。</p>
<p>　　　　假设我们的数据集$D={(x_1,y_1),(x_2,y_2),\cdots,((x_m,y_m))}$,其中任意样本$x_i$为n维向量，$y_i\in{0,1}$。我们定义$N_j(j=0,1)$为第j类样本的个数，$X_j(j=0,1)$为第j类样本的集合，而$μ_j(j=0,1)$为第j类样本的均值向量，定义$Σ_j(j=0,1)$为第j类样本的协方差矩阵。</p>
<p>　　　　$μ_j$的表达式为：<br>$$μ_j=\frac{1}{N_j}\sum_{x\in{X_j}}x(j=0,1)$$<br>　　　　$∑_j$的表达式为：<br>$$∑_j=\sum_{x\in{Xj}}(x−μ_j)(x−μ_j)^T(j=0,1)$$<br>　　　　由于是两类数据，因此我们只需要将数据投影到一条直线上即可。假设我们的投影直线是向量w,则对任意一个样本本$x_i$,它在直线w的投影为$w^Tx_i$,对于我们的两个类别的中心点$μ_0,μ_1$,在在直线w的投影为$w^Tμ_0$和$w^Tμ_1$。由于LDA需要让不同类别的数据的类别中心之间的距离尽可能的大，也就是我们要最大化$||w^Tμ_0−w^Tμ_1||^2_2$,同时我们希望同一种类别数据的投影点尽可能的接近，也就是要同类样本投影点的协方差$w^T\sum_0w$和$w^T\sum_1w$尽可能的小，即最小化$w^T\sum_0w+w^T\sum_1w$。综上所述，我们的优化目标为：<br>$$\underbrace{arg\ max}_w\ J(w)=\frac{||w^Tμ_0−w^Tμ_1||^2_2}{w^T\sum_0w+w^T\sum_1w}=\frac{w^T(μ_0−μ_1)(μ_0−μ_1)^Tw}{w^T(\sum_0+\sum_1)w}$$<br>　　　　我们一般定义类内散度矩阵$S_w$为：<br>$$S_w=∑_0+∑_1=\sum_{x\in{X0}}(x−μ0)(x−μ0)^T+\sum_{x\in{X1}}(x−μ1)(x−μ1)^T$$<br>　　　　同时定义类间散度矩阵$S_b$为：<br>$$S_b=(μ_0−μ_1)(μ_0−μ_1)^T$$<br>　　　　这样我们的优化目标重写为：<br>$$\underbrace{arg\ max}_w\ J(w)=\frac{w^TS_bw}{w^TS_ww}$$<br>　　　　仔细一看上式，这不就是我们的广义瑞利商嘛！这就简单了，利用我们第二节讲到的广义瑞利商的性质，我们知道我们的$J(w)$最大值为矩阵$S^{−1}_wS_b$的最大特征值，而对应的$w$为$S^{−1}_wS_b$的最大特征值对应的特征向量!</p>
<p>　　　　注意到对于二类的时候，$S_bw$的方向恒为$μ_0−μ_1$,不妨令$S_bw=\lambda (μ_0−μ_1)$，将其带入：$(S^{−1}_wS_b)w=λw$，可以得到$w=S^{−1}_w(μ_0−μ_1)$， 也就是说我们只要求出原始二类样本的均值和方差就可以确定最佳的投影方向$w$了。</p>
<ol>
<li>多类LDA原理</li>
</ol>
<p>　　　　有了二类LDA的基础，我们再来看看多类别LDA的原理。</p>
<p>　　　　假设我们的数据集$D={(x_1,y_1),(x_2,y_2),\cdots,((x_m,y_m))}$,其中任意样本$x_i$为n维向量，$y_i\in{C_1,C_2,\cdots,C_k}$。我们定义$N_j(j=1,2\cdots k)$为第j类样本的个数，$X_j(j=1,2\cdots k)$为第j类样本的集合，而$μ_j(j=1,2\cdots k)$为第j类样本的均值向量，定义$Σ_j(j=1,2\cdots k)$为第j类样本的协方差矩阵。在二类LDA里面定义的公式可以很容易的类推到多类LDA。</p>
<p>　　　　由于我们是多类向低维投影，则此时投影到的低维空间就不是一条直线，而是一个超平面了。假设我们投影到的低维空间的维度为d，对应的基向量为$(w_1,w_2,\cdots w_d)$，基向量组成的矩阵为$W$, 它是一个$m×d$的矩阵。</p>
<p>　　　　此时我们的优化目标应该可以变成为:<br>$$\frac{W^TS_bW}{W^TS_wW}$$<br>　　　　其中$Sb=\sum_{j=1}^kN_j(μ_j−μ)(μ_j−μ)^T$,μ为所有样本均值向量。$S_w=\sum_{j=1}^kS_{wj}=\sum_{j=1}^k\sum_{x\in{X_j}}(x−μ_j)(x−μ_j)^T$<br>　　　　但是有一个问题，就是$W^TS_bW$和$W^TS_wW$都是矩阵，不是标量，无法作为一个标量函数来优化！也就是说，我们无法直接用二类LDA的优化方法，怎么办呢？一般来说，我们可以用其他的一些替代优化目标来实现。</p>
<p>　　　　常见的一个LDA多类优化目标函数定义为：<br>$$\underbrace{arg\ max}_W\ J(W)=\frac{\prod_{diag}W^TS_bW}{\prod_{diag}W^TS_wW}$$<br>　　　　其中$\prod_{diag}A$为A的主对角线元素的乘积，$W$为$m×d$的矩阵。</p>
<p> 　　　　$J(W)$的优化过程可以转化为：<br>$$J(W)=\frac{\prod_{i=1}^dw^T_iS_bw_i}{\prod_{i=1}^dw^T_iS_ww_i}=\prod_{i=1}^d\frac{w^T_iS_bw_i}{w^T_iS_ww_i}$$<br>　　　　仔细观察上式最右边，这不就是广义瑞利商嘛！最大值是矩阵$S^{−1}_wS_b$的最大特征值,最大的d个值的乘积就是矩阵$S^{−1}_wS_b$的最大的d个特征值的乘积,此时对应的矩阵$W$为这最大的d个特征值对应的特征向量张成的矩阵。</p>
<p>　　　　由于W是一个利用了样本的类别得到的投影矩阵，因此它的降维到的维度d最大值为k-1。为什么最大维度不是类别数k呢？因为$S_b$中每个$μ_j−μ$的秩为1，因此协方差矩阵相加后最大的秩为k(矩阵的秩小于等于各个相加矩阵的秩的和)，但是由于如果我们知道前k-1个$μ_j$后，最后一个$μ_k$可以由前k-1个$μ_j$线性表示，因此$S_b$的秩最大为k-1，即特征向量最多有k-1个。</p>
<ol>
<li>LDA算法流程</li>
</ol>
<p>　　　　在第三节和第四节我们讲述了LDA的原理，现在我们对LDA降维的流程做一个总结。</p>
<p>　　　　输入：数据集$D={(x_1,y_1),(x_2,y_2),\cdots,((x_m,y_m))}$,其中任意样本$x_i$为n维向量，$y_i\in{C_1,C_2,\cdots,C_k}$，降维到的维度d。</p>
<p>　　　　输出：降维后的样本集 $D′$</p>
<p>　　　　1) 计算类内散度矩阵$S_w$</p>
<p>　　　　2) 计算类间散度矩阵$S_b$</p>
<p>　　　　3) 计算矩阵$S^{−1}_wS_b$</p>
<p>　　　　4）计算$S^{−1}_wS_b$的最大的d个特征值和对应的d个特征向量$(w_1,w_2,\cdots w_d)$,得到投影矩阵$W$</p>
<p>　　　　5) 对样本集中的每一个样本特征$x_i$,转化为新的样本$z_i=W^Tx_i$<br>　　　　6) 得到输出样本集$D′={(z_1,y_1),(z_2,y_2),\cdots,((z_m,y_m))}$</p>
<p>　　　　以上就是使用LDA进行降维的算法流程。实际上LDA除了可以用于降维以外，还可以用于分类。一个常见的LDA分类基本思想是假设各个类别的样本数据符合高斯分布，这样利用LDA进行投影后，可以利用极大似然估计计算各个类别投影数据的均值和方差，进而得到该类别高斯分布的概率密度函数。当一个新的样本到来后，我们可以将它投影，然后将投影后的样本特征分别带入各个类别的高斯分布概率密度函数，计算它属于这个类别的概率，最大的概率对应的类别即为预测类别。</p>
<p>　　　　由于LDA应用于分类现在似乎也不是那么流行，这里我就不多讲了。</p>
<ol>
<li>LDA vs PCA</li>
</ol>
<p>　　　　LDA用于降维，和PCA有很多相同，也有很多不同的地方，因此值得好好的比较一下两者的降维异同点。</p>
<p>　　　　首先我们看看相同点：</p>
<p>　　　　1）两者均可以对数据进行降维。</p>
<p>　　　　2）两者在降维时均使用了矩阵特征分解的思想。</p>
<p>　　　　3）两者都假设数据符合高斯分布。</p>
<p>　　　　我们接着看看不同点：</p>
<p>　　　　1）LDA是有监督的降维方法，而PCA是无监督的降维方法</p>
<p>　　　　2）LDA降维最多降到类别数k-1的维数，而PCA没有这个限制。</p>
<p>　　　　3）LDA除了可以用于降维，还可以用于分类。</p>
<p>　　　　4）LDA选择分类性能最好的投影方向，而PCA选择样本点投影具有最大方差的方向。</p>
<p>　　　　这点可以从下图形象的看出，在某些数据分布下LDA比PCA降维较优。
　　　　</p>
<center><br><img src="http://oq5d32gij.bkt.clouddn.com/14958087681939.jpg" alt=""><br></center>

<p>　　　　当然，某些某些数据分布下PCA比LDA降维较优，如下图所示：
　　　　</p>
<center><br><img src="http://oq5d32gij.bkt.clouddn.com/14958087756706.jpg" alt=""><br></center>

<ol>
<li>LDA算法小结</li>
</ol>
<p>　　　　LDA算法既可以用来降维，又可以用来分类，但是目前来说，主要还是用于降维。在我们进行图像识别图像识别相关的数据分析时，LDA是一个有力的工具。下面总结下LDA算法的优缺点。</p>
<p>　　　　LDA算法的主要优点有：</p>
<p>　　　　1）在降维过程中可以使用类别的先验知识经验，而像PCA这样的无监督学习则无法使用类别先验知识。</p>
<p>　　　　2）LDA在样本分类信息依赖均值而不是方差的时候，比PCA之类的算法较优。</p>
<p>　　　　LDA算法的主要缺点有：</p>
<p>　　　　1）LDA不适合对非高斯分布样本进行降维，PCA也有这个问题。</p>
<p>　　　　2）LDA降维最多降到类别数k-1的维数，如果我们降维的维度大于k-1，则不能使用LDA。当然目前有一些LDA的进化版算法可以绕过这个问题。</p>
<p>　　　　3）LDA在样本分类信息依赖方差而不是均值的时候，降维效果不好。</p>
<p>　　　　4）LDA可能过度拟合数据。</p>
]]></content>
      
        <categories>
            
            <category> machine learning </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LDA </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS UICollectionView自定义cell]]></title>
      <url>/2017/05/19/uicell/</url>
      <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p>自定义的UITableCell<br><a id="more"></a></p>
<pre><code class="mm">//
//  jokeCell.m
//  MyLaugh
//
//  Created by wangyu on 14/05/2017.
//  Copyright © 2017 wangyu. All rights reserved.
//

#import &quot;jokeCell.h&quot;
#define SCREEN_WIDTH [UIScreen mainScreen].bounds.size.width

@implementation jokeCell
{
    UILabel *_titleLabel;
    UILabel *_contentLabel;
    UILabel *_updatetimeLabel;
}

-(instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier
{
    self = [super initWithStyle:style reuseIdentifier:reuseIdentifier];
    _titleLabel = [[UILabel alloc]initWithFrame:CGRectMake(0,5,SCREEN_WIDTH,21)];
    _titleLabel.backgroundColor = [UIColor clearColor];
    _titleLabel.textAlignment = NSTextAlignmentCenter;
    _titleLabel.textColor = [UIColor purpleColor];
    _titleLabel.font = [UIFont italicSystemFontOfSize:17];
    _contentLabel = [[UILabel alloc]initWithFrame:CGRectMake(0, 30, SCREEN_WIDTH, 21)];
    _contentLabel.backgroundColor = [UIColor clearColor];
    _contentLabel.numberOfLines = 0;
    _updatetimeLabel = [[UILabel alloc]initWithFrame:CGRectMake(0, 30, SCREEN_WIDTH, 21)];
    _updatetimeLabel.textAlignment = NSTextAlignmentRight;
    self.selectionStyle = UITableViewCellSelectionStyleNone;
    return self;
}


- (void)layoutSubviews{
    [super layoutSubviews];
    [self.contentView addSubview:_titleLabel];
    [self.contentView addSubview:_contentLabel];
    [self.contentView addSubview:_updatetimeLabel];
}

-(void) setTitle:(NSString *)title
{
    _title = title;
    _titleLabel.text = title;
}

-(void) setContent:(NSString *)content
{
    _content = content;
    _contentLabel.text = content;
}

-(void)setUpdatetime:(NSString *)updatetime
{
    _updatetime = updatetime;
    _updatetimeLabel.text = updatetime;
}

-(void) setContentLabelHeight:(CGFloat)height
{
    _contentLabel.frame = CGRectMake(0, 30, _contentLabel.frame.size.width, height);
    _updatetimeLabel.frame = CGRectMake(0, 35+height, _updatetimeLabel.frame.size.width, 21);
}

-(CGFloat) getHeight
{
    //计算文字高度
    NSDictionary *attribute = @{NSFontAttributeName: _contentLabel.font};
    CGSize retSize = [_contentLabel.text boundingRectWithSize:CGSizeMake(SCREEN_WIDTH, MAXFLOAT) options:NSStringDrawingTruncatesLastVisibleLine|NSStringDrawingUsesLineFragmentOrigin|NSStringDrawingUsesFontLeading attributes:attribute context:nil].size;
    _contentLabel.frame = CGRectMake(0, 30, _contentLabel.frame.size.width, retSize.height);
    _updatetimeLabel.frame = CGRectMake(0, 35+_contentLabel.frame.size.height, _updatetimeLabel.frame.size.width, 21);
    return 30+_contentLabel.frame.size.height+10+21+5;
}

- (void)awakeFromNib {
    [super awakeFromNib];
    // Initialization code
}

- (void)setSelected:(BOOL)selected animated:(BOOL)animated {
    [super setSelected:selected animated:animated];

    // Configure the view for the selected state
}

@end
</code></pre>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ios </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MathJax]]></title>
      <url>/2017/05/18/math/</url>
      <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p>对LaTex基本用法的学习<br><a id="more"></a><br>$$T = \{(\vec{x_1},y_1),((\vec{x_2},y_2),\cdots,(\vec{x_N},y_N)\},\vec{x_i} $$</p>
<h2 id="常用数学符号的-LaTeX-表示方法"><a href="#常用数学符号的-LaTeX-表示方法" class="headerlink" title="常用数学符号的 LaTeX 表示方法"></a>常用数学符号的 LaTeX 表示方法</h2><p>１、指数和下标可以用 ^ 和 _ 后加相应字符来实现。比如：</p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/foot.gif" alt="foot"></p>
<p>2、平方根（square root）的输入命令为：\sqrt，n 次方根相应地为: \sqrt[n]。方根符号的大小由LATEX自动加以调整。也可用\surd 仅给出<br>符号。比如：</p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/sqrt.gif" alt="sqrt"></p>
<p>3、命令\overline 和\underline 在表达式的上、下方画出水平线。比如：</p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/overline.gif" alt="overline"></p>
<p>4、命令\overbrace 和\underbrace 在表达式的上、下方给出一水平的大括号。</p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/brace.gif" alt="brace"></p>
<p>5、向量（Vectors）通常用上方有小箭头（arrow symbols）的变量表示。这可由\vec 得到。另两个命令\overrightarrow 和\overleftarrow在定义从A 到B 的向量时非常有用。</p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/vec.gif" alt="ve"></p>
<p>6、分数（fraction）使用\frac{…}{…} 排版。一般来说，1/2 这种形式更受欢迎，因为对于少量的分式，它看起来更好些。</p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/frac.gif" alt="fra"></p>
<p>7、积分运算符（integral operator）用\int 来生成。求和运算符（sum operator）由\sum 生成。乘积运算符（product operator）由\prod 生成。上限和下限用^ 和_来生成，类似于上标和下标。</p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/int.gif" alt="int"></p>
<p>###以下提供一些常用符号的表示方法</p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/1.gif" alt="1"></p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/2.gif" alt="2"></p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/3.gif" alt="3"></p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/4.gif" alt="4"></p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/5.gif" alt="5"></p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/6.gif" alt="6"></p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/7.gif" alt="7"></p>
<p>大家都喜欢用 $E=mc^2$ 举例子，但是我不是很理解。  </p>
<p>这个公式 $\cos 2\theta = \cos^2 \theta - \sin^2 \theta =  2 \cos^2 \theta - 1$ 少年可还记得？</p>
<p>插入方程组（注意多行公式结尾\\\需要打成\\\，可能是因为markdown会自动转义第一个\\）：</p>
<p>\begin{aligned}<br>\dot{x} &amp; = \sigma(y-x) \\\<br>\dot{y} &amp; = \rho x - y - xz \\\<br>\dot{z} &amp; = -\beta z + xy<br>\end{aligned}</p>
<p>插入矩阵（同上）：</p>
<p>\begin{bmatrix}<br>1 &amp; 2\\\<br>3 &amp; 4<br>\end{bmatrix}</p>
<p>来个复杂点的（注意有的公式开头不会自动识别，用$ $包围）：</p>
<p>$$\frac{\partial u}{\partial t}= h^2\left( \frac{\partial^2u}{\partial x^2}+ \frac{\partial^2 u}{\partial y^2}+\frac{\partial^2 u}{\partial z^2}\right)$$</p>
<p>最后来个牛逼的吧，薛定谔方程，大学物理就记得这个了：</p>
<p>$$ i\hbar\frac{\partial \psi}{\partial t}= \frac{-\hbar^2}{2m} \left(\frac{\partial^2}{\partial x^2}+ \frac{\partial^2}{\partial y^2}+ \frac{\partial^2}{\partial z^2}\right) \psi + V \psi.$$</p>
<p>$$\begin{cases}\int\Omega \nabla \mathbf{F}&amp;=\int\Gamma \mathbf{F}\cdot d\mathbf{S} \<br>u&amp;=g_0,\quad \Gamma_D \<br>\partial_n u&amp;=g_1 ,\quad \Gamma_N<br>\end{cases} $$</p>
<p>$$\underbrace{a+b+\cdots+z}_{26}$$</p>
]]></content>
      
        <categories>
            
            <category> machine learning </category>
            
        </categories>
        
        
        <tags>
            
            <tag> math </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
