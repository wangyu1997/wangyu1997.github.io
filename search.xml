<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Java8中的streams API详解]]></title>
      <url>/2017/11/08/JAVA/Java8%E4%B8%AD%E7%9A%84Streams%20API/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p>Streams 的背景，以及 Java 8 中的使用详解 </p>
<h2 id="为什么需要-Stream"><a href="#为什么需要-Stream" class="headerlink" title="为什么需要 Stream"></a>为什么需要 Stream</h2><p>Stream 作为 Java 8 的一大亮点，它与 java.io 包里的 InputStream 和 OutputStream 是完全不同的概念。它也不同于 StAX 对 XML 解析的 Stream，也不是 Amazon Kinesis 对大数据实时处理的 Stream。Java 8 中的 Stream 是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation），或者大批量数据操作 (bulk data operation)。Stream API 借助于同样新出现的 Lambda 表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork/join 并行方式来拆分任务和加速处理过程。通常编写并行代码很难而且容易出错, 但使用 Stream API 无需编写一行多线程的代码，就可以很方便地写出高性能的并发程序。所以说，Java 8 中首次出现的 java.util.stream 是一个函数式语言+多核时代综合影响的产物。 </p>
<h3 id="什么是聚合操作"><a href="#什么是聚合操作" class="headerlink" title="什么是聚合操作"></a>什么是聚合操作</h3><p>在传统的 J2EE 应用中，Java 代码经常不得不依赖于关系型数据库的聚合操作来完成诸如： </p>
<ul>
<li>客户每月平均消费金额</li>
<li>最昂贵的在售商品</li>
<li>本周完成的有效订单（排除了无效的）</li>
<li>取十个数据样本作为首页推荐</li>
</ul>
<p>这类的操作。 </p>
<p>但在当今这个数据大爆炸的时代，在数据来源多样化、数据海量化的今天，很多时候不得不脱离 RDBMS，或者以底层返回的数据为基础进行更上层的数据统计。而 Java 的集合 API 中，仅仅有极少量的辅助型方法，更多的时候是程序员需要用 Iterator 来遍历集合，完成相关的聚合应用逻辑。这是一种远不够高效、笨拙的方法。在 Java 7 中，如果要发现 type 为 grocery 的所有交易，然后返回以交易值降序排序好的交易 ID 集合，我们需要这样写： </p>
<h5 id="清单-1-Java-7-的排序、取值实现"><a href="#清单-1-Java-7-的排序、取值实现" class="headerlink" title="清单 1. Java 7 的排序、取值实现"></a>清单 1. Java 7 的排序、取值实现</h5><pre><code>List&lt;Transaction&gt; groceryTransactions = new Arraylist&lt;&gt;();
for(Transaction t: transactions){
 if(t.getType() == Transaction.GROCERY){
 groceryTransactions.add(t);
 }
}
Collections.sort(groceryTransactions, new Comparator(){
 public int compare(Transaction t1, Transaction t2){
 return t2.getValue().compareTo(t1.getValue());
 }
});
List&lt;Integer&gt; transactionIds = new ArrayList&lt;&gt;();
for(Transaction t: groceryTransactions){
 transactionsIds.add(t.getId());
}
</code></pre><p>而在 Java 8 使用 Stream，代码更加简洁易读；而且使用并发模式，程序执行速度更快。 </p>
<h5 id="清单-2-Java-8-的排序、取值实现"><a href="#清单-2-Java-8-的排序、取值实现" class="headerlink" title="清单 2. Java 8 的排序、取值实现"></a>清单 2. Java 8 的排序、取值实现</h5><pre><code>List&lt;Integer&gt; transactionsIds = transactions.parallelStream().
 filter(t -&gt; t.getType() == Transaction.GROCERY).
 sorted(comparing(Transaction::getValue).reversed()).
 map(Transaction::getId).
 collect(toList());
</code></pre><h2 id="Stream-总览"><a href="#Stream-总览" class="headerlink" title="Stream 总览"></a>Stream 总览</h2><h3 id="什么是流"><a href="#什么是流" class="headerlink" title="什么是流"></a>什么是流</h3><p>Stream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的 Iterator。原始版本的 Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的 Stream，用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。 </p>
<p>Stream 就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。 </p>
<p>而和迭代器又不同的是，Stream 可以并行化操作，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方式去遍历时，每个 item 读完后再读下一个 item。而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。Stream 的并行操作依赖于 Java7 中引入的 Fork/Join 框架（JSR166y）来拆分任务和加速处理过程。Java 的并行 API 演变历程基本如下： </p>
<ol>
<li>1.0-1.4 中的 java.lang.Thread</li>
<li>5.0 中的 java.util.concurrent</li>
<li>6.0 中的 Phasers 等</li>
<li>7.0 中的 Fork/Join 框架</li>
<li>8.0 中的 Lambda</li>
</ol>
<p>Stream 的另外一大特点是，数据源本身可以是无限的。 </p>
<h3 id="流的构成"><a href="#流的构成" class="headerlink" title="流的构成"></a>流的构成</h3><p>当我们使用一个流的时候，通常包括三个基本步骤： </p>
<p>获取一个数据源（source）→ 数据转换→执行操作获取想要的结果，每次转换原有 Stream 对象不改变，返回一个新的 Stream 对象（可以有多次转换），这就允许对其操作可以像链条一样排列，变成一个管道，如下图所示。 </p>
<h5 id="图-1-流管道-Stream-Pipeline-的构成"><a href="#图-1-流管道-Stream-Pipeline-的构成" class="headerlink" title="图 1. 流管道 (Stream Pipeline) 的构成"></a>图 1. 流管道 (Stream Pipeline) 的构成</h5><p><img src="http://oq5d32gij.bkt.clouddn.com/15101508417650.png" alt=""></p>
<p>有多种方式生成 Stream Source： </p>
<ul>
<li>从 Collection 和数组</li>
<li><ul>
<li>Collection.stream()</li>
<li>Collection.parallelStream()</li>
<li>Arrays.stream(T array) or Stream.of()<br>从 BufferedReader</li>
<li>java.io.BufferedReader.lines()</li>
</ul>
</li>
<li>静态工厂</li>
<li>java.util.stream.IntStream.range()</li>
<li>java.nio.file.Files.walk()</li>
<li>自己构建</li>
<li><ul>
<li>java.util.Spliterator<br>其它</li>
<li>Random.ints()</li>
<li>BitSet.stream()</li>
<li>Pattern.splitAsStream(java.lang.CharSequence)</li>
<li>JarFile.stream()</li>
</ul>
</li>
</ul>
<p>流的操作类型分为两种： </p>
<ul>
<li><strong>Intermediate</strong>：一个流可以后面跟随零个或多个 intermediate 操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历。</li>
<li><strong>Terminal</strong>：一个流只能有一个 terminal 操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。Terminal 操作的执行，才会真正开始流的遍历，并且会生成一个结果，或者一个 side effect。</li>
</ul>
<p>在对于一个 Stream 进行多次转换操作 (Intermediate 操作)，每次都对 Stream 的每个元素进行转换，而且是执行多次，这样时间复杂度就是 N（转换次数）个 for 循环里把所有操作都做掉的总和吗？其实不是这样的，转换操作都是 lazy 的，多个转换操作只会在 Terminal 操作的时候融合起来，一次循环完成。我们可以这样简单的理解，Stream 里有个操作函数的集合，每次转换操作就是把转换函数放入这个集合中，在 Terminal 操作的时候循环 Stream 对应的集合，然后对每个元素执行所有的函数。 </p>
<p>还有一种操作被称为 <strong>short-circuiting</strong>。用以指： </p>
<ul>
<li>对于一个 intermediate 操作，如果它接受的是一个无限大（infinite/unbounded）的 Stream，但返回一个有限的新 Stream。</li>
<li>对于一个 terminal 操作，如果它接受的是一个无限大的 Stream，但能在有限的时间计算出结果。</li>
</ul>
<p>当操作一个无限大的 Stream，而又希望在有限时间内完成操作，则在管道内拥有一个 short-circuiting 操作是必要非充分条件。 </p>
<h5 id="清单-3-一个流操作的示例"><a href="#清单-3-一个流操作的示例" class="headerlink" title="清单 3. 一个流操作的示例"></a>清单 3. 一个流操作的示例</h5><pre><code>int sum = widgets.stream()
.filter(w -&gt; w.getColor() == RED)
 .mapToInt(w -&gt; w.getWeight())
 .sum();
</code></pre><p>stream() 获取当前小物件的 source，filter 和 mapToInt 为 intermediate 操作，进行数据筛选和转换，最后一个 sum() 为 terminal 操作，对符合条件的全部小物件作重量求和。 </p>
<h2 id="流的使用详解"><a href="#流的使用详解" class="headerlink" title="流的使用详解"></a>流的使用详解</h2><p>简单说，对 Stream 的使用就是实现一个 filter-map-reduce 过程，产生一个最终结果，或者导致一个副作用（side effect）。 </p>
<h3 id="流的构造与转换"><a href="#流的构造与转换" class="headerlink" title="流的构造与转换"></a>流的构造与转换</h3><p>下面提供最常见的几种构造 Stream 的样例。 </p>
<h5 id="清单-4-构造流的几种常见方法"><a href="#清单-4-构造流的几种常见方法" class="headerlink" title="清单 4. 构造流的几种常见方法"></a>清单 4. 构造流的几种常见方法</h5><pre><code>// 1. Individual values
Stream stream = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);
// 2. Arrays
String [] strArray = new String[] {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;};
stream = Stream.of(strArray);
stream = Arrays.stream(strArray);
// 3. Collections
List&lt;String&gt; list = Arrays.asList(strArray);
stream = list.stream();
</code></pre><p>需要注意的是，对于基本数值型，目前有三种对应的包装类型 Stream： </p>
<p>IntStream、LongStream、DoubleStream。当然我们也可以用 Stream<integer>、Stream<long> &gt;、Stream<double>，但是 boxing 和 unboxing 会很耗时，所以特别为这三种基本数值型提供了对应的 Stream。 </double></long></integer></p>
<p>Java 8 中还没有提供其它数值型 Stream，因为这将导致扩增的内容较多。而常规的数值型聚合运算可以通过上面三种 Stream 进行。 </p>
<h5 id="清单-5-数值流的构造"><a href="#清单-5-数值流的构造" class="headerlink" title="清单 5. 数值流的构造"></a>清单 5. 数值流的构造</h5><pre><code>IntStream.of(new int[]{1, 2, 3}).forEach(System.out::println);
IntStream.range(1, 3).forEach(System.out::println);
IntStream.rangeClosed(1, 3).forEach(System.out::println);
</code></pre><h5 id="清单-6-流转换为其它数据结构"><a href="#清单-6-流转换为其它数据结构" class="headerlink" title="清单 6. 流转换为其它数据结构"></a>清单 6. 流转换为其它数据结构</h5><pre><code>// 1. Array
String[] strArray1 = stream.toArray(String[]::new);
// 2. Collection
List&lt;String&gt; list1 = stream.collect(Collectors.toList());
List&lt;String&gt; list2 = stream.collect(Collectors.toCollection(ArrayList::new));
Set set1 = stream.collect(Collectors.toSet());
Stack stack1 = stream.collect(Collectors.toCollection(Stack::new));
// 3. String
String str = stream.collect(Collectors.joining()).toString();
</code></pre><p>一个 Stream 只可以使用一次，上面的代码为了简洁而重复使用了数次。 </p>
<h3 id="流的操作"><a href="#流的操作" class="headerlink" title="流的操作"></a>流的操作</h3><p>接下来，当把一个数据结构包装成 Stream 后，就要开始对里面的元素进行各类操作了。常见的操作可以归类如下。 </p>
<ul>
<li>Intermediate：</li>
</ul>
<p>map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、 skip、 parallel、 sequential、 unordered </p>
<ul>
<li>Terminal：</li>
</ul>
<p>forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、 anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 iterator </p>
<ul>
<li>Short-circuiting：</li>
</ul>
<p>anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 limit </p>
<p>我们下面看一下 Stream 的比较典型用法。 </p>
<p><strong>map/flatMap</strong></p>
<p>我们先来看 map。如果你熟悉 scala 这类函数式语言，对这个方法应该很了解，它的作用就是把 input Stream 的每一个元素，映射成 output Stream 的另外一个元素。 </p>
<h5 id="清单-7-转换大写"><a href="#清单-7-转换大写" class="headerlink" title="清单 7. 转换大写"></a>清单 7. 转换大写</h5><pre><code>List&lt;String&gt; output = wordList.stream().
map(String::toUpperCase).
collect(Collectors.toList());
</code></pre><p>这段代码把所有的单词转换为大写。 </p>
<h5 id="清单-8-平方数"><a href="#清单-8-平方数" class="headerlink" title="清单 8. 平方数"></a>清单 8. 平方数</h5><pre><code>List&lt;Integer&gt; nums = Arrays.asList(1, 2, 3, 4);
List&lt;Integer&gt; squareNums = nums.stream().
map(n -&gt; n * n).
collect(Collectors.toList());
</code></pre><p>这段代码生成一个整数 list 的平方数 {1, 4, 9, 16}。 </p>
<p>从上面例子可以看出，map 生成的是个 1:1 映射，每个输入元素，都按照规则转换成为另外一个元素。还有一些场景，是一对多映射关系的，这时需要 flatMap。 </p>
<h5 id="清单-9-一对多"><a href="#清单-9-一对多" class="headerlink" title="清单 9. 一对多"></a>清单 9. 一对多</h5><pre><code>Stream&lt;List&lt;Integer&gt;&gt; inputStream = Stream.of(
 Arrays.asList(1),
 Arrays.asList(2, 3),
 Arrays.asList(4, 5, 6)
 );
Stream&lt;Integer&gt; outputStream = inputStream.
flatMap((childList) -&gt; childList.stream());
</code></pre><p>flatMap 把 input Stream 中的层级结构扁平化，就是将最底层元素抽出来放到一起，最终 output 的新 Stream 里面已经没有 List 了，都是直接的数字。 </p>
<p><strong>filter</strong></p>
<p>filter 对原始 Stream 进行某项测试，通过测试的元素被留下来生成一个新 Stream。 </p>
<h5 id="清单-10-留下偶数"><a href="#清单-10-留下偶数" class="headerlink" title="清单 10. 留下偶数"></a>清单 10. 留下偶数</h5><pre><code>Integer[] sixNums = {1, 2, 3, 4, 5, 6};
Integer[] evens =
Stream.of(sixNums).filter(n -&gt; n%2 == 0).toArray(Integer[]::new);
</code></pre><p>经过条件“被 2 整除”的 filter，剩下的数字为 {2, 4, 6}。 </p>
<h5 id="清单-11-把单词挑出来"><a href="#清单-11-把单词挑出来" class="headerlink" title="清单 11. 把单词挑出来"></a>清单 11. 把单词挑出来</h5><pre><code>List&lt;String&gt; output = reader.lines().
 flatMap(line -&gt; Stream.of(line.split(REGEXP))).
 filter(word -&gt; word.length() &gt; 0).
 collect(Collectors.toList());
</code></pre><p>这段代码首先把每行的单词用 flatMap 整理到新的 Stream，然后保留长度不为 0 的，就是整篇文章中的全部单词了。 </p>
<p><strong>forEach</strong></p>
<p>forEach 方法接收一个 Lambda 表达式，然后在 Stream 的每一个元素上执行该表达式。 </p>
<h5 id="清单-12-打印姓名（forEach-和-pre-java8-的对比）"><a href="#清单-12-打印姓名（forEach-和-pre-java8-的对比）" class="headerlink" title="清单 12. 打印姓名（forEach 和 pre-java8 的对比）"></a>清单 12. 打印姓名（forEach 和 pre-java8 的对比）</h5><pre><code>// Java 8
roster.stream()
 .filter(p -&gt; p.getGender() == Person.Sex.MALE)
 .forEach(p -&gt; System.out.println(p.getName()));
// Pre-Java 8
for (Person p : roster) {
 if (p.getGender() == Person.Sex.MALE) {
 System.out.println(p.getName());
 }
}
</code></pre><p>对一个人员集合遍历，找出男性并打印姓名。可以看出来，forEach 是为 Lambda 而设计的，保持了最紧凑的风格。而且 Lambda 表达式本身是可以重用的，非常方便。当需要为多核系统优化时，可以 parallelStream().forEach()，只是此时原有元素的次序没法保证，并行的情况下将改变串行时操作的行为，此时 forEach 本身的实现不需要调整，而 Java8 以前的 for 循环 code 可能需要加入额外的多线程逻辑。 </p>
<p>但一般认为，forEach 和常规 for 循环的差异不涉及到性能，它们仅仅是函数式风格与传统 Java 风格的差别。 </p>
<p>另外一点需要注意，forEach 是 terminal 操作，因此它执行后，Stream 的元素就被“消费”掉了，你无法对一个 Stream 进行两次 terminal 运算。下面的代码是错误的： </p>
<pre><code>     stream.forEach(element -&gt; doOneThing(element));
     stream.forEach(element -&gt; doAnotherThing(element));
</code></pre><p>相反，具有相似功能的 intermediate 操作 peek 可以达到上述目的。如下是出现在该 api javadoc 上的一个示例。 </p>
<h5 id="清单-13-peek-对每个元素执行操作并返回一个新的-Stream"><a href="#清单-13-peek-对每个元素执行操作并返回一个新的-Stream" class="headerlink" title="清单 13. peek 对每个元素执行操作并返回一个新的 Stream"></a>清单 13. peek 对每个元素执行操作并返回一个新的 Stream</h5><pre><code>Stream.of(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;)
 .filter(e -&gt; e.length() &gt; 3)
 .peek(e -&gt; System.out.println(&quot;Filtered value: &quot; + e))
 .map(String::toUpperCase)
 .peek(e -&gt; System.out.println(&quot;Mapped value: &quot; + e))
 .collect(Collectors.toList());
</code></pre><p>forEach 不能修改自己包含的本地变量值，也不能用 break/return 之类的关键字提前结束循环。 </p>
<p><strong>findFirst</strong></p>
<p>这是一个 termimal 兼 short-circuiting 操作，它总是返回 Stream 的第一个元素，或者空。 </p>
<p>这里比较重点的是它的返回值类型：Optional。这也是一个模仿 Scala 语言中的概念，作为一个容器，它可能含有某值，或者不包含。使用它的目的是尽可能避免 NullPointerException。 </p>
<h5 id="清单-14-Optional-的两个用例"><a href="#清单-14-Optional-的两个用例" class="headerlink" title="清单 14. Optional 的两个用例"></a>清单 14. Optional 的两个用例</h5><pre><code>String strA = &quot; abcd &quot;, strB = null;
print(strA);
print(&quot;&quot;);
print(strB);
getLength(strA);
getLength(&quot;&quot;);
getLength(strB);
public static void print(String text) {
 // Java 8
 Optional.ofNullable(text).ifPresent(System.out::println);
 // Pre-Java 8
 if (text != null) {
 System.out.println(text);
 }
 }
public static int getLength(String text) {
 // Java 8
return Optional.ofNullable(text).map(String::length).orElse(-1);
 // Pre-Java 8
// return if (text != null) ? text.length() : -1;
 };
</code></pre><p>在更复杂的 if (xx != null) 的情况中，使用 Optional 代码的可读性更好，而且它提供的是编译时检查，能极大的降低 NPE 这种 Runtime Exception 对程序的影响，或者迫使程序员更早的在编码阶段处理空值问题，而不是留到运行时再发现和调试。 </p>
<p>Stream 中的 findAny、max/min、reduce 等方法等返回 Optional 值。还有例如 IntStream.average() 返回 OptionalDouble 等等。 </p>
<p><strong>reduce</strong></p>
<p>这个方法的主要作用是把 Stream 元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合。从这个意义上说，字符串拼接、数值的 sum、min、max、average 都是特殊的 reduce。例如 Stream 的 sum 就相当于 </p>
<p>Integer sum = integers.reduce(0, (a, b) -&gt; a+b); 或 </p>
<p>Integer sum = integers.reduce(0, Integer::sum); </p>
<p>也有没有起始值的情况，这时会把 Stream 的前面两个元素组合起来，返回的是 Optional。 </p>
<h5 id="清单-15-reduce-的用例"><a href="#清单-15-reduce-的用例" class="headerlink" title="清单 15. reduce 的用例"></a>清单 15. reduce 的用例</h5><pre><code>// 字符串连接，concat = &quot;ABCD&quot;
String concat = Stream.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;).reduce(&quot;&quot;, String::concat); 
// 求最小值，minValue = -3.0
double minValue = Stream.of(-1.5, 1.0, -3.0, -2.0).reduce(Double.MAX_VALUE, Double::min); 
// 求和，sumValue = 10, 有起始值
int sumValue = Stream.of(1, 2, 3, 4).reduce(0, Integer::sum);
// 求和，sumValue = 10, 无起始值
sumValue = Stream.of(1, 2, 3, 4).reduce(Integer::sum).get();
// 过滤，字符串连接，concat = &quot;ace&quot;
concat = Stream.of(&quot;a&quot;, &quot;B&quot;, &quot;c&quot;, &quot;D&quot;, &quot;e&quot;, &quot;F&quot;).
 filter(x -&gt; x.compareTo(&quot;Z&quot;) &gt; 0).
 reduce(&quot;&quot;, String::concat);
</code></pre><p>上面代码例如第一个示例的 reduce()，第一个参数（空白字符）即为起始值，第二个参数（String::concat）为 BinaryOperator。这类有起始值的 reduce() 都返回具体的对象。而对于第四个示例没有起始值的 reduce()，由于可能没有足够的元素，返回的是 Optional，请留意这个区别。 </p>
<p><strong>limit/skip</strong></p>
<p>limit 返回 Stream 的前面 n 个元素；skip 则是扔掉前 n 个元素（它是由一个叫 subStream 的方法改名而来）。 </p>
<h5 id="清单-16-limit-和-skip-对运行次数的影响"><a href="#清单-16-limit-和-skip-对运行次数的影响" class="headerlink" title="清单 16. limit 和 skip 对运行次数的影响"></a>清单 16. limit 和 skip 对运行次数的影响</h5><pre><code>public void testLimitAndSkip() {
 List&lt;Person&gt; persons = new ArrayList();
 for (int i = 1; i &lt;= 10000; i++) {
 Person person = new Person(i, &quot;name&quot; + i);
 persons.add(person);
 }
List&lt;String&gt; personList2 = persons.stream().
map(Person::getName).limit(10).skip(3).collect(Collectors.toList());
 System.out.println(personList2);
}
private class Person {
 public int no;
 private String name;
 public Person (int no, String name) {
 this.no = no;
 this.name = name;
 }
 public String getName() {
 System.out.println(name);
 return name;
 }
}
</code></pre><p>输出结果为： </p>
<pre><code>name1
name2
name3
name4
name5
name6
name7
name8
name9
name10
[name4, name5, name6, name7, name8, name9, name10]
</code></pre><p>这是一个有 10，000 个元素的 Stream，但在 short-circuiting 操作 limit 和 skip 的作用下，管道中 map 操作指定的 getName() 方法的执行次数为 limit 所限定的 10 次，而最终返回结果在跳过前 3 个元素后只有后面 7 个返回。 </p>
<p>有一种情况是 limit/skip 无法达到 short-circuiting 目的的，就是把它们放在 Stream 的排序操作后，原因跟 sorted 这个 intermediate 操作有关：此时系统并不知道 Stream 排序后的次序如何，所以 sorted 中的操作看上去就像完全没有被 limit 或者 skip 一样。 </p>
<h5 id="清单-17-limit-和-skip-对-sorted-后的运行次数无影响"><a href="#清单-17-limit-和-skip-对-sorted-后的运行次数无影响" class="headerlink" title="清单 17. limit 和 skip 对 sorted 后的运行次数无影响"></a>清单 17. limit 和 skip 对 sorted 后的运行次数无影响</h5><pre><code>List&lt;Person&gt; persons = new ArrayList();
 for (int i = 1; i &lt;= 5; i++) {
 Person person = new Person(i, &quot;name&quot; + i);
 persons.add(person);
 }
List&lt;Person&gt; personList2 = persons.stream().sorted((p1, p2) -&gt; 
p1.getName().compareTo(p2.getName())).limit(2).collect(Collectors.toList());
System.out.println(personList2);
</code></pre><p>上面的示例对清单 13 做了微调，首先对 5 个元素的 Stream 排序，然后进行 limit 操作。输出结果为： </p>
<pre><code> name2
name1
name3
name2
name4
name3
name5
name4
[stream.StreamDW$Person@816f27d, stream.StreamDW$Person@87aac27]
</code></pre><p>即虽然最后的返回元素数量是 2，但整个管道中的 sorted 表达式执行次数没有像前面例子相应减少。 </p>
<p>最后有一点需要注意的是，对一个 parallel 的 Steam 管道来说，如果其元素是有序的，那么 limit 操作的成本会比较大，因为它的返回对象必须是前 n 个也有一样次序的元素。取而代之的策略是取消元素间的次序，或者不要用 parallel Stream。 </p>
<p><strong>sorted</strong></p>
<p>对 Stream 的排序通过 sorted 进行，它比数组的排序更强之处在于你可以首先对 Stream 进行各类 map、filter、limit、skip 甚至 distinct 来减少元素数量后，再排序，这能帮助程序明显缩短执行时间。我们对清单 14 进行优化： </p>
<h5 id="清单-18-优化：排序前进行-limit-和-skip"><a href="#清单-18-优化：排序前进行-limit-和-skip" class="headerlink" title="清单 18. 优化：排序前进行 limit 和 skip"></a>清单 18. 优化：排序前进行 limit 和 skip</h5><pre><code>List&lt;Person&gt; persons = new ArrayList();
 for (int i = 1; i &lt;= 5; i++) {
 Person person = new Person(i, &quot;name&quot; + i);
 persons.add(person);
 }
List&lt;Person&gt; personList2 = persons.stream().limit(2).sorted((p1, p2) -&gt; p1.getName().compareTo(p2.getName())).collect(Collectors.toList());
System.out.println(personList2);
</code></pre><p>结果会简单很多： </p>
<pre><code>name2
name1
[stream.StreamDW$Person@6ce253f1, stream.StreamDW$Person@53d8d10a]
</code></pre><p>当然，这种优化是有 business logic 上的局限性的：即不要求排序后再取值。 </p>
<p><strong>min/max/distinct</strong></p>
<p>min 和 max 的功能也可以通过对 Stream 元素先排序，再 findFirst 来实现，但前者的性能会更好，为 O(n)，而 sorted 的成本是 O(n log n)。同时它们作为特殊的 reduce 方法被独立出来也是因为求最大最小值是很常见的操作。 </p>
<h5 id="清单-19-找出最长一行的长度"><a href="#清单-19-找出最长一行的长度" class="headerlink" title="清单 19. 找出最长一行的长度"></a>清单 19. 找出最长一行的长度</h5><pre><code>BufferedReader br = new BufferedReader(new FileReader(&quot;c:\\SUService.log&quot;));
int longest = br.lines().
 mapToInt(String::length).
 max().
 getAsInt();
br.close();
System.out.println(longest);
</code></pre><p>下面的例子则使用 distinct 来找出不重复的单词。 </p>
<h5 id="清单-20-找出全文的单词，转小写，并排序"><a href="#清单-20-找出全文的单词，转小写，并排序" class="headerlink" title="清单 20. 找出全文的单词，转小写，并排序"></a>清单 20. 找出全文的单词，转小写，并排序</h5><pre><code>List&lt;String&gt; words = br.lines().
 flatMap(line -&gt; Stream.of(line.split(&quot; &quot;))).
 filter(word -&gt; word.length() &gt; 0).
 map(String::toLowerCase).
 distinct().
 sorted().
 collect(Collectors.toList());
br.close();
System.out.println(words);
</code></pre><p><strong>Match</strong></p>
<p>Stream 有三个 match 方法，从语义上说： </p>
<ul>
<li>allMatch：Stream 中全部元素符合传入的 predicate，返回 true</li>
<li>anyMatch：Stream 中只要有一个元素符合传入的 predicate，返回 true</li>
<li>noneMatch：Stream 中没有一个元素符合传入的 predicate，返回 true</li>
</ul>
<p>它们都不是要遍历全部元素才能返回结果。例如 allMatch 只要一个元素不满足条件，就 skip 剩下的所有元素，返回 false。对清单 13 中的 Person 类稍做修改，加入一个 age 属性和 getAge 方法。 </p>
<h5 id="清单-21-使用-Match"><a href="#清单-21-使用-Match" class="headerlink" title="清单 21. 使用 Match"></a>清单 21. 使用 Match</h5><pre><code>List&lt;Person&gt; persons = new ArrayList();
persons.add(new Person(1, &quot;name&quot; + 1, 10));
persons.add(new Person(2, &quot;name&quot; + 2, 21));
persons.add(new Person(3, &quot;name&quot; + 3, 34));
persons.add(new Person(4, &quot;name&quot; + 4, 6));
persons.add(new Person(5, &quot;name&quot; + 5, 55));
boolean isAllAdult = persons.stream().
 allMatch(p -&gt; p.getAge() &gt; 18);
System.out.println(&quot;All are adult? &quot; + isAllAdult);
boolean isThereAnyChild = persons.stream().
 anyMatch(p -&gt; p.getAge() &lt; 12);
System.out.println(&quot;Any child? &quot; + isThereAnyChild);
</code></pre><p>输出结果： </p>
<pre><code> All are adult? false
 Any child? true
</code></pre><h3 id="进阶：自己生成流"><a href="#进阶：自己生成流" class="headerlink" title="进阶：自己生成流"></a>进阶：自己生成流</h3><p><strong>Stream.generate</strong></p>
<p>通过实现 Supplier 接口，你可以自己来控制流的生成。这种情形通常用于随机数、常量的 Stream，或者需要前后元素间维持着某种状态信息的 Stream。把 Supplier 实例传递给 Stream.generate() 生成的 Stream，默认是串行（相对 parallel 而言）但无序的（相对 ordered 而言）。由于它是无限的，在管道中，必须利用 limit 之类的操作限制 Stream 大小。 </p>
<h5 id="清单-22-生成-10-个随机整数"><a href="#清单-22-生成-10-个随机整数" class="headerlink" title="清单 22. 生成 10 个随机整数"></a>清单 22. 生成 10 个随机整数</h5><pre><code>Random seed = new Random();
Supplier&lt;Integer&gt; random = seed::nextInt;
Stream.generate(random).limit(10).forEach(System.out::println);
//Another way
IntStream.generate(() -&gt; (int) (System.nanoTime() % 100)).
limit(10).forEach(System.out::println);
</code></pre><p>Stream.generate() 还接受自己实现的 Supplier。例如在构造海量测试数据的时候，用某种自动的规则给每一个变量赋值；或者依据公式计算 Stream 的每个元素值。这些都是维持状态信息的情形。 </p>
<h5 id="清单-23-自实现-Supplier"><a href="#清单-23-自实现-Supplier" class="headerlink" title="清单 23. 自实现 Supplier"></a>清单 23. 自实现 Supplier</h5><pre><code>Stream.generate(new PersonSupplier()).
limit(10).
forEach(p -&gt; System.out.println(p.getName() + &quot;, &quot; + p.getAge()));
private class PersonSupplier implements Supplier&lt;Person&gt; {
 private int index = 0;
 private Random random = new Random();
 @Override
 public Person get() {
 return new Person(index++, &quot;StormTestUser&quot; + index, random.nextInt(100));
 }
}
</code></pre><p>输出结果： </p>
<pre><code> StormTestUser1, 9
StormTestUser2, 12
StormTestUser3, 88
StormTestUser4, 51
StormTestUser5, 22
StormTestUser6, 28
StormTestUser7, 81
StormTestUser8, 51
StormTestUser9, 4
StormTestUser10, 76
</code></pre><p><strong>Stream.iterate</strong></p>
<p>iterate 跟 reduce 操作很像，接受一个种子值，和一个 UnaryOperator（例如 f）。然后种子值成为 Stream 的第一个元素，f(seed) 为第二个，f(f(seed)) 第三个，以此类推。 </p>
<p><strong>清单 24. 生成一个等差数列</strong></p>
<pre><code>     Stream.iterate(0, n -&gt; n + 3).limit(10). forEach(x -&gt; System.out.print(x + &quot; &quot;));.
</code></pre><p>输出结果： </p>
<pre><code>     0 3 6 9 12 15 18 21 24 27
</code></pre><p>与 Stream.generate 相仿，在 iterate 时候管道必须有 limit 这样的操作来限制 Stream 大小。 </p>
<h3 id="进阶：用-Collectors-来进行-reduction-操作"><a href="#进阶：用-Collectors-来进行-reduction-操作" class="headerlink" title="进阶：用 Collectors 来进行 reduction 操作"></a>进阶：用 Collectors 来进行 reduction 操作</h3><p>java.util.stream.Collectors 类的主要作用就是辅助进行各类有用的 reduction 操作，例如转变输出为 Collection，把 Stream 元素进行归组。 </p>
<p><strong>groupingBy/partitioningBy</strong></p>
<h5 id="清单-25-按照年龄归组"><a href="#清单-25-按照年龄归组" class="headerlink" title="清单 25. 按照年龄归组"></a>清单 25. 按照年龄归组</h5><pre><code>Map&lt;Integer, List&lt;Person&gt;&gt; personGroups = Stream.generate(new PersonSupplier()).
 limit(100).
 collect(Collectors.groupingBy(Person::getAge));
Iterator it = personGroups.entrySet().iterator();
while (it.hasNext()) {
 Map.Entry&lt;Integer, List&lt;Person&gt;&gt; persons = (Map.Entry) it.next();
 System.out.println(&quot;Age &quot; + persons.getKey() + &quot; = &quot; + persons.getValue().size());
}
</code></pre><p>上面的 code，首先生成 100 人的信息，然后按照年龄归组，相同年龄的人放到同一个 list 中，可以看到如下的输出： </p>
<pre><code>Age 0 = 2
Age 1 = 2
Age 5 = 2
Age 8 = 1
Age 9 = 1
Age 11 = 2
……
</code></pre><h5 id="清单-26-按照未成年人和成年人归组"><a href="#清单-26-按照未成年人和成年人归组" class="headerlink" title="清单 26. 按照未成年人和成年人归组"></a>清单 26. 按照未成年人和成年人归组</h5><pre><code>Map&lt;Boolean, List&lt;Person&gt;&gt; children = Stream.generate(new PersonSupplier()).
 limit(100).
 collect(Collectors.partitioningBy(p -&gt; p.getAge() &lt; 18));
System.out.println(&quot;Children number: &quot; + children.get(true).size());
System.out.println(&quot;Adult number: &quot; + children.get(false).size());
</code></pre><p>输出结果： </p>
<pre><code>     Children number: 23 
     Adult number: 77
</code></pre><p>在使用条件“年龄小于 18”进行分组后可以看到，不到 18 岁的未成年人是一组，成年人是另外一组。partitioningBy 其实是一种特殊的 groupingBy，它依照条件测试的是否两种结果来构造返回的数据结构，get(true) 和 get(false) 能即为全部的元素对象。 </p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>总之，Stream 的特性可以归纳为： </p>
<ul>
<li>不是数据结构</li>
<li>它没有内部存储，它只是用操作管道从 source（数据结构、数组、generator function、IO channel）抓取数据。</li>
<li>它也绝不修改自己所封装的底层数据结构的数据。例如 Stream 的 filter 操作会产生一个不包含被过滤元素的新 Stream，而不是从 source 删除那些元素。</li>
<li>所有 Stream 的操作必须以 lambda 表达式为参数</li>
<li>不支持索引访问</li>
<li>你可以请求第一个元素，但无法请求第二个，第三个，或最后一个。不过请参阅下一项。</li>
<li>很容易生成数组或者 List</li>
<li>惰性化</li>
<li>很多 Stream 操作是向后延迟的，一直到它弄清楚了最后需要多少数据才会开始。</li>
<li>Intermediate 操作永远是惰性化的。</li>
<li>并行能力</li>
<li>当一个 Stream 是并行化的，就不需要再写多线程代码，所有对它的操作会自动并行进行的。</li>
<li>可以是无限的<ul>
<li>集合有固定大小，Stream 则不必。limit(n) 和 findFirst() 这类的 short-circuiting 操作可以对无限的 Stream 进行运算并很快完成。</li>
</ul>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java8 </tag>
            
            <tag> lambda </tag>
            
            <tag> steams </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java8方法引用]]></title>
      <url>/2017/11/08/JAVA/java8%20%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p>形如 <code>ClassName::methodName</code> 或者 <code>objectName::methodName</code> 的表达式，我们把它叫做方法引用（Method Reference）。可能你现在还理解不了，但是编译器足够聪明，或许你可以看看编译器是如何根据 “晦涩难懂” 的 Method Reference 来推断你的意图的。 </p>
<h2 id="方法引用的种类"><a href="#方法引用的种类" class="headerlink" title="方法引用的种类"></a>方法引用的种类</h2><p>方法引用有四种，分别是： </p>
<ul>
<li>指向静态方法的引用</li>
<li>指向某个对象的实例方法的引用</li>
<li>指向某个类型的实例方法的引用</li>
<li>指向构造方法的引用</li>
</ul>
<p>下面通过一些代码示例来和大家分享一下这四种引用使用场景，先定义一个 <code>Person</code> 类，后面我们会用到它： </p>
<pre><code>public class Person {
    private String name;

    private String getName() {
        return name;
    }

    public static int compareName(Person a, Person b) {
        return a.getName().compareTo(b.name);
    }
}
</code></pre><h3 id="指向静态方法的引用"><a href="#指向静态方法的引用" class="headerlink" title="指向静态方法的引用"></a>指向静态方法的引用</h3><p>形式：<code>ContainingClass:staticMethodName</code></p>
<p>如果要想实现一群人按名字排序，一般你会这么做： </p>
<pre><code>Arrays.sort(personArray, new Comparator() {
    @Override
    public int compare(Person a, Person b) {
        return a.getName().compareTo(b.getName());
    }
});
</code></pre><p>第二个参数很复杂，但是目的却很简单：实现 <code>Comparator</code> 的一个比较方法。我们自然会想——相信很多程序员都会这么想：有没有一种方法能够既简单明了又能无歧义的表达我们的意图？当然有，Java 8 引入的 lambda 表达式便很好的简化了我们的代码，瞧： </p>
<pre><code>Array.sort(personArray, (a, b) -&gt; {
    return a.getName().compareTo(b.getName());
});
</code></pre><p><code>(a, b)</code> 是 lambda 表达式的参数列表，箭头后的是方法体。编译器已经被训练得足够聪明：它知道 <code>(a, b)</code> 就是代表着要比较的两个 <code>Person</code> 对象。它在脑海里构想出了这个 lambda 表达式的 “原型”： </p>
<pre><code>new Comparator() {
    @Override
    public int compare(Person a, Person b) {
        return a.getName().compareTo(b.getName());
    }
}
</code></pre><p>机智的编译器从简化的代码中推断出了 <code>Comparator</code> 对象的 “原型”。但是程序员并不满足：还能不能进一步简化？当然可以，在不造成歧义的前提下可以无限地简化一个语法。我们注意到，<code>Person</code> 类有一个静态方法可以用来实现两个对象的比较，于是引入 <strong>指向静态方法的引用</strong>： </p>
<pre><code>Arrays.sort(personArray, Person::compareName);
</code></pre><p><code>Person.compareName()</code> 方法有两个 <code>Person</code> 类型的参数，一个 <code>int</code> 类型的返回值，所以 <code>Person::compareName</code> 这个方法引用拥有两个 <code>Person</code> 类型的不确定量（在这里指的就是 <code>compareName()</code> 的两个参数；文章末尾有关于不确定量的具体解释）和一个 <code>int</code> 类型的返回值。而 <code>Comparator</code> 中待实现的方法 <code>compare()</code> 也有两个 <code>Person</code> 类型的参数和一个 <code>int</code> 的返回值。方法引用和 <code>Comparator</code> 中要实现的方法有足够的相似度，因此编译器将 <code>Person::compareName</code> 的不确定量和返回值与 <code>compare()</code> 的参数和返回值对应了起来，由此推断出我们的意图是： </p>
<pre><code>Arrays.sort(personArray, new Comparator() {
    @Override
    public int compare(Person a, Person b) {
        return Person.compareName(a, b);
    }
})
</code></pre><p>编译器成功地识别了程序员的意图。但是编译器的聪明程度也是有限的，假如方法引用所对应的静态方法返回值不是 <code>int</code> 而是 <code>boolean</code>，那么编译器无法将该方法引用还原为一个 <code>Comparator</code> 对象，因为它并不知道该返回什么 <code>int</code> 值。幸亏我们提供的静态方法引用有 <code>int</code> 类型的返回值，编译器还原时就可以把它返回。 </p>
<h3 id="指向某个对象的实例方法的引用"><a href="#指向某个对象的实例方法的引用" class="headerlink" title="指向某个对象的实例方法的引用"></a>指向某个对象的实例方法的引用</h3><p>形式：<code>containingObject::instanceMethodName</code></p>
<p>有一个比较器，它可以比较多种对象： </p>
<pre><code>public class Comparator() {
    public int comarePerson(Person a, Person b) {
        return a.getName().compareTo(b.getName());
    }

    public int compareDog(Dog a, Dog b) {
        return a.getName().compareTo(b.getName());
    }

    ......
}
</code></pre><p>上面的 <code>Dog</code> 类和 <code>Person</code> 类结构相似，所以代码就省略了。现在我们要根据一群狗的名字给它们排序，我们同样使用方法引用（当然，你依旧可以用 lambda 表达式），但是这次是 <strong>指向某个对象的实例方法的引用</strong>： </p>
<pre><code>Comparator aComparator = new Comparator(); // 实例化一个比较器
// aComparator::compareDog 是指向实例对象 aComparetor 的实例方法
// compareDog() 的方法引用
Arrays.sort(dogs, aComparator::compareDog); 
</code></pre><p><code>compareDog()</code> 方法的两个参数是 <code>Dog</code> 类型，返回值为 <code>int</code>，也就是说 <code>aComparator::compareDog</code> 有两个 <code>Dog</code> 类型的不确定量和一个 int 类型的返回值。而 <code>Comparator</code> 中的 <code>compare()</code> 方法也是接受两个 <code>Dog</code> 对象，返回一个 <code>int</code> 值。根据这些线索编译器足够推断出我们的意图： </p>
<pre><code>Arrays.sort(dogs, new Comparator() {
    @Override
    public int compare(Dog a, Dog b) {
        return aComparator.compareDog(a, b);
    }
});
</code></pre><h3 id="指向某个类型的实例方法的引用"><a href="#指向某个类型的实例方法的引用" class="headerlink" title="指向某个类型的实例方法的引用"></a>指向某个类型的实例方法的引用</h3><p>形式：<code>ContainingClass::instanceMethodName</code></p>
<pre><code>Stream.of(&quot;A&quot;, &quot;is&quot;, &quot;a&quot;, &quot;dog&quot;).reduce(&quot;&quot;, new BinaryOperator() {
    @Override
    public String apply(String a, String b) {
        return a.toUpperCase() + b.toUpperCase();
    }
});
</code></pre><p><code>reduce()</code> 方法是把某类型对象的集合降解为一个对象，过程是两两合并。它的第一个参数为初始值，第二个参数是一个接口，用来定义两两合并的具体策略。如果你暂时不懂 <code>Stream</code> 以及它的 <code>reduce()</code> 方法也没关系，我们只关注它的第二个参数。我们实现 <code>BinaryOperator</code> 接口的方法是把两个字符串变成大写后连接起来。代码看起来很臃肿，但是没有办法，我们没有合适的方法引用来将它简化（现有方法中没有能够将两个字符串先转换成大写然后连接的，当然你可以自己实现一个这样的方法，但没必要，因为这样会使得代码更加复杂），顶多可以转化成 lambda 表达式： </p>
<pre><code>Stream.of(&quot;A&quot;, &quot;is&quot;, &quot;a&quot;, &quot;dog&quot;).reduce(&quot;&quot;, (a, b) -&gt; {
        return a.toUpperCase() + b.toUpperCase();
    }
});
</code></pre><p>但是如果两两合并的方式是直接将两个字符串连接的话，情况就不同了。我们可以用 <code>String::concat</code> 这个 <strong>指向某个类型的实例方法的引用</strong> 来使代码更简洁： </p>
<pre><code>Stream.of(&quot;A&quot;, &quot;is&quot;, &quot;a&quot;, &quot;dog&quot;).reduce(&quot;&quot;, String::concat);
</code></pre><p>编译器看看这行代码，愣了一下，不知道如何转化。还好，我们的编译器足够聪明，眼珠一转分析了下：我们要实现的方法有两个 <code>String</code> 的参数，一个 <code>String</code> 类型的返回值，而 <code>String::concat</code> 也有两个 <code>String</code> 类型的不确定量和一个 <code>String</code> 类型的返回值，其中一个不确定量是由于 <code>concat()</code> 这个方法是实例方法导致的，因为它必须通过一个 <code>String</code> 实例来调用；另一个不确定量为 <code>concat()</code> 方法的参数，它接受一个 <code>String</code> 类型的参数。以上信息足够编译器来推断我们的意图：程序员一定是想把两个参数和 <code>String::concat</code> 的两个不确定量对应起来，一个作为 <code>concat()</code> 方法调用的接收者，一个作为 <code>concat()</code> 方法的参数。这样一来上面的代码就转化成这样了： </p>
<pre><code>Stream.of(&quot;A&quot;, &quot;is&quot;, &quot;a&quot;, &quot;dog&quot;).reduce(&quot;&quot;, new BinaryOperator() {
    @Override
    public String apply(String a, String b) {
        return a.concat(b);
    }
});
</code></pre><p>Wonderful ！程序员正是这么想的。有心的程序员可能会发出疑问：根据编译器的推断思路，对于任意一个方法引用，是不是只要它有两个 <code>String</code> 类型的不确定量和一个 <code>String</code> 类型返回值（当然类型要为 <code>String</code>）就可以作为参数传入 <code>reduce()</code> 了呢？于是程序员想了个方法来测试： </p>
<pre><code>Stream.of(&quot;A&quot;, &quot;is&quot;, &quot;a&quot;, &quot;dog&quot;).reduce(&quot;&quot;, Test::test);

public class Test {
    public static String test(String a, String b) {
        return a.concat(b);
    }
}
</code></pre><p>程序员在 IDE 中写下上面的代码后，编译器没有错误提示 =&gt; 编译后通过 =&gt; 猜想正确。原因是 <code>Test</code> 的 <code>test()</code> 是一个静态方法，它有两个 <code>String</code> 类型的参数，一个 <code>String</code> 类型的返回值，也就是说 <code>Test::test</code> 有两个 <code>String</code> 类型的不确定量和一个 <code>String</code> 类型的返回值，因此编译器推断出程序员的意图是： </p>
<pre><code>Stream.of(&quot;A&quot;, &quot;is&quot;, &quot;a&quot;, &quot;dog&quot;).reduce(&quot;&quot;, new BinaryOperator() {
    @Override
    public String apply(String a, String b) {
        return Test.test(a, b);
    }
});
</code></pre><h3 id="指向构造方法的引用"><a href="#指向构造方法的引用" class="headerlink" title="指向构造方法的引用"></a>指向构造方法的引用</h3><p>形式：<code>ClassName::new</code></p>
<pre><code>Stream.of(&quot;A&quot;, &quot;is&quot;, &quot;a&quot;, &quot;dog&quot;).toArray(new IntFunction&lt;String[]&gt;() {
     @Override
     public String[] apply(int value) {
         return null; 
     }
});
</code></pre><p><code>toArray()</code> 方法的作用是把数据流转换成一个数组，它接收的参数是一个 <code>IntFunction</code> 的接口实现对象。该接口有一个待实现的方法 <code>apply()</code>，它有一个 <code>int</code> 型的参数和一个 <code>String[]</code> 类型的返回值。我们依旧可以用方法引用来代替它，但这次我们用的是 <strong>指向构造方法的引用</strong>： </p>
<pre><code>Stream.of(&quot;A&quot;, &quot;is&quot;, &quot;a&quot;, &quot;dog&quot;).toArray(String[]::new);
</code></pre><p>指向构造方法的引用可能较其他方法引用难理解一点，但是编译器却很机智的猜测到了程序员的意图：<code>String[]::new</code> 这个 指向构造方法的引用 有一个 <code>int</code> 类型的不确定量，即数组的长度；有一个 String[] 类型的返回值（构造方法不会有返回值，但是指向构造方法的引用却返回了一个该类型的实例）。因此编译器这样还原此方法引用： </p>
<pre><code>Stream.of(&quot;A&quot;, &quot;is&quot;, &quot;a&quot;, &quot;dog&quot;).toArray(new IntFunction&lt;String[]&gt;() {
    @Override
    public String[] apply(int value) {
        return new String[value];
    }
})
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实，JVM 本身并不支持指向方法引用，过去不支持，现在也不支持。Java 8 对方法引用的支持知识编译器层面的支持，虚拟机执行引擎并不了解方法引用。编译器遇到方法引用的时候，会像上面那样自动推断出程序员的意图，将方法引用还原成 <strong>接口实现对象</strong>，或者更形象地说，就是把方法引用设法包装成一个接口实现对象，这样虚拟机就可以无差别地执行字节码文件而不需要管什么是方法引用了。 </p>
<p>需要注意的是，方法引用是用来简化接口实现代码的，并且凡是能够用方法引用来简化的接口，都有这样的特征：有且只有一个待实现的方法。这种接口在 Java 中有个专门的名称： <strong>函数式接口</strong>。当你用试图用方法引用替代一个非函数式接口时，会有这样的错误提示： xxx is not a functional interface。 </p>
<p>文章中很多地方提到过 <strong>不确定量</strong> 这个名词，这个名词并非官方的，而是我为了更好地说明问题而引入的，它的意思是： <strong>方法引用在转换成接口实现对象的过程中需要确定的变量</strong>。如 <strong>方法引用所对应方法的接受者</strong>（ <strong>指向静态方法的引用</strong> 和 <strong>指向某个对象的实例方法的引用</strong> 没有该不确定量，因为前者不需要接受者，而后者接受者已经确定），以及 <strong>方法引用所对应方法的参数</strong> 都属于 <strong>不确定量</strong>。方法引用的 <strong>不确定量</strong> 以及返回值需要和接口中的待实现方法的参数和返回值对应起来，这样编译器才能成功将其还原。 </p>
<h2 id="感谢阅读"><a href="#感谢阅读" class="headerlink" title="感谢阅读"></a>感谢阅读</h2><p>写这篇文章的目的是让大家对方法引用有一个更好的理解，同时也作为个人的学习记录，但由于理解和水平有限，差错在所难免，还请大家不吝赐教。最后，感谢大家的阅读。 </p>
<p><strong>参考文章:</strong><br><a href="http://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html" target="_blank" rel="external">Method References</a><br><a href="http://stackoverflow.com/questions/20001427/double-colon-operator-in-java-8" target="_blank" rel="external">:: (double colon) operator in Java 8</a></p>
<hr>
<ul>
<li><a href="http://liwenkun.me/2017/03/09/android-hot-fix/" title="动态加载应用之简单热更新" target="_blank" rel="external">Previous<br>动态加载应用之简单热更新</a></li>
<li><a href="http://liwenkun.me/2017/05/30/operating-system-conclusion/" title="操作系统原理总结" target="_blank" rel="external">Next<br>操作系统原理总结</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java8 </tag>
            
            <tag> lambda </tag>
            
            <tag> reference </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hibernat中使用二级缓存]]></title>
      <url>/2017/11/03/Spring/Hibernate%E4%BD%BF%E7%94%A8%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h2 id="hibernate使用二级缓存"><a href="#hibernate使用二级缓存" class="headerlink" title="hibernate使用二级缓存"></a>hibernate使用二级缓存</h2>]]></content>
      
        <categories>
            
            <category> Spring </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hibernate </tag>
            
            <tag> cache </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Web应用中使用hibernate]]></title>
      <url>/2017/11/02/Spring/web%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8hibernate/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h2 id="web项目中使用Hibernate"><a href="#web项目中使用Hibernate" class="headerlink" title="web项目中使用Hibernate"></a>web项目中使用Hibernate</h2><blockquote>
<p>首先创建一个gradle项目 web-application-with-hibernate, 导入依赖</p>
</blockquote>
<pre><code>testCompile group: &#39;junit&#39;, name: &#39;junit&#39;, version: &#39;4.12&#39;
// https://mvnrepository.com/artifact/org.hibernate/hibernate-core
compile group: &#39;org.hibernate&#39;, name: &#39;hibernate-core&#39;, version: &#39;5.2.12.Final&#39;
// https://mvnrepository.com/artifact/mysql/mysql-connector-java
compile group: &#39;mysql&#39;, name: &#39;mysql-connector-java&#39;, version: &#39;8.0.8-dmr&#39;
</code></pre><blockquote>
<p>创建一个用户注册的静态页面 index.jsp</p>
</blockquote>
<pre><code>&lt;form action=&quot;&quot; method=&quot;post&quot;&gt;
    &lt;h2&gt;用户注册表&lt;/h2&gt;
    &lt;hr&gt;
    Name:&lt;input type=&quot;text&quot; name=&quot;name&quot;/&gt;&lt;br&gt;
    &lt;br&gt;Password: &lt;input type=&quot;password&quot; name=&quot;password&quot;/&gt;&lt;br&gt;
    &lt;br&gt;Email: &lt;input type=&quot;email&quot; name=&quot;email&quot;/&gt;&lt;br&gt;
    &lt;br&gt;&lt;input type=&quot;submit&quot; value=&quot;注册&quot;/&gt;
&lt;/form&gt;
</code></pre><blockquote>
<p>创建一个User实体类用来存储信息</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>Model<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>
    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> String password<span class="token punctuation">;</span>
    <span class="token keyword">private</span> String email<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">//GETTER AND SETTER</span>
    <span class="token comment" spellcheck="true">//...</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>然后创建hibernate映射文件User.hbm.xml</p>
</blockquote>
<pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version='1.0' encoding='UTF-8'?></span>
<span class="token doctype">&lt;!DOCTYPE hibernate-mapping PUBLIC
        "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
        "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hibernate-mapping</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>class</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.demo.Model.User<span class="token punctuation">"</span></span> <span class="token attr-name">table</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tb_user<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>generator</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>increment<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>email<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>class</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>hibernate-mapping</span><span class="token punctuation">></span></span>
</code></pre>
<blockquote>
<p>我们创建操作持久化层测试类UserDao</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>Dao<span class="token punctuation">;</span>

<span class="token keyword">import</span> com<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>Model<span class="token punctuation">.</span>User<span class="token punctuation">;</span>
<span class="token keyword">import</span> org<span class="token punctuation">.</span>hibernate<span class="token punctuation">.</span>Session<span class="token punctuation">;</span>
<span class="token keyword">import</span> org<span class="token punctuation">.</span>hibernate<span class="token punctuation">.</span>SessionFactory<span class="token punctuation">;</span>
<span class="token keyword">import</span> org<span class="token punctuation">.</span>hibernate<span class="token punctuation">.</span>Transaction<span class="token punctuation">;</span>
<span class="token keyword">import</span> org<span class="token punctuation">.</span>hibernate<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>MetadataSources<span class="token punctuation">;</span>
<span class="token keyword">import</span> org<span class="token punctuation">.</span>hibernate<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>registry<span class="token punctuation">.</span>StandardServiceRegistry<span class="token punctuation">;</span>
<span class="token keyword">import</span> org<span class="token punctuation">.</span>hibernate<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>registry<span class="token punctuation">.</span>StandardServiceRegistryBuilder<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserDao</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">save</span><span class="token punctuation">(</span>User u<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

        <span class="token keyword">final</span> StandardServiceRegistry registry <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StandardServiceRegistryBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">configure</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 2. 根据服务注册类创建一个元数据资源集，同时构建元数据并生成应用一般唯一的的session工厂</span>
        SessionFactory factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MetadataSources</span><span class="token punctuation">(</span>registry<span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">buildMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">buildSessionFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Session session <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">openSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Transaction t <span class="token operator">=</span> session<span class="token punctuation">.</span><span class="token function">beginTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        i <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> session<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>
        t<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        session<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>u<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>创建数据库</p>
</blockquote>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>tb_user<span class="token punctuation">`</span> <span class="token punctuation">(</span>
  <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> unsigned <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>
  <span class="token punctuation">`</span>name<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">''</span><span class="token punctuation">,</span>
  <span class="token punctuation">`</span>password<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">''</span><span class="token punctuation">,</span>
  <span class="token punctuation">`</span>email<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">''</span><span class="token punctuation">,</span>
  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span>
</code></pre>
<blockquote>
<p>hibernate配置文件</p>
</blockquote>
<pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version='1.0' encoding='utf-8'?></span>
<span class="token doctype">&lt;!DOCTYPE hibernate-configuration PUBLIC
        "-//Hibernate/Hibernate Configuration DTD//EN"
        "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hibernate-configuration</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>session-factory</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>connection.url<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>jdbc:mysql://localhost:3306/Spring<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>connection.driver_class<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>com.mysql.cj.jdbc.Driver<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>connection.username<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>root<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>connection.password<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>19970819wy<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>

        <span class="token comment" spellcheck="true">&lt;!-- DB schema will be updated if needed --></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dialect<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>org.hibernate.dialect.MySQL5Dialect<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>hbm2ddl.auto<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>update<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapping</span> <span class="token attr-name">resource</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mapping/User.hbm.xml<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>session-factory</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>hibernate-configuration</span><span class="token punctuation">></span></span>
</code></pre>
<blockquote>
<p>修改持久化层configuration</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> StandardServiceRegistry registry <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StandardServiceRegistryBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">configure</span><span class="token punctuation">(</span><span class="token string">"hibernate/hibernate.cfg.xml"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<blockquote>
<p>展示用户信息的jsp页面</p>
</blockquote>
<pre class=" language-jsp"><code class="language-jsp"><%@ page import="com.demo.Dao.UserDao" %><%--
  Created by IntelliJ IDEA.
  User: wangyu
  Date: 02/11/2017
  Time: 5:00 PM
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<jsp:useBean id="obj" class="com.demo.Model.User"/>
<jsp:setProperty name="obj" property="*"/>

<%
    int i = UserDao.save(obj);
    if (i > 0) {
        out.print("You are successfully registered");
    }
%>
</code></pre>
<blockquote>
<p>修改index页面的action </p>
</blockquote>
<pre class=" language-jsp"><code class="language-jsp"><form action="register.jsp" method="post">
</code></pre>
<blockquote>
<p>运行结果</p>
</blockquote>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15097043584807.jpg" alt=""></p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15097043681445.jpg" alt=""></p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15097043810482.jpg" alt=""></p>
<h2 id="hibernate生成器类"><a href="#hibernate生成器类" class="headerlink" title="hibernate生成器类"></a>hibernate生成器类</h2><p>id元素的<code>&lt;generator&gt;</code>子元素用于生成持久化类的对象的唯一标识符。 Hibernate框架中定义了许多生成器类。</p>
<ul>
<li>assigned</li>
<li>increment</li>
<li>sequence</li>
<li>hilo</li>
<li>native</li>
<li>identity</li>
<li>seqhilo</li>
<li>uuid</li>
<li>guid</li>
<li>select</li>
<li>foreign</li>
<li>sequence-identity</li>
</ul>
<blockquote>
<p>assigned</p>
</blockquote>
<p>默认的生成策略，由应用程序为对象分配ID</p>
<pre class=" language-xml"><code class="language-xml"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hibernate-mapping</span><span class="token punctuation">></span></span>  
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>class</span> <span class="token attr-name">...</span><span class="token punctuation">></span></span>  
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">...</span><span class="token punctuation">></span></span>  
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>generator</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>assigned<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>generator</span><span class="token punctuation">></span></span>  
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>  
    .....  
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>class</span><span class="token punctuation">></span></span>  
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>hibernate-mapping</span><span class="token punctuation">></span></span>
</code></pre>
<blockquote>
<p>increment</p>
</blockquote>
<p>当没有其他进程讲数据插入此表时，才会生成唯一的ID，它生成short、int或long类型的数据<br>第一个生成的数据通常为1，然后每次递增为1</p>
<pre class=" language-xml"><code class="language-xml"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hibernate-mapping</span><span class="token punctuation">></span></span>  
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>class</span> <span class="token attr-name">...</span><span class="token punctuation">></span></span>  
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">...</span><span class="token punctuation">></span></span>  
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>generator</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>increment<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>generator</span><span class="token punctuation">></span></span>  
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>  
    .....  
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>class</span><span class="token punctuation">></span></span>  
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>hibernate-mapping</span><span class="token punctuation">></span></span>
</code></pre>
<blockquote>
<p>sequence</p>
</blockquote>
<p>它使用数据库的顺序序列。如果没有定义序列，它会自动创建一个序列。 在Oracle数据库的情况下，它将创建一个名为HIBERNATE_SEQUENCE的序列。 在Oracle，DB2，SAP DB，Postgre SQL或McKoi的情况下，它使用序列(sequence)，但在interbase中使用生成器。</p>
<pre class=" language-xml"><code class="language-xml"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">...</span><span class="token punctuation">></span></span>  
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>generator</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sequence<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>generator</span><span class="token punctuation">></span></span>  
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>
</code></pre>
<p>要定义自己的序列，使用param的name</p>
<pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">...</span><span class="token punctuation">></span></span>  
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>generator</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sequence<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sequence<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>your_sequence_name<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param</span><span class="token punctuation">></span></span>  
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>generator</span><span class="token punctuation">></span></span>  
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>
</code></pre>
<blockquote>
<p>hilo<br>使用高低算法来生成short、int和long类型的数据</p>
</blockquote>
<pre class=" language-xml"><code class="language-xml"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">...</span><span class="token punctuation">></span></span>  
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>generator</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>hilo<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>generator</span><span class="token punctuation">></span></span>  
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>
</code></pre>
<blockquote>
<p>native</p>
</blockquote>
<p>它使用标识，序列或希洛取决于数据库供应商</p>
<pre class=" language-xml"><code class="language-xml"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">...</span><span class="token punctuation">></span></span>  
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>generator</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>native<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>generator</span><span class="token punctuation">></span></span>  
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>
</code></pre>
<blockquote>
<p>identity</p>
</blockquote>
<p>它用于Sybase，Mysql，MS SQL Server，DB2和Hypersonic SQL以支持id列。 返回的ID类型为short，int或long。</p>
<blockquote>
<p>seqhilo</p>
</blockquote>
<p>它在指定的序列名称上使用高低算法。 返回的ID类型为short，int或long。</p>
<blockquote>
<p>uuid</p>
</blockquote>
<p>它使用128位UUID算法生成id。 返回的ID是String类型，在网络中是唯一的(因为使用了IP)。 UUID以十六进制数字表示，长度为32。</p>
<blockquote>
<p>guid</p>
</blockquote>
<p>它使用由字符串类型的数据库生成的GUID。 它适用于MS SQL Server和MySQL。</p>
<blockquote>
<p>select</p>
</blockquote>
<p>它使用数据库触发器返回主键。</p>
<blockquote>
<p>foreign</p>
</blockquote>
<p>它使用另一个关联对象的id，主要用于&lt;一对一&gt;关联。</p>
<blockquote>
<p>sequence-identity</p>
</blockquote>
<p>它使用特殊的序列生成策略。 仅在Oracle 10g驱动程序中支持。</p>
]]></content>
      
        <categories>
            
            <category> Spring </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hibernate </tag>
            
            <tag> Java Web </tag>
            
            <tag> Hibernate生成器 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[学习Spring第六天]]></title>
      <url>/2017/10/25/Spring/Hibernate/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h2 id="hibernate框架使用"><a href="#hibernate框架使用" class="headerlink" title="hibernate框架使用"></a>hibernate框架使用</h2><blockquote>
<p>首先引入gradle依赖:</p>
</blockquote>
<pre><code>testCompile group: &#39;junit&#39;, name: &#39;junit&#39;, version: &#39;4.12&#39;
// https://mvnrepository.com/artifact/org.hibernate/hibernate-core
compile group: &#39;org.hibernate&#39;, name: &#39;hibernate-core&#39;, version: &#39;5.2.12.Final&#39;
// https://mvnrepository.com/artifact/mysql/mysql-connector-java
compile group: &#39;mysql&#39;, name: &#39;mysql-connector-java&#39;, version: &#39;8.0.8-dmr&#39;
</code></pre><blockquote>
<p>然后创建一个实体类 Employee:</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>Model<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>
    <span class="token keyword">private</span> String firstName<span class="token punctuation">;</span>
    <span class="token keyword">private</span> String lastName<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> id<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setId</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> String <span class="token function">getFirstName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> firstName<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setFirstName</span><span class="token punctuation">(</span>String firstName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>firstName <span class="token operator">=</span> firstName<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> String <span class="token function">getLastName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> lastName<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setLastName</span><span class="token punctuation">(</span>String lastName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>lastName <span class="token operator">=</span> lastName<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>然后创建持久化类 employee.hbm.xml</p>
</blockquote>
<pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version='1.0' encoding='UTF-8'?></span>
<span class="token doctype">&lt;!DOCTYPE hibernate-mapping PUBLIC
        "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
        "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hibernate-mapping</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>class</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.demo.Model.Employee<span class="token punctuation">"</span></span> <span class="token attr-name">table</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>employee<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ID<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>generator</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>assigned<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>firstName<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>FIRST_NAME<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>lastName<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>LAST_NAME<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>class</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>hibernate-mapping</span><span class="token punctuation">></span></span>
</code></pre>
<blockquote>
<p>创建hibernate配置文件 hibernate.cfg.xml</p>
</blockquote>
<pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version='1.0' encoding='UTF-8'?></span>
<span class="token doctype">&lt;!DOCTYPE hibernate-configuration PUBLIC
        "-//Hibernate/Hibernate Configuration DTD 3.0//EN"
        "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hibernate-configuration</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>session-factory</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>connection.driver_class<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>com.mysql.cj.jdbc.Driver<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>connection.url<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>jdbc:mysql://localhost:3306/hibernate<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>connection.username<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>root<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>connection.password<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>19970819wy<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dialect<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>org.hibernate.dialect.MySQL5Dialect<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>show_sql<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>hibernate.hbm2ddl.auto<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>create<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapping</span> <span class="token attr-name">resource</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>hibernate/employee.hbm.xml<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>session-factory</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>hibernate-configuration</span><span class="token punctuation">></span></span>
</code></pre>
<blockquote>
<p>编写测试类 StoreData</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>demo<span class="token punctuation">;</span>


<span class="token keyword">import</span> com<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>Model<span class="token punctuation">.</span>Employee<span class="token punctuation">;</span>
<span class="token keyword">import</span> org<span class="token punctuation">.</span>hibernate<span class="token punctuation">.</span>Session<span class="token punctuation">;</span>
<span class="token keyword">import</span> org<span class="token punctuation">.</span>hibernate<span class="token punctuation">.</span>SessionFactory<span class="token punctuation">;</span>
<span class="token keyword">import</span> org<span class="token punctuation">.</span>hibernate<span class="token punctuation">.</span>Transaction<span class="token punctuation">;</span>
<span class="token keyword">import</span> org<span class="token punctuation">.</span>hibernate<span class="token punctuation">.</span>cfg<span class="token punctuation">.</span>Configuration<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StoreData</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Configuration cfg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Configuration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        cfg<span class="token punctuation">.</span><span class="token function">configure</span><span class="token punctuation">(</span><span class="token string">"hibernate/hibernate.cfg.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        SessionFactory factory <span class="token operator">=</span> cfg<span class="token punctuation">.</span><span class="token function">buildSessionFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        Session session <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">openSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        Transaction transaction <span class="token operator">=</span> session<span class="token punctuation">.</span><span class="token function">beginTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        Employee employee <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        employee<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        employee<span class="token punctuation">.</span><span class="token function">setFirstName</span><span class="token punctuation">(</span><span class="token string">"Wang"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        employee<span class="token punctuation">.</span><span class="token function">setLastName</span><span class="token punctuation">(</span><span class="token string">"Yu"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        session<span class="token punctuation">.</span><span class="token function">persist</span><span class="token punctuation">(</span>employee<span class="token punctuation">)</span><span class="token punctuation">;</span>

        transaction<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        session<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"successful saved"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>运行结果如下：</p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15096117112127.jpg" alt=""></p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15096117282494.jpg" alt=""></p>
<h3 id="使用注解的形式来创建持久化实体类"><a href="#使用注解的形式来创建持久化实体类" class="headerlink" title="使用注解的形式来创建持久化实体类"></a>使用注解的形式来创建持久化实体类</h3><p>我们首先用注解的形式来修改上面的Employee实体类</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>Model<span class="token punctuation">;</span>

<span class="token keyword">import</span> javax<span class="token punctuation">.</span>persistence<span class="token punctuation">.</span>Column<span class="token punctuation">;</span>
<span class="token keyword">import</span> javax<span class="token punctuation">.</span>persistence<span class="token punctuation">.</span>Entity<span class="token punctuation">;</span>
<span class="token keyword">import</span> javax<span class="token punctuation">.</span>persistence<span class="token punctuation">.</span>Id<span class="token punctuation">;</span>
<span class="token keyword">import</span> javax<span class="token punctuation">.</span>persistence<span class="token punctuation">.</span>Table<span class="token punctuation">;</span>

<span class="token annotation punctuation">@Entity</span>
<span class="token annotation punctuation">@Table</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"tb_employee"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Id</span>
    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"Em_ID"</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"Em_FirstName"</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> String firstName<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"Em_LastName"</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> String lastName<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> id<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setId</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> String <span class="token function">getFirstName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> firstName<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setFirstName</span><span class="token punctuation">(</span>String firstName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>firstName <span class="token operator">=</span> firstName<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> String <span class="token function">getLastName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> lastName<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setLastName</span><span class="token punctuation">(</span>String lastName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>lastName <span class="token operator">=</span> lastName<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>@Id表示主键<br>@Column表示对应数据表的列名称<br>@Entity是必须的，把Employee注册成实体类<br>@Table指定对应的数据表的名称</p>
<blockquote>
<p>在hibernate.cfg.xml中修改一下mapping</p>
</blockquote>
<pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapping</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.demo.Model.Employee<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
</code></pre>
<p>运行结果一致</p>
]]></content>
      
        <categories>
            
            <category> Spring </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hibernate </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[计算机系统概论]]></title>
      <url>/2017/10/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p>物联网：把感应器嵌入和装备到电网、铁路、桥梁、隧道、公路、建筑、供水系统、大坝、油气管道等各种物体中，并且被普遍连接，形成所谓的“物联网”，然后将“物联网”与现有的互联网整合起来，实现人类社会与无力系统的整合，形成智慧地球</p>
<a id="more"></a>      
<h2 id="计算机系统简介"><a href="#计算机系统简介" class="headerlink" title="计算机系统简介"></a>计算机系统简介</h2><p>计算机系统分为硬件和软件</p>
<p>硬件：计算机的实体，如主机、外设等</p>
<p>软件：由具有各类特殊功能的信息（程序）组成</p>
<ul>
<li><p>分类：系统软件、应用软件</p>
<p> 系统软件： 用来管理整个计算机系统</p>
<pre><code> e.g. : 语言处理程序、操作系统、服务性程序、数据库管理系统、网络软件
</code></pre><p> 应用软件： 按任务需要编织成的各种程序</p>
</li>
</ul>
<h2 id="计算机系统的层次结构"><a href="#计算机系统的层次结构" class="headerlink" title="计算机系统的层次结构"></a>计算机系统的层次结构</h2><p>层次结构：</p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15088579483898.jpg" alt=""></p>
<p>系统复杂性管理的方法：</p>
<blockquote>
<p>抽象：隐藏系统中不重要的细节</p>
</blockquote>
<p>从语言的角度划分层次</p>
<pre><code>微指令系统  微程序机器M0
              |
              |
机器语言    实际机器M1
              |
              |
操作系统    虚拟机器
              |
              |
汇编语言    虚拟机器M2
              |
              |
高级语言    虚拟机器M3
</code></pre><p>高级语言执行的过程</p>
<pre><code>虚拟机器M4      用编译程序翻译成汇编语言程序
    |
    |
虚拟机器M3      用汇编语言程序翻译成机器语言程序
    |
    |
虚拟机器M2      用机器语言解释操作系统
    |
==============软硬件分界线=========
    |
实际机器M1      用微指令解释机器指令
    |
    |
微程序机器M0     由硬件直接执行微指令
</code></pre><p>软硬件对于功能的实现逻辑上等价</p>
<ul>
<li><p>硬件实现：造价贵</p>
</li>
<li><p>软件实现：软件体系庞大 实现复杂</p>
</li>
</ul>
<p>计算机组成与计算机体系结构从研究内容上的区别：</p>
<blockquote>
<p>计算机体系结构：程序员所见到的计算机系统的属性概念性的结构与功能特性(机器语言程序员)=&gt;有无乘法指令</p>
<p>计算机组成：实现计算机体系结构所体现的属性(具体指令的实现)=&gt;如何实现乘法指令</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 组成原理 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 概论 </tag>
            
            <tag> 计算机体系结构 </tag>
            
            <tag> 计算机组成 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[计算机网络基本概念]]></title>
      <url>/2017/10/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p>计算机网络是通信技术和计算机技术紧密结合的产物</p>
<a id="more"></a>    
<p>通信系统模型：</p>
<p><img src="media/15088842118439.jpg" alt=""></p>
<ul>
<li>计算机网络就是一种通信网络</li>
</ul>
<p>定义：计算机网络就是互连的、自治的计算机集合</p>
<ul>
<li>自治：无主从关系</li>
<li>互连：互联互通<br>  通信链路</li>
</ul>
<p><img src="media/15088843816499.jpg" alt=""></p>
<p>当两台主机距离过远时，直接使用物理链路连接不可行。通过交换网络互连主机</p>
<p><img src="media/15088844808106.jpg" alt=""></p>
<p>Internet：</p>
<p>组成细节角度</p>
<pre><code>全球最大的互联网络
 * ISP（Internet Service Provider）网络互连的“网络之网络”
    数以百万计的互连的计算设备集合
     * 主机=端系统
     * 运行各种网络应用
* 通信链路
    光纤、铜缆、无线电、卫星...
分组交换：转发分组（数据包）
    * 路由器和交换机
</code></pre><p>服务角度</p>
<pre><code>为网络应用提供通信服务的通信基础设施
    * Web、VoIP、email、网络游戏、电子商务、社交网络...
为网络应用提供应用编程接口(API)
    * 支持应用程序“连接”Internet，发送／接收数据
    * 提供类似于邮政系统的数据传输服务
</code></pre><p><img src="media/15088846455227.jpg" alt=""></p>
<p>硬件（主机、路由器、通信链路等）是计算机网络的基础<br>计算机网络中的数据必须交换遵守事先预定好的规则</p>
<blockquote>
<p>任何通信和信息交换过程都需要规则</p>
</blockquote>
<p>网络通信：</p>
<pre><code>* 通信主体是“机器”不是人
* 交换”电子化“或”数字化“消息
* 计算机网络的所有通信过程都必须遵守某种／些规则---协议
</code></pre><blockquote>
<p>网络协议，简称协议，是为进行网络中的数据交换而建立的规则、标准或约定<br>协议规定了通信实体之间所交换的消息的格式、意义、顺序以及针对收到消息或发生的事件所采取的动作（action）</p>
</blockquote>
<p>协议三要素：<br>语法（Syntax）</p>
<pre><code>* 数据与控制信息的结构或格式
* 信号电平
</code></pre><p>语意（Semantics）</p>
<pre><code>* 需要发出何种控制信息
* 完成何种动作以及作出何种响应
* 差错控制
</code></pre><p>时序（Timing）</p>
<pre><code>* 事件顺序
* 速度匹配
</code></pre><ul>
<li>协议规范了网络中所有信息发送和接收过程</li>
<li>学习网络的重要内容之一</li>
<li>网络创新的表现形式之一</li>
<li>Internet协议标准<br>  RFC：Request for Comments<br>  IETF：互联网工程任务组</li>
</ul>
<p>网络边缘：</p>
<pre><code>* 主机
* 网络应用
</code></pre><p>接入网络、物理介质</p>
<pre><code>* 有线或无线通信链路
</code></pre><p>网络核心（核心网络）</p>
<pre><code>* 互联的路由器（或分组转发设备）
* 网络之网络
</code></pre><p>主机（端系统）</p>
<pre><code>* 位于“网络边缘”
* 运行网络应用程序
    Web、email
</code></pre><p>客户／服务器（client／server）应用模型<br>    客户端发送请求，接收服务器响应（Web，FTP）<br>对等（peer-peer，P2P）应用模型<br>    无专用服务器<br>    通信在对等实体之间直接进行</p>
<blockquote>
<p>接入网络</p>
</blockquote>
<p><img src="media/15088866522095.jpg" alt=""></p>
<p>数字用户线路（DSL）（独占）<br>    利用已有的电话线连接中心局的DSLAM<br>    语音通过DSL电话线接入电话网<br>上行低，下行快</p>
<p><img src="media/15088866356085.jpg" alt=""></p>
<p>电缆网络：有线电视网络（共享）</p>
<p><img src="media/15088868501997.jpg" alt=""></p>
<p>频分多路复用：在不同频带（载波）上传输不同的频道<br>HFC：混合光纤同轴电缆（共享）<br>    非对称</p>
<p>典型家庭网络的接入：</p>
<p><img src="media/15088869044970.jpg" alt=""></p>
<p>机构接入：</p>
<p><img src="media/15088869559608.jpg" alt=""></p>
<p>无线接入：<br>通过共享的无线接入网络连接端系统与路由器<br>    通过基站（base station）或称为“接入点”（access point）</p>
<p>无线局域网络（LANs）<br>广域无线接入（蜂窝网）</p>
<p>网络核心的关键功能：路由+转发<br>    路由：确定分组从源到目的传输路径<br>    转发：将分组从路由器的输入端口交换至正确的输出端口</p>
]]></content>
      
        <categories>
            
            <category> 计算机网络 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 基本概念 </tag>
            
            <tag> 网络协议 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[学习Spring第五天]]></title>
      <url>/2017/10/24/Spring/AOP/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a>  
<h2 id="BeanNameAutoProxyCreator"><a href="#BeanNameAutoProxyCreator" class="headerlink" title="BeanNameAutoProxyCreator"></a>BeanNameAutoProxyCreator</h2><p>生产中会有会多bean需要代理，为了节约时间和减少工作量，我们可以使用自动代理来创建代理Bean</p>
<p>个人感觉十分简单</p>
<p>首先创建一个BeanNameAutoProxyCreator的Bean，然后把Advisor和需要代理的Bean丢进去(支持正则匹配)</p>
<pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span>bean <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator"</span><span class="token operator">></span>
    <span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">"beanNames"</span><span class="token operator">></span>
        <span class="token operator">&lt;</span>list<span class="token operator">></span>
            <span class="token operator">&lt;</span>value<span class="token operator">></span><span class="token operator">*</span>Service<span class="token operator">&lt;</span><span class="token operator">/</span>value<span class="token operator">></span>
        <span class="token operator">&lt;</span><span class="token operator">/</span>list<span class="token operator">></span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>property<span class="token operator">></span>
    <span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">"interceptorNames"</span><span class="token operator">></span>
        <span class="token operator">&lt;</span>list<span class="token operator">></span>
            <span class="token operator">&lt;</span>value<span class="token operator">></span>customerPointCut<span class="token operator">&lt;</span><span class="token operator">/</span>value<span class="token operator">></span>
            <span class="token operator">&lt;</span>value<span class="token operator">></span>customerAdvisor<span class="token operator">&lt;</span><span class="token operator">/</span>value<span class="token operator">></span>
        <span class="token operator">&lt;</span><span class="token operator">/</span>list<span class="token operator">></span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>property<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>bean<span class="token operator">></span>
</code></pre>
<p>然后测试类不需要在调用Proxy的名字，直接使用，Spring会自动创建代理</p>
<h2 id="DefaultAdvisorAutoProxyCreator"><a href="#DefaultAdvisorAutoProxyCreator" class="headerlink" title="DefaultAdvisorAutoProxyCreator"></a>DefaultAdvisorAutoProxyCreator</h2><p>听说十分强大，如果有Bean相关联，会自动创建相应的代理</p>
<p><code>&lt;bean class=&quot;org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator&quot;/&gt;</code></p>
<p>一行代码即可，感觉是有点方便，运行结果不变</p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15088497883546.jpg" alt=""></p>
<ul>
<li>拦截器的序列会影响结果，我们需要自己调整顺序如果是使用BeanNameAutoProxyCreator</li>
</ul>
<h2 id="AOP-AspectJ-面向切面编程"><a href="#AOP-AspectJ-面向切面编程" class="headerlink" title="AOP+AspectJ 面向切面编程"></a>AOP+AspectJ 面向切面编程</h2><p>AspectJ常见的注解</p>
<pre><code>@Before – 方法执行前运行
@After – 运行在方法返回结果后
@AfterReturning – 运行在方法返回一个结果后，在拦截器返回结果。
@AfterThrowing – 运行方法在抛出异常后，
@Around – 围绕方法执行运行，结合以上这三个通知。
</code></pre><blockquote>
<p>创建一个Dao</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>Dao<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">CustomerBo</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">addCustomer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    String <span class="token function">addCustomerReturnValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">void</span> <span class="token function">addCustomerThrowException</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">;</span>

    <span class="token keyword">void</span> <span class="token function">addCustomerAround</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>实现类CustomerBoImpl</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>Dao<span class="token punctuation">.</span>Impl<span class="token punctuation">;</span>

<span class="token keyword">import</span> com<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>Dao<span class="token punctuation">.</span>CustomerBo<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CustomerBoImpl</span> <span class="token keyword">implements</span> <span class="token class-name">CustomerBo</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addCustomer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"addCustomer() is running"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> String <span class="token function">addCustomerReturnValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"addCustomerReturnValue() is running"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token string">"abc"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addCustomerThrowException</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"addCustomerThrowException() is running"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Exception</span><span class="token punctuation">(</span><span class="token string">"Generic Error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addCustomerAround</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"addCustomerAround(String name) is running, args: "</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>然后定义一个AspectJ用来输出日志信息</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>AspectJ<span class="token punctuation">;</span>

<span class="token keyword">import</span> org<span class="token punctuation">.</span>aspectj<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>JoinPoint<span class="token punctuation">;</span>
<span class="token keyword">import</span> org<span class="token punctuation">.</span>aspectj<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Aspect<span class="token punctuation">;</span>
<span class="token keyword">import</span> org<span class="token punctuation">.</span>aspectj<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Before<span class="token punctuation">;</span>

<span class="token annotation punctuation">@Aspect</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LoggingAspect</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Before</span><span class="token punctuation">(</span><span class="token string">"execution(* com.demo.Dao.CustomerBo.addCustomer(..))"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">logBefore</span><span class="token punctuation">(</span>JoinPoint joinPoint<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"logBefore() is running"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Method "</span> <span class="token operator">+</span> joinPoint<span class="token punctuation">.</span><span class="token function">getSignature</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"**********"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>在applicationContext.xml中声明Beans</p>
</blockquote>
<pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">xmlns:</span>aop</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/aop<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-4.0.xsd
    http://www.springframework.org/schema/aop
    http://www.springframework.org/schema/aop/spring-aop-4.0.xsd <span class="token punctuation">"</span></span><span class="token punctuation">></span></span>

    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>aspectj-autoproxy</span><span class="token punctuation">/></span></span>

    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>customerBo<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.demo.Dao.Impl.CustomerBoImpl<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>

    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>logAspect<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.demo.AspectJ.LoggingAspect<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">></span></span>
</code></pre>
<p>这里用到了<code>&lt;aop:aspectj-autoproxy/&gt;</code>开启切片自动拦截</p>
<p>然后在xml中注册了这个日志拦截切片</p>
<p>运行结果如下:</p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15088527301527.jpg" alt=""></p>
<blockquote>
<p>下面把其余的几个注解一起使用</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>AspectJ<span class="token punctuation">;</span>

<span class="token keyword">import</span> org<span class="token punctuation">.</span>aspectj<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>JoinPoint<span class="token punctuation">;</span>
<span class="token keyword">import</span> org<span class="token punctuation">.</span>aspectj<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>ProceedingJoinPoint<span class="token punctuation">;</span>
<span class="token keyword">import</span> org<span class="token punctuation">.</span>aspectj<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>*<span class="token punctuation">;</span>

<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span>

<span class="token annotation punctuation">@Aspect</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LoggingAspect</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Before</span><span class="token punctuation">(</span><span class="token string">"execution(* com.demo.Dao.CustomerBo.addCustomer(..))"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">logBefore</span><span class="token punctuation">(</span>JoinPoint joinPoint<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"logBefore() is running"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Method "</span> <span class="token operator">+</span> joinPoint<span class="token punctuation">.</span><span class="token function">getSignature</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"**********"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@After</span><span class="token punctuation">(</span><span class="token string">"execution(* com.demo.Dao.CustomerBo.addCustomer(..))"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">logAfter</span><span class="token punctuation">(</span>JoinPoint joinPoint<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"logAfter() is running"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Method "</span> <span class="token operator">+</span> joinPoint<span class="token punctuation">.</span><span class="token function">getSignature</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"**********"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@AfterReturning</span><span class="token punctuation">(</span><span class="token string">"execution(* com.demo.Dao.CustomerBo.addCustomerReturnValue(..))"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">logAfterReturn</span><span class="token punctuation">(</span>JoinPoint joinPoint<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"logAfterReturn() is running"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Method "</span> <span class="token operator">+</span> joinPoint<span class="token punctuation">.</span><span class="token function">getSignature</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"**********"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@AfterThrowing</span><span class="token punctuation">(</span>pointcut <span class="token operator">=</span> <span class="token string">"execution(* com.demo.Dao.CustomerBo.addCustomerThrowException(..))"</span><span class="token punctuation">,</span> throwing <span class="token operator">=</span> <span class="token string">"error"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">logAfterThrowing</span><span class="token punctuation">(</span>JoinPoint joinPoint<span class="token punctuation">,</span> Throwable error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"logAfterThrowing() is running"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Method : "</span> <span class="token operator">+</span> joinPoint<span class="token punctuation">.</span><span class="token function">getSignature</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Error : "</span> <span class="token operator">+</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"**********"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Around</span><span class="token punctuation">(</span><span class="token string">"execution(* com.demo.Dao.CustomerBo.addCustomerAround(..))"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">logAround</span><span class="token punctuation">(</span>ProceedingJoinPoint joinPoint<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"logAround() is running"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Method : "</span> <span class="token operator">+</span> joinPoint<span class="token punctuation">.</span><span class="token function">getSignature</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Method Parameters : "</span> <span class="token operator">+</span> Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>joinPoint<span class="token punctuation">.</span><span class="token function">getArgs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Around Before is running"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        joinPoint<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Around After is running"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"**********"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre>
<p>感觉跟写Advice差不多</p>
<p>流程就是这样: DaoImpl-&gt;AspectJ-&gt;xml开启aspect自动代理-&gt;xml注入-&gt;调用</p>
<ul>
<li>注解可以用xml代替</li>
</ul>
<pre><code>&lt;aop:before&gt; = @Before
&lt;aop:after&gt; = @After
&lt;aop:after-returning&gt; = @AfterReturning
&lt;aop:after-throwing&gt; = @AfterThrowing
&lt;aop:after-around&gt; = @Around
</code></pre><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">xmlns:</span>aop</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/aop<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-4.0.xsd
    http://www.springframework.org/schema/aop
    http://www.springframework.org/schema/aop/spring-aop-4.0.xsd <span class="token punctuation">"</span></span><span class="token punctuation">></span></span>

    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>aspectj-autoproxy</span><span class="token punctuation">/></span></span>

    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>customerBo<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.demo.Dao.Impl.CustomerBoImpl<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>

    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>logAspect<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.demo.AspectJ.LoggingAspect<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>config</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>aspect</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aspectLogging<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>logAspect<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>pointcut</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>pointCutBefore<span class="token punctuation">"</span></span> <span class="token attr-name">expression</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>execution(* com.demo.Dao.CustomerBo.addCustomer(..))<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>before</span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>logBefore<span class="token punctuation">"</span></span> <span class="token attr-name">pointcut-ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>pointCutBefore<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>

            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>pointcut</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>pointCutAfter<span class="token punctuation">"</span></span> <span class="token attr-name">expression</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>execution(* com.demo.Dao.CustomerBo.addCustomer(..))<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>after</span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>logAfter<span class="token punctuation">"</span></span> <span class="token attr-name">pointcut-ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>pointCutAfter<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">aop:</span>aspect</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">aop:</span>config</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">></span></span>
</code></pre>
<p>在xml中注册<code>&lt;aop:config&gt;</code>在内层用<code>&lt;aop:aspect&gt;</code>包裹，内部每声明一个pointcut就有一个响应的<code>&lt;aop:xxx&gt;</code>与之对应，我理解为一个切片，一个执行</p>
]]></content>
      
        <categories>
            
            <category> Spring </category>
            
        </categories>
        
        
        <tags>
            
            <tag> AOP </tag>
            
            <tag> AutoProxyCreator </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[学习Spring第四天]]></title>
      <url>/2017/10/22/Spring/AspectJ/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a>  
<h2 id="Spring-PropertyPlaceholderConfigurer的使用"><a href="#Spring-PropertyPlaceholderConfigurer的使用" class="headerlink" title="Spring PropertyPlaceholderConfigurer的使用"></a>Spring PropertyPlaceholderConfigurer的使用</h2><blockquote>
<p>对于一些隐秘的或者是全局变量的操作我们希望可以统一的管理他，我们可以把这些配置写在properties或者yaml文件里，然后在xml配置文件里获取相应的值，PropertyPlaceholderConfigurer就可以帮助我们实现这个功能 </p>
</blockquote>
<p>我们还是从简单的jdbc开始，项目结构如下： </p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15086031216749.jpg" alt=""></p>
<blockquote>
<p>gradle依赖 </p>
</blockquote>
<pre><code>testCompile group: &#39;junit&#39;, name: &#39;junit&#39;, version: &#39;4.12&#39;

compile group: &#39;org.springframework&#39;, name: &#39;spring-context&#39;, version: &#39;5.0.0.RELEASE&#39;

compile group: &#39;mysql&#39;, name: &#39;mysql-connector-java&#39;, version: &#39;8.0.8-dmr&#39;

compile group: &#39;org.springframework&#39;, name: &#39;spring-jdbc&#39;, version: &#39;5.0.0.RELEASE&#39;

compile group: &#39;org.springframework&#39;, name: &#39;spring-core&#39;, version: &#39;5.0.0.RELEASE&#39;
</code></pre><p>数据表如下: </p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15086032783308.jpg" alt=""></p>
<blockquote>
<p>首先我们新建一个Entity </p>
</blockquote>
<pre><code>Customer.java

package com.demo.Model;

public class Customer {
    private int custId;
    private String name;
    private int age;

    public void setCustId(int custId) {
        this.custId = custId;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public int getCustId() {
        return custId;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    @Override
    public String toString() {
        return &quot;Cust_Id: &quot; + custId + &quot;\nName: &quot; + name + &quot;\nAge: &quot; + age;
    }
}
</code></pre><blockquote>
<p>Dao层接口实现 </p>
</blockquote>
<pre><code>CustomerDao.java

package com.demo.Dao;

import com.demo.Model.Customer;

public interface CustomerDao {
    void insert(Customer customer);

    Customer findById(int custId);
}
</code></pre><blockquote>
<p>Impl实现接口方法 </p>
</blockquote>
<pre><code>CustomerDaoImpl.java

package com.demo.Impl;

import com.demo.Dao.CustomerDao;
import com.demo.Model.Customer;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.support.JdbcDaoSupport;

import java.util.List;

public class CustomerDaoImpl extends JdbcDaoSupport implements CustomerDao {
    @Override
    public void insert(Customer customer) {

        String sql = &quot;INSERT INTO customer VALUES (? ,? ,?)&quot;;
        getJdbcTemplate().update(sql, customer.getCustId(), customer.getName(), customer.getAge());
    }

    @Override
    public Customer findById(int custId) {
        String sql = &quot;SELECT * FROM customer WHERE CUST_ID = ?&quot;;

        List&lt;Customer&gt; customers = getJdbcTemplate().query(sql, new Object[]{custId}, new BeanPropertyRowMapper&lt;&gt;(Customer.class));

        return customers.get(0);
    }
}
</code></pre><p>上面都是很基本的Jdbc操作，通过增删改查来测试代码 </p>
<blockquote>
<p>不同于之前，我们把数据库的变量写在properties里 </p>
</blockquote>
<pre><code>data-config.properties

jdbc.driverClassName=com.mysql.cj.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/Spring
jdbc.username=root
jdbc.password=19970819wy
</code></pre><blockquote>
<p>Spring-Beans中配置dataSource和beans </p>
</blockquote>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-4.0.xsd&quot;&gt;

    &lt;bean class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt;
        &lt;property name=&quot;location&quot; value=&quot;database-config.properties&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driverClassName}&quot;/&gt;
        &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;customer&quot; class=&quot;com.demo.Impl.CustomerDaoImpl&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre><p>这里我们首先通过PropertyPlaceholderConfigurer来导入properties里的变量(location属性定位properties文件)<br>然后我们就可以在dataSource里通过${}来获取对应的值 </p>
<blockquote>
<p>测试类 </p>
</blockquote>
<pre><code>App.java

package com.demo;

import com.demo.Impl.CustomerDaoImpl;
import com.demo.Model.Customer;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class App {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;Spring-Beans.xml&quot;);

        Customer customer = new Customer();
        customer.setCustId(1);
        customer.setName(&quot;RenBuRuGu&quot;);
        customer.setAge(20);

        CustomerDaoImpl impl = context.getBean(CustomerDaoImpl.class);

        impl.insert(customer);

        System.out.println(impl.findById(1));
    }
}
</code></pre><h2 id="Bean的继承"><a href="#Bean的继承" class="headerlink" title="Bean的继承"></a>Bean的继承</h2><p>继承的方式有两种 直接继承和抽象继承<br>子类可以继承父类的一系列属性 </p>
<blockquote>
<p>直接继承 </p>
</blockquote>
<p>我个人认为有两种 一种是class由父类指定，子类不指定class，那么父类和子类都会共享同一个实体类，子类可以省略父类既定的字段或者重写。第二种是父类子类都指定class，这里的class不一定要存在继承关系，只要相应的class有共享的字段即可(我感觉这样不是很好) </p>
<blockquote>
<p>创建一个entity </p>
</blockquote>
<pre><code>package com.demo.Model;

public class Customer {
    private int type;
    private String action;
    private String country;

    public int getType() {
        return type;
    }

    public void setType(int type) {
        this.type = type;
    }

    public String getAction() {
        return action;
    }

    public void setAction(String action) {
        this.action = action;
    }

    public String getCountry() {
        return country;
    }

    public void setCountry(String country) {
        this.country = country;
    }

    @Override
    public String toString() {
        return &quot;type: &quot; + type + &quot;\naction: &quot; + action + &quot;\ncountry: &quot; + country;
        }
    }
</code></pre><blockquote>
<p>xml配置文件 </p>
</blockquote>
<pre><code>&lt;bean id=&quot;baseBean&quot; class=&quot;com.demo.Model.Customer&quot;&gt;
    &lt;property name=&quot;country&quot; value=&quot;China&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;customerBean&quot; parent=&quot;baseBean&quot;&gt;
    &lt;property name=&quot;action&quot; value=&quot;buy&quot;/&gt;
    &lt;property name=&quot;type&quot; value=&quot;1&quot;/&gt;
&lt;/bean&gt;
</code></pre><blockquote>
<p>这样子类的country字段就变成China了 运行结果如下: </p>
</blockquote>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15086384239944.jpg" alt=""></p>
<blockquote>
<p>抽象继承 </p>
</blockquote>
<p>抽象继承也分为两种，一般抽象继承和纯抽象继承 </p>
<p>抽象继承的目的是为了父类只提供属性模板而不可被实例化，直接抽象继承很简单，只需要在父类后面加一个<code>abstract=&quot;true&quot;</code>即可 </p>
<pre><code>&lt;bean id=&quot;baseBean&quot; class=&quot;com.demo.Model.Customer&quot; abstract=&quot;true&quot;&gt;
    &lt;property name=&quot;country&quot; value=&quot;China&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;customerBean&quot; parent=&quot;baseBean&quot;&gt;
    &lt;property name=&quot;action&quot; value=&quot;buy&quot;/&gt;
    &lt;property name=&quot;type&quot; value=&quot;1&quot;/&gt;
&lt;/bean&gt;
</code></pre><p>纯抽象继承允许父类不设置class，只是为了共享字段使用 </p>
<pre><code>&lt;bean id=&quot;baseBean&quot; abstract=&quot;true&quot;&gt;
    &lt;property name=&quot;country&quot; value=&quot;China&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;customerBean&quot; parent=&quot;baseBean&quot; class=&quot;com.demo.Model.Customer&quot;&gt;
    &lt;property name=&quot;action&quot; value=&quot;buy&quot;/&gt;
    &lt;property name=&quot;type&quot; value=&quot;1&quot;/&gt;
&lt;/bean&gt;
</code></pre><ul>
<li>父类的属性值在子类中可以被覆盖</li>
</ul>
<p>##依赖检查(感觉4.x这个功能不被支持，更多的使用注解完成(如@Required字段)) </p>
<blockquote>
<p>当我们在xml配置文件中没有对属性值进行赋值时，一般不会报错，如果我们需要它报错，就要用到依赖检查这个功能(<code>dependency-check</code>)<br>依赖检查分为四种 none(默认) simple objects all </p>
</blockquote>
<p>默认方式为none，即他不会检查是否赋值 </p>
<p>simple方式只检查基本数据类型(int, long,double…)和集合类型(map, list..)，如果以上任何属性都没有设置，UnsatisfiedDependencyException将被抛出 </p>
<p>objects方式检查对象类型的数据 </p>
<p>all检查任何类型的数据 </p>
<blockquote>
<p>举一个objects的例子 </p>
</blockquote>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-2.5.xsd&quot;&gt;

    &lt;bean id=&quot;CustomerBean&quot; class=&quot;com.demo.Model.Customer&quot; 
            dependency-check=&quot;objects&quot;&gt;
        &lt;property name=&quot;action&quot; value=&quot;buy&quot; /&gt;
        &lt;property name=&quot;type&quot; value=&quot;1&quot; /&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;PersonBean&quot; class=&quot;com.demo.Model.Person&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;RenBuRuGu&quot; /&gt;
        &lt;property name=&quot;address&quot; value=&quot;address ABC&quot; /&gt;
        &lt;property name=&quot;age&quot; value=&quot;20&quot; /&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre><p>这里我们漏掉了person的注入，由于使用objects的依赖检查方式，将会收到UnsatisfiedDependencyException报错 </p>
<h2 id="Required注解"><a href="#Required注解" class="headerlink" title="@Required注解"></a>@Required注解</h2><blockquote>
<p>对于必须的字段我们可以采用@Required注解的方式 </p>
</blockquote>
<pre><code>public class Customer 
{
    private Person person;
    private int type;
    private String action;

    public Person getPerson() {
        return person;
    }

    @Required
    public void setPerson(Person person) {
        this.person = person;
    }
}
</code></pre><p>还要在xml配置文件中打开annotation注解，像以前一样，有两种方式 </p>
<p><code>&lt;context:annotation-config/&gt;</code>和<code>&lt;bean class=&quot;org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor&quot;/&gt;</code></p>
<h2 id="自定义required注解-个人感觉没什么用…"><a href="#自定义required注解-个人感觉没什么用…" class="headerlink" title="自定义required注解(个人感觉没什么用…)"></a>自定义required注解(个人感觉没什么用…)</h2><blockquote>
<p>首先自定义一个注解 </p>
</blockquote>
<pre><code>import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Mandatory {
}
</code></pre><blockquote>
<p>现在我们可以在业务逻辑中使用它 </p>
</blockquote>
<pre><code>public class Customer 
{
    private Person person;
    private int type;
    private String action;

    @Mandatory
    public void setPerson(Person person) {
        this.person = person;
    }

}
</code></pre><blockquote>
<p>最后需要在xml中去注册它 </p>
</blockquote>
<pre><code>&lt;bean class=&quot;org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor&quot;&gt;
    &lt;property name=&quot;requiredAnnotationType&quot; value=&quot;com.demo.Annotation.Mandatory&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;CustomerBean&quot; class=&quot;com.demo.Model.Customer&quot;&gt;
    &lt;property name=&quot;action&quot; value=&quot;buy&quot; /&gt;
    &lt;property name=&quot;type&quot; value=&quot;1&quot; /&gt;
&lt;/bean&gt;
</code></pre><h2 id="InitializingBean和DisposableBean接口"><a href="#InitializingBean和DisposableBean接口" class="headerlink" title="InitializingBean和DisposableBean接口"></a>InitializingBean和DisposableBean接口</h2><p>这两个接口在我理解中是两个钩子，分别用在bean初始化完成和即将被销毁时调用<br>InitializingBean中的afterPropertiesSet()用于执行初始化方法<br>DisposableBean中的destroy()用于执行bean被容器销毁之前的操作 </p>
<pre><code>Person.java

package com.demo.Model;

import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.InitializingBean;

public class Person implements InitializingBean,DisposableBean {
    private int age;
    private String name;
    private String address;

    @Override
    public void destroy() throws Exception {
        System.out.println(&quot;Destroy&quot;);
    }

    @Override
    public void afterPropertiesSet() throws Exception {
        System.out.println(&quot;Init&quot;);
    }
}

App.java

public class App {
    public static void main(String[] args) {
        ConfigurableApplicationContext context = new ClassPathXmlApplicationContext(&quot;Spring-Beans.xml&quot;);

        Person person = context.getBean(Person.class);

        context.close();
    }
}
</code></pre><p>运行结果如下: </p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15086423947200.jpg" alt=""></p>
<p>官方不推荐这么做，我也不推荐，因为如果钩子方法都写在业务代码中，就违反了Spring的低耦合机制，业务代码和Spring容器的耦合度大大加强。 </p>
<h2 id="init-method和destroy-method"><a href="#init-method和destroy-method" class="headerlink" title="init-method和destroy-method"></a>init-method和destroy-method</h2><blockquote>
<p>不继承接口，我们单纯的写两个方法，然后在xml配置文件中将他们指定为初始化和销毁之前执行的方法 </p>
</blockquote>
<pre><code>package com.demo.Model;

import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.InitializingBean;

public class Person{
    private int age;
    private String name;
    private String address;

    public void destroy() throws Exception {
        System.out.println(&quot;Destroy&quot;);
    }

    public void init() throws Exception {
        System.out.println(&quot;Init&quot;);
    }
}
</code></pre><blockquote>
<p>我们在xml中手动管理 </p>
</blockquote>
<pre><code>&lt;bean id=&quot;person&quot; class=&quot;com.demo.Model.Person&quot;
        init-method=&quot;init&quot;
        destroy-method=&quot;destroy&quot;
        p:name=&quot;RenBuRuGu&quot;
        p:age=&quot;20&quot;
        p:address=&quot;JiangSu NanJing&quot;/&gt;
</code></pre><ul>
<li><p>@PostConstruct 和 @PreDestroy可以帮我们达到同样的目的 当然前提是需要在xml中开启注解</p>
<p>package com.demo.Model;</p>
<p>import org.springframework.beans.factory.DisposableBean;<br>import org.springframework.beans.factory.InitializingBean;</p>
<p>import javax.annotation.PostConstruct;<br>import javax.annotation.PreDestroy;</p>
<p>public class Person{</p>
<pre><code>private int age;
private String name;
private String address;

@PreDestroy
public void destroy() throws Exception {
    System.out.println(&quot;Destroy&quot;);
}

@PostConstruct
public void init() throws Exception {
    System.out.println(&quot;Init&quot;);
}
</code></pre><p>}</p>
</li>
</ul>
<p>xml中不需要写init和destroy方法 </p>
<h2 id="Spring中的EL表达式"><a href="#Spring中的EL表达式" class="headerlink" title="Spring中的EL表达式"></a>Spring中的EL表达式</h2><p>el表达式可以简化代码量，我觉得还是很有必要了解的 </p>
<p>1、在使用PropertyPlaceholderConfigurer从properties文件引入配置信息时，使用<code>${SpEL expression}</code>来引用<br>2、引用同一xml中的其他bean的属性,使用<code>#{SpEL expression}</code></p>
<pre><code>&lt;bean id=&quot;itemBean&quot; class=&quot;com.demo.Model.Item&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;RenBuRuGu&quot;/&gt;
    &lt;property name=&quot;qty&quot; value=&quot;10&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;customer&quot; class=&quot;com.demo.Model.Customer&quot;&gt;
    &lt;property name=&quot;item&quot; value=&quot;#{itemBean}&quot;/&gt;
    &lt;property name=&quot;itemName&quot; value=&quot;#{itemBean.name}&quot;/&gt;
&lt;/bean&gt;
</code></pre><p>Spring EL也可以使用纯注解的方式完成，但是有几个前提<br>1、每一个bean使用Component注解(个人理解相当于xml中配置bean)<br>2、相应的字段增加@Value注解，Spring EL表达式写在注解中<br>3、xml配置文件中开启自动扫描Components </p>
<blockquote>
<p>item.java </p>
</blockquote>
<pre><code>package com.demo.Model;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component(&quot;itemBean&quot;)
public class Item {
    @Value(&quot;RenBuRuGu&quot;)
    private String name;

    @Value(&quot;10&quot;)
    private int qty;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getQty() {
        return qty;
    }

    public void setQty(int qty) {
        this.qty = qty;
    }

    @Override
    public String toString() {
        return name + &quot;  &quot; + qty;
    }
}
</code></pre><blockquote>
<p>Customer.java </p>
</blockquote>
<pre><code>package com.demo.Model;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component(&quot;customerBean&quot;)
public class Customer {

    @Value(&quot;#{itemBean}&quot;)
    private Item item;

    @Value(&quot;#{itemBean.name}&quot;)
    private String itemName;

    public Item getItem() {
        return item;
    }

    public void setItem(Item item) {
        this.item = item;
    }

    public String getItemName() {
        return itemName;
    }

    public void setItemName(String itemName) {
        this.itemName = itemName;
    }

    @Override
    public String toString() {
        return item + &quot;  &quot; + itemName;
    }
}
</code></pre><blockquote>
<p>Spring-Beans.xml </p>
</blockquote>
<pre><code>&lt;context:component-scan base-package=&quot;com.demo.Model&quot;/&gt;
</code></pre><ul>
<li>EL表达式可以直接引用Entity实例、属性和方法，也可以执行java内置的方法，运算符和三元表达式</li>
<li><p>EL表达式中的正则匹配 可以简单的使用<code>matches</code>关键字</p>
<p>@Component(“customerBean”)<br>public class Customer {</p>
</li>
</ul>
<pre><code>    String emailRegEx = &quot;^[_A-Za-z0-9-]+(\\.[_A-Za-z0-9-]+)&quot; +
                &quot;*@[A-Za-z0-9]+(\\.[A-Za-z0-9]+)*(\\.[A-Za-z]{2,})$&quot;;


    @Value(&quot;#{&#39;100&#39; matches &#39;\\d+&#39; }&quot;)
    private boolean validDigit;


    @Value(&quot;#{ (&#39;100&#39; matches &#39;\\d+&#39;) == true ? &quot; +
                &quot;&#39;yes this is digit&#39; : &#39;No this is not a digit&#39;  }&quot;)
    private String msg;


    @Value(&quot;#{emailBean.emailAddress matches customerBean.emailRegEx}&quot;)
    private boolean validEmail;


}
</code></pre><h3 id="ExpressionParser-不知道有什么用…"><a href="#ExpressionParser-不知道有什么用…" class="headerlink" title="ExpressionParser(不知道有什么用…)"></a>ExpressionParser(不知道有什么用…)</h3><p>看意思好像大概也许是提取字符并转化成相应的数据类型 </p>
<pre><code>ExpressionParser parser = new SpelExpressionParser();
Expression exp = parser.parseExpression(&quot;&#39;put spel expression here&#39;&quot;);
String msg = exp.getValue(String.class);
</code></pre><p>下面给个例子自己感受一下 </p>
<pre><code>import org.springframework.expression.Expression;
import org.springframework.expression.ExpressionParser;
import org.springframework.expression.spel.standard.SpelExpressionParser;
import org.springframework.expression.spel.support.StandardEvaluationContext;

public class App {
    public static void main(String[] args) {

        ExpressionParser parser = new SpelExpressionParser();

        Expression exp = parser.parseExpression(&quot;&#39;Hello World&#39;&quot;);
        String msg1 = exp.getValue(String.class);
        System.out.println(msg1);

        Expression exp2 = parser.parseExpression(&quot;&#39;Hello World&#39;.length()&quot;);  
        int msg2 = (Integer) exp2.getValue();
        System.out.println(msg2);

        Expression exp3 = parser.parseExpression(&quot;100 * 2&quot;);  
        int msg3 = (Integer) exp3.getValue();
        System.out.println(msg3);

        Item item = new Item(&quot;RenBuRuGu&quot;, 100);

        StandardEvaluationContext itemContext = new StandardEvaluationContext(item);


        Expression exp4 = parser.parseExpression(&quot;name&quot;);
        String msg4 = exp4.getValue(itemContext, String.class);
        System.out.println(msg4);

        Expression exp5 = parser.parseExpression(&quot;name == &#39;RenBuRuGu&#39;&quot;);
        boolean msg5 = exp5.getValue(itemContext, Boolean.class);
        System.out.println(msg5);

    }
}
</code></pre><h2 id="Spring自动扫描组件"><a href="#Spring自动扫描组件" class="headerlink" title="Spring自动扫描组件"></a>Spring自动扫描组件</h2><p>Spring的业务逻辑分为好多层(DAO,Service,Controller,Views)，主要目的还是为了解耦 </p>
<blockquote>
<p>一般我们都会通过xml的方式来注册组件<br>Dao层<br>首先创建一个CustomerDao </p>
</blockquote>
<pre><code>package com.demo.Dao;

public class CustomerDao {
    @Override
    public String toString() {
        return &quot;Hello, This is CustomerDao&quot;;
    }
}
</code></pre><blockquote>
<p>Service层实现业务逻辑 </p>
</blockquote>
<pre><code>package com.demo.Service;

import com.demo.Dao.CustomerDao;

public class CustomerService {
    CustomerDao customerDao;

    public void setCustomerDao(CustomerDao customerDao) {
        this.customerDao = customerDao;
    }

    @Override
    public String toString() {
        return &quot;CustomerService [ customerDao = &quot; +  customerDao + &quot; ]&quot;;
    }
}
</code></pre><blockquote>
<p>xml注册bean </p>
</blockquote>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-4.0.xsd&quot;&gt;
    &lt;bean id=&quot;customerDao&quot; class=&quot;com.demo.Dao.CustomerDao&quot;/&gt;

    &lt;bean id=&quot;customerService&quot; class=&quot;com.demo.Service.CustomerService&quot;&gt;
        &lt;property name=&quot;customerDao&quot; ref=&quot;customerDao&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre><blockquote>
<p>测试函数 </p>
</blockquote>
<pre><code>package com.demo;

import com.demo.Service.CustomerService;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class App {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;Spring-Beans.xml&quot;);

        CustomerService service = context.getBean(CustomerService.class);

        System.out.println(service);
    }
}
</code></pre><p>运行结果如下: </p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15086548386608.jpg" alt=""></p>
<p>这是一般做法 </p>
<blockquote>
<p>我们还可以通过自动扫描组件来完成相同的工作 </p>
</blockquote>
<p>像之前所说，给所有的实体类加上@Components注解，通过注解的方式注册实体类 </p>
<pre><code>CustomerDao.java

package com.demo.Dao;

import org.springframework.stereotype.Component;

@Component
public class CustomerDao {
    @Override
    public String toString() {
        return &quot;Hello, This is CustomerDao&quot;;
    }
}

CustomerService.java

package com.demo.Service;

import com.demo.Dao.CustomerDao;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class CustomerService {
    private CustomerDao customerDao;

    @Autowired
    public void setCustomerDao(CustomerDao customerDao) {
        this.customerDao = customerDao;
    }

    @Override
    public String toString() {
        return &quot;CustomerService [ customerDao = &quot; +  customerDao + &quot; ]&quot;;
    }
}
</code></pre><blockquote>
<p>然后在xml中开启自动扫描beans </p>
</blockquote>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;context:component-scan base-package=&quot;com.demo&quot;/&gt;
&lt;/beans&gt;
</code></pre><p>运行结果相同 </p>
<p>为了区分开功能不同的各个模块，Spring官方给出了四种注解 </p>
<pre><code>@Component – 指示自动扫描组件。
@Repository – 表示在持久层DAO组件。
@Service – 表示在业务层服务组件。
@Controller – 表示在表示层控制器组件。
</code></pre><p>所有的注解最后都会被编译为Components，但是这样就可以很好的区分业务层和持久层的组件 </p>
<blockquote>
<p>附上代码 </p>
</blockquote>
<pre><code>CustomerDao.java

package com.demo.Dao;

import org.springframework.stereotype.Repository;

@Repository
public class CustomerDao {
    @Override
    public String toString() {
        return &quot;Hello, This is CustomerDao&quot;;
    }
}

CustomerService.java

package com.demo.Service;

import com.demo.Dao.CustomerDao;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class CustomerService {
    private CustomerDao customerDao;

    @Autowired
    public void setCustomerDao(CustomerDao customerDao) {
        this.customerDao = customerDao;
    }

    @Override
    public String toString() {
        return &quot;CustomerService [ customerDao = &quot; +  customerDao + &quot; ]&quot;;
    }
}
</code></pre><h3 id="component-scan过滤器的使用"><a href="#component-scan过滤器的使用" class="headerlink" title="component-scan过滤器的使用"></a>component-scan过滤器的使用</h3><p>过滤器有两种(include-filter和exclude-filter)，顾名思义，一个是包含的过滤器另一个则是排除的过滤器.<br>filter可以通过很多种方式进行过滤,有以下几种类型: </p>
<pre><code>annotation  注解方式
regix       正则表达式
custom      自定义方式
assignable  未知.....
aspectj     切片方式(面向切片编程)
</code></pre><blockquote>
<p>通过正则过滤 </p>
</blockquote>
<pre><code>&lt;context:component-scan base-package=&quot;com.yiibai&quot; &gt;

    &lt;context:include-filter type=&quot;regex&quot; 
                    expression=&quot;com.demo.Dao.*DAO.*&quot; /&gt;

    &lt;context:include-filter type=&quot;regex&quot; 
                    expression=&quot;com.demo.Services.*Service.*&quot; /&gt;

&lt;/context:component-scan&gt;
</code></pre><p>通过include的方式，Spring只会扫描在com.demo.Dao和com.demo.Service包下面名为_Dao._和_Service._的文件 </p>
<blockquote>
<p>通过annotation注解的方式 </p>
</blockquote>
<pre><code>&lt;context:component-scan base-package=&quot;com.demo&quot;&gt;
    &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Service&quot;/&gt;
&lt;/context:component-scan&gt;
</code></pre><p>通过exclude-filter方式，所有@Service注解的entity将会被Spring忽略 </p>
<h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><ul>
<li>面向接口编程</li>
</ul>
<p>我们首先来创建一个简单的小例子 </p>
<blockquote>
<p>创建Service层 </p>
</blockquote>
<pre><code>CustomerService.java

package com.demo.Service;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

@Service
public class CustomerService {

    @Value(&quot;RenBuRuGu&quot;)
    private String name;

    @Value(&quot;https://wangyu1997.github.io/&quot;)
    private String url;

    public void printName() {
        System.out.println(&quot;Customer name: &quot; + this.name);
    }

    public void printUrl() {
        System.out.println(&quot;Customer url: &quot; + this.url);
    }

    public void printThrowException() {
        throw new IllegalArgumentException();
    }
}
</code></pre><blockquote>
<p>创建入口测试函数 </p>
</blockquote>
<pre><code>package com.demo;

import com.demo.Service.CustomerService;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

@Configuration
@ComponentScan({&quot;com.demo.Service&quot;})
public class App {
    public static void main(String[] args) {
        ApplicationContext context = new AnnotationConfigApplicationContext(App.class);

        CustomerService customerService = context.getBean(CustomerService.class);

        customerService.printName();
        customerService.printUrl();
        customerService.printThrowException();
    }
}
</code></pre><p>运行结果如下: </p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15086575392576.jpg" alt=""></p>
<blockquote>
<p>通过注解的方式加入AOP </p>
</blockquote>
<p>1、之前通知 </p>
<p>首先实现MethodBeforeAdvice方法 </p>
<pre><code>@Component(&quot;heiBeforeMethod&quot;)
public class HiBeforeMethod implements MethodBeforeAdvice {
    @Override
    public void before(Method method, Object[] args, @Nullable Object target) throws Throwable {
        System.out.println(&quot;Method Before:  Hey Spring AOP !&quot;);
    }
}
</code></pre><p>在配置文件中注册一个代理bean </p>
<pre><code>@Configuration
public class CustomerServiceProxy {

    @Bean(&quot;customerServiceProxy&quot;)
    public ProxyFactoryBean proxyFactoryBean() {
        ProxyFactoryBean bean = new ProxyFactoryBean();
        bean.setTargetName(&quot;customerService&quot;);
        bean.setInterceptorNames(&quot;heiBeforeMethod&quot;);

        return bean;
    }

}
</code></pre><p>测试类中调用 </p>
<pre><code>@Configuration
@ComponentScan({&quot;com.demo.Service&quot;,&quot;com.demo.Impl&quot;})
@Import({CustomerServiceProxy.class})
public class App {
    public static void main(String[] args) {
        ApplicationContext context = new AnnotationConfigApplicationContext(App.class);
        CustomerService customerService = (CustomerService) context.getBean(&quot;customerServiceProxy&quot;);

        customerService.printName();
        customerService.printUrl();
        try {
            customerService.printThrowException();
        }catch (IllegalArgumentException e){
            System.out.println(&quot;Throw exception...&quot;);
        }
    }
}
</code></pre><p>注意这里的引用不再是<code>customerService</code>而是<code>customerServiceProxy</code></p>
<p>运行结果如下: </p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15086609643673.jpg" alt=""></p>
<p>2、返回后通知 </p>
<p>通过重写AfterReturningAdvice的afterReturning方法来实现功能 </p>
<blockquote>
<p>接着上面再加一个类 </p>
</blockquote>
<pre><code>package com.demo.Impl;

import org.springframework.aop.AfterReturningAdvice;
import org.springframework.lang.Nullable;
import org.springframework.stereotype.Component;

import java.lang.reflect.Method;

@Component(&quot;afterReturn&quot;)
public class AfterReturn implements AfterReturningAdvice {
    @Override
    public void afterReturning(@Nullable Object returnValue, Method method, Object[] args, @Nullable Object target) throws Throwable {
        System.out.println(&quot;Spring after returning: Spring AOP!&quot;);
    }
}
</code></pre><blockquote>
<p>CustomerServiceProxy中InterceptorNames加入该类 </p>
</blockquote>
<p><code>bean.setInterceptorNames(&quot;afterReturn&quot;,&quot;heiBeforeMethod&quot;);</code></p>
<p>运行结果如下: </p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15086613289318.jpg" alt=""></p>
<p>3、抛出后通知，即方法抛出异常后调用 </p>
<p>同上，新建一个类实现ThrowsAdvice的afterThrowing方法即可 </p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15086615601291.jpg" alt=""></p>
<p>不过，我感觉，可能是在新版本中被删除了吧… </p>
<p>4、环绕通知 </p>
<p>我感觉这种方式十分强大，首先实现MethodInterceptor的invoke方法，这里用到了反射 </p>
<pre><code>package com.demo.Impl;

import org.aopalliance.intercept.MethodInterceptor;
import org.aopalliance.intercept.MethodInvocation;
import org.springframework.stereotype.Component;

import java.util.Arrays;

@Component(&quot;aroundMethod&quot;)
public class AroundMethod implements MethodInterceptor {
    @Override
    public Object invoke(MethodInvocation invocation) throws Throwable {
        System.out.println(&quot;Method name : &quot; + invocation.getMethod().getName());
        System.out.println(&quot;Method arguments : &quot; + Arrays.toString(invocation.getArguments()));

        System.out.println(&quot;Around: Method Before&quot;);
        try {
            Object result = invocation.proceed();

            System.out.println(&quot;Around: Method After&quot;);

            return result;
        } catch (Exception ignored) {
            System.out.println(&quot;Around: Method Exception&quot;);

            throw ignored;
        }
    }
}
</code></pre><p>运行结果如下: </p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15086622863646.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Spring </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Spring </tag>
            
            <tag> AspectJ </tag>
            
            <tag> PropertyPlaceholderConfigurer </tag>
            
            <tag> Spring AOP </tag>
            
            <tag> dependency </tag>
            
            <tag> inheritance </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[学习Spring第三天]]></title>
      <url>/2017/10/21/Spring/JdbcTemplate/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a>  
<h2 id="JdbcTemplate"><a href="#JdbcTemplate" class="headerlink" title="JdbcTemplate"></a>JdbcTemplate</h2><hr>
<blockquote>
<p>原始的jdbc </p>
</blockquote>
<pre><code>public void insert(Customer customer) {
    String sql = &quot;INSERT INTO customer(CUST_ID,NAME,AGE) VALUES(?,?,?)&quot;;
    Connection conn = null;

    try {
        conn = dataSource.getConnection();
        PreparedStatement ps = conn.prepareStatement(sql);
        ps.setInt(1, customer.getCusId());
        ps.setString(2, customer.getName());
        ps.setInt(3, customer.getAge());
        ps.executeUpdate();
        ps.close();
    } catch (SQLException e) {
        e.printStackTrace();
    } finally {
        if (conn != null) {
            try {
                conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }
}
</code></pre><blockquote>
<p>改用JdbcTemplate方法 </p>
</blockquote>
<pre><code>private DataSource dataSource;
private JdbcTemplate jdbcTemplate;

public void setDataSource(DataSource dataSource) {
    this.dataSource = dataSource;
}

@Override
public void insert(Customer customer) {
    String sql = &quot;INSERT INTO customer(CUST_ID,NAME,AGE) VALUES(?,?,?)&quot;;

    jdbcTemplate = new JdbcTemplate(dataSource);
    jdbcTemplate.update(sql,customer.getCusId(),customer.getName(),customer.getAge());
}
</code></pre><p>瞬间感觉代码量少了很多，对比之前复杂的原生操作，jdbctemplate还是很容易理解的 </p>
<blockquote>
<p>JdbcDaoSupport </p>
</blockquote>
<pre><code>public class JdbcCustomerDao extends JdbcDaoSupport implements CustomerDao {


    @Override
    public void insert(Customer customer) {
        String sql = &quot;INSERT INTO customer(CUST_ID,NAME,AGE) VALUES(?,?,?)&quot;;

        getJdbcTemplate().update(sql, customer.getCusId(), customer.getName(), customer.getAge());
    }

    @Override
    public Customer findByCustomerId(int cusId) {
        String sql = &quot;SELECT * FROM customer WHERE CUST_ID = ?&quot;;
        List&lt;Customer&gt; customers = new ArrayList&lt;&gt;();
        getJdbcTemplate().query(sql, new Object[]{cusId}, new RowCallbackHandler() {
            Customer customer;

            @Override
            public void processRow(ResultSet rs) throws SQLException {
                customer = new Customer(rs.getInt(&quot;CUST_ID&quot;), rs.getString(&quot;NAME&quot;), rs.getInt(&quot;AGE&quot;));
                customers.add(customer);
            }
        });
        return customers.get(0);
    }
}
</code></pre><hr>
<h2 id="自定义RowMapper"><a href="#自定义RowMapper" class="headerlink" title="自定义RowMapper"></a>自定义RowMapper</h2><p>JdbcTemplate推荐使用自定义的RowMapper进行字段的映射 </p>
<blockquote>
<p>我们自定义一个Mapper </p>
</blockquote>
<pre><code>package com.demo.Mapper;

import com.demo.Model.Customer;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.lang.Nullable;

import java.sql.ResultSet;
import java.sql.SQLException;

public class CustomerRowMapper implements RowMapper&lt;Customer&gt; {
    @Nullable
    @Override
    public Customer mapRow(ResultSet rs, int rowNum) throws SQLException {
        Customer customer = new Customer();
        customer.setCusId(rs.getInt(&quot;CUST_ID&quot;));
        customer.setName(rs.getString(&quot;NAME&quot;));
        customer.setAge(rs.getInt(&quot;AGE&quot;));

        return customer;
    }
}
</code></pre><blockquote>
<p>FindByCustomerId方法可以重写了 </p>
</blockquote>
<pre><code>@Override
public Customer findByCustomerId(int cusId) {
    String sql = &quot;SELECT * FROM customer WHERE CUST_ID = ?&quot;;
    List&lt;Customer&gt; customers = new ArrayList&lt;&gt;();
    customers = getJdbcTemplate().query(sql, new Object[]{cusId}, new RowMapperResultSetExtractor&lt;&gt;(new CustomerRowMapper()));
    return customers.get(0);
}
</code></pre><p>运行结果也是不变的.<br>如果我们想限制数量可以在RowMapperResultSetExtractor加上第二的参数，表示查询的数量，为1时则为单个实体类，其他的情况下是该实体类的List集合 </p>
<blockquote>
<p>Example </p>
</blockquote>
<pre><code>JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);  
RowMapper rowMapper = new UserRowMapper();  

List allUsers = (List) jdbcTemplate.query(
        &quot;select * from user&quot;,
        new RowMapperResultSetExtractor(rowMapper, 10));

User user = (User) jdbcTemplate.queryForObject(
        &quot;select * from user where id=?&quot;, new Object[] {id},
        new RowMapperResultSetExtractor(rowMapper, 1));
</code></pre><blockquote>
<p>BeanPropertyRowMapper </p>
</blockquote>
<p>当Entity属性的名称和数据表的字段名称一致的时候可以用BeanPropertyRowMapper来进行映射 </p>
<pre><code>customers = getJdbcTemplate().query(sql, new Object[]{cusId}, new BeanPropertyRowMapper&lt;&gt;(Customer.class));
</code></pre><blockquote>
<p>batchUpdate的用法 </p>
</blockquote>
<p>当我们需要批量操作(同时插入多个值),重复调用相同的方法会显得相当麻烦,这时我们可以使用batchUpdate方法 </p>
<p>我们写一个批量插入的方法 </p>
<pre><code>public void insertBatch(List&lt;Customer&gt; customers) {
    String sql = &quot;INSERT INTO customer(CUST_ID,NAME,AGE) VALUES(?,?,?)&quot;;

    getJdbcTemplate().batchUpdate(sql, new BatchPreparedStatementSetter() {
        @Override
        public void setValues(PreparedStatement ps, int i) throws SQLException      {
            Customer customer = customers.get(i);
            ps.setInt(1, customer.getCustId());
            ps.setString(2, customer.getName());
            ps.setInt(3, customer.getAge());
        }

        @Override
        public int getBatchSize() {
            return customers.size();
        }
    });
}
</code></pre><p>这里使用了jdbcTemplate的batchUpdate方法,通过第二个参数设置字段映射.当你的字段与数据库字段一致时可以省略 </p>
<p>记录一下JdbcDaoSupport的用法 </p>
<blockquote>
<p>原生sql语句执行 </p>
</blockquote>
<pre><code>jdbcTemplate.execute(&quot;CREATE TABLE USER (user_id integer, name varchar(100))&quot;);
</code></pre><blockquote>
<p>如果是UPDATE或INSERT,可以用update()方法 </p>
</blockquote>
<pre><code>jdbcTemplate.update(&quot;INSERT INTO USER VALUES(&#39;&quot;  
        + user.getId() + &quot;&#39;, &#39;&quot;  
        + user.getName() + &quot;&#39;, &#39;&quot;  
        + user.getSex() + &quot;&#39;, &#39;&quot;  
        + user.getAge() + &quot;&#39;)&quot;);
</code></pre><blockquote>
<p>带参数的更新 </p>
</blockquote>
<pre><code>jdbcTemplate.update(&quot;UPDATE USER SET name = ? WHERE user_id = ?&quot;, new Object[] {name, id});

jdbcTemplate.update(&quot;INSERT INTO USER VALUES(?, ?, ?, ?)&quot;, new Object[] {user.getId(), user.getName(), user.getSex(), user.getAge()});
</code></pre><blockquote>
<p>使用JdbcTemplate进行查询时，使用queryForXXX()等方法 </p>
</blockquote>
<pre><code>int count = jdbcTemplate.queryForInt(&quot;SELECT COUNT(*) FROM USER&quot;);

String name = (String) jdbcTemplate.queryForObject(&quot;SELECT name FROM USER WHERE user_id = ?&quot;, new Object[] {id}, java.lang.String.class);
</code></pre><blockquote>
<p>使用iterator迭代器查询 </p>
</blockquote>
<pre><code>List rows = jdbcTemplate.queryForList(&quot;SELECT * FROM USER&quot;);  

List rows = jdbcTemplate.queryForList(&quot;SELECT * FROM USER&quot;);  
Iterator it = rows.iterator();  
while(it.hasNext()) {  
    Map userMap = (Map) it.next();  
    System.out.print(userMap.get(&quot;user_id&quot;) + &quot;\t&quot;);  
    System.out.print(userMap.get(&quot;name&quot;) + &quot;\t&quot;);  
    System.out.print(userMap.get(&quot;sex&quot;) + &quot;\t&quot;);  
    System.out.println(userMap.get(&quot;age&quot;) + &quot;\t&quot;);  
}
</code></pre><blockquote>
<p>在update或者query时还可以通过callback回调设置你的字段 </p>
</blockquote>
<pre><code>final String id = user.getId();  
final String name = user.getName();  
final String sex = user.getSex() + &quot;&quot;;  
final int age = user.getAge();  

jdbcTemplate.update(&quot;INSERT INTO USER VALUES(?, ?, ?, ?)&quot;,  
                    new PreparedStatementSetter() {  
                        public void setValues(PreparedStatement ps) throws SQLException {  
                                ps.setString(1, id);  
                                ps.setString(2, name);            
                                ps.setString(3, sex);  
                                ps.setInt(4, age);  
                                }  
                        });


final User user = new User();  
jdbcTemplate.query(&quot;SELECT * FROM USER WHERE user_id = ?&quot;,  
                    new Object[] {id},  
                    new RowCallbackHandler() {  
                        public void processRow(ResultSet rs) throws SQLException {  
                                user.setId(rs.getString(&quot;user_id&quot;));  
                                user.setName(rs.getString(&quot;name&quot;));  
                                user.setSex(rs.getString(&quot;sex&quot;).charAt(0));  
                                user.setAge(rs.getInt(&quot;age&quot;));  
                        }  
                    });
</code></pre><blockquote>
<p>RowMapper </p>
</blockquote>
<pre><code>class UserRowMapper implements RowMapper {  
    public Object mapRow(ResultSet rs, int index) throws SQLException {  
        User user = new User();  

        user.setId(rs.getString(&quot;user_id&quot;));  
        user.setName(rs.getString(&quot;name&quot;));  
        user.setSex(rs.getString(&quot;sex&quot;).charAt(0));  
        user.setAge(rs.getInt(&quot;age&quot;));  

        return user;  
    }  
}  

public List findAllByRowMapperResultReader() {  
    String sql = &quot;SELECT * FROM USER&quot;;  
    return jdbcTemplate.query(sql, new RowMapperResultReader(new UserRowMapper()));  
}



public User getUser(final String id) throws DataAccessException {  
    String sql = &quot;SELECT * FROM USER WHERE user_id=?&quot;;  
    final Object[] params = new Object[] { id };  
    List list = jdbcTemplate.query(sql, params, new RowMapperResultReader(new UserRowMapper()));  

    return (User) list.get(0);  
}
</code></pre><hr>
<h2 id="Spring自动装配Beans"><a href="#Spring自动装配Beans" class="headerlink" title="Spring自动装配Beans"></a>Spring自动装配Beans</h2><p>Spring对于Bean采用自动装配(AueoWire)机制<br>分为五种： </p>
<pre><code>1、no 省缺情况下，通过ref属性绑定     
2、byName 根据属性名自动装配 如果一个property的name和另一个bean的id相同，Spring将会自动装配  
3、byType 根据属性数据类型自动装配 如果一个property的属性和另一个bean的数据类型相同，Spring将会自动装配   
4、construtor 对于构造函数的属性使用byType方式    
5、autodetect 如果找到默认的构造函数采用“自动装配使用构造”，否则使用“按类型装配”
</code></pre><p>这里演示使用constructor的方式 </p>
<blockquote>
<p>Person Model </p>
</blockquote>
<pre><code>package com.demo.Model;

public class Person {
    private String name;
    private int age;
    private String address;

    public Person() {
    }

    public Person(String name, int age, String address) {
        this.name = name;
        this.age = age;
        this.address = address;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }
}
</code></pre><blockquote>
<p>Customer Model </p>
</blockquote>
<pre><code>package com.demo.Model;

public class Customer {
    private Person person;

    public Customer(Person person) {
        this.person = person;
    }

    public Person getPerson() {
        return person;
    }

    public void setPerson(Person person) {
        this.person = person;
    }
}
</code></pre><blockquote>
<p>在resources中加入配置文件Spring-Beans.xml </p>
</blockquote>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-4.0.xsd&quot;&gt;

    &lt;bean id=&quot;customer&quot; class=&quot;com.demo.Model.Customer&quot; autowire=&quot;constructor&quot;/&gt;

    &lt;bean id=&quot;person&quot; class=&quot;com.demo.Model.Person&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;RenBuRuGu&quot;/&gt;
        &lt;property name=&quot;age&quot; value=&quot;20&quot;/&gt;
        &lt;property name=&quot;address&quot; value=&quot;JiangSu NanJing&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre><blockquote>
<p>测试类App </p>
</blockquote>
<pre><code>package com.demo;

import com.demo.Model.Customer;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class App {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;Spring-Beans.xml&quot;);

        Customer customer = context.getBean(Customer.class);

        System.out.println(customer.getPerson().getAddress());
        System.out.println(customer.getPerson().getAge());
        System.out.println(customer.getPerson().getName());
    }
}
</code></pre><blockquote>
<p>运行结果如下: </p>
</blockquote>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15085762440587.jpg" alt=""></p>
<h3 id="AutoWired字段"><a href="#AutoWired字段" class="headerlink" title="@AutoWired字段"></a>@AutoWired字段</h3><blockquote>
<p>首先在beans中加入 </p>
<pre><code>&lt;context:annotation-config /&gt;
</code></pre></blockquote>
<p>或者 </p>
<pre><code>&lt;bean class=&quot;org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor&quot;/&gt;
</code></pre><blockquote>
<p>@AutoWired注解可以在属性、setter方法、或者构造方法中使用 </p>
</blockquote>
<p>Spring-Beans.xml </p>
<pre><code>&lt;context:annotation-config/&gt;

&lt;bean id=&quot;customer&quot; class=&quot;com.demo.Model.Customer&quot;/&gt;

&lt;bean id=&quot;person&quot; class=&quot;com.demo.Model.Person&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;RenBuRuGu&quot;/&gt;
    &lt;property name=&quot;age&quot; value=&quot;20&quot;/&gt;
    &lt;property name=&quot;address&quot; value=&quot;JiangSu NanJing&quot;/&gt;
&lt;/bean&gt;
</code></pre><blockquote>
<p>setter方法 </p>
</blockquote>
<pre><code>public class Customer {
    private Person person;

    public Person getPerson() {
            return person;
    }

    @Autowired
    public void setPerson(Person person) {
        this.person = person;
    }
}
</code></pre><blockquote>
<p>属性 </p>
</blockquote>
<pre><code>public class Customer {
    @Autowired
    private Person person;

    public Person getPerson() {
            return person;
    }
}
</code></pre><blockquote>
<p>构造方法 </p>
</blockquote>
<pre><code>public class Customer {

    private Person person;

    @Autowired
    public Customer(Person person) {
        this.person = person;
    }

    public Person getPerson() {
        return person;
    }
}
</code></pre><h3 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h3><blockquote>
<p>当自动装载的bean有冲突时，就可以用@Qualifier属性 </p>
</blockquote>
<pre><code>import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;

public class Customer {

    @Autowired
    @Qualifier(&quot;personA&quot;)
    private Person person;

}
</code></pre><h2 id="JavaConfig"><a href="#JavaConfig" class="headerlink" title="JavaConfig"></a>JavaConfig</h2><blockquote>
<p>我们之前注册bean都是通过xml注册的,形式如下: </p>
</blockquote>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-4.0.xsd&quot;&gt;

    &lt;bean id=&quot;helloBean&quot; class=&quot;com.demo.Model.HelloBean&quot;&gt;
        &lt;property name=&quot;id&quot; value=&quot;1&quot;/&gt;
        &lt;property name=&quot;content&quot; value=&quot;Hello Spring&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre><p>实体类代码如下: </p>
<pre><code>package com.demo.Model;

public class HelloBean {
    private int id;
    private String content;

    public void setId(int id) {
        this.id = id;
    }

    public void setContent(String content) {
        this.content = content;
    }

    public void print() {
        System.out.println(&quot;HelloBean:[ &quot; + id + &quot; &quot; + content + &quot; ]&quot;);
    }
}
</code></pre><p>我们写一个测试类来测试一下: </p>
<pre><code>package com.demo;

import com.demo.Model.HelloBean;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class App {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;Spring-Beans.xml&quot;);
        HelloBean helloBean = context.getBean(HelloBean.class);

        helloBean.print();
    }
}
</code></pre><p>输出结果如下: </p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15085829234470.jpg" alt=""></p>
<blockquote>
<p>我们也可以通过Spring注解的方式来用java代码完成配置 </p>
</blockquote>
<pre><code>package com.demo;

import com.demo.Model.HelloBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class AppConfig {
    @Bean(name = &quot;helloBean&quot;)
    public HelloBean helloBean(){
        HelloBean bean = new HelloBean();
        bean.setContent(&quot;Hello Spring&quot;);
        bean.setId(1);
        return bean;
    }
}
</code></pre><p>在Spring中，配置文件必须用configuration注解，相应的bean用@Bean注入 </p>
<p>相应的修改一下App测试类 </p>
<pre><code>import com.demo.Model.HelloBean;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class App {
    public static void main(String[] args) {

        ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);

        HelloBean helloBean = context.getBean(HelloBean.class);

        helloBean.print();
    }
}
</code></pre><p>输出结果完全一致 </p>
<h3 id="Import的使用"><a href="#Import的使用" class="headerlink" title="@Import的使用"></a>@Import的使用</h3><p>通常我们会把不同功能的配置文件分开到不同的xml中书写，然后统一在一个xml中导入进来，就像下面: </p>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-2.5.xsd&quot;&gt;

    &lt;import resource=&quot;config/customer.xml&quot;/&gt;
    &lt;import resource=&quot;config/scheduler.xml&quot;/&gt;

&lt;/beans&gt;
</code></pre><blockquote>
<p>我们可以使用Import注解来完成相同的功能 </p>
</blockquote>
<pre><code>import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;

@Configuration
@Import({ CustomerConfig.class, SchedulerConfig.class })
public class AppConfig {

}
</code></pre><blockquote>
<p>我们分别创建两个实体类CustomerBo和SchedulerBo </p>
</blockquote>
<pre><code>package com.demo.Model;

public class CustomerBo {
    public void printMsg(String msg) {
        System.out.println(&quot;CustomerBo: &quot; + msg);
    }
}

package com.demo.Model;

public class SchedulerBo {

    public void printMsg(String msg) {
        System.out.println(&quot;SchedulerBo: &quot; + msg);
    }
}
</code></pre><blockquote>
<p>接着创建相应的配置文件 </p>
</blockquote>
<pre><code>package com.demo.Config;

import com.demo.Model.CustomerBo;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class CustomerConfig {
    @Bean(name = &quot;customer&quot;)
    public CustomerBo customerBo(){
        return new CustomerBo();
    }
}

package com.demo.Config;

import com.demo.Model.SchedulerBo;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class SchedulerConfig {
    @Bean(name = &quot;scheduler&quot;)
    public SchedulerBo schedulerBo() {
        return new SchedulerBo();
    }
}
</code></pre><blockquote>
<p>然后在AppConfig中引用 </p>
</blockquote>
<pre><code>package com.demo;

import com.demo.Config.CustomerConfig;
import com.demo.Config.SchedulerConfig;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;

@Configuration
@Import({CustomerConfig.class, SchedulerConfig.class})
public class AppConfig {

}
</code></pre><blockquote>
<p>我们在测试类中就可以正常获取到这两个实体类了 </p>
</blockquote>
<pre><code>public class App {
    public static void main(String[] args) {
        ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);

        CustomerBo customerBo = context.getBean(CustomerBo.class);

        SchedulerBo schedulerBo = context.getBean(SchedulerBo.class);

        customerBo.printMsg(&quot;hello Spring&quot;);

        schedulerBo.printMsg(&quot;hello Spring&quot;);
    }
}
</code></pre><p>运行结果如下: </p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15085854585356.jpg" alt=""></p>
<h2 id="DI注入的小问题"><a href="#DI注入的小问题" class="headerlink" title="DI注入的小问题"></a>DI注入的小问题</h2><blockquote>
<p>我们通过在xml中书写配置文件进行DI注入,有两种方式:setter函数注入和构造函数注入 </p>
</blockquote>
<p>setter函数注入：用ref引用相应的bean<br>构造函数注入：用<code>&lt;constructor-arg&gt;</code>标签<br>如果存在多个构造函数，为了避免歧义，需要手动指定数据类型 </p>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-2.5.xsd&quot;&gt;

    &lt;bean id=&quot;CustomerBean&quot; class=&quot;com.yiibai.common.Customer&quot;&gt;

        &lt;constructor-arg type=&quot;java.lang.String&quot;&gt;
            &lt;value&gt;yiibai&lt;/value&gt;
        &lt;/constructor-arg&gt;

        &lt;constructor-arg type=&quot;java.lang.String&quot;&gt;
            &lt;value&gt;188&lt;/value&gt;
        &lt;/constructor-arg&gt;

        &lt;constructor-arg type=&quot;int&quot;&gt;
            &lt;value&gt;28&lt;/value&gt;
        &lt;/constructor-arg&gt;

    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre><h2 id="Spring中对Bean的引用"><a href="#Spring中对Bean的引用" class="headerlink" title="Spring中对Bean的引用"></a>Spring中对Bean的引用</h2><p>有两种方式bean和local </p>
<p><code>&lt;ref&gt;</code> 提供了如下几方面的属性 :<br>1)bean: 在当前 Spring XML 配置文件中，或者在同一 BeanFactory(ApplicationContext) 中的其他 JavaBean 中 .<br>2)local: 在当前 Spring XML 配置文件中 . 其依赖的 JavaBean 必须存在于当前 Spring XML配置文件中 . 如果借助于 Spring IDE, 则在编译期可以对其依赖的 JavaBean 进行验证。基于 local 方式，开发者能够使用到 XML 本身提供 的优势，而进行验证。<br>3)parent: 用于指定其依赖的父 JavaBean 定义。 </p>
<p>local属性在Spring 4.x中被废弃 </p>
<pre><code>&lt;bean id=&quot;OutputHelper&quot; class=&quot;com.yiibai.output.OutputHelper&quot;&gt;
    &lt;property name=&quot;outputGenerator&quot; &gt;
            &lt;ref local=&quot;CsvOutputGenerator&quot;/&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id=&quot;OutputHelper&quot; class=&quot;com.yiibai.output.OutputHelper&quot;&gt;
    &lt;property name=&quot;outputGenerator&quot; &gt;
        &lt;ref bean=&quot;CsvOutputGenerator&quot;/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre><blockquote>
<p>在xml中注入属性有三种方式 正常模式、快捷方式和P模式 </p>
</blockquote>
<p>正常模式(4.x不推荐使用) </p>
<pre><code>&lt;bean id=&quot;helloBean&quot; class=&quot;com.demo.Model.CustomerBo&quot;&gt;
    &lt;property name=&quot;content&quot;&gt;
        &lt;value&gt;Hello World&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre><p>快捷方式(value属性) </p>
<pre><code>&lt;bean id=&quot;helloBean&quot; class=&quot;com.demo.Model.CustomerBo&quot;&gt;
    &lt;property name=&quot;content&quot; value=&quot;Hello World&quot;/&gt;
&lt;/bean&gt;
</code></pre><p>P模式(value和value-ref两种模式 分别表示直接赋值和引用) </p>
<pre><code>&lt;bean id=&quot;helloBean&quot; class=&quot;com.demo.Model.CustomerBo&quot; p:content=&quot;hello world&quot;/&gt;
</code></pre><h2 id="Spring-Bean的作用域"><a href="#Spring-Bean的作用域" class="headerlink" title="Spring Bean的作用域"></a>Spring Bean的作用域</h2><p>Spring中Bean的作用域有两种 singleton(默认)单例模式和prototype 原型模式<br>生命作用域的方式很简单，至于要在xml的bean中使用<code>scope</code>属性即可 </p>
<p>我们还可以通过@Scope注解的方式来实现相同的效果 </p>
<pre><code>@Service
@Scope(&quot;prototype&quot;)
public class CustomerService 
{
    String message;

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }
}
</code></pre><p>需要在xml中开启自动扫描组件功能 </p>
<pre><code>&lt;context:component-scan base-package=&quot;com.yiibai.customer&quot; /&gt;
</code></pre><h2 id="Spring中注册List-Map-Set-Properties等集合"><a href="#Spring中注册List-Map-Set-Properties等集合" class="headerlink" title="Spring中注册List Map Set Properties等集合"></a>Spring中注册List Map Set Properties等集合</h2><blockquote>
<p>Spring中支持对这些集合类的注册和使用，下面是例子 </p>
</blockquote>
<p>创建两个实体类Person和Customer </p>
<pre><code>Person.java

package com.demo.Model;

public class Person {
    private String name;
    private String address;
    private int age;

    public void setName(String name) {
        this.name = name;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return &quot;[ name: &quot; + name + &quot;address: &quot; + address + &quot;age: &quot; + age + &quot; ]&quot;;
    }
}

Customer.java

package com.demo.Model;

import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;

public class Customer {
    private List&lt;Object&gt; lists;
    private Set&lt;Object&gt; sets;
    private Map&lt;Object, Object&gt; maps;
    private Properties props;

    public void setLists(List&lt;Object&gt; lists) {
        this.lists = lists;
    }

    public void setSets(Set&lt;Object&gt; sets) {
        this.sets = sets;
    }

    public void setMaps(Map&lt;Object, Object&gt; maps) {
        this.maps = maps;
    }

    public void setProps(Properties props) {
        this.props = props;
    }

    @Override
    public String toString() {
        StringBuffer buffer = new StringBuffer();
        buffer.append(&quot;list:\n&quot;);
        for (Object o : lists) {
            buffer.append(o.toString() + &quot;\n&quot;);
        }
        buffer.append(&quot;set:\n&quot;);
        for (Object o : sets) {
            buffer.append(o.toString() + &quot;\n&quot;);
        }
        buffer.append(&quot;map:\n&quot;);
        for (Object o : maps.keySet()) {
            buffer.append(&quot;key: &quot; + o.toString() + &quot;  value: &quot; + maps.get(o).toString() + &quot;\n&quot;);
        }
        buffer.append(&quot;properties:\n&quot;);
        for (Object o : props.keySet()) {
            buffer.append(&quot;key: &quot; + o.toString() + &quot;  value: &quot; + props.get(o).toString() + &quot;\n&quot;);
        }
        return buffer.toString();
    }
}
</code></pre><p>我们可以在xml中去注册这些属性值 </p>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-4.0.xsd&quot;&gt;

    &lt;bean id=&quot;customer&quot; class=&quot;com.demo.Model.Customer&quot;&gt;
        &lt;property name=&quot;lists&quot;&gt;
            &lt;list&gt;
                &lt;value&gt;1&lt;/value&gt;
                &lt;ref bean=&quot;person&quot;/&gt;
                &lt;bean class=&quot;com.demo.Model.Person&quot;
                        p:name=&quot;RenBuRuGu123&quot;
                        p:address=&quot;JiangSu NanJing&quot;
                        p:age=&quot;22&quot;/&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;property name=&quot;maps&quot;&gt;
            &lt;map&gt;
                &lt;entry key=&quot;1&quot; value=&quot;1&quot;/&gt;
                &lt;entry key=&quot;2&quot; value-ref=&quot;person&quot;/&gt;
                &lt;entry key=&quot;hello&quot;&gt;
                    &lt;bean class=&quot;com.demo.Model.Person&quot;
                            p:name=&quot;RenBuRuGu&quot;
                            p:address=&quot;JiangSu NanJing&quot;
                            p:age=&quot;20&quot;/&gt;
                &lt;/entry&gt;
            &lt;/map&gt;
        &lt;/property&gt;
        &lt;property name=&quot;props&quot;&gt;
            &lt;props&gt;
                &lt;prop key=&quot;admin&quot;&gt;Admin@123&lt;/prop&gt;
                &lt;prop key=&quot;support&quot;&gt;support@gmail.com&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
        &lt;property name=&quot;sets&quot;&gt;
            &lt;set&gt;
                &lt;set&gt;
                    &lt;value&gt;1&lt;/value&gt;
                    &lt;ref bean=&quot;person&quot;/&gt;
                    &lt;bean class=&quot;com.demo.Model.Person&quot;&gt;
                        &lt;property name=&quot;name&quot; value=&quot;Test Set&quot;/&gt;
                        &lt;property name=&quot;address&quot; value=&quot;Hainan Haikou&quot;/&gt;
                        &lt;property name=&quot;age&quot; value=&quot;28&quot;/&gt;
                    &lt;/bean&gt;
                &lt;/set&gt;
            &lt;/set&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;person&quot; class=&quot;com.demo.Model.Person&quot;
            p:name=&quot;RenBuRuGu&quot;
            p:address=&quot;JiangSu NanJing&quot;
            p:age=&quot;20&quot;/&gt;
&lt;/beans&gt;
</code></pre><p>测试类: </p>
<pre><code>public class App {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;Spring-Beans.xml&quot;);
        Customer customer = context.getBean(Customer.class);

        System.out.println(customer);
    }
}
</code></pre><p>运行结果如下: </p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15085930603056.jpg" alt=""></p>
<blockquote>
<p>自定义List类型 </p>
</blockquote>
<p>如果想要返回的List是ArrayList数据类型的 你有两种方式去实现它 ListFactoryBean 和 util:list<br>分别举个例子 </p>
<blockquote>
<p>ListFactoryBean方式 </p>
</blockquote>
<pre><code>&lt;property name=&quot;lists&quot;&gt;
    &lt;bean class=&quot;org.springframework.beans.factory.config.ListFactoryBean&quot;&gt;
        &lt;property name=&quot;targetListClass&quot; value=&quot;java.util.ArrayList&quot;/&gt;
        &lt;property name=&quot;sourceList&quot;&gt;
            &lt;list&gt;
                &lt;value&gt;1&lt;/value&gt;
                &lt;ref bean=&quot;person&quot;/&gt;
                &lt;bean class=&quot;com.demo.Model.Person&quot;
                        p:name=&quot;RenBuRuGu123&quot;
                        p:address=&quot;JiangSu NanJing&quot;
                        p:age=&quot;22&quot;/&gt;
            &lt;/list&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/property&gt;
</code></pre><p>通过targetListClass指定List的数据类型，sourceList包裹原list数据 </p>
<blockquote>
<p>util:list方式 </p>
</blockquote>
<pre><code>&lt;util:list list-class=&quot;java.util.ArrayList&quot;&gt;
    &lt;value&gt;1&lt;/value&gt;
    &lt;ref bean=&quot;person&quot;/&gt;
    &lt;bean class=&quot;com.demo.Model.Person&quot;
            p:name=&quot;RenBuRuGu123&quot;
            p:address=&quot;JiangSu NanJing&quot;
            p:age=&quot;22&quot;/&gt;
&lt;/util:list&gt;
</code></pre><p>效果完全一样，个人觉得这种方式比较简便 </p>
<ul>
<li>MapFactoryBean和SetFactoryBean用法完全相同,不做过多介绍…</li>
</ul>
<h2 id="Spring注入日期类型的数据"><a href="#Spring注入日期类型的数据" class="headerlink" title="Spring注入日期类型的数据"></a>Spring注入日期类型的数据</h2><p>1、通过factoryBean的方式 </p>
<pre><code>&lt;bean id=&quot;dateFormat&quot; class=&quot;java.text.SimpleDateFormat&quot;&gt;
    &lt;constructor-arg value=&quot;yyyy-MM-dd&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;customer&quot; class=&quot;com.demo.Model.Customer&quot;&gt;
    &lt;property name=&quot;date&quot;&gt;
        &lt;bean factory-bean=&quot;dateFormat&quot; factory-method=&quot;parse&quot;&gt;
            &lt;constructor-arg value=&quot;2015-12-31&quot;/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre><p>我们创建一个SimpleDateFormat的Bean然后通过Factory-bean和Factory-method方法调用SimpleDataFormat的prase方法来初始化我们的日期 </p>
<p>2、通过CustomDateEditor的方式(反正我不会用，一直报错) </p>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-2.5.xsd&quot;&gt;

    &lt;bean id=&quot;dateEditor&quot;
        class=&quot;org.springframework.beans.propertyeditors.CustomDateEditor&quot;&gt;

        &lt;constructor-arg&gt;
            &lt;bean class=&quot;java.text.SimpleDateFormat&quot;&gt;
                &lt;constructor-arg value=&quot;yyyy-MM-dd&quot; /&gt;
            &lt;/bean&gt;
        &lt;/constructor-arg&gt;
        &lt;constructor-arg value=&quot;true&quot; /&gt;

    &lt;/bean&gt;

    &lt;bean class=&quot;org.springframework.beans.factory.config.CustomEditorConfigurer&quot;&gt;
        &lt;property name=&quot;customEditors&quot;&gt;
            &lt;map&gt;
                &lt;entry key=&quot;java.util.Date&quot;&gt;
                    &lt;ref local=&quot;dateEditor&quot; /&gt;
                &lt;/entry&gt;
            &lt;/map&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;customer&quot; class=&quot;com.yiibai.common.Customer&quot;&gt;
        &lt;property name=&quot;date&quot; value=&quot;2015-12-31&quot; /&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre><ul>
<li><code>&lt;ref local=&quot;&quot;&gt;</code>用法好像在4.x中被删除了</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Spring </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Spring </tag>
            
            <tag> AutoWire </tag>
            
            <tag> Beans </tag>
            
            <tag> JdbcTemplate </tag>
            
            <tag> SimpleJdbcTemplate </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[学习Spring第二天]]></title>
      <url>/2017/10/20/Spring/Spring%E4%BD%BF%E7%94%A8jdbc/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a>  
<h2 id="在Spring中使用jdbc"><a href="#在Spring中使用jdbc" class="headerlink" title="在Spring中使用jdbc"></a>在Spring中使用jdbc</h2><hr>
<blockquote>
<p>添加gradle依赖 </p>
</blockquote>
<pre><code>dependencies {

testCompile group: &#39;junit&#39;, name: &#39;junit&#39;, version: &#39;4.12&#39;

compile group: &#39;org.springframework&#39;, name: &#39;spring-context&#39;, version: &#39;5.0.0.RELEASE&#39;

compile group: &#39;org.springframework&#39;, name: &#39;spring-jdbc&#39;, version: &#39;5.0.0.RELEASE&#39;

compile group: &#39;mysql&#39;, name: &#39;mysql-connector-java&#39;, version: &#39;8.0.8-dmr&#39;

}
</code></pre><blockquote>
<p>首先创建数据表 </p>
</blockquote>
<pre><code>CREATE TABLE `customer` (
    `CUST_ID` int(10) unsigned NOT NULL AUTO_INCREMENT,
    `NAME` varchar(100) NOT NULL,
    `AGE` int(10) unsigned NOT NULL,
        PRIMARY KEY (`CUST_ID`)
) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;
</code></pre><p>下面实现业务代码 </p>
<blockquote>
<p>创建一个Customer实体类 </p>
</blockquote>
<pre><code>package com.demo.Model;

public class Customer {
    private int cusId;
    private String name;
    private int age;

    public Customer(int cusId, String name, int age) {
        this.cusId = cusId;
        this.name = name;
        this.age = age;
    }

    public int getCusId() {
        return cusId;
    }

    public void setCusId(int cusId) {
        this.cusId = cusId;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return &quot;id: &quot; + cusId + &quot;\nname: &quot; + name + &quot;\nage: &quot; + age;
    }
}
</code></pre><blockquote>
<p>下面创建一个DAO </p>
</blockquote>
<pre><code>public interface CustomerDao {
    void insert(Customer customer);

    Customer findByCustomerId(int cusId);
}
</code></pre><blockquote>
<p>创建一个DAO的实现层 </p>
</blockquote>
<pre><code>public class JdbcCustomerDao implements CustomerDao {
    private DataSource dataSource;

    public void setDataSource(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    @Override
    public void insert(Customer customer) {
        String sql = &quot;INSERT INTO customer(CUST_ID,NAME,AGE) VALUES(?,?,?)&quot;;
        Connection conn = null;

        try {
            conn = dataSource.getConnection();
            PreparedStatement ps = conn.prepareStatement(sql);
            ps.setInt(1, customer.getCusId());
            ps.setString(2, customer.getName());
            ps.setInt(3, customer.getAge());
            ps.executeUpdate();
            ps.close();
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            if (conn != null) {
                try {
                    conn.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
</code></pre><p>这里采用最原始的jdbc对数据库进行操作，通过dataSource的方式获取connection.dataSource通过Spring-DataSource.xml获取 </p>
<blockquote>
<p>下面创建Spring-Dataource.xml </p>
</blockquote>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-4.0.xsd&quot;&gt;

    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/Spring&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;19970819wy&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre><p>这里使用Spring-JDBC，配置好jdbc的一系列信息 </p>
<blockquote>
<p>Spring-Customer.xml </p>
</blockquote>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-4.0.xsd&quot;&gt;

    &lt;bean id=&quot;customerDAO&quot; class=&quot;com.demo.DaoImpl.JdbcCustomerDao&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre><blockquote>
<p>Spring-Moudle.xml </p>
</blockquote>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-4.0.xsd&quot;&gt;

    &lt;import resource=&quot;Spring-DataSource.xml&quot;/&gt;
    &lt;import resource=&quot;Spring-Customer.xml&quot;/&gt;
&lt;/beans&gt;
</code></pre><p>到此为止xml配置文件已经写完了，最后写个测试类测试一下 </p>
<blockquote>
<p>App.java </p>
</blockquote>
<pre><code>package com.demo;

import com.demo.Dao.CustomerDao;
import com.demo.Model.Customer;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class App
{
    public static void main( String[] args )
    {
        ApplicationContext context =
                new ClassPathXmlApplicationContext(&quot;Spring-Moudle.xml&quot;);

        CustomerDao customerDAO = (CustomerDao) context.getBean(&quot;customerDAO&quot;);
        Customer customer = new Customer(1, &quot;RenBuRuGu&quot;,20);
        customerDAO.insert(customer);

        Customer customer1 = customerDAO.findByCustomerId(1);
        System.out.println(customer1);

    }
}
</code></pre><p>运行结果如下: </p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15085578276768.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Spring </category>
            
        </categories>
        
        
        <tags>
            
            <tag> spring </tag>
            
            <tag> jdbc </tag>
            
            <tag> mysql </tag>
            
            <tag> spring-jdbc </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[学习Spring第一天]]></title>
      <url>/2017/10/19/Spring/xml%E8%8E%B7%E5%8F%96Bean/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a>  
<h2 id="在xml中装载Bean实体"><a href="#在xml中装载Bean实体" class="headerlink" title="在xml中装载Bean实体"></a>在xml中装载Bean实体</h2><hr>
<blockquote>
<p>首先新建一个实体类 HelloWorld.java </p>
</blockquote>
<pre><code>public class HelloWorld{
    private String name;

    public void setName(String name){
        this.name = name;
    }

    public void printHello(){
        System.out.println(&quot;Spring 4: Hello!&quot; + name);
    }  
}
</code></pre><p>一个实体类就创建完成了，接下来我们在xml中注册这个实体类. </p>
<blockquote>
<p>在resources文件夹下创建applicationContext.xml </p>
</blockquote>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15084257704294.jpg" alt=""></p>
<p>代码结构如上，我们在xml中配置beans. </p>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-4.0.xsd&quot;&gt;

    &lt;bean id=&quot;helloBean&quot; class=&quot;com.demo.Entity.HelloWorld&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;RenBuRuGu&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre><p>其中id为bean的唯一编号，每一个实体类都需要注册成一个bean。class为对应的entity，property为属性值，对应着HelloWorld里的name，spring会根据setName函数自动为name赋值.<br>完成了这一步之后，下面我们来编写一个测试函数调用一下. </p>
<blockquote>
<p>在com.demo根目录下创建App.java. </p>
</blockquote>
<pre><code>public class App {
    public static void main(String[] args){

        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;application.xml&quot;);

        HelloWorld helloWorld = context.getBean(&quot;helloBean&quot;);

        helloWorld.printHello();
    }

}
</code></pre><p>我们通过ClassPathXmlApplicationContext获取xml的bean实体，然后通过Spring的IOC从容器中获取HelloWorld. </p>
<blockquote>
<p>运行结果如下. </p>
</blockquote>
<p><img src="http://oq5d32gij.bkt.clouddn.com/15084265313737.jpg" alt=""></p>
<hr>
<h2 id="Spring的松耦合机制"><a href="#Spring的松耦合机制" class="headerlink" title="Spring的松耦合机制"></a>Spring的松耦合机制</h2><blockquote>
<p>下面为大家介绍一下Spring的松耦合机制. </p>
</blockquote>
<p>项目结构如下:<br><img src="http://oq5d32gij.bkt.clouddn.com/15084583360437.jpg" alt=""><br>如果我们想实现一个可以用Csv和Json格式输出的功能，稍微有点经验的java程序员可能会把输出功能抽象成一个接口然后分别实现. </p>
<blockquote>
<p>先创建一个输出功能的interface </p>
</blockquote>
<pre><code>public interface IOutputGenerator{
    void generateOutput();
}
</code></pre><blockquote>
<p>然后我们创建两个类分别去实现这个接口.<br>CsvOutputGenerator </p>
</blockquote>
<pre><code>public class CsvOutputGenerator implements IOutputGenerator {

    @Override
    public void generateOutput(){
        System.out.println(&quot;Csv Output Generator&quot;);
    }
}
</code></pre><blockquote>
<p>JsonOutputGenerator </p>
</blockquote>
<pre><code>public class JsonOutputGenerator implements IOutputGenerator {

    @Override
    public void generateOutput(){
        System.out.println(&quot;Json Output Generator&quot;);
    }
}
</code></pre><p>如果我们想要在业务逻辑代码中使用输出功能，有如下三个方法: </p>
<pre><code>IoutputGenerator output = new CsvOutputGenerator();

output.generateOutput();
</code></pre><p>这种方式肯定是不好的，如果需求变了或者需要使用新的Generator，必须在所有引用到的地方都手动修改，这种方式的工作量是巨大的. </p>
<pre><code>public class OutputHelper{
    private IOutputGenerator output;

    public OutputHelper(){
        this.output = new CsvOutputGenerator();
    }

    public generateOutput(){
        output.generateOutput();
    }

}
</code></pre><p>当我们需要使用的时候直接调用OutputHelper就可以了. </p>
<pre><code>OutputHelper helper = new OutputHelper();

helper.generateOutput();
</code></pre><p>这种方法比第一种好，当需求改变时(比如从csv变成json)，我们只需要在OutputHelper里手动修改就好了. </p>
<p>第三种方法是用Spring的松耦合机制.<br>我们先在xml中配置bean. </p>
<blockquote>
<p>Spring-common.xml </p>
</blockquote>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-4.0.xsd&quot;&gt;
    &lt;bean id=&quot;outputHelper&quot; class=&quot;com.demo.Helper.OutputHelper&quot;&gt;
        &lt;property name=&quot;outputGenerator&quot; ref=&quot;csvOutputGenerator&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;csvOutputGenerator&quot; class=&quot;com.demo.Generator.CsvOutputGenerator&quot;/&gt;
    &lt;bean id=&quot;jsonOutputGenerator&quot; class=&quot;com.demo.Generator.JsonOutputGenerator&quot;/&gt;
&lt;/beans&gt;
</code></pre><blockquote>
<p>OutputHelper </p>
</blockquote>
<pre><code>public class OutputHelper {

    private IOutputGenerator outputGenerator;

    public void setOutputGenerator(IOutputGenerator outputGenerator) {
        this.outputGenerator = outputGenerator;
    }

    public void generatorOutput() {
        outputGenerator.generateOutput();
    }
}
</code></pre><p>我们现在可以这么使用它: </p>
<pre><code>public class App {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;Spring-common.xml&quot;);
        OutputHelper outputHelper = (OutputHelper) context.getBean(&quot;outputHelper&quot;);

        outputHelper.generatorOutput();
    }
}
</code></pre>]]></content>
      
        <categories>
            
            <category> Spring </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Spring </tag>
            
            <tag> ClassPathXmlApplicationCOntext </tag>
            
            <tag> Hello World </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MyBatis最详细配置]]></title>
      <url>/2017/10/10/JavaWeb/MyBatis%E6%9C%80%E8%AF%A6%E7%BB%86%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a> 
<p>同学们有福了，花了一些时间，重新整理了一个最完整的Mybatis Generator（简称MBG）的最完整配置文件，带详解，再也不用去看EN的User Guide了；  </p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE generatorConfiguration
  PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;
&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;
&lt;!-- 配置生成器 --&gt;
&lt;generatorConfiguration&gt;
&lt;!-- 可以用于加载配置项或者配置文件，在整个配置文件中就可以使用${propertyKey}的方式来引用配置项
    resource：配置资源加载地址，使用resource，MBG从classpath开始找，比如com/myproject/generatorConfig.properties        
    url：配置资源加载地质，使用URL的方式，比如file:///C:/myfolder/generatorConfig.properties.
    注意，两个属性只能选址一个;

    另外，如果使用了mybatis-generator-maven-plugin，那么在pom.xml中定义的properties都可以直接在generatorConfig.xml中使用
&lt;properties resource=&quot;&quot; url=&quot;&quot; /&gt;
 --&gt;

 &lt;!-- 在MBG工作的时候，需要额外加载的依赖包
     location属性指明加载jar/zip包的全路径
&lt;classPathEntry location=&quot;/Program Files/IBM/SQLLIB/java/db2java.zip&quot; /&gt;
  --&gt;

&lt;!-- 
    context:生成一组对象的环境 
    id:必选，上下文id，用于在生成错误时提示
    defaultModelType:指定生成对象的样式
        1，conditional：类似hierarchical；
        2，flat：所有内容（主键，blob）等全部生成在一个对象中；
        3，hierarchical：主键生成一个XXKey对象(key class)，Blob等单独生成一个对象，其他简单属性在一个对象中(record class)
    targetRuntime:
        1，MyBatis3：默认的值，生成基于MyBatis3.x以上版本的内容，包括XXXBySample；
        2，MyBatis3Simple：类似MyBatis3，只是不生成XXXBySample；
    introspectedColumnImpl：类全限定名，用于扩展MBG
--&gt;
&lt;context id=&quot;mysql&quot; defaultModelType=&quot;hierarchical&quot; targetRuntime=&quot;MyBatis3Simple&quot; &gt;

    &lt;!-- 自动识别数据库关键字，默认false，如果设置为true，根据SqlReservedWords中定义的关键字列表；
        一般保留默认值，遇到数据库关键字（Java关键字），使用columnOverride覆盖
     --&gt;
    &lt;property name=&quot;autoDelimitKeywords&quot; value=&quot;false&quot;/&gt;
    &lt;!-- 生成的Java文件的编码 --&gt;
    &lt;property name=&quot;javaFileEncoding&quot; value=&quot;UTF-8&quot;/&gt;
    &lt;!-- 格式化java代码 --&gt;
    &lt;property name=&quot;javaFormatter&quot; value=&quot;org.mybatis.generator.api.dom.DefaultJavaFormatter&quot;/&gt;
    &lt;!-- 格式化XML代码 --&gt;
    &lt;property name=&quot;xmlFormatter&quot; value=&quot;org.mybatis.generator.api.dom.DefaultXmlFormatter&quot;/&gt;

    &lt;!-- beginningDelimiter和endingDelimiter：指明数据库的用于标记数据库对象名的符号，比如ORACLE就是双引号，MYSQL默认是`反引号； --&gt;
    &lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot;/&gt;
    &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt;

    &lt;!-- 必须要有的，使用这个配置链接数据库
        @TODO:是否可以扩展
     --&gt;
    &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql:///pss&quot; userId=&quot;root&quot; password=&quot;admin&quot;&gt;
        &lt;!-- 这里面可以设置property属性，每一个property属性都设置到配置的Driver上 --&gt;
    &lt;/jdbcConnection&gt;

    &lt;!-- java类型处理器 
        用于处理DB中的类型到Java中的类型，默认使用JavaTypeResolverDefaultImpl；
        注意一点，默认会先尝试使用Integer，Long，Short等来对应DECIMAL和 NUMERIC数据类型； 
    --&gt;
    &lt;javaTypeResolver type=&quot;org.mybatis.generator.internal.types.JavaTypeResolverDefaultImpl&quot;&gt;
        &lt;!-- 
            true：使用BigDecimal对应DECIMAL和 NUMERIC数据类型
            false：默认,
                scale&gt;0;length&gt;18：使用BigDecimal;
                scale=0;length[10,18]：使用Long；
                scale=0;length[5,9]：使用Integer；
                scale=0;length&lt;5：使用Short；
         --&gt;
        &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&gt;
    &lt;/javaTypeResolver&gt;


    &lt;!-- java模型创建器，是必须要的元素
        负责：1，key类（见context的defaultModelType）；2，java类；3，查询类
        targetPackage：生成的类要放的包，真实的包受enableSubPackages属性控制；
        targetProject：目标项目，指定一个存在的目录下，生成的内容会放到指定目录中，如果目录不存在，MBG不会自动建目录
     --&gt;
    &lt;javaModelGenerator targetPackage=&quot;com._520it.mybatis.domain&quot; targetProject=&quot;src/main/java&quot;&gt;
        &lt;!--  for MyBatis3/MyBatis3Simple
            自动为每一个生成的类创建一个构造方法，构造方法包含了所有的field；而不是使用setter；
         --&gt;
        &lt;property name=&quot;constructorBased&quot; value=&quot;false&quot;/&gt;

        &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt;
        &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;

        &lt;!-- for MyBatis3 / MyBatis3Simple
            是否创建一个不可变的类，如果为true，
            那么MBG会创建一个没有setter方法的类，取而代之的是类似constructorBased的类
         --&gt;
        &lt;property name=&quot;immutable&quot; value=&quot;false&quot;/&gt;

        &lt;!-- 设置一个根对象，
            如果设置了这个根对象，那么生成的keyClass或者recordClass会继承这个类；在Table的rootClass属性中可以覆盖该选项
            注意：如果在key class或者record class中有root class相同的属性，MBG就不会重新生成这些属性了，包括：
                1，属性名相同，类型相同，有相同的getter/setter方法；
         --&gt;
        &lt;property name=&quot;rootClass&quot; value=&quot;com._520it.mybatis.domain.BaseDomain&quot;/&gt;

        &lt;!-- 设置是否在getter方法中，对String类型字段调用trim()方法 --&gt;
        &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt;
    &lt;/javaModelGenerator&gt;


    &lt;!-- 生成SQL map的XML文件生成器，
        注意，在Mybatis3之后，我们可以使用mapper.xml文件+Mapper接口（或者不用mapper接口），
            或者只使用Mapper接口+Annotation，所以，如果 javaClientGenerator配置中配置了需要生成XML的话，这个元素就必须配置
        targetPackage/targetProject:同javaModelGenerator
     --&gt;
    &lt;sqlMapGenerator targetPackage=&quot;com._520it.mybatis.mapper&quot; targetProject=&quot;src/main/resources&quot;&gt;
        &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt;
        &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;
    &lt;/sqlMapGenerator&gt;


    &lt;!-- 对于mybatis来说，即生成Mapper接口，注意，如果没有配置该元素，那么默认不会生成Mapper接口 
        targetPackage/targetProject:同javaModelGenerator
        type：选择怎么生成mapper接口（在MyBatis3/MyBatis3Simple下）：
            1，ANNOTATEDMAPPER：会生成使用Mapper接口+Annotation的方式创建（SQL生成在annotation中），不会生成对应的XML；
            2，MIXEDMAPPER：使用混合配置，会生成Mapper接口，并适当添加合适的Annotation，但是XML会生成在XML中；
            3，XMLMAPPER：会生成Mapper接口，接口完全依赖XML；
        注意，如果context是MyBatis3Simple：只支持ANNOTATEDMAPPER和XMLMAPPER
    --&gt;
    &lt;javaClientGenerator targetPackage=&quot;com._520it.mybatis.mapper&quot; type=&quot;ANNOTATEDMAPPER&quot; targetProject=&quot;src/main/java&quot;&gt;
        &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt;
        &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;

        &lt;!-- 可以为所有生成的接口添加一个父接口，但是MBG只负责生成，不负责检查
        &lt;property name=&quot;rootInterface&quot; value=&quot;&quot;/&gt;
         --&gt;
    &lt;/javaClientGenerator&gt;

    &lt;!-- 选择一个table来生成相关文件，可以有一个或多个table，必须要有table元素
        选择的table会生成一下文件：
        1，SQL map文件
        2，生成一个主键类；
        3，除了BLOB和主键的其他字段的类；
        4，包含BLOB的类；
        5，一个用户生成动态查询的条件类（selectByExample, deleteByExample），可选；
        6，Mapper接口（可选）

        tableName（必要）：要生成对象的表名；
        注意：大小写敏感问题。正常情况下，MBG会自动的去识别数据库标识符的大小写敏感度，在一般情况下，MBG会
            根据设置的schema，catalog或tablename去查询数据表，按照下面的流程：
            1，如果schema，catalog或tablename中有空格，那么设置的是什么格式，就精确的使用指定的大小写格式去查询；
            2，否则，如果数据库的标识符使用大写的，那么MBG自动把表名变成大写再查找；
            3，否则，如果数据库的标识符使用小写的，那么MBG自动把表名变成小写再查找；
            4，否则，使用指定的大小写格式查询；
        另外的，如果在创建表的时候，使用的&quot;&quot;把数据库对象规定大小写，就算数据库标识符是使用的大写，在这种情况下也会使用给定的大小写来创建表名；
        这个时候，请设置delimitIdentifiers=&quot;true&quot;即可保留大小写格式；

        可选：
        1，schema：数据库的schema；
        2，catalog：数据库的catalog；
        3，alias：为数据表设置的别名，如果设置了alias，那么生成的所有的SELECT SQL语句中，列名会变成：alias_actualColumnName
        4，domainObjectName：生成的domain类的名字，如果不设置，直接使用表名作为domain类的名字；可以设置为somepck.domainName，那么会自动把domainName类再放到somepck包里面；
        5，enableInsert（默认true）：指定是否生成insert语句；
        6，enableSelectByPrimaryKey（默认true）：指定是否生成按照主键查询对象的语句（就是getById或get）；
        7，enableSelectByExample（默认true）：MyBatis3Simple为false，指定是否生成动态查询语句；
        8，enableUpdateByPrimaryKey（默认true）：指定是否生成按照主键修改对象的语句（即update)；
        9，enableDeleteByPrimaryKey（默认true）：指定是否生成按照主键删除对象的语句（即delete）；
        10，enableDeleteByExample（默认true）：MyBatis3Simple为false，指定是否生成动态删除语句；
        11，enableCountByExample（默认true）：MyBatis3Simple为false，指定是否生成动态查询总条数语句（用于分页的总条数查询）；
        12，enableUpdateByExample（默认true）：MyBatis3Simple为false，指定是否生成动态修改语句（只修改对象中不为空的属性）；
        13，modelType：参考context元素的defaultModelType，相当于覆盖；
        14，delimitIdentifiers：参考tableName的解释，注意，默认的delimitIdentifiers是双引号，如果类似MYSQL这样的数据库，使用的是`（反引号，那么还需要设置context的beginningDelimiter和endingDelimiter属性）
        15，delimitAllColumns：设置是否所有生成的SQL中的列名都使用标识符引起来。默认为false，delimitIdentifiers参考context的属性

        注意，table里面很多参数都是对javaModelGenerator，context等元素的默认属性的一个复写；
     --&gt;
    &lt;table tableName=&quot;userinfo&quot; &gt;

        &lt;!-- 参考 javaModelGenerator 的 constructorBased属性--&gt;
        &lt;property name=&quot;constructorBased&quot; value=&quot;false&quot;/&gt;

        &lt;!-- 默认为false，如果设置为true，在生成的SQL中，table名字不会加上catalog或schema； --&gt;
        &lt;property name=&quot;ignoreQualifiersAtRuntime&quot; value=&quot;false&quot;/&gt;

        &lt;!-- 参考 javaModelGenerator 的 immutable 属性 --&gt;
        &lt;property name=&quot;immutable&quot; value=&quot;false&quot;/&gt;

        &lt;!-- 指定是否只生成domain类，如果设置为true，只生成domain类，如果还配置了sqlMapGenerator，那么在mapper XML文件中，只生成resultMap元素 --&gt;
        &lt;property name=&quot;modelOnly&quot; value=&quot;false&quot;/&gt;

        &lt;!-- 参考 javaModelGenerator 的 rootClass 属性 
        &lt;property name=&quot;rootClass&quot; value=&quot;&quot;/&gt;
         --&gt;

        &lt;!-- 参考javaClientGenerator 的  rootInterface 属性
        &lt;property name=&quot;rootInterface&quot; value=&quot;&quot;/&gt;
        --&gt;

        &lt;!-- 如果设置了runtimeCatalog，那么在生成的SQL中，使用该指定的catalog，而不是table元素上的catalog 
        &lt;property name=&quot;runtimeCatalog&quot; value=&quot;&quot;/&gt;
        --&gt;

        &lt;!-- 如果设置了runtimeSchema，那么在生成的SQL中，使用该指定的schema，而不是table元素上的schema 
        &lt;property name=&quot;runtimeSchema&quot; value=&quot;&quot;/&gt;
        --&gt;

        &lt;!-- 如果设置了runtimeTableName，那么在生成的SQL中，使用该指定的tablename，而不是table元素上的tablename 
        &lt;property name=&quot;runtimeTableName&quot; value=&quot;&quot;/&gt;
        --&gt;

        &lt;!-- 注意，该属性只针对MyBatis3Simple有用；
            如果选择的runtime是MyBatis3Simple，那么会生成一个SelectAll方法，如果指定了selectAllOrderByClause，那么会在该SQL中添加指定的这个order条件；
         --&gt;
        &lt;property name=&quot;selectAllOrderByClause&quot; value=&quot;age desc,username asc&quot;/&gt;

        &lt;!-- 如果设置为true，生成的model类会直接使用column本身的名字，而不会再使用驼峰命名方法，比如BORN_DATE，生成的属性名字就是BORN_DATE,而不会是bornDate --&gt;
        &lt;property name=&quot;useActualColumnNames&quot; value=&quot;false&quot;/&gt;


        &lt;!-- generatedKey用于生成生成主键的方法，
            如果设置了该元素，MBG会在生成的&lt;insert&gt;元素中生成一条正确的&lt;selectKey&gt;元素，该元素可选
            column:主键的列名；
            sqlStatement：要生成的selectKey语句，有以下可选项：
                Cloudscape:相当于selectKey的SQL为： VALUES IDENTITY_VAL_LOCAL()
                DB2       :相当于selectKey的SQL为： VALUES IDENTITY_VAL_LOCAL()
                DB2_MF    :相当于selectKey的SQL为：SELECT IDENTITY_VAL_LOCAL() FROM SYSIBM.SYSDUMMY1
                Derby      :相当于selectKey的SQL为：VALUES IDENTITY_VAL_LOCAL()
                HSQLDB      :相当于selectKey的SQL为：CALL IDENTITY()
                Informix  :相当于selectKey的SQL为：select dbinfo(&#39;sqlca.sqlerrd1&#39;) from systables where tabid=1
                MySql      :相当于selectKey的SQL为：SELECT LAST_INSERT_ID()
                SqlServer :相当于selectKey的SQL为：SELECT SCOPE_IDENTITY()
                SYBASE      :相当于selectKey的SQL为：SELECT @@IDENTITY
                JDBC      :相当于在生成的insert元素上添加useGeneratedKeys=&quot;true&quot;和keyProperty属性
        &lt;generatedKey column=&quot;&quot; sqlStatement=&quot;&quot;/&gt;
         --&gt;

        &lt;!-- 
            该元素会在根据表中列名计算对象属性名之前先重命名列名，非常适合用于表中的列都有公用的前缀字符串的时候，
            比如列名为：CUST_ID,CUST_NAME,CUST_EMAIL,CUST_ADDRESS等；
            那么就可以设置searchString为&quot;^CUST_&quot;，并使用空白替换，那么生成的Customer对象中的属性名称就不是
            custId,custName等，而是先被替换为ID,NAME,EMAIL,然后变成属性：id，name，email；

            注意，MBG是使用java.util.regex.Matcher.replaceAll来替换searchString和replaceString的，
            如果使用了columnOverride元素，该属性无效；

        &lt;columnRenamingRule searchString=&quot;&quot; replaceString=&quot;&quot;/&gt;
         --&gt;


         &lt;!-- 用来修改表中某个列的属性，MBG会使用修改后的列来生成domain的属性；
             column:要重新设置的列名；
             注意，一个table元素中可以有多个columnOverride元素哈~
          --&gt;
         &lt;columnOverride column=&quot;username&quot;&gt;
             &lt;!-- 使用property属性来指定列要生成的属性名称 --&gt;
             &lt;property name=&quot;property&quot; value=&quot;userName&quot;/&gt;

             &lt;!-- javaType用于指定生成的domain的属性类型，使用类型的全限定名
             &lt;property name=&quot;javaType&quot; value=&quot;&quot;/&gt;
              --&gt;

             &lt;!-- jdbcType用于指定该列的JDBC类型 
             &lt;property name=&quot;jdbcType&quot; value=&quot;&quot;/&gt;
              --&gt;

             &lt;!-- typeHandler 用于指定该列使用到的TypeHandler，如果要指定，配置类型处理器的全限定名
                 注意，mybatis中，不会生成到mybatis-config.xml中的typeHandler
                 只会生成类似：where id = #{id,jdbcType=BIGINT,typeHandler=com._520it.mybatis.MyTypeHandler}的参数描述
             &lt;property name=&quot;jdbcType&quot; value=&quot;&quot;/&gt;
             --&gt;

             &lt;!-- 参考table元素的delimitAllColumns配置，默认为false
             &lt;property name=&quot;delimitedColumnName&quot; value=&quot;&quot;/&gt;
              --&gt;
         &lt;/columnOverride&gt;

         &lt;!-- ignoreColumn设置一个MGB忽略的列，如果设置了改列，那么在生成的domain中，生成的SQL中，都不会有该列出现 
             column:指定要忽略的列的名字；
             delimitedColumnName：参考table元素的delimitAllColumns配置，默认为false

             注意，一个table元素中可以有多个ignoreColumn元素
         &lt;ignoreColumn column=&quot;deptId&quot; delimitedColumnName=&quot;&quot;/&gt;
         --&gt;
    &lt;/table&gt;

&lt;/context&gt;

&lt;/generatorConfiguration&gt;
</code></pre><p>好了，就到这里了，可以作为一个工具文档查看。 </p>
]]></content>
      
        <categories>
            
            <category> JavaWeb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javaweb </tag>
            
            <tag> gradle </tag>
            
            <tag> mybatis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Groovy读取yaml和properties文件]]></title>
      <url>/2017/10/10/JavaWeb/Groovy%E8%AF%BB%E5%8F%96yaml%E5%92%8Cproperties%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a> 
<p>Java 可以使用 <code>PropertiesConfiguration</code> 来读取 properties 属性文件，Spring 4.3 后还支持了 <code>Yaml 格式的属性文件</code></p>
<ul>
<li>PropertiesConfiguration: 读取时可以自动进行类型转换，可以给定默认值</li>
<li>Yaml 格式的属性文件: 可以使用树形结构，方便分组，比 <code>.properties</code> 属性文件更灵活，但是以普通的 <code>java.util.Properties</code> 来读取</li>
</ul>
<h1 id="Gradle-依赖"><a href="#Gradle-依赖" class="headerlink" title="Gradle 依赖"></a>Gradle 依赖</h1><pre><code>compile &#39;org.springframework:spring-context:4.3.0.RELEASE&#39;

compile &#39;org.yaml:snakeyaml:1.17&#39;

compile &#39;commons-configuration:commons-configuration:1.10&#39;

testCompile &#39;org.springframework:spring-test:4.3.0.RELEASE&#39;

testCompile &#39;junit:junit:4.12&#39;
</code></pre><h1 id="属性文件"><a href="#属性文件" class="headerlink" title="属性文件"></a>属性文件</h1><blockquote>
<p>config.properties </p>
</blockquote>
<pre><code>username=Dr. Alice 

age=22 

config.yml
</code></pre><p>#mysql </p>
<pre><code>mysql: 

    jdbc: 

        url: jdbc:mysql://localhost:3306 

        dirverClass: com.mysql.jdbc.Driver 

        username: root 

        password: root 

        username: Ritchie Yu 
</code></pre><h1 id="Spring-Bean-配置文件"><a href="#Spring-Bean-配置文件" class="headerlink" title="Spring Bean 配置文件"></a>Spring Bean 配置文件</h1><blockquote>
<p>spring-beans-config.xml </p>
</blockquote>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;

xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;

xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans

http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

&lt;bean id=&quot;yamlProperties&quot; class=&quot;org.springframework.beans.factory.config.YamlPropertiesFactoryBean&quot;&gt;

&lt;property name=&quot;resources&quot;&gt;

&lt;list&gt;

&lt;value&gt;classpath:config.yml&lt;/value&gt;

&lt;/list&gt;

&lt;/property&gt;

&lt;/bean&gt;

&lt;bean id=&quot;propertiesConfig&quot; class=&quot;org.apache.commons.configuration.PropertiesConfiguration&quot;&gt;

&lt;constructor-arg value=&quot;config.properties&quot;/&gt;

&lt;/bean&gt;

&lt;/beans&gt;
</code></pre><h1 id="测试案例"><a href="#测试案例" class="headerlink" title="测试案例"></a>测试案例</h1><pre><code>import org.apache.commons.configuration.PropertiesConfiguration; 

import org.junit.runner.RunWith; 

import org.junit.Test; 

import org.springframework.test.context.ContextConfiguration; 

import org.springframework.test.context.junit4.SpringRunner; 

import javax.annotation.Resource; 

import java.util.Properties; 

@RunWith(SpringRunner.class) 

@ContextConfiguration({&quot;classpath:spring-beans-config.xml&quot;}) 

public class TestYamlPropertiesAndPropertiesConfig { 

@Resource(name = &quot;yamlProperties&quot;) 

private Properties yamlProperties; 

@Resource(name = &quot;propertiesConfig&quot;) 

private PropertiesConfiguration propertiesConfig; 

@Test

public void testYamlProperties() { 

System.out.println(yamlProperties.getProperty(&quot;mysql.jdbc.url&quot;)); 

System.out.println(yamlProperties.getProperty(&quot;username&quot;)); 

} 

@Test

public void testPropertiesConfig() { 

System.out.println(propertiesConfig.getString(&quot;username&quot;)); 

System.out.println(propertiesConfig.getInteger(&quot;age&quot;, 0)); 

} 

} 
</code></pre><p>输出: </p>
<pre><code>Dr. Alice 

22 

jdbc:mysql://localhost:3306 

Ritchie Yu 
</code></pre>]]></content>
      
        <categories>
            
            <category> JavaWeb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> gradle </tag>
            
            <tag> groovy </tag>
            
            <tag> yaml </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Intellij Ideal下Gradle部署mybatis]]></title>
      <url>/2017/10/09/JavaWeb/Gradle%E9%83%A8%E7%BD%B2mybatis/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a> 
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="http://www.mybatis.org/generator/index.html" target="_blank" rel="external">Mybatis Generator</a>是一个mybatis工具项目，用于生成mybatis的model,mapper,dao持久层代码。<strong>Mybatis Generator</strong>提供了maven plugin,ant target，java三种方式启动。现在主流的构建工具是<a href="https://gradle.org/" target="_blank" rel="external">Gradle</a>,虽然mybatis generator没有提供gradle的插件，但gradle可以调用ant任务，因此，gradle也能启动Mybatis Generator。 </p>
<h2 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h2><ul>
<li>数据库:mysql</li>
<li>数据库配置文件:src/main/resources/jdbc.properties</li>
<li>项目中使用了通用mapper 3.3.2 插件</li>
</ul>
<h2 id="项目依赖"><a href="#项目依赖" class="headerlink" title="项目依赖"></a>项目依赖</h2><p>在<strong>build.gradle</strong>中: 运行ant需要运行环境，也就是相应的jar包，因此添加一个配置 </p>
<pre><code>configurations {
    mybatisGenerator
}
</code></pre><p>给这个配置添加依赖 </p>
<pre><code>dependencies {
    mybatisGenerator &quot;org.mybatis.generator:mybatis-generator-core:${generatorVersion}&quot;
    mybatisGenerator &quot;mysql:mysql-connector-java:${mysqlVersion}&quot;
    mybatisGenerator &quot;tk.mybatis:mapper:${mybatisMapperVersion}&quot;
}
</code></pre><h2 id="配置task"><a href="#配置task" class="headerlink" title="配置task"></a>配置task</h2><pre><code>def getDbProperties = {
    def properties = new Properties()
    file(&quot;src/main/resources/jdbc.properties&quot;).withInputStream { inputStream -&gt;
        properties.load(inputStream)
    }
    properties;
}
task mybatisGenerate &lt;&lt; {
    def properties = getDbProperties()
    ant.properties[&#39;targetProject&#39;] = projectDir.path
    ant.properties[&#39;driverClass&#39;] = properties.getProperty(&quot;jdbc.driverClassName&quot;)
    ant.properties[&#39;connectionURL&#39;] = properties.getProperty(&quot;jdbc.url&quot;)
    ant.properties[&#39;userId&#39;] = properties.getProperty(&quot;jdbc.username&quot;)
    ant.properties[&#39;password&#39;] = properties.getProperty(&quot;jdbc.password&quot;)
    ant.properties[&#39;src_main_java&#39;] = sourceSets.main.java.srcDirs[0].path
    ant.properties[&#39;src_main_resources&#39;] = sourceSets.main.resources.srcDirs[0].path
    ant.properties[&#39;modelPackage&#39;] = this.modelPackage
    ant.properties[&#39;mapperPackage&#39;] = this.mapperPackage
    ant.properties[&#39;sqlMapperPackage&#39;] = this.sqlMapperPackage
    ant.taskdef(
            name: &#39;mbgenerator&#39;,
            classname: &#39;org.mybatis.generator.ant.GeneratorAntTask&#39;,
            classpath: configurations.mybatisGenerator.asPath
    )
    ant.mbgenerator(overwrite: true,
            configfile: &#39;src/main/resources/generatorConfig.xml&#39;, verbose: true) {
        propertyset {
            propertyref(name: &#39;targetProject&#39;)
            propertyref(name: &#39;userId&#39;)
            propertyref(name: &#39;driverClass&#39;)
            propertyref(name: &#39;connectionURL&#39;)
            propertyref(name: &#39;password&#39;)
            propertyref(name: &#39;src_main_java&#39;)
            propertyref(name: &#39;src_main_resources&#39;)
            propertyref(name: &#39;modelPackage&#39;)
            propertyref(name: &#39;mapperPackage&#39;)
            propertyref(name: &#39;sqlMapperPackage&#39;)
        }
    }
}
</code></pre><p>大致思路 </p>
<ul>
<li>从_jdbc.propertis_读取配置</li>
<li>_把配置注入ant任务_</li>
<li>_运行ant_生成文件</li>
</ul>
<p>jdbc.properties </p>
<pre><code>jdbc.driverClassName=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://127.0.0.1:3306/userdb?useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;allowMultiQueries=true
jdbc.username=root
jdbc.password=admin
</code></pre><p>其他配置_gradle.propertis_ </p>
<pre><code>#生成实体类所在的包
modelPackage=test.mybatis.pojo
#生成的mapper接口类所在包
mapperPackage=test.mybatis.mapper
#生成的mapper xml文件所在包，默认存储在resources目录下
sqlMapperPackage=mybatis
</code></pre><h2 id="generatorConfig配置"><a href="#generatorConfig配置" class="headerlink" title="generatorConfig配置"></a>generatorConfig配置</h2><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE generatorConfiguration
        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;
&lt;generatorConfiguration&gt;
    &lt;context id=&quot;Mysql&quot; targetRuntime=&quot;MyBatis3Simple&quot; defaultModelType=&quot;flat&quot;&gt;
        &lt;commentGenerator&gt;
            &lt;property name=&quot;suppressAllComments&quot; value=&quot;false&quot;&gt;&lt;/property&gt;
            &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;&gt;&lt;/property&gt;
            &lt;property name=&quot;javaFileEncoding&quot; value=&quot;utf-8&quot;/&gt;
        &lt;/commentGenerator&gt;

        &lt;jdbcConnection driverClass=&quot;${driverClass}&quot;
                        connectionURL=&quot;${connectionURL}&quot;
                        userId=&quot;${userId}&quot;
                        password=&quot;${password}&quot;&gt;
        &lt;/jdbcConnection&gt;

        &lt;javaTypeResolver &gt;
            &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt;
        &lt;/javaTypeResolver&gt;

        &lt;javaModelGenerator targetPackage=&quot;${modelPackage}&quot; targetProject=&quot;${src_main_java}&quot;&gt;
            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot;&gt;&lt;/property&gt;
            &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;&gt;&lt;/property&gt;
        &lt;/javaModelGenerator&gt;

        &lt;sqlMapGenerator targetPackage=&quot;${sqlMapperPackage}&quot; targetProject=&quot;${src_main_resources}&quot;&gt;
            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot;&gt;&lt;/property&gt;
        &lt;/sqlMapGenerator&gt;


        &lt;javaClientGenerator targetPackage=&quot;${mapperPackage}&quot; targetProject=&quot;${src_main_java}&quot; type=&quot;XMLMAPPER&quot;&gt;
            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot;/&gt;
        &lt;/javaClientGenerator&gt;

        &lt;table tableName=&quot;ta_user&quot; enableCountByExample=&quot;false&quot;
               enableDeleteByExample=&quot;false&quot;
               enableSelectByExample=&quot;false&quot;
               enableUpdateByExample=&quot;false&quot;&gt;
            &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;MySql&quot; identity=&quot;true&quot;/&gt;
        &lt;/table&gt;
    &lt;/context&gt;
&lt;/generatorConfiguration&gt;
</code></pre><h2 id="run生成代码"><a href="#run生成代码" class="headerlink" title="run生成代码"></a>run生成代码</h2><pre><code>gradle  mybatisGenerate
</code></pre><h2 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构"></a>项目目录结构</h2><p><img src="http://dandandeshangni.oss-cn-beijing.aliyuncs.com/github/gradle_mybatis_generator.png" alt=""></p>
<p>dependencies.gradle配置 </p>
<pre><code>ext {
    //gradle
    gradleVersion = &#39;2.5&#39;
    //junit
    junitVersion = &#39;4.12&#39;
    //log4j
    log4jVersion = &#39;1.2.16&#39;
    //mybatis
    mybatisMapperVersion = &#39;3.3.2&#39;
    //mybatis
    mybatisVersion = &#39;3.2.6&#39;
    //mysql驱动
    mysqlVersion = &#39;5.1.18&#39;
    //mybatis-spring
    mybatisSpringVersion = &#39;1.3.0&#39;
    //generatorVersion
    generatorVersion = &#39;1.3.2&#39;
}
</code></pre><p>build.gradle完整配置 </p>
<pre><code>group &#39;test.mybatis&#39;
version &#39;1.0-SNAPSHOT&#39;

apply from: &quot;${rootDir}/gradle/dependencies.gradle&quot;

apply plugin: &#39;java&#39;
apply plugin: &#39;war&#39;

configurations {
    mybatisGenerator
}

repositories {
    mavenCentral()
}
dependencies {
    mybatisGenerator &quot;org.mybatis.generator:mybatis-generator-core:${generatorVersion}&quot;
    mybatisGenerator &quot;mysql:mysql-connector-java:${mysqlVersion}&quot;
    mybatisGenerator &quot;tk.mybatis:mapper:${mybatisMapperVersion}&quot;
}



compileJava {
    sourceCompatibility = JavaVersion.VERSION_1_8
    targetCompatibility = JavaVersion.VERSION_1_8
}

repositories {
    jcenter()
    mavenCentral()
}

dependencies {
//    compile &#39;tk.mybatis:mapper:3.3.9&#39;
    compile &quot;log4j:log4j:${log4jVersion}&quot;
    compile &quot;org.mybatis:mybatis:${mybatisVersion}&quot;
    compile &quot;mysql:mysql-connector-java:${mysqlVersion}&quot;
    compile &quot;junit:junit:${junitVersion}&quot;
    compile &quot;org.mybatis:mybatis-spring:${mybatisSpringVersion}&quot;
}

def getDbProperties = {
    def properties = new Properties()
    file(&quot;src/main/resources/jdbc.properties&quot;).withInputStream { inputStream -&gt;
        properties.load(inputStream)
    }
    properties;
}
task mybatisGenerate &lt;&lt; {
    def properties = getDbProperties()
    ant.properties[&#39;targetProject&#39;] = projectDir.path
    ant.properties[&#39;driverClass&#39;] = properties.getProperty(&quot;jdbc.driverClassName&quot;)
    ant.properties[&#39;connectionURL&#39;] = properties.getProperty(&quot;jdbc.url&quot;)
    ant.properties[&#39;userId&#39;] = properties.getProperty(&quot;jdbc.username&quot;)
    ant.properties[&#39;password&#39;] = properties.getProperty(&quot;jdbc.password&quot;)
    ant.properties[&#39;src_main_java&#39;] = sourceSets.main.java.srcDirs[0].path
    ant.properties[&#39;src_main_resources&#39;] = sourceSets.main.resources.srcDirs[0].path
    ant.properties[&#39;modelPackage&#39;] = this.modelPackage
    ant.properties[&#39;mapperPackage&#39;] = this.mapperPackage
    ant.properties[&#39;sqlMapperPackage&#39;] = this.sqlMapperPackage
    ant.taskdef(
            name: &#39;mbgenerator&#39;,
            classname: &#39;org.mybatis.generator.ant.GeneratorAntTask&#39;,
            classpath: configurations.mybatisGenerator.asPath
    )
    ant.mbgenerator(overwrite: true,
            configfile: &#39;src/main/resources/generatorConfig.xml&#39;, verbose: true) {
        propertyset {
            propertyref(name: &#39;targetProject&#39;)
            propertyref(name: &#39;userId&#39;)
            propertyref(name: &#39;driverClass&#39;)
            propertyref(name: &#39;connectionURL&#39;)
            propertyref(name: &#39;password&#39;)
            propertyref(name: &#39;src_main_java&#39;)
            propertyref(name: &#39;src_main_resources&#39;)
            propertyref(name: &#39;modelPackage&#39;)
            propertyref(name: &#39;mapperPackage&#39;)
            propertyref(name: &#39;sqlMapperPackage&#39;)
        }
    }
}
</code></pre><p>刷新gradle出现mybatisGenerate <img src="http://dandandeshangni.oss-cn-beijing.aliyuncs.com/github/gradle_mybatisgenerate.png" alt=""></p>
<p>完整项目地址：<a href="https://github.com/longfeizheng/mybatisDemo" target="_blank" rel="external">mybatisDemo</a></p>
<p>参考链接 </p>
<ul>
<li><a href="http://chenkaihua.com/2015/12/19/running-mybatis-generator-with-gradle/" target="_blank" rel="external">http://chenkaihua.com/2015/12/19/running-mybatis-generator-with-gradle/</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> JavaWeb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javaweb </tag>
            
            <tag> gradle </tag>
            
            <tag> mybatis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSS布局--flex]]></title>
      <url>/2017/10/04/VueJs/flex%E5%B8%83%E5%B1%80/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a> 
<p>网页布局（layout）是 CSS 的一个重点应用。 </p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071001.gif" alt=""></p>
<p>布局的传统解决方案，基于<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/box_model" target="_blank" rel="external">盒状模型</a>，依赖 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/display" target="_blank" rel="external"><code>display</code></a> 属性 + <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/position" target="_blank" rel="external"><code>position</code></a>属性 + <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/float" target="_blank" rel="external"><code>float</code></a>属性。它对于那些特殊布局非常不方便，比如，<a href="https://css-tricks.com/centering-css-complete-guide/" target="_blank" rel="external">垂直居中</a>就不容易实现。 </p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071002.png" alt=""></p>
<p>2009年，W3C 提出了一种新的方案—-Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。 </p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071003.jpg" alt=""></p>
<p>Flex 布局将成为未来布局的首选方案。本文介绍它的语法，<a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" target="_blank" rel="external">下一篇文章</a>给出常见布局的 Flex 写法。网友 <a href="http://vgee.cn/" target="_blank" rel="external">JailBreak</a> 为本文的所有示例制作了 <a href="http://static.vgee.cn/static/index.html" target="_blank" rel="external">Demo</a>，也可以参考。 </p>
<p>以下内容主要参考了下面两篇文章：<a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/" target="_blank" rel="external">A Complete Guide to Flexbox</a> 和 <a href="https://scotch.io/tutorials/a-visual-guide-to-css3-flexbox-properties" target="_blank" rel="external">A Visual Guide to CSS3 Flexbox Properties</a>。 </p>
<h2 id="一、Flex-布局是什么？"><a href="#一、Flex-布局是什么？" class="headerlink" title="一、Flex 布局是什么？"></a>一、Flex 布局是什么？</h2><p>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 </p>
<p>任何一个容器都可以指定为 Flex 布局。 </p>
<blockquote>
<p>.box{<br>      display: flex;<br>    }</p>
</blockquote>
<p>行内元素也可以使用 Flex 布局。 </p>
<blockquote>
<p>.box{<br>      display: inline-flex;<br>    }</p>
</blockquote>
<p>Webkit 内核的浏览器，必须加上<code>-webkit</code>前缀。 </p>
<blockquote>
<p>.box{<br>      display: -webkit-flex; /<em> Safari </em>/<br>      display: flex;<br>    }</p>
</blockquote>
<p>注意，设为 Flex 布局以后，子元素的<code>float</code>、<code>clear</code>和<code>vertical-align</code>属性将失效。 </p>
<h2 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h2><p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。 </p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071004.png" alt=""></p>
<p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做<code>main start</code>，结束位置叫做<code>main end</code>；交叉轴的开始位置叫做<code>cross start</code>，结束位置叫做<code>cross end</code>。 </p>
<p>项目默认沿主轴排列。单个项目占据的主轴空间叫做<code>main size</code>，占据的交叉轴空间叫做<code>cross size</code>。 </p>
<h2 id="三、容器的属性"><a href="#三、容器的属性" class="headerlink" title="三、容器的属性"></a>三、容器的属性</h2><p>以下6个属性设置在容器上。 </p>
<blockquote>
<ul>
<li>flex-direction</li>
<li>flex-wrap</li>
<li>flex-flow</li>
<li>justify-content</li>
<li>align-items</li>
<li>align-content</li>
</ul>
</blockquote>
<h3 id="3-1-flex-direction属性"><a href="#3-1-flex-direction属性" class="headerlink" title="3.1 flex-direction属性"></a>3.1 flex-direction属性</h3><p><code>flex-direction</code>属性决定主轴的方向（即项目的排列方向）。 </p>
<blockquote>
<p>.box {<br>      flex-direction: row | row-reverse | column | column-reverse;<br>    }</p>
</blockquote>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071005.png" alt=""></p>
<p>它可能有4个值。 </p>
<blockquote>
<ul>
<li><code>row</code>（默认值）：主轴为水平方向，起点在左端。</li>
<li><code>row-reverse</code>：主轴为水平方向，起点在右端。</li>
<li><code>column</code>：主轴为垂直方向，起点在上沿。</li>
<li><code>column-reverse</code>：主轴为垂直方向，起点在下沿。</li>
</ul>
</blockquote>
<h3 id="3-2-flex-wrap属性"><a href="#3-2-flex-wrap属性" class="headerlink" title="3.2 flex-wrap属性"></a>3.2 flex-wrap属性</h3><p>默认情况下，项目都排在一条线（又称”轴线”）上。<code>flex-wrap</code>属性定义，如果一条轴线排不下，如何换行。 </p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071006.png" alt=""></p>
<blockquote>
<p>.box{<br>      flex-wrap: nowrap | wrap | wrap-reverse;<br>    }</p>
</blockquote>
<p>它可能取三个值。 </p>
<p>（1）<code>nowrap</code>（默认）：不换行。 </p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071007.png" alt=""></p>
<p>（2）<code>wrap</code>：换行，第一行在上方。 </p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071008.jpg" alt=""></p>
<p>（3）<code>wrap-reverse</code>：换行，第一行在下方。 </p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071009.jpg" alt=""></p>
<h3 id="3-3-flex-flow"><a href="#3-3-flex-flow" class="headerlink" title="3.3 flex-flow"></a>3.3 flex-flow</h3><p><code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code>。 </p>
<blockquote>
<p>.box {<br>      flex-flow: <flex-direction> || <flex-wrap>;<br>    }</flex-wrap></flex-direction></p>
</blockquote>
<h3 id="3-4-justify-content属性"><a href="#3-4-justify-content属性" class="headerlink" title="3.4 justify-content属性"></a>3.4 justify-content属性</h3><p><code>justify-content</code>属性定义了项目在主轴上的对齐方式。 </p>
<blockquote>
<p>.box {<br>      justify-content: flex-start | flex-end | center | space-between | space-around;<br>    }</p>
</blockquote>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071010.png" alt=""></p>
<p>它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。 </p>
<blockquote>
<ul>
<li><code>flex-start</code>（默认值）：左对齐</li>
<li><code>flex-end</code>：右对齐</li>
<li><code>center</code>： 居中</li>
<li><code>space-between</code>：两端对齐，项目之间的间隔都相等。</li>
<li><code>space-around</code>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li>
</ul>
</blockquote>
<h3 id="3-5-align-items属性"><a href="#3-5-align-items属性" class="headerlink" title="3.5 align-items属性"></a>3.5 align-items属性</h3><p><code>align-items</code>属性定义项目在交叉轴上如何对齐。 </p>
<blockquote>
<p>.box {<br>      align-items: flex-start | flex-end | center | baseline | stretch;<br>    }</p>
</blockquote>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071011.png" alt=""></p>
<p>它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。 </p>
<blockquote>
<ul>
<li><code>flex-start</code>：交叉轴的起点对齐。</li>
<li><code>flex-end</code>：交叉轴的终点对齐。</li>
<li><code>center</code>：交叉轴的中点对齐。</li>
<li><code>baseline</code>: 项目的第一行文字的基线对齐。</li>
<li><code>stretch</code>（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li>
</ul>
</blockquote>
<h3 id="3-6-align-content属性"><a href="#3-6-align-content属性" class="headerlink" title="3.6 align-content属性"></a>3.6 align-content属性</h3><p><code>align-content</code>属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 </p>
<blockquote>
<p>.box {<br>      align-content: flex-start | flex-end | center | space-between | space-around | stretch;<br>    }</p>
</blockquote>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071012.png" alt=""></p>
<p>该属性可能取6个值。 </p>
<blockquote>
<ul>
<li><code>flex-start</code>：与交叉轴的起点对齐。</li>
<li><code>flex-end</code>：与交叉轴的终点对齐。</li>
<li><code>center</code>：与交叉轴的中点对齐。</li>
<li><code>space-between</code>：与交叉轴两端对齐，轴线之间的间隔平均分布。</li>
<li><code>space-around</code>：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li>
<li><code>stretch</code>（默认值）：轴线占满整个交叉轴。</li>
</ul>
</blockquote>
<h3 id="四、项目的属性"><a href="#四、项目的属性" class="headerlink" title="四、项目的属性"></a>四、项目的属性</h3><p>以下6个属性设置在项目上。 </p>
<blockquote>
<ul>
<li><code>order</code></li>
<li><code>flex-grow</code></li>
<li><code>flex-shrink</code></li>
<li><code>flex-basis</code></li>
<li><code>flex</code></li>
<li><code>align-self</code></li>
</ul>
</blockquote>
<h3 id="4-1-order属性"><a href="#4-1-order属性" class="headerlink" title="4.1 order属性"></a>4.1 order属性</h3><p><code>order</code>属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 </p>
<blockquote>
<p>.item {<br>      order: <integer>;<br>    }</integer></p>
</blockquote>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071013.png" alt=""></p>
<h3 id="4-2-flex-grow属性"><a href="#4-2-flex-grow属性" class="headerlink" title="4.2 flex-grow属性"></a>4.2 flex-grow属性</h3><p><code>flex-grow</code>属性定义项目的放大比例，默认为<code>0</code>，即如果存在剩余空间，也不放大。 </p>
<blockquote>
<p>.item {<br>      flex-grow: <number>; /<em> default 0 </em>/<br>    }</number></p>
</blockquote>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071014.png" alt=""></p>
<p>如果所有项目的<code>flex-grow</code>属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的<code>flex-grow</code>属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 </p>
<h3 id="4-3-flex-shrink属性"><a href="#4-3-flex-shrink属性" class="headerlink" title="4.3 flex-shrink属性"></a>4.3 flex-shrink属性</h3><p><code>flex-shrink</code>属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 </p>
<blockquote>
<p>.item {<br>      flex-shrink: <number>; /<em> default 1 </em>/<br>    }</number></p>
</blockquote>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071015.jpg" alt=""></p>
<p>如果所有项目的<code>flex-shrink</code>属性都为1，当空间不足时，都将等比例缩小。如果一个项目的<code>flex-shrink</code>属性为0，其他项目都为1，则空间不足时，前者不缩小。 </p>
<p>负值对该属性无效。 </p>
<h3 id="4-4-flex-basis属性"><a href="#4-4-flex-basis属性" class="headerlink" title="4.4 flex-basis属性"></a>4.4 flex-basis属性</h3><p><code>flex-basis</code>属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为<code>auto</code>，即项目的本来大小。 </p>
<blockquote>
<p>.item {<br>      flex-basis: <length> | auto; /<em> default auto </em>/<br>    }</length></p>
</blockquote>
<p>它可以设为跟<code>width</code>或<code>height</code>属性一样的值（比如350px），则项目将占据固定空间。 </p>
<h3 id="4-5-flex属性"><a href="#4-5-flex属性" class="headerlink" title="4.5 flex属性"></a>4.5 flex属性</h3><p><code>flex</code>属性是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选。 </p>
<blockquote>
<p>.item {<br>      flex: none | [ &lt;’flex-grow’&gt; &lt;’flex-shrink’&gt;? || &lt;’flex-basis’&gt; ]<br>    }</p>
</blockquote>
<p>该属性有两个快捷值：<code>auto</code> (<code>1 1 auto</code>) 和 none (<code>0 0 auto</code>)。 </p>
<p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 </p>
<h3 id="4-6-align-self属性"><a href="#4-6-align-self属性" class="headerlink" title="4.6 align-self属性"></a>4.6 align-self属性</h3><p><code>align-self</code>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。 </p>
<blockquote>
<p>.item {<br>      align-self: auto | flex-start | flex-end | center | baseline | stretch;<br>    }</p>
</blockquote>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071016.png" alt=""></p>
<p>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。 </p>
]]></content>
      
        <categories>
            
            <category> VueJs </category>
            
        </categories>
        
        
        <tags>
            
            <tag> css </tag>
            
            <tag> boxing </tag>
            
            <tag> flexing box </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Stylus使用指南]]></title>
      <url>/2017/10/03/VueJs/Stylus%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a> 
<blockquote>
<p>很少有文章针对Sass、LESS和Stylus做这么详细的对比。<a href="http://weibo.com/u/1143654280" target="_blank" rel="external">@Justineo</a>写的《<a href="http://efe.baidu.com/blog/revisiting-css-preprocessors/" target="_blank" rel="external">再谈 CSS 预处理器</a>》让我受益良多，特将此文转载到小站。 </p>
</blockquote>
<p>CSS 预处理器是什么？一般来说，它们基于 CSS 扩展了一套属于自己的 DSL，来解决我们书写 CSS 时难以解决的问题： </p>
<ul>
<li>语法不够强大，比如无法嵌套书写导致模块化开发中需要书写很多重复的选择器；</li>
<li>没有变量和合理的样式复用机制，使得逻辑上相关的属性值必须以字面量的形式重复输出，导致难以维护。</li>
</ul>
<p>所以这就决定了 CSS 预处理器的主要目标：提供 CSS 缺失的样式层复用机制、减少冗余代码，提高样式代码的可维护性。这不是锦上添花，而恰恰是雪中送炭。 </p>
<p>网上已经有不少对比目前最主流的三个预处理器 Less、Sass 和 Stylus（按字母顺序排名）的文章了，但是似乎都不是很详细，或者内容有些过时。下面我会更详细地探讨一下这三种预处理器的特性和它们的差异。 </p>
<p>下面主要会分为如下几方面来讨论： </p>
<ul>
<li>基本语法</li>
<li>嵌套语法</li>
<li>变量</li>
<li><code>@import</code></li>
<li>混入</li>
<li>继承</li>
<li>函数</li>
<li>逻辑控制</li>
</ul>
<p>事先声明一下，平时我在开发中主要使用的是 Less，所以可能对 Sass 和 Stylus 的熟悉程度稍差一些，比较时主要参考三者官网的语言特性说明，有一些正在开发的功能可能会遗漏。 </p>
<p>本文中对 CSS 语法的话术与 MDN 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Syntax" target="_blank" rel="external">CSS 语法</a>介绍一致。 </p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>Less 的基本语法属于「CSS 风格」，而 Sass、Stylus 相比之下激进一些，利用缩进、空格和换行来减少需要输入的字符。不过区别在于 Sass、Stylus 同时也兼容「CSS 风格」代码。多一种选择在更灵活的同时，在团队开发中也免不了增加更多约定来保持风格统一。而对个人而言，语法风格按自己口味选择即可。 </p>
<p><strong>注：后面的 Sass 代码会用被更多人接受的 SCSS 风格给出。</strong></p>
<p>Less &amp; SCSS： </p>
<pre><code>.box {
  display: block;
}
</code></pre><p>Sass： </p>
<pre><code>.box
  display: block
</code></pre><p>Stylus： </p>
<pre><code>.box
  display: block
</code></pre><h2 id="嵌套语法"><a href="#嵌套语法" class="headerlink" title="嵌套语法"></a>嵌套语法</h2><p>三者的嵌套语法都是一致的，甚至连引用父级选择器的标记 `&amp;`` 也相同。区别只是 Sass 和 Stylus 可以用没有大括号的方式书写。以 Less 为例： </p>
<pre><code>.a {
  &amp;.b {
    color: red;
  }
}
</code></pre><p>生成的 CSS 为： </p>
<pre><code>.a.b {
  color: red;
}
</code></pre><p>除了规则集的嵌套，Sass 额外提供了一个我个人认为比较另（jī）类（lèi）的「属性嵌套」： </p>
<pre><code>.funky {
  font: {
    family: fantasy;
    size: 30em;
    weight: bold;
  }
}
</code></pre><h2 id="选择器引用"><a href="#选择器引用" class="headerlink" title="选择器引用"></a>选择器引用</h2><p>三者都支持用 <code>&amp;</code> 在嵌套的规则集中引用上层的选择器，这可以是嵌套书写 CSS 时的「惯例」了。语法相同，但是逻辑上有些许差异。在一个选择器中用两次以上 <code>&amp;</code> 且父选择器是一个列表时，Less 会对选择器进行排列组合，而 Sass 和 Stylus 不会这么做。 </p>
<p>也就是说，假设上层选择器为 <code>.a</code>, <code>.b</code>，则内部的 <code>&amp; &amp;</code> 在 Less 中会成为 <code>.a .a</code>, <code>.a .b</code>, <code>.b .a</code>, <code>.b .b</code>，而 Sass 和 Stylus 则输出 <code>.a .a, .b .b</code>。 </p>
<p>假设我们要用预处理器书写 [WHATWG 推荐的 section 标题样式][4]，在 Less 中可以方便地书写为： </p>
<pre><code>   [4]: https://html.spec.whatwg.org/multipage/rendering.html#sections-and-headings
</code></pre><p>article, aside, nav, section {<br>          h1 {<br>            margin-top: 0.83em; margin-bottom: 0.83em; font-size: 1.50em;<br>          }<br>          &amp; &amp; h1 {<br>            margin-top: 1.00em; margin-bottom: 1.00em; font-size: 1.17em;<br>          }<br>          &amp; &amp; &amp; h1 {<br>            margin-top: 1.33em; margin-bottom: 1.33em; font-size: 1.00em;<br>          }<br>          &amp; &amp; &amp; &amp; h1 {<br>            margin-top: 1.67em; margin-bottom: 1.67em; font-size: 0.83em;<br>          }<br>          &amp; &amp; &amp; &amp; &amp; h1 {<br>            margin-top: 2.33em; margin-bottom: 2.33em; font-size: 0.67em;<br>          }<br>        }</p>
<p>当然，这个推荐样式十分脑残，编译出来的结果会有 47KB 之巨，根本不可用，这里只是借来演示一下。 </p>
<p>除了 <code>&amp;</code>，Sass 和 Stylus 更进一步，分别用 <code>@at-root</code> 和 <code>/</code> 符号作为嵌套时「根」规则集的选择器引用。这有什么用呢？举个例子，假设 HTML 结构是这样的： </p>
<pre><code>&lt;article class=&quot;post&quot;&gt;
  &lt;h1&gt;我是一篇文章&lt;/h1&gt;
  &lt;section&gt;
    &lt;h1 class=&quot;section-title&quot;&gt;&lt;a href=&quot;#s1&quot; class=&quot;section-link&quot;&gt;#&lt;/a&gt;我是章节标题&lt;/h1&gt;
    &lt;p&gt;我只是一个&lt;em&gt;例子&lt;/em&gt;。&lt;/p&gt;
  &lt;/section&gt;
&lt;/article&gt;
</code></pre><p>如果我这么写 Sass 代码，是完全符合业务的嵌套关系的： </p>
<pre><code>.post {
  section {
    .section-title {
      color: #333;
      .section-link {
        color: #999;
      }
    }
    /* other section styles */
  }
  /* other post styles */
}
</code></pre><p>但是这样生成出来的选择器会有 <code>.post section .section-title .section-link</code>，很多时候我们觉得写成 <code>.post .section-link</code> 就够了。 </p>
<p>于是我们在 Stylus 中可以这么写： </p>
<pre><code>.post
  section
    .section-title
      color #333
      /.post .section-link
        color #999
    /* other section styles */

  /* other post styles */
</code></pre><p>这样输出的 CSS 就会是： </p>
<pre><code>.post section .section-title {
  color: #333;
}
.post .section-link {
  color: #999;
}
</code></pre><p>这就是我们想要的样子了。当然也可以这样写： </p>
<pre><code>.post
  section
    .section-title
      color #333
    /* other section styles */

  .section-link
    color #999
  /* other post styles */
</code></pre><p>我个人是推荐这种写法（不使用 <code>root</code> 引用）的，因为当你确定 <code>.section-link</code> 的样式不依赖于它位于 <code>section</code> 或 <code>.section-title</code> 下时，就不应该嵌套于此。否则如果为了一点点性能上的考虑（还不一定会是优化），使得设计意图变得更不准确，我觉得得不偿失。 </p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量无疑为 CSS 增加了一种有效的复用方式，减少了原来在 CSS 中无法避免的重复「硬编码」。 </p>
<p>Less： </p>
<pre><code>@red: #c00;

strong {
  color: @red;
}
</code></pre><p>Sass： </p>
<pre><code>$red: #c00;

strong {
  color: $red;
}
</code></pre><p>Stylus： </p>
<pre><code>red = #c00

strong
  color: red
</code></pre><p>Less 的选择有一个问题：<code>@</code>规则在 CSS 中可以算是一种「原生」的扩展方式，变量名用 <code>@</code>开头很可能会和以后的新 <code>@</code>规则冲突。（当然理论上只要 CSS 规范不引入 <code>@a: b</code> 这样的规则，问题也不大。而且规范制定的时候也会参考很多现有的实现。） </p>
<p>相比之下 Sass 的选择中规中矩，而 Stylus 就不同了，不需要额外的标志符。这意味着：在 Stylus 中，我们可以覆写 CSS 原生的属性值！Stylus 的设计让人有一种「你以为你在写 CSS，但其实你不是」的感觉，后面会有更多这样的例子。 </p>
<p>顺便说一下，CSS 规范也有关于变量实现的草案，目前的方案是这个样子的： </p>
<pre><code>/* global scope */
:root {
  --red: #c00;
}

strong {
  color: var(--red);
}
</code></pre><p>不管语法槽点如何，原生 CSS 变量可以通过 DOM 结构来继承，也就是说是代码真正「运行」时（runtime）决定的。元素引用一个变量时会按 DOM 向上查找定义在上层元素上的同名变量。这一点是任何预处理语言都无法做到的。可以用 Firefox 31+ 看一下这个 <a href="http://jsbin.com/webuju/1/edit" target="_blank" rel="external">demo</a>。至于这种机制是不是好用，暂时还没研究过。不过从开发的思维惯性来看，还很难一下子适应这种方式。 </p>
<h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>三种预处理器的变量作用域都是按嵌套的规则集划分，并且在当前规则集下找不到对应变量时会逐级向上查找，注意这个和原生 CSS 的逻辑是完全不同的。 </p>
<p>如果我们在代码中重写某个已经定义的变量的值，Less 的处理逻辑和其他两者有非常关键的区别。在 Less 中，这个行为被称为「<a href="http://lesscss.org/features/#variables-feature-lazy-loading" target="_blank" rel="external">懒加载（Lazy Loading）</a>」。所有 Less 变量的计算，都是以这个变量最后一次被定义的值为准。举一个例子更容易说清楚： </p>
<p>Less： </p>
<pre><code>@size: 10px;
.box {
    width: @size;
}

@size: 20px;
.ball {
    width: @size;
}
</code></pre><p>输出： </p>
<pre><code>.box {
  width: 20px;
}
.ball {
  width: 20px;
}
</code></pre><p>而在 Stylus 中： </p>
<pre><code>size = 10px
.box
  width: size

size = 20px
.ball
  width: size
</code></pre><p>输出： </p>
<pre><code>.box {
  width: 10px;
}
.ball {
  width: 20px;
}
</code></pre><p>Sass 的处理方式和 Stylus 相同，变量值输出时根据之前最近的一次定义计算。这其实代表了两种理念：Less 更倾向接近 CSS 的声明式，计算过程弱化调用时机；而 Sass 和 Stylus 更倾向于指令式。这两种方式会导致怎样的结果呢？ </p>
<p>举个例子来说，对于 Less，如果项目中引入了这样一个文件： </p>
<pre><code>@error-color: #c00;
@success-color: #0c0;
.error {
  color: @error-color;
  background-color: lighten(@error-color, 40%);
}
.success {
  color: @success-color;
  background-color: lighten(@success-color, 40%);
}
</code></pre><p>在业务代码中，在不修改外部引入文件的情况下，如果我想重写这两种状态的配色，只需要重新配置 <code>@error-color</code> 和 <code>@success-color</code> 这两个变量，就能改变 <code>.error</code> 和 <code>.success</code> 的样式。 </p>
<p>而在 Stylus 中，如果引入的第三方样式库中有这样的代码： </p>
<pre><code>error-color = #c00
success-color = #0c0

.error
  color: error-color
  background-color: lighten(error-color, 40%)

.success
  color: success-color
  background-color: lighten(success-color, 40%)
</code></pre><p>这种情况下后面的代码就无法通过重写变量值来覆盖样式了。Sass 也是如此。优点是 Stylus 和 Sass 这样的处理会不容易受多个第三方库变量名冲突的影响，因为一个变量不能影响在定义它以前的输出样式。 </p>
<p>由于 Sass 和 Stylus 变量在「运行」过程中使用完可以修改后再使用输出不同的值，所以这两者还提供了「仅当变量不存在时才赋值」的功能： </p>
<p>Sass： </p>
<pre><code>$x: 1;
$x: 5 !default;
$y: 3 !default;

// $x = 1, $y = 3
</code></pre><p>Stylus： </p>
<pre><code>x = 1
x := 5 // or x ?= 5
y = 3

// x = 1, y = 3
</code></pre><p>因为变量只能在输出前修改才能生效，所以如果要定制第三方库的样式，用户代码理论上得插入第三方库的配置与样式之间才能生效。而有了 <code>!default</code>，第三方库在提供默认配置时可以将开发给用户修改的变量设置为 <code>!default</code>，这样只要用户提前引入配置进行覆盖，就可以按需重写默认配置了： </p>
<pre><code>// lib.scss
$alert-color: red !default;
.alert {
  color: $alert-color;
}
// var.scss
$alert-color: #c00;
// page.scss
@import var
@import lib
</code></pre><p>这样最终页面输出的效果就是被用户重定义过的内容了。 </p>
<pre><code>/* page.css */
.alert {
  color: #c00;
}
</code></pre><p>由于 Less 处理变量的方式，如果我们要引入多个外部样式库或在多个团队进行合作开发时，如果不能确保开发过程可控，那为变量添加模块前缀就变得很有必要。 </p>
<p>此外，Sass 中提供一个 <code>!global</code> 的语法来让局部变量变成全局变量，也就是说 Sass 代码可以在内层覆盖全局变量的值。输出一段局部的样式可能使得后续所有样式都受到全局变量变化的影响。（这其实是 Sass 开始时默认的逻辑，Sass 3.3 以前所有变量都是全局的，之后改成了和 Less 和 Stylus 一样有嵌套作用域，全局变量要显式指定 <code>!global</code>。） </p>
<h2 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h2><p>预处理器都有定义变量的功能，除了在最常见的属性值中使用，其他还有哪些地方能用变量来增强对样式的抽象、复用呢？ </p>
<h2 id="变量名插值"><a href="#变量名插值" class="headerlink" title="变量名插值"></a>变量名插值</h2><p>Less 中支持 <code>@@foo</code> 的形式引用变量，即该变量的名字是由 <code>@foo</code> 的值决定的。比如我们可以利用它简化更清晰地调用 mixin： </p>
<pre><code>// some icon font lib

// variables with prefix to prevent conflicts
@content-apple: &quot;A&quot;;
@content-google: &quot;G&quot;;

// clearer argument values
.icon-content(@icon) {
  @var: ~&quot;content-@{icon}&quot;;
  &amp;::before {
    content: @@var;
  }
}

.icon-apple {
  .icon-content(apple); // &quot;A&quot;
}

.icon-google {
  .icon-content(google); // &quot;G&quot;
}
</code></pre><h2 id="选择器插值"><a href="#选择器插值" class="headerlink" title="选择器插值"></a>选择器插值</h2><p>选择器是样式表和 DOM 的纽带，是我们实际暴露给 HTML 的接口。支持插值显然可以让接口更不容易和其他内容冲突。假设我们在开发一个 UI 库，生成的组件类名希望有一个可配置的前缀，这时选择器插值就变得相当重要。初看下来，三者用法类似： </p>
<p>Less： </p>
<pre><code>@prefix: ui;
.@{prefix}-button {
  color: #333;
}
</code></pre><p>Sass： </p>
<pre><code>$prefix: ui
.#{$prefix}-button
  color: #333;
</code></pre><p>Stylus： </p>
<pre><code>prefix = ui
.{prefix}-button
  color #333
</code></pre><p>但是在 Less 中，有一个很严重的问题：通过选择器插值生成的规则无法被继承（<a href="https://github.com/less/less.js/issues/2200%EF%BC%89" target="_blank" rel="external">Extend dynamically generated selectors</a>！当然，如果有类似 Placeholder 的机制，这都不是事儿了。问题是 Less 没有！未来的方案看来可能是通过 <code>:extend(.mixin()</code>) 的方式实现类似功能（<a href="https://github.com/less/less.js/issues/1177" target="_blank" rel="external"><code>:extend mixins</code></a>），虽然用 <code>:extend</code> 本身的语法说不过去，但是在现有机制上来看还算可以接受。关于样式的继承复用，后面会详细讲到。 </p>
<h2 id="import-语句插值"><a href="#import-语句插值" class="headerlink" title="@import 语句插值"></a>@import 语句插值</h2><p>Sass 中只能在使用 <code>url()</code> 表达式引入时进行变量插值： </p>
<pre><code>$device: mobile;
@import url(styles.#{$device}.css);
</code></pre><p>Less 中可以在字符串中进行插值： </p>
<pre><code>@device: mobile;
@import &quot;styles.@{device}.css&quot;;
</code></pre><p>Stylus 中在这里插值不管用，但是可以利用其字符串拼接的功能实现： </p>
<pre><code>device = &quot;mobile&quot;
@import &quot;styles.&quot; + device + &quot;.css&quot;
</code></pre><p>注意由于 Less 的 Lazy Load 特性，即使是 <code>@import</code> 也是可以在后面的文件内容中进行覆盖的，修改掉变量就可以在前面引入不同的外部文件。而 Sass 与 Stylus 一旦输出语句，就无法通过变量改变了。 </p>
<h2 id="属性名插值"><a href="#属性名插值" class="headerlink" title="属性名插值"></a>属性名插值</h2><p>三个预处理器的目前版本都支持属性名插值，用法也类似。这里仅以 Stylus 为例： </p>
<pre><code>red-border(sides)
  for side in sides
    border-{side}-color: red // property name interpolation

.x
  red-border(top right)
</code></pre><p>输出： </p>
<pre><code>.x {
  border-top-color: #f00;
  border-right-color: #f00;
}
</code></pre><h2 id="其他-规则插值"><a href="#其他-规则插值" class="headerlink" title="其他 @ 规则插值"></a>其他 @ 规则插值</h2><p>三种预处理器均支持在 <code>@media</code>、<code>@keyframes</code>、<code>@counter-style</code> 等规则中进行插值。<code>@media</code> 插值主要用来做响应式的配置，而 <code>@keyframes</code> 这样带名称名称的 <code>@</code>规则则可以通过插值来避免命名冲突。 </p>
<p>Less： </p>
<pre><code>@m: screen;
@orient: landscape;
@media @m and (orientation: @orient) {
  body {
    width: 960px;
  }
}

@prefix: ui;
@keyframes ~&quot;@{prefix}-fade-in&quot; {
  0% {
    opacity: 0;
  }
  100% {
    opacity: 1;
  }
}
</code></pre><p>Sass： </p>
<pre><code>$m: screen;
$orient: landscape;
@media #{$m} and (orientation: $orient) {
  body {
    width: 1000px;
  }
}

$prefix: ui;
@keyframes #{$prefix}-fade-in {
  0% {
    opacity: 0;
  }
  100% {
    opacity: 1;
  }
}
</code></pre><p>Stylus： </p>
<pre><code>m = screen
orient = landscape
mq = m + &quot; and (orientation: &quot; + orient + &quot;)&quot;
@media mq
  body
    width: 960px

vendors = official
prefix = ui;
@keyframes {prefix}-fade-in {
  0% {
    opacity: 0;
  }
  100% {
    opacity: 1;
  }
}
</code></pre><p>三者均会输出如下 CSS： </p>
<pre><code>@media screen and (orientation: landscape) {
  body {
    width: 960px;
  }
}
@keyframes ui-fade-in {
  0% {
    opacity: 0;
  }
  100% {
    opacity: 1;
  }
}
</code></pre><p>Stylus 中似乎有 <code>and</code>时由于表达式计算的逻辑不能直接像 Less 与 Sass 那样写插值，所以这里采用了字符串拼接的方式。 </p>
<h2 id="import"><a href="#import" class="headerlink" title="@import"></a>@import</h2><p><code>@import</code> 对于模块化开发来说非常有帮助，但就这个功能来说，三种预处理器的行为各不相同。 </p>
<p>先说 Less，Less 扩展了语法，为 <code>@import</code> 增加了多种选项： </p>
<ul>
<li><code>@import (less) somefile.ext</code>:会将无论什么扩展名的文件都作为 Less 文件引入、一起编译；</li>
<li><code>@import (css) somefile.ext</code>:直接编译生成 <code>@import somefile.ext</code>，当做原生 <code>@import</code>；</li>
<li><code>@import (inline) somefile.ext</code>:直接将外部文件拷贝进输出文件的这个位置，但不会参与编译；</li>
<li><code>@import (reference) somefile.ext</code>:外部文件参与编译，但不输出内容，仅用来被本文件中的样式继承；</li>
<li><code>@import (optional) somefile.ext</code>:引入文件但在文件不存在时不报错，静默失败。</li>
</ul>
<p>上面的选项是可以联合使用的，比如可以这样写： </p>
<pre><code>@import (less, optional) somefile.ext;
</code></pre><p>除此之外还有 <code>once</code> 和 <code>multiple</code> 选项分别用来表示去重和不去重的引入方式，默认为 <code>once</code>。在不写任何选项时，Less 会根据扩展名进行推断来决定引入逻辑。 </p>
<p>Sass 没有扩展语法，而是自己推断引入的方式。<code>.css</code> 后缀、绝对路径、<code>url()</code> 表达式和带有 media query 的 <code>@import</code> 会直接用原生 <code>@import</code>，其他都会作为 Sass 代码参与编译。相比之下 Less 更灵活也更复杂。Sass 有个特有的功能叫做「partial」，因为 Sass 默认的编译工具可以编译整个目录下的文件，所以当一些文件不需要编译时，可以在文件名前加上 <code>_</code> 表明这是一个被别的模块引入本身不需要编译的代码片段。Less 的 lessc 由于本来就只处理一个文件，所以这件事就交给用户自己去写编译脚本了。Sass 中有一个比较棘手的问题是，<code>@import</code> 不会被去重，多次引入会导致一个样式文件被多次输出到编译结果中。为了解决这个问题，Foundation 做了如下的 <a href="https://github.com/ecomfe/spec/blob/master/less-code-style.md#user-content-%E6%B7%B7%E5%85%A5mixin-1" target="_blank" rel="external">hack</a>： </p>
<pre><code>   [9]: https://github.com/zurb/foundation/blob/a1eb7561ef835313e20995488afb3f627b27354a/scss/foundation/_functions.scss#L8-L21
</code></pre><p>// IMPORT ONCE<br>// We use this to prevent styles from being loaded multiple times for components that rely on other components.<br>$modules: () !default; </p>
<pre><code>@mixin exports($name) {
  // Import from global scope
  $modules: $modules !global;
  // Check if a module is already on the list
  $module_index: index($modules, $name);
  @if (($module_index == null) or ($module_index == false)) {
    $modules: append($modules, $name) !global;
    @content;
  }
}
</code></pre><p>然后在定义样式时都调用 <code>exports</code> 这个 mixin 来输出，起到只输出一次的效果。 </p>
<p>Stylus 和 Sass 比较接近，也使用隐性推断的方式，但在处理重复输出的问题上，Stylus 给出了一个自定义指令 <code>@require</code>，用法和 <code>@import</code> 完全一样，但只会输出一次。Stylus 还支持通配符，比如<code>@import &#39;product/*&#39;</code> 会引入 <code>product</code> 目录下的所有 <code>.styl</code> 文件，但因为一般引入样式都要显式指定顺序，所以这个功能实用性不高。 </p>
<p>三者相比较之下，Sass 的引入功能似乎有点残缺，不能去重是很大的硬伤。虽然能用 Foundation 那种方式「解决」，但实际上这是语言本身应该解决的问题。 </p>
<h2 id="混入"><a href="#混入" class="headerlink" title="混入"></a>混入</h2><p>混入（mixin）应该说是预处理器最精髓的功能之一了。它提供了 CSS 缺失的最关键的东西：样式层面的抽象。从语法上来说，三种预处理器的差异也比较大，这甚至会直接影响到我们的开发方式。 </p>
<p>Less 的混入有两种方式： </p>
<ul>
<li>直接在目标位置混入另一个类样式（输出已经确定，无法使用参数）；</li>
<li>定义一个不输出的样式片段（可以输入参数），在目标位置输出。（注：后面如无特殊说明，mixin 均用来指代此类混入。）</li>
</ul>
<p>举例来说： </p>
<pre><code>.alert {
  font-weight: 700;
}

.highlight(@color: red) {
  font-size: 1.2em;
  color: @color;
}

.heads-up {
  .alert;
  .highlight(red);
}
</code></pre><p>最后输出： </p>
<pre><code>.alert {
  font-weight: 700;
}
.heads-up {
  font-weight: 700;
  font-size: 1.2em;
  color: red;
}
</code></pre><p>可以混入已有类样式这一点很值得商榷。在上面的例子中，<code>.alert</code> 样式在被混入时甚至可以是 <code>.alert();</code>；<code>.highlight()</code> 混入时也可以写成 <code>.highlight;</code>。那么我们遇到这样的代码时根本不知道 <code>alert</code> 会不会是一个 HTML class。但由于这一点是在 Less 还不支持 <code>extend</code> 时就有的，所以也能够理解作者可能就是将这作为 <code>extend</code> 来用了。所以目前比较好的实践是：用代码规范规约开发者不得使用直接混入已有类样式的方式，而是先定义 mixin 然后在输出的类样式中进行调用，调用时必须显式加上 <code>()</code> 来表明这不是一个 class（事实上百度 EFE 已有的 <a href="https://github.com/ecomfe/spec/blob/master/less-code-style.md#user-content-%E6%B7%B7%E5%85%A5mixin-1" target="_blank" rel="external">Less 编码规范</a>就是这么定义的）。继承则应该直接通过 Less 的 <code>:extend</code> 来实现。 </p>
<p>另外需要注意的是，Less 在进行混入时，会找到所有符合调用参数的「mixin 签名」的样式一起输出。比如： </p>
<pre><code>.mixin(dark; @color) {
  color: darken(@color, 10%);
}
.mixin(light; @color) {
  color: lighten(@color, 10%);
}
.mixin(@_; @color) {
  display: block;
}

@switch: light;
.class {
  .mixin(@switch; #888);
}
</code></pre><p>这个例子中，第二个和第三个 mixin 都匹配了调用时的参数，于是它们的规则都会被输出： </p>
<pre><code>.class {
  color: #a2a2a2;
  display: block;
}
</code></pre><p>也就是说同名的 mixin 不是后面覆盖前面，而是会累加输出。只要参数符合定义，就会将 mixin 内部的样式规则、甚至变量全部拷贝到目标作用域下。 </p>
<p>这一点同样会带来一个问题：如果存在和 mixin 同名的 class 样式，如果 mixin 没有参数则在调用时会把对应的 class 样式一起输出，这显然是不符合预期的。 </p>
<p>假设有个叫 <code>.clearfix</code> 的 mixin，有两个 class 样式调用了它（其中一个也叫 <code>clearfix</code>）： </p>
<pre><code>.clearfix() {
  *zoom: 1;
  &amp;:before,
  &amp;:after {
    display: table;
    content: &quot;&quot;;
  }
}

.clearfix {
  .clearfix();
}

.list {
  .clearfix();
}
</code></pre><p>得到的输出是： </p>
<pre><code>.clearfix {
  *zoom: 1;
}
.clearfix:before,
.clearfix:after {
  display: table;
  content: &quot;&quot;;
}
.clearfix:after {
  clear: both;
}
.list {
  *zoom: 1;
}
.list:before,
.list:after {
  display: table;
  content: &quot;&quot;;
}
.list:after {
  clear: both;
}
.list:before,
.list:after {
  display: table;
  content: &quot;&quot;;
}
.list:after {
  clear: both;
}
</code></pre><p><code>.list</code> 的样式调用了两次！这一点在开发中一定要注意，不要给和非输出型 mixin 同名的类定义样式。 </p>
<p>对于 Sass，语义非常明确： </p>
<pre><code>@mixin large-text {
  font: {
    family: Arial;
    size: 20px;
    weight: bold;
  }
  color: #ff0000;
}

.page-title {
  @include large-text;
  padding: 4px;
  margin-top: 10px;
}
</code></pre><p>Sass 用 <code>@mixin</code> 和 <code>@include</code></p>
<p>两个指令清楚地描述了语义，不存在混入类样式的情况，但是书写时略显繁琐一些。当然，用 Sass 语法 而非 SCSS 语法的话可以简单地用 <code>=</code>定义 mixin，用 <code>+</code>引入 mixin： </p>
<pre><code>=large-text
  font:
    family: Arial
    size: 20px
    weight: bold
  color: #ff0000

.page-title
  +large-text
  padding: 4px
  margin-top: 10px
</code></pre><p>和 Less 不同，同名的 mixin 可以覆盖之前的定义，作用机制类似变量。 </p>
<p>Stylus 和 Sass 类似，但不用什么特殊的标记来引入： </p>
<pre><code>border-radius(n)
  -webkit-border-radius: n
  -moz-border-radius: n
  border-radius: n

.circle
  border-radius(50%)
</code></pre><p>Stylus 中还有一个「透明 mixin」的功能，也就是说引入 mixin 完全可以和引入普通属性一样！例如上面的这个 mixin，也可以这样引入： </p>
<pre><code>.circle
  border-radius: 50%
</code></pre><p>这意味着可以把兼容性上的处理隐藏在 mixin 中，直接用标准属性同名的 mixin 按普通属性的方式输出。当不需要兼容老浏览器时，直接把 mixin 定义删除仍然能够正常输出。不过这种写法虽然感觉非常「爽快」，但要求开发者必须能很好地区分原生属性和某个样式库中提供的 mixin 功能（对于有经验的开发者问题不大），而且透明意味着看到一个普通属性开发者不能判断是否已经在某处用 mixin 进行了重写，无法明确知道这里的代码最后输出会不会发生变化。在可控条件下，这个功能应该说是非常诱人的。 </p>
<h2 id="将声明块作为混入参数"><a href="#将声明块作为混入参数" class="headerlink" title="将声明块作为混入参数"></a>将声明块作为混入参数</h2><p>如果说调用时想传入一组样式声明而非单个值，三种预处理器都提供了相应的功能，但实现方式各有不同。 </p>
<p>在 Less 中需要先定义一个「规则集变量」（detached ruleset，其实就是 CSS 声明块，即规则集去掉选择器的部分），然后在调用 mixin 时把它作为参数传进去，然后在 mixin 中用 <code>@var()</code> 的方式输出： </p>
<pre><code>.red(@custom) {
  color: red;
  @custom();
}

.alert {
  @styles: {
    font-weight: 700;
    font-size: 1.5em;
  }

  .red(@styles);
}
</code></pre><p>在 Sass 和 Stylus 中，都支持直接在 mixin 调用下层传入声明块： </p>
<p>Sass 下直接跟一个声明块即可，然后用关键字 <code>@content</code> 来进行输出： </p>
<pre><code>@mixin red() {
  color: red;
  @content;
}

.alert {
  @include red() {
    font-weight: 700;
    font-size: 1.5em;
  }
}
</code></pre><p>Stylus 支持两种方法，首先是 Less 那样的「具名」声明块，调用时当做变量： </p>
<pre><code>red(foo)
  color: red
  {foo}

.alert
  foo =
    font-weight: 700
    font-size: 1.5em
  red(foo)
</code></pre><p>第二种是 Sass 那样类似传入「字面量」，并且用关键词 block 输出的方式。这种方式需要为要传入声明块的 mixin 前添加一个 <code>+</code> 符号（可能是来自 SCSS 的对应功能）： </p>
<pre><code>red()
  color: red
  {block}

.alert
  +red()
    font-weight: 700
    font-size: 1.5em
</code></pre><p>第二种方式可以看做是第一种方式的语法糖，在 mixin 只需要传入一个声明块时可以免去起名字带来的困扰。 </p>
<p>相比之下 Less 只支持先定义变量后传入的方式，优点是可以传入多个声明块；而 Sass 只支持传入一个「匿名」声明块但是更简单；Stylus 则是两种方式都支持。这个功能在抽象「需要应用样式的条件」时非常有用，比如我们基于 Stylus 的样式库 <a href="https://github.com/ecomfe/rider" target="_blank" rel="external">rider</a> 中就用它来实现<a href="https://github.com/ecomfe/rider/blob/master/lib/rider/breakpoint.styl" target="_blank" rel="external">对 media query 的抽象封装</a>。 </p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>混入很好用，可也有问题：如果多个地方都混入同样的代码，会造成输出代码的多次重复。比如在 Stylus 下： </p>
<pre><code>message()
  padding: 10px
  border: 1px solid #eee

.message
  message()

.warning
  message()
  color: #e2e21e
</code></pre><p>会输出： </p>
<pre><code>.message {
  padding: 10px;
  border: 1px solid #eee;
}
.warning {
  padding: 10px;
  border: 1px solid #eee;
  color: #e2e21e;
}
</code></pre><p>而我们可能期望的输出是： </p>
<pre><code>.message,
.warning {
  padding: 10px;
  border: 1px solid #eee;
}
.warning {
  color: #e2e21e;
}
</code></pre><p>也许大家会说可以这么写： </p>
<pre><code>message()
  padding: 10px
  border: 1px solid #eee

.message,
.warning
  message()

.warning
  color: #e2e21e
</code></pre><p>这样就可以按需要输出了。但其实预处理器的一个好处就是可以方便我们进行模块化开发。上面的例子中，<code>.message</code> 和 <code>.warning</code> 的样式如果是分布在两个模块中的，我合并过的选择器组样式写在哪里呢？情况更复杂的时候就更棘手了。 </p>
<p>这个时候就该继承出场了： </p>
<pre><code>.message
  padding: 10px
  border: 1px solid #eee

.warning
  @extend .message
  color: #e2e21e
</code></pre><p>这样就可以按模块进行开发（不管是分文件还是在同一文件中按业务功能安排样式的顺序），同时兼顾输出的效率了。 </p>
<p>Stylus 的继承方式来自 Sass，两者如出一辙。 而 Less 则又「独树一帜」地用伪类来描述继承关系： </p>
<pre><code>.message {
  padding: 10px;
  border: 1px solid #eee;
}

.warning {
  &amp;:extend(.message);
  color: #e2e21e;
}
/* Or:
.warning:extend(.message) {
  color: #e2e21e;
}
*/
</code></pre><p>同时，Less 默认只继承父类本身的样式，如果要同时继承嵌套定义在父类作用域下的样式，得使用关键字 <code>all</code>，比如 <code>&amp;:extend(.message all);</code>。 </p>
<p>关于使用伪类描述继承关系，<a href="http://weibo.com/u/1960954893" target="_blank" rel="external">Hax</a> 在 Less 的另一个 issue 下曾经<a href="https://github.com/less/less.js/issues/1177#issuecomment-17404003" target="_blank" rel="external">言辞激烈地提出了批评</a>，同时也遭到了 Less 项目组毫不客气的回应。我个人完全赞同 Hax 的看法，因为选择器是用来在树结构中找到元素的，和样式本身完全无关。但 Less 社区在当时却对<a href="https://github.com/less/less.js/pull/509#issuecomment-9963343" target="_blank" rel="external">这个语法</a>表示了一致的赞同，不禁让人对其感到担忧。 </p>
<p>不管语法如何，继承功能还有一个潜在的问题：继承会影响输出的顺序。假设有如下的 Sass 代码： </p>
<pre><code>.active {
   color: red;
}
button.primary {
   color: green;
}
button.active {
   @extend .active;
}
</code></pre><p>而对应的 HTML 代码是： </p>
<pre><code>&lt;button class=&quot;primary active&quot;&gt;Submit&lt;/button&gt;
</code></pre><p>很容易误以为效果是红色的。而其实生成的 CSS 顺序如下： </p>
<pre><code>.active, button.active {
  color: red;
}

button.primary {
  color: green;
}
</code></pre><p>由于合并选择器的关系 <code>.active</code> 被移到了 <code>.primary</code> 之前，所以依赖顺序而非选择器 specificity 时可能会遇到陷阱。 </p>
<h2 id="placeholder"><a href="#placeholder" class="headerlink" title="placeholder"></a>placeholder</h2><p>Placeholder 是什么？简单来说就是一个声明块（预处理器 DSL 中的声明块，包含其下嵌套规则），但是不会在最终的 CSS 中输出。其实这是一组「抽象」样式，只存在于预处理器的编译过程中（类似 mixin），但不同之处是它可以被继承。这样我们就可以在纯样式层为声明块起与样式强耦合的名称而不怕它出现在 CSS 与 HTML 的「接口」——选择器之中了。 </p>
<p>Sass： </p>
<pre><code>%red-card {
  border: 1px solid #300;
  background-color: #ecc;
  color: #c00;
}

.alert {
  @extend %red-card;
}
</code></pre><p>Stylus： </p>
<pre><code>$red-card
  border: 1px solid #300
  background-color: #ecc
  color: #c00

.alert
  @extend $red-card
</code></pre><p>均输出： </p>
<pre><code>.alert {
  border: 1px solid #300;
  background-color: #ecc;
  color: #c00;
}
</code></pre><p>Less 目前不支持这个功能，但开发组目前的共识是可能会用<a href="https://github.com/less/less.js/issues/1878" target="_blank" rel="external">继承 mixin</a> 的方式来实现，比如上面的这个例子未来可能可以通过如下方法实现： </p>
<pre><code>   [16]: https://github.com/less/less.js/issues/1177
</code></pre><p>.red-card() {<br>border: 1px solid #300;<br>background-color: #ecc;<br>color: #c00;<br>} </p>
<pre><code>.alert {
  &amp;:extend(.red-card());
}
</code></pre><p>当前在 Less 下也有一个 hack 来模拟 placeholder 功能，原理是利用 <code>@import (reference)</code> 来实现「placeholder」不输出的功能： </p>
<pre><code>// placeholder.less
.red-card {
  border: 1px solid #300;
  background-color: #ecc;
  color: #c00;
}

// style.less
@import (reference) &quot;placeholder.less&quot;;
.alert {
  &amp;:extend(.red-card);
}
</code></pre><p>不过 <code>@import (reference)</code> 在复杂一些的情况下（被引入的文件有 <code>@import</code>、有 <code>:extend</code> 等）可能会遇到一些 bug，比如：<a href="https://github.com/less/less.js/issues/1851" target="_blank" rel="external">#1851</a>、<a href="https://github.com/less/less.js/issues/1878" target="_blank" rel="external">#1878</a>、<a href="https://github.com/less/less.js/issues/1896" target="_blank" rel="external">#1896</a>。目前以 reference 方式引入 Bootstrap 时就会直接产生代码输出。 </p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>先说说原生函数。三种预处理器都自带了诸如色彩处理、类型判断、数值计算等内置函数，目前版本的数量都在 80 个左右。由于 Sass 和 Stylus 都内置脚本语言，所以自带函数中包括了很多处理不同数据类型、修改选择器的函数。Sass 更是提供了不少特性检测函数比如 <a href="http://sass-lang.com/documentation/Sass/Script/Functions.html#feature_exists-instance_method" target="_blank" rel="external">feature-exists($feature)、variable-exists($name)</a> 等，这为第三方库的兼容性提供了很好的保障。因为有了这些函数可以方便地对不同版本的 Sass 编译器有针对性地提供兼容，而不怕在老版本的编译环境中直接报错。 </p>
<p>三者调用函数的方式几乎一致，不同之处在于 Sass 和 Stylus 支持直接指定参数名的方式传入参数。以 Stylus 为例： </p>
<pre><code>subtract(a, b)
  a - b

subtract(b: 10, a: 25) // same as substract(25, 10)
</code></pre><p>这样做的好处是，如果参数列表比较长，Stylus 可以直接为列表后面的参数赋值，而不需要一路将之前的参数填上 <code>null</code> 或默认值。Stylus 将这个特性称为「Named parameters」，而 Sass 称为「Keyword arguments」。 </p>
<p>关于函数，真正的区别在于：Sass 和 Stylus 都支持用 DSL 直接添加自定义函数，而 Less 中如果要添加自定义函数必须通过使用插件（2.0.0 以后的版本才支持插件）。这决定了用 Sass 和 Stylus 书写的代码可移植性更高，不需要编译环境有插件即可运行，而 Less 则需要额外添加编译时的依赖。 </p>
<p>Sass 中自定义函数需要使用 <code>@function</code> 指令，并用 <code>@return</code> 指令返回结果： </p>
<pre><code>@function golden-ratio($n) {
  @return $n * 0.618;
}

.golden-box {
  width: 200px;
  height: golden-ratio(200px);
}
</code></pre><p>在 Stylus 中，这些都是隐含的，最后一个表达式的值会作为返回值： </p>
<pre><code>golden-ratio(n)
  n * 0.618

.golden-box
  width: 200px
  height: golden-ratio(@width)
</code></pre><p>这种写法和 mixin 有什么区别？当把函数作为 mixin 调用时，如果其中有 <code>prop: value</code> 这样格式的内容，就会被当做样式规则输出。Stylus 中大量的内容都是根据调用时的 context 去隐式推断该使用什么逻辑进行输出，而非 Less 和 Sass 那样使用关键字去显式地进行区分。 </p>
<h2 id="逻辑控制"><a href="#逻辑控制" class="headerlink" title="逻辑控制"></a>逻辑控制</h2><p>Sass 中通过常见的 <code>@if</code>、<code>@else if</code>、<code>@else</code> 实现条件分支，通过 <code>@for</code>、<code>@each</code>、<code>@while</code> 实现循环，配合 map 和 list 这两种数据类型可以轻松地实现多数编程语言提供的功能。 </p>
<p>在 Stylus 中，不需要使用 <code>@</code> 规则，提供了 <code>if</code>、<code>else if</code>、<code>else</code>、<code>unless</code>、<code>for...in</code> 来实现类似功能，语法比 Sass 更简洁灵活。 </p>
<p>再来看 Less，上面说到的功能 Less 都没有提供。那在 Less 中如何进行逻辑控制呢？Less 中只有一个方式：使用 mixin。 </p>
<p>Less 中的 mixin 通过「guard」的方式支持简单的条件分支控制。比如我们要实现一个控制 <code>::placeholder</code> 样式的 mixin，当传入颜色时只设置颜色，当传入声明块时输出对应的样式规则，其他情况输出一个默认的 <code>color</code>： </p>
<pre><code>.mixin(@val) when (iscolor(@val)) {
  color: @val;
}
.mixin(@val) when (isruleset(@val)) {
  @val();
}
.mixin(@val) when (default()) {
  // default() in guards acts as else
  color: #666;
}
</code></pre><p>Guard 语句中的语法非常类似 CSS media query 中的对应功能，事实上这也是 Less 一直以来的理念：保持声明式语法，弱化指令和流程。但是事实上，这为书写需要提供灵活接口的样式库造成了非常大的不便。最简单的三元表达式在 Less 中也需要先定义一个 mixin，根据判断条件写对应的 guard 表达式，然后再输出。 </p>
<p>而对于循环，Less 本身并不支持。但官网给出了一个使用 mixin 递归调用模拟循环的例子： </p>
<pre><code>.loop(@counter) when (@counter &gt; 0) {
  .loop((@counter - 1));    // next iteration
  width: (10px * @counter); // code for each iteration
}

div {
  .loop(5); // launch the loop
}
</code></pre><p>编译结果为： </p>
<pre><code>div {
  width: 10px;
  width: 20px;
  width: 30px;
  width: 40px;
  width: 50px;
}
</code></pre><p>这是一种非常别（dàn）扭（téng）的实现方式，但从 Less 开发团队的态度来看，未来并没什么可能在 Less 中见到真正的条件分支和循环——因为「Less 不是 Sass」。 </p>
<p>由于逻辑处理能力不能与 Sass 和 Stylus 相比，所以在 Less 中可能还会需要借助 JS 表达式来进行 mixin 参数的解析处理。这个功能 Less 官方已经是不推荐使用的了（已经从官网文档中移除）——因为使用这一功能也会导致 Less 代码的可移植性变低，因为直接内嵌 JS 代码，所以无法使用 <a href="http://www.dotlesscss.org/" target="_blank" rel="external">dotless</a> 等其他语言的 Less 编译器进行处理。而且不同 JS 引擎还可能有兼容性差异。 </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我个人认为，Less 从语言特性的设计到功能的健壮程度和另外两者相比都有一些缺陷，但因为 Bootstrap 引入了 Less，导致 Less 在今天还是有很多用户。用 Less 可以满足大多数场景的需求，但相比另外两者，基于 Less 开发类库会复杂得多，实现的代码会比较脏，能实现的功能也会受到 DSL 的制约。比 Stylus 语义更清晰、比 Sass 更接近 CSS 语法，使得刚刚转用 CSS 预编译的开发者能够更平滑地进行切换。当初 Sass 并不支持 SCSS 语法，使得转投 Sass 成本较高，所以 <a href="http://cloudhead.io/" target="_blank" rel="external">Alexis Sellier</a>才萌生开发一个更「CSS」的预处理器的念头。大获成功以后反过来影响到了 Sass，迫使其也支持类似 CSS 语法的 SCSS。另外，Less 支持浏览器端编译，这无疑降低了开发门槛，使得很多非专业的开发者能够更快地上手（对于一些个人项目来说，能让项目跑起来就行，对前端的性能并没有专业工程师那么高的要求）。 </p>
<p>Sass 在三者之中历史最久，也吸收了其他两者的一些有点。从功能上来说 Sass 大而全，语义明晰但是代码很容易显得累赘。主项目基于 Ruby 可能也是一部分人不选择它的理由（Less 开始也是基于 Ruby 开发，后来逐渐转到 <a href="https://github.com/less/less.js" target="_blank" rel="external">less.js</a> 项目中）。 Sass 有一个「事实标准」库——<a href="http://compass-style.org/" target="_blank" rel="external">Compass</a>，于是对于很多开发者而言省去了选择类库的烦恼，对于提升开发效率也有不小的帮助。 </p>
<p>Stylus 的语法非常灵活，很多语义都是根据上下文隐含的。基于 Stylus 可以写出非常简洁的代码，但对使用团队的开发素养要求也更高，更需要有良好的开发规范或约定。Stylus 是前 Node.js 圈第一大神 <a href="https://github.com/tj/" target="_blank" rel="external">TJ Holowaychuk</a> 的作品，虽然他已经弃坑了，但是仍然有不小的号召力。和 Sass 有 Compass 类似，Stylus 有一个官方开发的样式库 <a href="http://tj.github.io/nib/" target="_blank" rel="external">nib</a>，同样提供了不少好用的 mixin。对于比较有经验的开发者，用 Stylus 可能更会有一种畅快的感觉。总的来说用一个词形容 Stylus 的话，我会用「sexy」。 </p>
<p>总的来说，三种预处理器百分之七八十的功能是类似的。Less 适合帮助团队更快地上手预处理代码的开发，而 Sass 和 Stylus 的差异更在于口味。比如有的人喜欢 jQuery 用一个 <code>$</code> 做大部分的事，而另一些人觉得不一样的功能就该有明确的语义上的差别。在这里我不会做具体的推荐。当然，再次声明一下由于我个人接触 Less 开发比较多，所以可能遇到的坑也多一些，文中没有列出 Sass 和 Stylus 的问题并不代表他们没有。 </p>
<blockquote>
<p><strong>特别声明：本文转自<a href="http://efe.baidu.com/" target="_blank" rel="external">百度EFE团队</a>的<a href="http://weibo.com/u/1143654280" target="_blank" rel="external">@Justineo</a>写的《<a href="http://efe.baidu.com/blog/revisiting-css-preprocessors/" target="_blank" rel="external">再谈 CSS 预处理器</a>》。如需转载，烦请注明原文出处：<a href="http://efe.baidu.com/blog/revisiting-css-preprocessors/" target="_blank" rel="external">http://efe.baidu.com/blog/revisiting-css-preprocessors/</a></strong></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> VueJs </category>
            
        </categories>
        
        
        <tags>
            
            <tag> vue </tag>
            
            <tag> css </tag>
            
            <tag> loader </tag>
            
            <tag> stylus </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Vue轮播解决方案--BetterScroll]]></title>
      <url>/2017/10/03/VueJs/BetterScroll/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a> 
<p>From: <a href="https://wangyu1997.github.io/2017/10/03/VueJs/BetterScroll/">https://wangyu1997.github.io/2017/10/03/VueJs/BetterScroll/</a></p>
<p>inspired by iscroll, and it has a better scroll perfermance <a href="https://link.juejin.im?target=https%3A%2F%2Fustbhuangyi.github.io%2Fbetter-scroll%2F" target="_blank" rel="external">ustbhuangyi.github.io/better-scro…</a></p>
<h2 id="立即使用"><a href="#立即使用" class="headerlink" title="立即使用"></a>立即使用</h2><pre><code>&lt;body&gt;
  &lt;div id=&quot;wrapper&quot;&gt;
    &lt;ul&gt;
           &lt;li&gt;...&lt;/li&gt;
           &lt;li&gt;...&lt;/li&gt;
           ...
    &lt;/ul&gt;
  &lt;/div&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;better-scroll.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  new BScroll(document.getElementById(&#39;wrapper&#39;));
&lt;/script&gt;
&lt;/body&gt;
</code></pre><p>搞定 ! </p>
<h2 id="通过npm引入"><a href="#通过npm引入" class="headerlink" title="通过npm引入"></a>通过npm引入</h2><p>安装better-scroll </p>
<pre><code>npm install better-scroll
</code></pre><p>引入better-scroll </p>
<pre><code>import BScroll from &#39;better-scroll&#39;
</code></pre><blockquote>
<p>如果不支持import, 请使用 </p>
</blockquote>
<pre><code>var BScroll = require(&#39;better-scroll&#39;)
</code></pre><h2 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h2><p>better-scroll 的源码是基于 Webpack 构建的 </p>
<p>首先，clone项目源码 </p>
<pre><code>git clone https://github.com/ustbhuangyi/better-scroll.git
</code></pre><p>安装依赖 </p>
<pre><code>cd better-scroll
npm install
</code></pre><p>测试demo页 </p>
<pre><code>npm run dev
</code></pre><p>打开浏览器访问如下地址, 查看效果 </p>
<blockquote>
<p>localhost:9090 </p>
</blockquote>
<h2 id="Options-参数"><a href="#Options-参数" class="headerlink" title="Options 参数"></a>Options 参数</h2><p>Example: </p>
<pre><code>let scroll = new BScroll(document.getElementById(&#39;wrapper&#39;), {
  startX: 0,
  startY: 0
})
</code></pre><p>Options List: </p>
<ul>
<li>startX: <code>0</code> 开始的X轴位置</li>
<li>startY: <code>0</code> 开始的Y轴位置</li>
<li>scrollY: <code>true</code> 滚动方向为 Y 轴</li>
<li>scrollX: ‘true’ 滚动方向为 X 轴</li>
<li>click: <code>true</code> 是否派发click事件</li>
<li>directionLockThreshold: <code>5</code></li>
<li>momentum: <code>true</code> 当快速滑动时是否开启滑动惯性</li>
<li>bounce: <code>true</code> 是否启用回弹动画效果</li>
<li>selectedIndex: <code>0</code> wheel 为 true 时有效，表示被选中的 wheel 索引</li>
<li>rotate: <code>25</code> wheel 为 true 时有效，表示被选中的 wheel 每一层的旋转角度</li>
<li>wheel: <code>false</code> 该属性是给 picker 组件使用的，普通的列表滚动不需要配置</li>
<li>snap: <code>false</code> 该属性是给 slider 组件使用的，普通的列表滚动不需要配置</li>
<li>snapLoop: <code>false</code> 是否可以无缝循环轮播</li>
<li>snapThreshold: <code>0.1</code> 用手指滑动时页面可切换的阈值，大于这个阈值可以滑动的下一页</li>
<li>snapSpeed: <code>400</code>, 轮播图切换的动画时间</li>
<li>swipeTime: <code>2500</code> swipe 持续时间</li>
<li>bounceTime: <code>700</code> 弹力动画持续的毫秒数</li>
<li>adjustTime: <code>400</code> wheel 为 true 有用，调整停留位置的时间</li>
<li>swipeBounceTime: <code>1200</code> swipe 回弹 时间</li>
<li>deceleration: <code>0.001</code> 滚动动量减速越大越快，建议不大于0.01</li>
<li>momentumLimitTime: <code>300</code> 符合惯性拖动的最大时间</li>
<li>momentumLimitDistance: <code>15</code> 符合惯性拖动的最小拖动距离</li>
<li>resizePolling: <code>60</code> 重新调整窗口大小时，重新计算better-scroll的时间间隔</li>
<li>preventDefault: <code>true</code> 是否阻止默认事件</li>
<li>preventDefaultException: <code>{ tagName: /^(INPUT|TEXTAREA|BUTTON|SELECT)$/ }</code> 阻止默认事件的例外配置</li>
<li>HWCompositing: <code>true</code> 是否启用硬件加速</li>
<li>useTransition: <code>true</code> 是否使用CSS3的Transition属性</li>
<li>useTransform: <code>true</code> 是否使用CSS3的Transform属性</li>
<li>probeType: <code>1</code> 会截流,只有在滚动结束的时候派发一个 scroll 事件。<code>2</code>在手指 move 的时候也会实时派发 scroll 事件，不会截流。 <code>3</code>除了手指 move 的时候派发scroll事件，在 swipe（手指迅速滑动一小段距离）的情况下，列表会有一个长距离的滚动动画，这个滚动的动画过程中也会实时派发滚动事件</li>
</ul>
<h2 id="Events-事件"><a href="#Events-事件" class="headerlink" title="Events 事件"></a>Events 事件</h2><p>Example: </p>
<pre><code>let scroll = new BScroll(document.getElementById(&#39;wrapper&#39;),{
   probeType: 3
})

scroll.on(&#39;scroll&#39;, (pos) =&gt; {
  console.log(pos.x + &#39;~&#39; + pos.y)
  ...
})
</code></pre><p>Events 列表 </p>
<ul>
<li>beforeScrollStart - 滚动开始之前触发</li>
<li>scrollStart - 滚动开始时触发</li>
<li>scroll - 滚动时触发</li>
<li>scrollCancel - 取消滚动时触发</li>
<li>scrollEnd - 滚动结束时触发</li>
<li>touchend - 手指移开屏幕时触发</li>
<li>flick - 轻拂时触发</li>
<li>refresh - 当 better-scroll 刷新时触发</li>
<li>destroy - 销毁 better-scroll 实例时触发</li>
</ul>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul>
<li>scrollTo(x, y, time, easing)</li>
</ul>
<p>滚动到某个位置，x,y 代表坐标，time 表示动画时间，easing 表示缓动函数 </p>
<p>Example: </p>
<pre><code>let scroll = new BScroll(document.getElementById(&#39;wrapper&#39;))
scroll.scrollTo(0, 500)
...
</code></pre><ul>
<li>scrollToElement(el, time, offsetX, offsetY, easing)</li>
</ul>
<p>滚动到某个元素，el（必填）表示 dom 元素，time 表示动画时间，offsetX 和 offsetY 表示坐标偏移量，easing 表示缓动函数 </p>
<ul>
<li>refresh()</li>
</ul>
<p>强制 scroll 重新计算，当 better-scroll 中的元素发生变化的时候调用此方法。 </p>
<ul>
<li>getCurrentPage()</li>
</ul>
<p>当 snap 为 true 时，获取滚动的当前页，返回的对象结构为 {x, y, pageX, pageY}，其中 x,y 代表滚动横向和纵向的位置；pageX，pageY 表示横向和纵向的页面索引 </p>
<ul>
<li>goToPage(x, y, time, easing)</li>
</ul>
<p>当 snap 为 true，滚动到对应的页面，x 表示横向页面索引，y 表示纵向页面索引， time 表示动画，easing 表示缓动函数 </p>
<ul>
<li>enable()</li>
</ul>
<p>启用 better-scroll，默认开启 </p>
<ul>
<li>disable()</li>
</ul>
<p>禁用 better-scroll </p>
<ul>
<li>destroy()</li>
</ul>
<p>销毁 better-scroll，解绑事件 </p>
]]></content>
      
        <categories>
            
            <category> VueJs </category>
            
        </categories>
        
        
        <tags>
            
            <tag> better scroll </tag>
            
            <tag> vue </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Vue实战]]></title>
      <url>/2017/10/02/VueJs/Vue%E5%AE%9E%E6%88%98/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a> 
<p>这个系统使用的技术栈为：Vue+Webpack+Element+Axios+vueRouter.系统是一个快餐店的POS系统，当然我们不可能实现一个完整POS系统的所有功能（业余时间我会开发完成并开源），我们在视频中只完成收银模块的制作。你在这个视频中会学习到很多实战的技巧，让你在真实的工作中得心应手，脱颖而出。 </p>
<p>如果你是一个Vue新手，你可能还不能完全掌握文章的内容，你需要一些Vue的初级知识和中级知识。如果你是新手是不是感到很无奈，幸运的是本站为你提供了全部的前置视频学习资源，你可以踏踏实实的学习。 </p>
<h3 id="学习前置课程："><a href="#学习前置课程：" class="headerlink" title="学习前置课程："></a>学习前置课程：</h3><p><strong>初级课程：</strong></p>
<ol>
<li><a href="https://link.juejin.im?target=http%3A%2F%2Fjspang.com%2F2017%2F02%2F23%2Fvue2_01%2F" target="_blank" rel="external">【第一季】Vue2.0视频教程-内部指令(共8集)</a></li>
<li><a href="https://link.juejin.im?target=http%3A%2F%2Fjspang.com%2F2017%2F03%2F14%2Fvue2_02%2F" target="_blank" rel="external">【第二季】Vue2.0视频教程-全局API(共9集)</a></li>
<li><a href="https://link.juejin.im?target=http%3A%2F%2Fjspang.com%2F2017%2F03%2F26%2Fvue3%2F" target="_blank" rel="external">【第三季】Vue2.0视频教程-选项（共6集）</a></li>
<li><a href="https://link.juejin.im?target=http%3A%2F%2Fjspang.com%2F2017%2F04%2F09%2Fvue2_4%2F" target="_blank" rel="external">【第四季】Vue2.0视频教程-实例和内置组件（共4集）</a></li>
</ol>
<p><strong>中级课程：</strong></p>
<ol>
<li><a href="https://link.juejin.im?target=http%3A%2F%2Fjspang.com%2F2017%2F04%2F10%2Fvue-cli%2F" target="_blank" rel="external">技术胖的Vue-cli 视频教程（共3集）</a></li>
<li><a href="https://link.juejin.im?target=http%3A%2F%2Fjspang.com%2F2017%2F04%2F13%2Fvue-router%2F" target="_blank" rel="external">技术胖的Vue-router视频教程（共11集）</a></li>
<li><a href="https://link.juejin.im?target=http%3A%2F%2Fjspang.com%2F2017%2F05%2F03%2Fvuex%2F" target="_blank" rel="external">技术胖的vuex视频教程（共6集）</a></li>
</ol>
<p>Mockplus是产品经理装逼使用的利器，但是真的很好用，作为一个已经工作的程序员必须舔产品经理的脸，所以你也要对Mockplus的使用有所了解，并会简单的使用。其实Mockplus就是一个线框图制作工具，能把我们的想法或者不太好用语言表达的地方，快速画出线框草图增加理解能力。 </p>
<h3 id="为什么选择快餐店POS系统？"><a href="#为什么选择快餐店POS系统？" class="headerlink" title="为什么选择快餐店POS系统？"></a>为什么选择快餐店POS系统？</h3><p>刚开始我想作一套以酒水商城为背景的手机端应用，但是我发现网上这样的应用太多了，什么仿饿了么，什么知乎，什么购物车都可以在网上找到，所以你完全可以Github网站中下载，自学掌握。我觉的既然作了这个实战，就要够酷够复杂，我下面列举了三个原因，大家可以看一下（你其实可以忽略前两点）。 </p>
<ul>
<li>这个收银界面足够复杂：我们采用三栏布局，每栏的交互操作都很有技术技巧，让你快速掌握复杂应用的开发。</li>
<li>用到的知识点多：用到实战中90%以上的知识点，让你把Vue的知识串联起来，快速成为单位中的技术牛人。</li>
<li>为了更好的和女神啪啪啪：京东-强东哥的女神愿望就是开奶茶店，我的女神愿望就是开个快餐店。</li>
</ul>
<h3 id="MockPlus软件下载："><a href="#MockPlus软件下载：" class="headerlink" title="MockPlus软件下载："></a>MockPlus软件下载：</h3><p>Mockplus是一款免费的软件，你可以随便下载：<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.mockplus.cn%2F" target="_blank" rel="external">www.mockplus.cn/</a> 。下载好后你需要注册一个账户，就可以正常使用了。 </p>
<p><img src="https://user-gold-cdn.xitu.io/2017/6/15/fcb4c4f46535eea5ef279118eec3ce60?imageView2/0/w/1280/h/960" alt=""></p>
<p>软件的基本需求分析和画的过程，请看视频，这里就不用文字描述了，去看视频吧。 </p>
<h3 id="项目框线图；"><a href="#项目框线图；" class="headerlink" title="项目框线图；"></a>项目框线图；</h3><p>下面是我们用Mockplus制作的应用框线图，虽然简单，但是已经把我脑海中快餐店Pos系统的大体样式画出来了。在作项目之前，一定要画出框线图，反复讨论需求和技术实现，这样能避免开发中的大范围修改，在实际工作当中非常重要。 </p>
<p><img src="https://user-gold-cdn.xitu.io/2017/6/15/5060628e6a2352003bd2ac33c04792b9?imageView2/0/w/1280/h/960" alt=""></p>
<p>我们采用Vue-cli进行快速搭建，如果你对Vue-cli还不了解，请观看下面的文章，大概30分钟可完全掌握Vue-cli。 </p>
<ol>
<li><a href="https://link.juejin.im?target=http%3A%2F%2Fjspang.com%2F2017%2F04%2F10%2Fvue-cli%2F" target="_blank" rel="external">技术胖的Vue-cli 视频教程（共3集）</a></li>
</ol>
<h3 id="搭建项目架构："><a href="#搭建项目架构：" class="headerlink" title="搭建项目架构："></a>搭建项目架构：</h3><p>项目采用Webpack+Vue-router的架构方式，开始安装（全部在windows系统上操作，我也没有mac电脑）。 </p>
<ol>
<li><p>按Win+R，然后在文本框中输入cmd，回车打开命令行，输入vue-cli安装命令：</p>
<p>mpm install vue-cli -g</p>
</li>
</ol>
<p>这里的-g代表全局安装。 </p>
<ol>
<li><p>在命令行中初始化项目，我们采用的是webpack模板，输入初始化命令：</p>
<p>vue init webpack AwesomePos</p>
</li>
</ol>
<p>这里的AwesmonePos是我的项目文件夹名称，你可以起一个自己喜欢的名称。安装时根据项目需要配置所需要的模块。这里有一个小技巧，就是在你已经提前建立好了文件夹的时候，我们也进入了文件夹，这时候我们可以省略这个文件夹名称。如下情况： </p>
<pre><code>mikdir AwesomePos
cd AwesomePos
vue init webpack
</code></pre><ol>
<li>在命令行中，进入项目目录，使用npm install 安装package.json里项目的依赖包。如果你网速较慢的话，可以使用淘宝镜像的cnpm来进行安装。</li>
<li>查看是否安装正确。在命令行中输入 npm run dev ，如果能在浏览器中正常打开页面，说明安装正确。</li>
</ol>
<p>到这里为止，我们的项目架构就建立好了，我们需要对Vue-cli给我们生成的文件进行一些必要的修改。 </p>
<h3 id="修改项目文件内容："><a href="#修改项目文件内容：" class="headerlink" title="修改项目文件内容："></a>修改项目文件内容：</h3><ol>
<li><p>修改根目录下的index.html文件，我们想写一些CSS样式，这样作是为了更好的布局，然后修改一下标题栏。让标题符合项目这里起名叫“AwesomePOS-快餐店管理系统”。index.html修改后内容如下。</p>
<p>   &lt;!DOCTYPE html&gt;<br>   <html></html></p>
<pre><code> &lt;head&gt;
   &lt;meta charset=&quot;utf-8&quot;&gt;
   &lt;title&gt;AwesomePOS-快餐管理系统&lt;/title&gt;
   &lt;link rel=&quot;stylesheet&quot; href=&quot;http://at.alicdn.com/t/font_wyhhdpv5lhvbzkt9.css&quot;&gt;
   &lt;style&gt;
     html,body,#app{height:100%;padding: 0;margin:0;}
   &lt;/style&gt;
 &lt;/head&gt;
 &lt;body &gt;
</code></pre></li>
</ol>
<pre><code>        &lt;div id=&quot;app&quot; &gt;&lt;/div&gt;
        &lt;!-- built files will be auto injected --&gt;

      &lt;/body&gt;

    &lt;/html&gt;
</code></pre><ol>
<li><p>新建Pos组件，这个相当于程序员的入口文件。在src/components/page/目录下新建Pos.vue文件。文件内容写出vue模板的架构就可以。</p>
   <template><br>     <div class="pos"><br>      Hello Pos Demo!<br>     </div><br>   </template>

<p>   <script><br>   export default {</p>
<pre><code> name: &#39;Pos&#39;
</code></pre><p>   }<br>   </script></p>
   <style scoped>

   </style>


</li>
</ol>
<ol>
<li><p>修改路由文件，项目根目录/src/router/index.js，让入口文件变成Pos组件。<br>先用import引入了Pos模板组件，然后修改routes里边的内容。如果你对Vue-router的知识还不了解，可以去看我以前的课程，这里就不作过多的讲解了。</p>
<p>import Vue from ‘vue’<br>import Router from ‘vue-router’<br>import Pos from ‘@/components/page/Pos’</p>
<p>Vue.use(Router)</p>
<p>export default new Router({<br> routes: [<br>   {</p>
<pre><code> path: &#39;/&#39;,
 name: &#39;Pos&#39;,
 component: Pos
</code></pre><p>   }<br> ]<br>})</p>
</li>
</ol>
<p>这时候看一下浏览器中的网页，如果显示出了Hello Pos Demo.我们就算成功搭建项目架构了。下节课我们确定一下项目中使用的图标。 </p>
<p>在开发中经常会遇到小图标的使用问题，小图标的使用可以让程序更美观和增加可用性。网上给程序加上小图标的方法有很多。曾经为了寻找一款使用简单，图标美观的图标库，我真的是到处搜索，直到遇到了IconFont，我觉的它能满足我的大部分要求。那在这里我推荐大家使用IconFont，这是阿里巴巴的矢量图标库。（这绝对不是广告，只是自己使用的一些感受） </p>
<p>挑选自己喜欢的图标 </p>
<p>Iconfont中有很多图标，我们可以像在超市逛街一样，挑选自己喜欢的商品，然后放入购物车。 </p>
<h3 id="挑选图标的过程（共6步）"><a href="#挑选图标的过程（共6步）" class="headerlink" title="挑选图标的过程（共6步）"></a>挑选图标的过程（共6步）</h3><ol>
<li>进入网站：Iconfont网址：[<a href="http://www.iconfont.cn][12" target="_blank" rel="external">http://www.iconfont.cn][12</a>]</li>
<li>点击网站上方的“官方图标库”，选择自己喜欢的图标。在这里我选择天猫的图标库。</li>
<li>选择好自己喜欢的图标，你可以有两个选择，下载代码 和 添加至项目。</li>
<li>我们这两选择添加至项目，然后新建项目，并输入名称。</li>
<li>项目添加好后，会自动给我们转入到我们项目库中。点击查看在线链接。</li>
<li>生产css引入的代码，生成后就可以在项目首页index.html引入了。</li>
</ol>
<pre><code>   [12]: http://www.iconfont.cn

 &lt;link rel=&quot;stylesheet&quot; href=&quot;http://at.alicdn.com/t/font_wyhhdpv5lhvbzkt9.css&quot;&gt;
</code></pre><h3 id="图标的使用："><a href="#图标的使用：" class="headerlink" title="图标的使用："></a>图标的使用：</h3><p>图标顺利引入到项目中，已经可以使用它们了，在“我的项目中”你会看到图标的font class值。可以直接复制代码粘贴，也可以自己写代码。 </p>
<pre><code>&lt;i class=&quot;icon iconfont icon-hanbao&quot;&gt;&lt;/i&gt;
</code></pre><p>这样在页面中就可以看到图标了。 </p>
<h3 id="添加更多图标："><a href="#添加更多图标：" class="headerlink" title="添加更多图标："></a>添加更多图标：</h3><p>如果在项目中觉的图标不够用了，需要添加更多图标。可以利用下面四步进行添加。 </p>
<ol>
<li>去Iconfont网站继续挑选，把相中的图标加入购物车中。</li>
<li>把购物车中的图标加入到项目中。</li>
<li>重新生成在线链接。（这部很重要）</li>
<li>在项目主页中(index.html)，更换css引入链接。</li>
</ol>
<p>实战项目开发的知识点就是很多，也很杂，但是这些都很实用，你也会快速成长，不要感觉和Vue无关就忽略，让我们共同努力，变成更好的自己。 </p>
<p>上节学习了inconFont的使用，可以在项目中加入漂亮的icon图标了。这节课我们要快速撸一个侧边栏组件出来。组件的作用就是在可以复用，想在那个页面使用都可以，并且像写html标签一样简单。 </p>
<h3 id="建立leftNav-vue文件："><a href="#建立leftNav-vue文件：" class="headerlink" title="建立leftNav.vue文件："></a>建立leftNav.vue文件：</h3><p>我们在src/components目录下，先新建一个common和page文件夹。 </p>
<ul>
<li>common文件夹用来放共用组件，下面写的leftNav.vue组件就放到这里。</li>
<li>page文件夹用来放我们的页面模板组件，页面的模板文件放到这里。</li>
</ul>
<p>在common文件夹下，新建leftNav.vue文件。 </p>
<p>开始动手写代码： </p>
<p>建立好文件后，我们先给components来个基本组件结构，你可以复制粘贴也可以手写。 </p>
<pre><code>&lt;template&gt;
  &lt;div class=&quot;left-nav&quot;&gt;

  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: &#39;leftNav&#39;,
  data () {
    return {
    }
  }
}
&lt;/script&gt;
&lt;style&gt;

&lt;/style&gt;
</code></pre><p>开始写html结构，我们用列表li来代表导航。菜单栏有收银、店铺、商品、会员、统计。我们编写的html结构如下 </p>
<pre><code> &lt;ul&gt;
        &lt;li&gt;
            &lt;i class=&quot;icon iconfont icon-wodezichan&quot;&gt;&lt;/i&gt;
            &lt;div&gt;收银&lt;/div&gt;
        &lt;/li&gt;

        &lt;li&gt;
            &lt;i class=&quot;icon iconfont icon-dianpu&quot;&gt;&lt;/i&gt;
            &lt;div&gt;店铺&lt;/div&gt;
        &lt;/li&gt;

        &lt;li&gt;
            &lt;i class=&quot;icon iconfont icon-hanbao&quot;&gt;&lt;/i&gt;
            &lt;div&gt;商品&lt;/div&gt;
        &lt;/li&gt;

         &lt;li&gt;
            &lt;i class=&quot;icon iconfont icon-huiyuanqia&quot;&gt;&lt;/i&gt;
            &lt;div&gt;会员&lt;/div&gt;
        &lt;/li&gt;


        &lt;li&gt;
            &lt;i class=&quot;icon iconfont icon-tongji&quot;&gt;&lt;/i&gt;
            &lt;div&gt;统计&lt;/div&gt;
        &lt;/li&gt;
&lt;/ul&gt;
</code></pre><p>注意：这里你也许和我使用的图标不一样，请自行改成你图标用的代码，不要无脑拷贝，图标会显示不出来。 </p>
<p>components（组件）基本结构写好后，开始动手写CSS样式，让我们的组件变的好看。 </p>
<pre><code>&lt;style&gt;
    .left-nav{
       color:#fff;
       font-size:10px;
       height:100%;
       background-color: #1D8ce0;
       float:left;
       width:5%;
    }
    .iconfont{
       font-size:24px;
    }
    .left-nav ul{
        padding:0px;
        margin: 0px;
    }
    .left-nav li{
        list-style: none;
        text-align: center;
        border-bottom:1px solid #20a0ff;
        padding:10px;
    }
&lt;/style&gt;
</code></pre><p>编写完CSS样式，这个组件算是大体写好了，以后根据需求我们会在组件里添加标签。但是现在还没有这个需求，所以暂时不添加。 </p>
<h3 id="把leftNav组件放到模板中"><a href="#把leftNav组件放到模板中" class="headerlink" title="把leftNav组件放到模板中"></a>把leftNav组件放到模板中</h3><p>先用import在App.vue中引入leftNav组件。 </p>
<pre><code>import leftNav from &#39;@/components/common/leftNav&#39;
</code></pre><p>引入后在vue的构造器里添加components属性，并放入我们的leftNav组件。 </p>
<pre><code>export default {
  name: &#39;app&#39;,
  components:{
    leftNav
  }
}
</code></pre><p>这样组件就算在也页面引入成功了，接下来我们就可以在区域里愉快的使用它（）。贴出引入使用全部代码，方便大家学习查看。 </p>
<pre><code>&lt;template&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;!--左侧导航--&gt;

        &lt;leftNav&gt;&lt;/leftNav&gt;

    &lt;!--操作区域--&gt;
    &lt;div class=&quot;main&quot;&gt;
      &lt;router-view&gt;&lt;/router-view&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import leftNav from &#39;@/components/common/leftNav&#39;
export default {
  name: &#39;app&#39;,
  components:{
    leftNav
  }
}
&lt;/script&gt;

&lt;style&gt;
#app {
  font-family: &#39;Microsoft YaHei&#39;,&#39;Avenir&#39;, Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-align: left;
  color: #2c3e50;
   height:100%;
}

.main{
  float:left;
  width:95%; 
  background-color: #EFF2F7;
  height:100%;
  overflow: auto;

}
&lt;/style&gt;
</code></pre><p>Element是一套为开发者、设计师和产品经理准备的基于Vue2.0的组件库，提供了配套设计资源，帮助你的网站快速成型。在项目中自己写组件虽然灵活，但是效率并不高效，所以要学会站在巨人的肩膀上干活，Element就是巨人的肩旁，也是现在国内比较成熟的以一套Vue的组件库。所以我决定 使用这个组件库开发项目。 </p>
<h3 id="npm安装"><a href="#npm安装" class="headerlink" title="npm安装"></a>npm安装</h3><p>这里使用npm的方式安装，它能更好地和webpack打包工具配合使用。 </p>
<pre><code>npm install element-ui --save
</code></pre><p>如果你网络状况不佳可以使用cnpm来进行安装。 </p>
<h3 id="完整引入项目"><a href="#完整引入项目" class="headerlink" title="完整引入项目"></a>完整引入项目</h3><p>在main.js中写入以下内容: </p>
<pre><code>import Vue from &#39;vue&#39;
import ElementUI from &#39;element-ui&#39;
import &#39;element-ui/lib/theme-default/index.css&#39;
import App from &#39;./App.vue&#39;

Vue.use(ElementUI)

new Vue({
  el: &#39;#app&#39;,
  render: h =&gt; h(App)
})
</code></pre><p>以上代码便完成了Element的引入。需要注意的是，样式文件需要单独引入。 </p>
<h3 id="用Element的el-row的布个局"><a href="#用Element的el-row的布个局" class="headerlink" title="用Element的el-row的布个局"></a>用Element的el-row的布个局</h3><p>安装好，先做个简单的布局小试牛刀，这里作两栏布局，Element支持用24栏的形式进行布局。 </p>
<p><strong>在Pos.vue里添加模版布局：</strong></p>
<pre><code>&lt;template&gt;
  &lt;div class=&quot;pos&quot;&gt;
    &lt;div&gt;
        &lt;el-row &gt;
            &lt;el-col :span=&#39;7&#39;&gt;
            我是订单栏
            &lt;/el-col&gt;
            &lt;!--商品展示--&gt;
            &lt;el-col :span=&quot;17&quot;&gt;
             我是产品栏
            &lt;/el-col&gt;
        &lt;/el-row&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: &#39;Pos&#39;,
  data () {
    return { 
    }
  }
}
&lt;/script&gt;
&lt;style scoped&gt;
&lt;/style&gt;
</code></pre><h3 id="解决100-高的问题"><a href="#解决100-高的问题" class="headerlink" title="解决100%高的问题"></a>解决100%高的问题</h3><p>在页面中使用了Element组件，这样他会自动给我们生产虚拟DOM，我们无法设置高度100%； </p>
<p>这时候可以利用javascript，来设置100%高度问题。先要给我们的标签上添加一个id，我们这里把ID设置为 </p>
<p>order-list。然后在vue构造器里使用mounted钩子函数来设置高度。 </p>
<pre><code>  mounted:function(){
      var orderHeight=document.body.clientHeight;
      document.getElementById(&quot;order-list&quot;).style.height=orderHeight+&#39;px&#39;;
  },
</code></pre><p>布局的基本架构，我们已经做好，剩下的就是一些细节。下节课我们将用一节课的时间制作大部分CSS样式内容。 </p>
<p>这节课我们将快速利用Element进行布局页面，这章视频中我会直接拷贝Style代码，因为我觉的你学Vue，那CSS也没有任何问题的，所以不耽误大家的宝贵事件。 </p>
<h3 id="el-tabs标签页组件"><a href="#el-tabs标签页组件" class="headerlink" title="el-tabs标签页组件"></a>el-tabs标签页组件</h3><p>用Element里提供的el-tabs组件可以快速制作我们的tabs标签页效果，具体使用方法可以到Element的官网查看API。 </p>
<p>基本用法很简单，可以直接在模板中引入标签，标签里边用来代表每个每个标签页。 </p>
<p>先看一个最简单的代码： </p>
<pre><code>&lt;el-tabs&gt;
      &lt;el-tab-pane label=&quot;点餐&quot;&gt;
       点餐   
      &lt;/el-tab-pane&gt;
      &lt;el-tab-pane label=&quot;挂单&quot;&gt;
      挂单
      &lt;/el-tab-pane&gt;
      &lt;el-tab-pane label=&quot;外卖&quot;&gt;
      外卖
     &lt;/el-tab-pane&gt;
&lt;/el-tabs&gt;
</code></pre><p>细心的小伙伴会看到每个里会有一个label属性，这个属性就是你标签页的标题。内容可以直接写在里。 </p>
<h3 id="el-table组件制作表格"><a href="#el-table组件制作表格" class="headerlink" title="el-table组件制作表格"></a>el-table组件制作表格</h3><p>需要在订单的tab标签页里放入表格，把点选的食品放入到待结账列表里,可以使用Element的内置组件el-table。如果你对el-table不了解， 可以去Element官网去查看一下。我这里不作太多的解释，先把代码贴过来，然后根据代码在讲解。 </p>
<pre><code>&lt;el-table :data=&quot;tableData&quot; border show-summary style=&quot;width: 100%&quot; &gt;

    &lt;el-table-column prop=&quot;goodsName&quot; label=&quot;商品&quot;  &gt;&lt;/el-table-column&gt;
    &lt;el-table-column prop=&quot;count&quot; label=&quot;量&quot; width=&quot;50&quot;&gt;&lt;/el-table-column&gt;
    &lt;el-table-column prop=&quot;price&quot; label=&quot;金额&quot; width=&quot;70&quot;&gt;&lt;/el-table-column&gt;
    &lt;el-table-column  label=&quot;操作&quot; width=&quot;100&quot; fixed=&quot;right&quot;&gt;
        &lt;template scope=&quot;scope&quot;&gt;
            &lt;el-button type=&quot;text&quot; size=&quot;small&quot;&gt;删除&lt;/el-button&gt;
            &lt;el-button type=&quot;text&quot; size=&quot;small&quot;&gt;增加&lt;/el-button&gt;

        &lt;/template&gt;
    &lt;/el-table-column&gt;
&lt;/el-table&gt;
</code></pre><p>这里我们采用了五列布表格， 在第1行中的:data是用来绑定数据源的， border代表表格有边框效果。在这视频里我会有详细的讲解。 </p>
<p>tableData中的数据源的值，为了布局方便，所以我们进行了写死，以后会改成动态添加的数据。 </p>
<pre><code> tableData: [{

          goodsName: &#39;可口可乐&#39;,
          price: 8,
          count:1
        }, {

          goodsName: &#39;香辣鸡腿堡&#39;,
          price: 15,
          count:1
        }, {

          goodsName: &#39;爱心薯条&#39;,
          price: 8,
          count:1
        }, {

          goodsName: &#39;甜筒&#39;,
          price: 8,
          count:1
        }]
</code></pre><p>你现在可以打开浏览器进行一下预览，看一下效果了。如果效果正常，我们可以继续往下编写了。 </p>
<h3 id="el-button-按钮组件"><a href="#el-button-按钮组件" class="headerlink" title="el-button 按钮组件"></a>el-button 按钮组件</h3><p>需要在点餐表格的下方放入三个功能性按钮，分别是挂单按钮、删除按钮、结账按钮。同样使用Element里的组件，进行快速写入。el-button 的type属性是设置按钮样式的，为了学些和区分我们这里用三个属性来设置按钮。 </p>
<pre><code>&lt;el-button type=&quot;warning&quot; &gt;挂单&lt;/el-button&gt;
&lt;el-button type=&quot;danger&quot; &gt;删除&lt;/el-button&gt;
&lt;el-button type=&quot;success&quot; &gt;结账&lt;/el-button&gt;
</code></pre><p>到这里我们左边最重要的订单操作区域就布局完成了，下节课我们布局右侧的商品布局。 </p>
<p>上节完成了左边订单栏的布局，这节我们还是利用Element完成大部分布局。 </p>
<p><img src="https://user-gold-cdn.xitu.io/2017/6/15/6ddcd9473d6c915981d98eec79f41aad?imageView2/0/w/1280/h/960" alt=""></p>
<p>这是完成布局的图片 </p>
<h3 id="常用商品区域布局："><a href="#常用商品区域布局：" class="headerlink" title="常用商品区域布局："></a>常用商品区域布局：</h3><p>在标签里增加一个层，然后在层内进行布局。因为里边的商品实际意义上是列表，所以用无序列表 </p>
<ul>
<li>来布局商品。贴出布局的html代码。</li>
<li><div class="often-goods"><br>    <div class="title">常用商品</div><br>    <div class="often-goods-list"><br><br>        <ul><br>            <li><br>                <span>香辣鸡腿堡</span><br>                <span class="o-price">￥15元</span><br>            </li><br><br>        </ul><br>    </div><br></div>


</li>
</ul>
<p>有了基本html结构后，需要增加一些css样式来美化页面： </p>
<pre><code> .title{
       height: 20px;
       border-bottom:1px solid #D3DCE6;
       background-color: #F9FAFC;
       padding:10px;
   }
   .often-goods-list ul li{
      list-style: none;
      float:left;
      border:1px solid #E5E9F2;
      padding:10px;
      margin:5px;
      background-color:#fff;
   }
  .o-price{
      color:#58B7FF; 
   }
</code></pre><p>现在页面变的漂亮了，我们这时候为了页面更逼近真实效果，我们在Vue的构造器里临时加一个数组，用作常用商品使用。声明的变量叫oftenGoods（真实项目不能这样起名字，这里只是练习使用）。 </p>
<pre><code> oftenGoods:[
          {
              goodsId:1,
              goodsName:&#39;香辣鸡腿堡&#39;,
              price:18
          }, {
              goodsId:2,
              goodsName:&#39;田园鸡腿堡&#39;,
              price:15
          }, {
              goodsId:3,
              goodsName:&#39;和风汉堡&#39;,
              price:15
          }, {
              goodsId:4,
              goodsName:&#39;快乐全家桶&#39;,
              price:80
          }, {
              goodsId:5,
              goodsName:&#39;脆皮炸鸡腿&#39;,
              price:10
          }, {
              goodsId:6,
              goodsName:&#39;魔法鸡块&#39;,
              price:20
          }, {
              goodsId:7,
              goodsName:&#39;可乐大杯&#39;,
              price:10
          }, {
              goodsId:8,
              goodsName:&#39;雪顶咖啡&#39;,
              price:18
          }, {
              goodsId:9,
              goodsName:&#39;大块鸡米花&#39;,
              price:15
          }, {
              goodsId:20,
              goodsName:&#39;香脆鸡柳&#39;,
              price:17
          }

      ]
</code></pre><p>有了数据，可以使用v-for循环来输出到html模板中。 </p>
<h3 id="商品分类布局："><a href="#商品分类布局：" class="headerlink" title="商品分类布局："></a>商品分类布局：</h3><p>这样我们商品的上半部分就布局完成了，现在需要布局下半部分，我们在下半部分先添加一个tabs的标签样式。 </p>
<pre><code>&lt;div class=&quot;goods-type&quot;&gt;

    &lt;el-tabs&gt;
        &lt;el-tab-pane label=&quot;汉堡&quot;&gt;
            汉堡
        &lt;/el-tab-pane&gt;
            &lt;el-tab-pane label=&quot;小食&quot;&gt;
            小食
        &lt;/el-tab-pane&gt;
        &lt;el-tab-pane label=&quot;饮料&quot;&gt;
            饮料
        &lt;/el-tab-pane&gt;
        &lt;el-tab-pane label=&quot;套餐&quot;&gt;
            套餐
        &lt;/el-tab-pane&gt;

    &lt;/el-tabs&gt;
&lt;/div&gt;
</code></pre><p>有上节课作tabs标签页的经验，这个变的异常简单。 </p>
<p>制作商品的无序列表： </p>
<pre><code>&lt;ul class=&#39;cookList&#39;&gt;
    &lt;li&gt;
        &lt;span class=&quot;foodImg&quot;&gt;&lt;img src=&quot;http://7xjyw1.com1.z0.glb.clouddn.com/pos001.jpg&quot; width=&quot;100%&quot;&gt;&lt;/span&gt;
        &lt;span class=&quot;foodName&quot;&gt;香辣鸡腿堡&lt;/span&gt;
        &lt;span class=&quot;foodPrice&quot;&gt;￥20.00元&lt;/span&gt;
    &lt;/li&gt;
&lt;/ul&gt;
</code></pre><p>对无序列表进行CSS样式编写： </p>
<pre><code>.cookList li{
       list-style: none;
       width:23%;
       border:1px solid #E5E9F2;
       height: auot;
       overflow: hidden;
       background-color:#fff;
       padding: 2px;
       float:left;
       margin: 2px;

   }
   .cookList li span{

        display: block;
        float:left;
   }
   .foodImg{
       width: 40%;
   }
   .foodName{
       font-size: 18px;
       padding-left: 10px;
       color:brown;

   }
   .foodPrice{
       font-size: 16px;
       padding-left: 10px;
       padding-top:10px;
   }
</code></pre><p>有了基本的样式，我们可以在Vue的构造器里添加汉堡类的数据。声明一个type0Goods的数据，数据格式如下。 </p>
<pre><code>    type0Goods:[
          {
              goodsId:1,
              goodsImg:&quot;http://7xjyw1.com1.z0.glb.clouddn.com/pos001.jpg&quot;,
              goodsName:&#39;香辣鸡腿堡&#39;,
              price:18
          }, {
              goodsId:2,
              goodsImg:&quot;http://7xjyw1.com1.z0.glb.clouddn.com/pos002.jpg&quot;,
              goodsName:&#39;田园鸡腿堡&#39;,
              price:15
          }, {
              goodsId:3,
              goodsImg:&quot;http://7xjyw1.com1.z0.glb.clouddn.com/pos004.jpg&quot;,
              goodsName:&#39;和风汉堡&#39;,
              price:15
          }, {
              goodsId:4,
               goodsImg:&quot;http://7xjyw1.com1.z0.glb.clouddn.com/pos003.jpg&quot;,
              goodsName:&#39;快乐全家桶&#39;,
              price:80
          }, {
              goodsId:5,
               goodsImg:&quot;http://7xjyw1.com1.z0.glb.clouddn.com/pos003.jpg&quot;,
              goodsName:&#39;脆皮炸鸡腿&#39;,
              price:10
          }, {
              goodsId:6,
               goodsImg:&quot;http://7xjyw1.com1.z0.glb.clouddn.com/pos004.jpg&quot;,
              goodsName:&#39;魔法鸡块&#39;,
              price:20
          }, {
              goodsId:7,
               goodsImg:&quot;http://7xjyw1.com1.z0.glb.clouddn.com/pos001.jpg&quot;,
              goodsName:&#39;可乐大杯&#39;,
              price:10
          }, {
              goodsId:8,
               goodsImg:&quot;http://7xjyw1.com1.z0.glb.clouddn.com/pos003.jpg&quot;,
              goodsName:&#39;雪顶咖啡&#39;,
              price:18
          }, {
              goodsId:9,
               goodsImg:&quot;http://7xjyw1.com1.z0.glb.clouddn.com/pos002.jpg&quot;,
              goodsName:&#39;大块鸡米花&#39;,
              price:15
          }, {
              goodsId:20,
               goodsImg:&quot;http://7xjyw1.com1.z0.glb.clouddn.com/pos002.jpg&quot;,
              goodsName:&#39;香脆鸡柳&#39;,
              price:17
          }

      ],
</code></pre><p>用v-for改造我们的无序列表： </p>
<pre><code>&lt;li v-for=&quot;goods in type0Goods&quot;&gt;
    &lt;span class=&quot;foodImg&quot;&gt;&lt;img :src=&quot;goods.goodsImg&quot; width=&quot;100%&quot;&gt;&lt;/span&gt;
    &lt;span class=&quot;foodName&quot;&gt;{{goods.goodsName}}&lt;/span&gt;
    &lt;span class=&quot;foodPrice&quot;&gt;￥{{goods.price}}元&lt;/span&gt;
&lt;/li&gt;
</code></pre><p>页面的基本布局我们已经制作完成，终于看起来像个收银界面了。但是现在的数据都是写死的，下节课我们将从后端用Axios拉去数据。 </p>
<p>上节课我们利用Elemnt已经把页面布局的差不多了，如果你觉的不够美观，可以自己再进行美化，因为课程的原因css细节我们这里就不深入美化了。这节课我们开始学习Axios的知识，并把商品数据从远端读取到页面上。学这节课时技术胖已经为大家准备好了后端数据，你们只要调用相应的页面就可以调取，在实际开发中，这些后台数据是需要后端程序员和你共同讨论制作的。我们现在只做前端，数据大家只要会调用即可。 </p>
<h3 id="安装Axios"><a href="#安装Axios" class="headerlink" title="安装Axios"></a>安装Axios</h3><p>我们直接使用npm install来进行安装。 </p>
<pre><code>npm install axios --save
</code></pre><p>由于axios是需要打包到生产环境中的，所以我们使用–save来进行安装。 </p>
<h3 id="引入Axios"><a href="#引入Axios" class="headerlink" title="引入Axios"></a>引入Axios</h3><p>我们在Pos.vue页面引入Axios，由于使用了npm来进行安装，所以这里不需要填写路径。 </p>
<pre><code>import axios from &#39;axios&#39;
</code></pre><h3 id="服务端拉取常用商品数据"><a href="#服务端拉取常用商品数据" class="headerlink" title="服务端拉取常用商品数据"></a>服务端拉取常用商品数据</h3><p>远端服务器地址：<a href="http://jspang.com/DemoApi/oftenGoods.php" target="_blank" rel="external">http://jspang.com/DemoApi/oftenGoods.php</a></p>
<p>（在实际项目中这个后台接口地址是后端程序员提供给你的，你可以随便调用这个接口，我已经放到服务器上了。） </p>
<p>可以先把地址放到地址栏访问一下，是可以正常访问的，并且输出了json格式的字符串，这就是我们需要的远端数据了。这里我们使用Axios的get 方式来获得数据。 </p>
<pre><code>  created(){
      axios.get(&#39;http://jspang.com/DemoApi/oftenGoods.php&#39;)
      .then(response=&gt;{
         console.log(response);
         this.oftenGoods=response.data;
      })
      .catch(error=&gt;{
          console.log(error);
          alert(&#39;网络错误，不能访问&#39;);
      })
  },
</code></pre><p>把axios的方法写到了created钩子函数中，我们使用了get 方法进行拉取数据，如果拉取成功用远端数据对oftenGoods进行赋值。 </p>
<p>拉取报错，一般有两种情况： </p>
<pre><code>1. 网络不通：网络状况不是很好，这可以在失败后隔5秒再次请求。
2. 报决绝访问：这种多是后端程序员设置了不允许跨域访问，需要你和后端程序员一起调试解决。
</code></pre><h3 id="拉取分类商品数据："><a href="#拉取分类商品数据：" class="headerlink" title="拉取分类商品数据："></a>拉取分类商品数据：</h3><p>远端服务器地址：<a href="http://jspang.com/DemoApi/typeGoods.php" target="_blank" rel="external">http://jspang.com/DemoApi/typeGoods.php</a></p>
<p>依然用Get进行拉取，拉取后先用consoe.log(response)查看一下数据结构，让后进行赋值。由于知识跟上边的很像，文字版我就不多描述了，详细可以查看视频教程。 </p>
<p>在这里贴出拉取和分配不同分类代码： </p>
<pre><code>       //读取分类商品列表
      axios.get(&#39;http://jspang.com/DemoApi/typeGoods.php&#39;)
      .then(response=&gt;{
         console.log(response);
         //this.oftenGoods=response.data;
         this.type0Goods=response.data[0];
         this.type1Goods=response.data[1];
         this.type2Goods=response.data[2];
         this.type3Goods=response.data[3];

      })
      .catch(error=&gt;{
          console.log(error);
          alert(&#39;网络错误，不能访问&#39;);
      })
</code></pre><p>html模板输出代码： </p>
<pre><code>&lt;ul class=&#39;cookList&#39;&gt;
     &lt;li v-for=&quot;goods in type3Goods&quot;&gt;
         &lt;span class=&quot;foodImg&quot;&gt;&lt;img :src=&quot;goods.goodsImg&quot; width=&quot;100%&quot;&gt;&lt;/span&gt;
         &lt;span class=&quot;foodName&quot;&gt;{{goods.goodsName}}&lt;/span&gt;
         &lt;span class=&quot;foodPrice&quot;&gt;￥{{goods.price}}元&lt;/span&gt;
      &lt;/li&gt;
&lt;/ul&gt;
</code></pre><p>在实际开发中类别也是循环出来的，这里为了教学演示，没有写的那么复杂，你只要明白了如何操作，以后你可以自己增加。就像我这个项目一样，在视频结束后，会慢慢写完善所有功能，最后送给女神，赢得女神芳心。 </p>
<p>下节课我们学习订单操作里需要的功能，比如点击商品，添加到左边的订单栏里，增加，删除商品，模拟订单提交到后台。如果下节课一节讲不完，我们就分成两节课来讲。 </p>
<p>经过上节课的学习，我们已经可以从后台取得数据了。这节课要完成的任务是实现页面左侧的订单列表页面的添加操作。本来我想一节课讲完的，但是内容还是比较多的，又不想让大家每节课学习很长时间，所以我把这个内容进行了划分。 </p>
<h3 id="添加商品到订单页面"><a href="#添加商品到订单页面" class="headerlink" title="添加商品到订单页面"></a>添加商品到订单页面</h3><p>我们在vue的构造器里加入methods方法，在methods方法里再加入addOrderList方法。这个方法的作用是点击右侧的商品，然后把商品添加到左边的列表里。 </p>
<p>addOrderList方法(也许你只看文字版无法理解，推荐查看视频)： </p>
<pre><code>methods:{
      //添加订单列表的方法
      addOrderList(goods){
            this.totalCount=0; //汇总数量清0
            this.totalMoney=0;
            let isHave=false;
            //判断是否这个商品已经存在于订单列表
            for (let i=0; i&lt;this.tableData.length;i++){
                console.log(this.tableData[i].goodsId);
                if(this.tableData[i].goodsId==goods.goodsId){
                    isHave=true; //存在
                }
            }
            //根据isHave的值判断订单列表中是否已经有此商品
            if(isHave){
                //存在就进行数量添加
                 let arr = this.tableData.filter(o =&gt;o.goodsId == goods.goodsId);
                 arr[0].count++;
                 //console.log(arr);
            }else{
                //不存在就推入数组
                let newGoods={goodsId:goods.goodsId,goodsName:goods.goodsName,price:goods.price,count:1};
                 this.tableData.push(newGoods);

            }

            //进行数量和价格的汇总计算
            this.tableData.forEach((element) =&gt; {
                this.totalCount+=element.count;
                this.totalMoney=this.totalMoney+(element.price*element.count);   
            });

      }
  }
</code></pre><p>在作这个方法的时候，在订单列表的下方又添加了订单的统计功能，其实也就两项：<strong>订单价格汇总</strong>和订单商品数量汇总。我们在data里声明的值是totalMoney和totalCount。 </p>
<p>写完这个方法后，我们还需要在我们的商品上绑定方法，来进行调用添加方法。 </p>
<pre><code> @click=&quot;addOrderList(goods)&quot;
</code></pre><p>这样在点击商品时订单列表就会根据我们的程序逻辑发生变化。 </p>
<h3 id="订单列表中的增加按钮"><a href="#订单列表中的增加按钮" class="headerlink" title="订单列表中的增加按钮"></a><strong>订单列表中的增加按钮</strong></h3><p>商品中绑定addOrderList方法是非常容易的，如果在订单列表中绑定是需要特殊处理一下的，需要用到template的scope值，让后进行绑定。 </p>
<pre><code>&lt;el-button type=&quot;text&quot; size=&quot;small&quot; @click=&quot;addOrderList(scope.row)&quot;&gt;增加&lt;/el-button&gt;
</code></pre><p>这节课我们把订单增加的操作制作完成了，下节课我们要制作订单商品的删除和订单的整体删除功能，最后模拟一下订单的结账功能。 </p>
<p>继续制作订单模块，这节课主要三个功能的制作，删除列表中的单个商品，删除列表中的全部商品，简单模拟结账。 </p>
<h3 id="删除单个商品"><a href="#删除单个商品" class="headerlink" title="删除单个商品"></a>删除单个商品</h3><p>在veu构造器methods属性里增加一个delSingleGoods方法，并接收goods对象为参数，用数组的filter可以轻松删除数组中单个的商品。 </p>
<pre><code>    //删除单个商品
      delSingleGoods(goods){
        console.log(goods);
        this.tableData=this.tableData.filter(o =&gt; o.goodsId !=goods.goodsId);

      },
</code></pre><p>现在可以npm run dev试一下了，会发现现在商品可以正确的删除了，但是统计的数量和金额是不正确的，我们需要写一些统计的代码。在下手之前你会发现在增加商品方法中也有类似统计的方法，既然两个功能很像，我们就重新写一个方法。 </p>
<pre><code>//汇总数量和金额
getAllMoney(){
    this.totalCount=0;
    this.totalMoney=0;
    if(this.tableData){
            this.tableData.forEach((element) =&gt; {
        this.totalCount+=element.count;
        this.totalMoney=this.totalMoney+(element.price*element.count);   
    });
    }

}
</code></pre><p>需要注意的是，以前我们是单独使用的，所以不用把totoalCount和totalMoney清零，但是做成公用方法了，记得清零。方法做好了，我们在需要的地方直接用this.getAllMoney()引用就可以了。 </p>
<p>功能做好了，我们还需要为删除按钮绑定事件： </p>
<pre><code>&lt;el-button type=&quot;text&quot; size=&quot;small&quot; @click=&quot;delSingleGoods(scope.row)&quot;&gt;删除&lt;/el-button&gt;
</code></pre><p>这样我们就把删除单个订单商品的功能做好了，我们可以测试调试一下。 </p>
<h3 id="删除全部订单商品"><a href="#删除全部订单商品" class="headerlink" title="删除全部订单商品"></a>删除全部订单商品</h3><p>这个功能其实很简单，只要把this.tableData清空就可以了，在methods属性中写一个delAllGoods的方法。 </p>
<pre><code>      //删除所有商品
        delAllGoods() {
            this.tableData = [];
            this.totalCount = 0;
            this.totalMoney = 0;
        },
</code></pre><p>有的小伙伴会好奇，你完全可以再次复用getAllMoney()方法进行汇总，为什么不用那？汇总方法里毕竟是有业务逻辑的，我们只做两个清零，这样消耗的资源更少，所以我们没有使用。 </p>
<h3 id="模拟结账"><a href="#模拟结账" class="headerlink" title="模拟结账"></a>模拟结账</h3><p>因为模拟结账需要Post数据到后台，我的服务器又不能提供这样的借口给大家，所以我只说制作思路，大家可以在自己的服务器上去实现。 </p>
<p>1、设置我们Aixos的Pos方法。 </p>
<p>2、接受返回值进行处理。 </p>
<p>3、如果成功，清空现有构造器里的tableData，totalMoney，totalCount数据。 </p>
<p>4、进行用户的友好提示。 </p>
<p>由于前两个步骤不能演示，所以这里我们只模拟3和4步。在methods里作一个结账方法，清空数据和进行友好提示。 </p>
<pre><code>checkout() {
    if (this.totalCount!=0) {
        this.tableData = [];
        this.totalCount = 0;
        this.totalMoney = 0;
        this.$message({
            message: &#39;结账成功，感谢你又为店里出了一份力!&#39;,
            type: &#39;success&#39;
        });

    }else{
        this.$message.error(&#39;不能空结。老板了解你急切的心情！&#39;);
    }

}
</code></pre><p>订单模块基本的功能就制作完成了，我希望大家都能动手练习一下，如果你不动手练习你永远学不会的。 </p>
<p>一直追看的小伙伴可能知道原来还有一节挂单功能的制作，但是在录制的过程中我发现90%的知识点都是重复的，不重复的知识点讲的还和Vue没有关系，是html5的localStorage操作，所以我去掉了这节。这节我们主要讲一下打包需要注意的事项和总结一下我们学习的知识。 </p>
<h3 id="打包注意事项："><a href="#打包注意事项：" class="headerlink" title="打包注意事项："></a>打包注意事项：</h3><p>1、把绝对路径改为相对路径 </p>
<p>我们打开config/index.js 会看到一个build属性，这里就我们打包的基本配置了。你在这里可以修改打包的目录，打包的文件名。最重要的是一定要把绝对目录改为相对目录。 </p>
<pre><code>assetsPublicPath:&#39;./&#39;
</code></pre><p>这样才能保证我们打包出去的项目可以正常预览。 </p>
<p>2、在命令行中用npm run build 进行打包。 </p>
<pre><code>npm run build
</code></pre><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3>]]></content>
      
        <categories>
            
            <category> VueJs </category>
            
        </categories>
        
        
        <tags>
            
            <tag> vue </tag>
            
            <tag> 实战 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[AOP实战]]></title>
      <url>/2017/10/01/JavaWeb/AOP%E5%AE%9E%E6%88%98/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a> 
<p>接上一小节<a href="https://wangyu1997.github.io/2017/10/01/JavaWeb/AOP%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3/">彻底征服 Spring AOP 之 理论篇</a></p>
<h2 id="Spring-AOP-实战"><a href="#Spring-AOP-实战" class="headerlink" title="Spring AOP 实战"></a>Spring AOP 实战</h2><p>看了上面这么多的理论知识, 不知道大家有没有觉得枯燥哈. 不过不要急, 俗话说理论是实践的基础, 对 Spring AOP 有了基本的理论认识后, 我们来看一下下面几个具体的例子吧.<br>下面的几个例子是我在工作中所遇见的比较常用的 Spring AOP 的使用场景, 我精简了很多有干扰我们学习的注意力的细枝末节, 以力求整个例子的简洁性. </p>
<p>下面几个 Demo 的源码都可以在我的 <a href="https://github.com/yongshun/some_java_code" target="_blank" rel="external">Github</a> 上下载到. </p>
<h3 id="HTTP-接口鉴权"><a href="#HTTP-接口鉴权" class="headerlink" title="HTTP 接口鉴权"></a>HTTP 接口鉴权</h3><p>首先让我们来想象一下如下场景: 我们需要提供的 HTTP RESTful 服务, 这个服务会提供一些比较敏感的信息, 因此对于某些接口的调用会进行调用方权限的校验, 而某些不太敏感的接口则不设置权限, 或所需要的权限比较低(例如某些监控接口, 服务状态接口等).<br>实现这样的需求的方法有很多, 例如我们可以在每个 HTTP 接口方法中对服务请求的调用方进行权限的检查, 当调用方权限不符时, 方法返回错误. 当然这样做并无不可, 不过如果我们的 api 接口很多, 每个接口都进行这样的判断, 无疑有很多冗余的代码, 并且很有可能有某个粗心的家伙忘记了对调用者的权限进行验证, 这样就会造成潜在的 bug.<br>那么除了上面的所说的方法外, 还有没有别的比较优雅的方式来实现呢? 当然有啦, 不然我在这啰嗦半天干嘛呢, 它就是我们今天的主角: <code>AOP</code>. </p>
<p>让我们来提炼一下我们的需求: </p>
<ol>
<li><p>可以定制地为某些指定的 HTTP RESTful api 提供权限验证功能. </p>
</li>
<li><p>当调用方的权限不符时, 返回错误. </p>
</li>
</ol>
<p>根据上面所提出的需求, 我们可以进行如下设计: </p>
<ol>
<li><p>提供一个特殊的注解 <code>AuthChecker</code>, 这个是一个方法注解, 有此注解所标注的 Controller 需要进行调用方权限的认证. </p>
</li>
<li><p>利用 Spring AOP, 以 <strong>@annotation</strong> 切点标志符来匹配有注解 <code>AuthChecker</code> 所标注的 joinpoint. </p>
</li>
<li><p>在 advice 中, 简单地检查调用者请求中的 Cookie 中是否有我们指定的 token, 如果有, 则认为此调用者权限合法, 允许调用, 反之权限不合法, 范围错误. </p>
</li>
</ol>
<p>根据上面的设计, 我们来看一下具体的源码吧.<br>首先是 <code>AuthChecker</code> 注解的定义:<br><strong>AuthChecker.java:</strong></p>
<pre><code>@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface AuthChecker {
}
</code></pre><p><code>AuthChecker</code> 注解是一个方法注解, 它用于注解 RequestMapping 方法. </p>
<p>有了注解的定义, 那我们再来看一下 aspect 的实现吧:<br><strong>HttpAopAdviseDefine.java:</strong></p>
<pre><code>@Component
@Aspect
public class HttpAopAdviseDefine {

    // 定义一个 Pointcut, 使用 切点表达式函数 来描述对哪些 Join point 使用 advise.
    @Pointcut(&quot;@annotation(com.xys.demo1.AuthChecker)&quot;)
    public void pointcut() {
    }

    // 定义 advise
    @Around(&quot;pointcut()&quot;)
    public Object checkAuth(ProceedingJoinPoint joinPoint) throws Throwable {
        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes())
                .getRequest();

        // 检查用户所传递的 token 是否合法
        String token = getUserToken(request);
        if (!token.equalsIgnoreCase(&quot;123456&quot;)) {
            return &quot;错误, 权限不合法!&quot;;
        }

        return joinPoint.proceed();
    }

    private String getUserToken(HttpServletRequest request) {
        Cookie[] cookies = request.getCookies();
        if (cookies == null) {
            return &quot;&quot;;
        }
        for (Cookie cookie : cookies) {
            if (cookie.getName().equalsIgnoreCase(&quot;user_token&quot;)) {
                return cookie.getValue();
            }
        }
        return &quot;&quot;;
    }
}
</code></pre><p>在这个 aspect 中, 我们首先定义了一个 pointcut, 以 <strong>@annotation</strong> 切点标志符来匹配有注解 <code>AuthChecker</code> 所标注的 joinpoint, 即: </p>
<pre><code>// 定义一个 Pointcut, 使用 切点表达式函数 来描述对哪些 Join point 使用 advise.
@Pointcut(&quot;@annotation(com.xys.demo1.AuthChecker)&quot;)
public void pointcut() {
}
</code></pre><p>然后再定义一个 advice: </p>
<pre><code>// 定义 advise
@Around(&quot;pointcut()&quot;)
public Object checkAuth(ProceedingJoinPoint joinPoint) throws Throwable {
    HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes())
            .getRequest();

    // 检查用户所传递的 token 是否合法
    String token = getUserToken(request);
    if (!token.equalsIgnoreCase(&quot;123456&quot;)) {
        return &quot;错误, 权限不合法!&quot;;
    }

    return joinPoint.proceed();
}
</code></pre><p>当被 <code>AuthChecker</code> 注解所标注的方法调用前, 会执行我们的这个 advice, 而这个 advice 的处理逻辑很简单, 即从 HTTP 请求中获取名为 <code>user_token</code> 的 cookie 的值, 如果它的值是 <code>123456</code>, 则我们认为此 HTTP 请求合法, 进而调用 <code>joinPoint.proceed()</code> 将 HTTP 请求转交给相应的控制器处理; 而如果<code>user_token</code> cookie 的值不是 <code>123456</code>, 或为空, 则认为此 HTTP 请求非法, 返回错误. </p>
<p>接下来我们来写一个模拟的 HTTP 接口:<br><strong>DemoController.java:</strong></p>
<pre><code>@RestController
public class DemoController {
    @RequestMapping(&quot;/aop/http/alive&quot;)
    public String alive() {
        return &quot;服务一切正常&quot;;
    }

    @AuthChecker
    @RequestMapping(&quot;/aop/http/user_info&quot;)
    public String callSomeInterface() {
        return &quot;调用了 user_info 接口.&quot;;
    }
}
</code></pre><p>注意到上面我们提供了两个 HTTP 接口, 其中 接口 <strong>/aop/http/alive</strong> 是没有 <code>AuthChecker</code> 标注的, 而 <strong>/aop/http/user_info</strong> 接口则用到了 <code>@AuthChecker</code> 标注. 那么自然地, 当请求了 <strong>/aop/http/user_info</strong> 接口时, 就会触发我们所设置的权限校验逻辑. </p>
<p>接下来我们来验证一下, 我们所实现的功能是否有效吧.<br>首先在 Postman 中, 调用 <strong>/aop/http/alive</strong> 接口, 请求头中不加任何参数: </p>
<p>可以看到, 我们的 HTTP 请求完全没问题. </p>
<p>那么再来看一下请求 <strong>/aop/http/user_info</strong> 接口会怎样呢: </p>
<p>当我们请求 <strong>/aop/http/user_info</strong> 接口时, 服务返回一个权限异常的错误, 为什么会这样呢? 自然就是我们的权限认证系统起了作为: 当一个方法被调用并且这个方法有 <code>AuthChecker</code> 标注时, 那么首先会执行到我们的 <code>around advice</code>, 在这个 advice 中, 我们会校验 HTTP 请求的 cookie 字段中是否有携带 <code>user_token</code> 字段时, 如果没有, 则返回权限错误.<br>那么为了能够正常地调用 <strong>/aop/http/user_info</strong> 接口, 我们可以在 Cookie 中添加 <strong>user_token=123456</strong>, 这样我们可以愉快的玩耍了: </p>
<blockquote>
<p><code>注意</code>, Postman 默认是不支持 Cookie 的, 所以为了实现添加 Cookie 的功能, 我们需要安装 Postman 的 <code>interceptor</code> 插件. 安装方法可以看<a href="https://www.getpostman.com/docs/interceptor_cookies" target="_blank" rel="external">官网的文章</a></p>
</blockquote>
<h4 id="完整源码"><a href="#完整源码" class="headerlink" title="完整源码"></a>完整源码</h4><p><a href="https://github.com/yongshun/some_java_code/tree/master/SpringAOPDemo/src/main/java/com/xys/demo1" target="_blank" rel="external">HTTP 接口鉴权</a></p>
<h3 id="方法调用日志"><a href="#方法调用日志" class="headerlink" title="方法调用日志"></a>方法调用日志</h3><p>第二个 AOP 实例是记录一个方法调用的log. 这应该是一个很常见的功能了.<br>首先假设我们有如下需求: </p>
<ol>
<li><p>某个服务下的方法的调用需要有 log: 记录调用的参数以及返回结果. </p>
</li>
<li><p>当方法调用出异常时, 有特殊处理, 例如打印异常 log, 报警等. </p>
</li>
</ol>
<p>根据上面的需求, 我们可以使用 before advice 来在调用方法前打印调用的参数, 使用 after returning advice 在方法返回打印返回的结果. 而当方法调用失败后, 可以使用 after throwing advice 来做相应的处理.<br>那么我们来看一下 aspect 的实现: </p>
<pre><code>@Component
@Aspect
public class LogAopAdviseDefine {
    private Logger logger = LoggerFactory.getLogger(getClass());

    // 定义一个 Pointcut, 使用 切点表达式函数 来描述对哪些 Join point 使用 advise.
    @Pointcut(&quot;within(NeedLogService)&quot;)
    public void pointcut() {
    }

    // 定义 advise
    @Before(&quot;pointcut()&quot;)
    public void logMethodInvokeParam(JoinPoint joinPoint) {
        logger.info(&quot;---Before method {} invoke, param: {}---&quot;, joinPoint.getSignature().toShortString(), joinPoint.getArgs());
    }

    @AfterReturning(pointcut = &quot;pointcut()&quot;, returning = &quot;retVal&quot;)
    public void logMethodInvokeResult(JoinPoint joinPoint, Object retVal) {
        logger.info(&quot;---After method {} invoke, result: {}---&quot;, joinPoint.getSignature().toShortString(), joinPoint.getArgs());
    }

    @AfterThrowing(pointcut = &quot;pointcut()&quot;, throwing = &quot;exception&quot;)
    public void logMethodInvokeException(JoinPoint joinPoint, Exception exception) {
        logger.info(&quot;---method {} invoke exception: {}---&quot;, joinPoint.getSignature().toShortString(), exception.getMessage());
    }
}
</code></pre><p>第一步, 自然是定义一个 <code>pointcut</code>, 以 <strong>within</strong> 切点标志符来匹配类 <code>NeedLogService</code> 下的所有 joinpoint, 即: </p>
<pre><code>@Pointcut(&quot;within(NeedLogService)&quot;)
public void pointcut() {
}
</code></pre><p>接下来根据我们前面的设计, 我们分别定义了三个 advice, 第一个是一个 before advice: </p>
<pre><code>@Before(&quot;pointcut()&quot;)
public void logMethodInvokeParam(JoinPoint joinPoint) {
    logger.info(&quot;---Before method {} invoke, param: {}---&quot;, joinPoint.getSignature().toShortString(), joinPoint.getArgs());
}
</code></pre><p>它在一个符合要求的 joinpoint 方法调用前执行, 打印调用的方法名和调用的参数. </p>
<p>第二个是 after return advice: </p>
<pre><code>@AfterReturning(pointcut = &quot;pointcut()&quot;, returning = &quot;retVal&quot;)
public void logMethodInvokeResult(JoinPoint joinPoint, Object retVal) {
    logger.info(&quot;---After method {} invoke, result: {}---&quot;, joinPoint.getSignature().toShortString(), joinPoint.getArgs());
}
</code></pre><p>这个 advice 会在方法调用成功后打印出方法名还反的参数. </p>
<p>最后一个是 after throw advice: </p>
<pre><code>@AfterThrowing(pointcut = &quot;pointcut()&quot;, throwing = &quot;exception&quot;)
public void logMethodInvokeException(JoinPoint joinPoint, Exception exception) {
    logger.info(&quot;---method {} invoke exception: {}---&quot;, joinPoint.getSignature().toShortString(), exception.getMessage());
}
</code></pre><p>这个 advice 会在指定的 joinpoint 抛出异常时执行, 打印异常的信息. </p>
<p>接下来我们再写两个 Service 类:<br><strong>NeedLogService.java:</strong></p>
<pre><code>@Service
public class NeedLogService {
    private Logger logger = LoggerFactory.getLogger(getClass());
    private Random random = new Random(System.currentTimeMillis());

    public int logMethod(String someParam) {
        logger.info(&quot;---NeedLogService: logMethod invoked, param: {}---&quot;, someParam);
        return random.nextInt();
    }

    public void exceptionMethod() throws Exception {
        logger.info(&quot;---NeedLogService: exceptionMethod invoked---&quot;);
        throw new Exception(&quot;Something bad happened!&quot;);
    }
}
</code></pre><p><strong>NormalService.java:</strong></p>
<pre><code>@Service
public class NormalService {
    private Logger logger = LoggerFactory.getLogger(getClass());

    public void someMethod() {
        logger.info(&quot;---NormalService: someMethod invoked---&quot;);
    }
}
</code></pre><p>根据我们 pointcut 的规则, 类 NeedLogService 下的所有方法都会被织入 advice, 而类 NormalService 则不会. </p>
<p>最后我们分别调用这几个方法: </p>
<pre><code>@PostConstruct
public void test() {
    needLogService.logMethod(&quot;xys&quot;);
    try {
        needLogService.exceptionMethod();
    } catch (Exception e) {
        // Ignore
    }
    normalService.someMethod();
}
</code></pre><p>我们可以看到有如下输出: </p>
<pre><code>---Before method NeedLogService.logMethod(..) invoke, param: [xys]---
---NeedLogService: logMethod invoked, param: xys---
---After method NeedLogService.logMethod(..) invoke, result: [xys]---

---Before method NeedLogService.exceptionMethod() invoke, param: []---
---NeedLogService: exceptionMethod invoked---
---method NeedLogService.exceptionMethod() invoke exception: Something bad happened!---

---NormalService: someMethod invoked---
</code></pre><p>根据 log, 我们知道, NeedLogService.logMethod 执行的前后确实有 advice 执行了, 并且在 NeedLogService.exceptionMethod 抛出异常后, <code>logMethodInvokeException</code> 这个 advice 也被执行了. 而由于 pointcut 的匹配规则, 在 <code>NormalService</code> 类中的方法则不会织入 advice. </p>
<h4 id="完整源码-1"><a href="#完整源码-1" class="headerlink" title="完整源码"></a>完整源码</h4><p><a href="https://github.com/yongshun/some_java_code/tree/master/SpringAOPDemo/src/main/java/com/xys/demo2" target="_blank" rel="external">方法调用日志</a></p>
<h3 id="方法耗时统计"><a href="#方法耗时统计" class="headerlink" title="方法耗时统计"></a>方法耗时统计</h3><p>作为程序员, 我们都知道服务监控对于一个服务能够长期稳定运行的重要性, 因此很多公司都有自己内部的监控报警系统, 或者是使用一些开源的系统, 例如小米的 Falcon 监控系统. </p>
<p>那么在程序监控中, AOP 有哪些用武之地呢? 我们来假想一下如下场景: </p>
<blockquote>
<p>有一天, leader 对小王说, “小王啊, 你负责的那个服务不太稳定啊, 经常有超时发生! 你有对这些服务接口进行过耗时统计吗?”<br>耗时统计? 小王嘀咕了, 小声的回答到: “还没有加呢.”<br>leader: “你看着办吧, 我明天要看到各个时段的服务接口调用的耗时分布!”<br>小王这就犯难了, 虽然说计算一个方法的调用耗时并不是一个很难的事情, 但是整个服务有二十来个接口呢, 一个一个地添加统计代码, 那还不是要累死人了.<br>看着同事一个一个都下班回家了, 小王眉头更加紧了. 不过此时小王灵机一动: “噫, 有了!”.<br>小王想到了一个好方法, 立即动手, 吭哧吭哧地几分钟就搞定了. </p>
</blockquote>
<p>那么小王的解决方法是什么呢? 自然是我们的主角 <code>AOP</code> 啦. </p>
<p>首先让我们来提炼一下需求: </p>
<ol>
<li><p>为服务中的每个方法调用进行调用耗时记录. </p>
</li>
<li><p>将方法调用的时间戳, 方法名, 调用耗时上报到监控平台 </p>
</li>
</ol>
<p>有了需求, 自然设计实现就很简单了. 首先我们可以使用 around advice, 然后在方法调用前, 记录一下开始时间, 然后在方法调用结束后, 记录结束时间, 它们的时间差就是方法的调用耗时. </p>
<p>我们来看一下具体的 aspect 实现: </p>
<p><strong>ExpiredAopAdviseDefine.java:</strong></p>
<pre><code>@Component
@Aspect
public class ExpiredAopAdviseDefine {
    private Logger logger = LoggerFactory.getLogger(getClass());

    // 定义一个 Pointcut, 使用 切点表达式函数 来描述对哪些 Join point 使用 advise.
    @Pointcut(&quot;within(SomeService)&quot;)
    public void pointcut() {
    }

    // 定义 advise
    // 定义 advise
    @Around(&quot;pointcut()&quot;)
    public Object methodInvokeExpiredTime(ProceedingJoinPoint pjp) throws Throwable {
        StopWatch stopWatch = new StopWatch();
        stopWatch.start();
        // 开始
        Object retVal = pjp.proceed();
        stopWatch.stop();
        // 结束

        // 上报到公司监控平台
        reportToMonitorSystem(pjp.getSignature().toShortString(), stopWatch.getTotalTimeMillis());

        return retVal;
    }


    public void reportToMonitorSystem(String methodName, long expiredTime) {
        logger.info(&quot;---method {} invoked, expired time: {} ms---&quot;, methodName, expiredTime);
        //
    }
}
</code></pre><p>aspect 一开始定义了一个 <code>pointcut</code>, 匹配 <code>SomeService</code> 类下的所有的方法.<br>接着呢, 定义了一个 around advice: </p>
<pre><code>@Around(&quot;pointcut()&quot;)
public Object methodInvokeExpiredTime(ProceedingJoinPoint pjp) throws Throwable {
    StopWatch stopWatch = new StopWatch();
    stopWatch.start();
    // 开始
    Object retVal = pjp.proceed();
    stopWatch.stop();
    // 结束

    // 上报到公司监控平台
    reportToMonitorSystem(pjp.getSignature().toShortString(), stopWatch.getTotalTimeMillis());

    return retVal;
}
</code></pre><p>advice 中的代码也很简单, 它使用了 Spring 提供的 StopWatch 来统计一段代码的执行时间. 首先我们先调用 <strong>stopWatch.start()</strong> 开始计时, 然后通过 <code>pjp.proceed()</code> 来调用我们实际的服务方法, 当调用结束后, 通过 <strong>stopWatch.stop()</strong> 来结束计时. </p>
<p>接着我们来写一个简单的服务, 这个服务提供一个 <strong>someMethod</strong> 方法用于模拟一个耗时的方法调用:<br><strong>SomeService.java:</strong></p>
<pre><code>@Service
public class SomeService {
    private Logger logger = LoggerFactory.getLogger(getClass());
    private Random random = new Random(System.currentTimeMillis());

    public void someMethod() {
        logger.info(&quot;---SomeService: someMethod invoked---&quot;);
        try {
            // 模拟耗时任务
            Thread.sleep(random.nextInt(500));
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
</code></pre><p>这样当 <code>SomeService</code> 类下的方法调用时, 我们所提供的 advice 就会被执行, 因此就可以自动地为我们统计此方法的调用耗时, 并自动上报到监控系统中了.<br>看到 <code>AOP</code> 的威力了吧, 我们这里仅仅使用了寥寥数语就把一个需求完美地解决了, 并且还与原来的业务逻辑完全解耦, 扩展及其方便. </p>
<h4 id="完整源码-2"><a href="#完整源码-2" class="headerlink" title="完整源码"></a>完整源码</h4><p><a href="https://github.com/yongshun/some_java_code/tree/master/SpringAOPDemo/src/main/java/com/xys/demo3" target="_blank" rel="external">方法耗时统计</a></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过上面的几个简单例子, 我们对 <code>Spring AOP</code> 的使用应该有了一个更为深入的了解了. 其实 Spring AOP 的使用的地方不止这些, 例如 Spring 的 <code>声明式事务</code> 就是在 AOP 之上构建的. 读者朋友也可以根据自己的实际业务场景, 合理使用 Spring AOP, 发挥它的强大功能! </p>
<h2 id="End"><a href="#End" class="headerlink" title="End."></a>End.</h2>]]></content>
      
        <categories>
            
            <category> JavaWeb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> AOP </tag>
            
            <tag> javaweb </tag>
            
            <tag> Spring </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[AOP编程详解]]></title>
      <url>/2017/10/01/JavaWeb/AOP%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a> 
<h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><p>其实, 接触了这么久的 AOP, 我感觉, AOP 给人难以理解的一个关键点是它的概念比较多, 而且坑爹的是, 这些概念经过了中文翻译后, 变得面目全非, 相同的一个术语, 在不同的翻译下, 含义总有着各种莫名其妙的差别. 鉴于此, 我在本章的开头, 着重为为大家介绍一个 Spring AOP 的各项术语的基本含义. 为了术语传达的准确性, 我在接下来的叙述中, 能使用英文术语的地方, 尽量使用英文. </p>
<h3 id="什么是-AOP"><a href="#什么是-AOP" class="headerlink" title="什么是 AOP"></a>什么是 AOP</h3><p>AOP(Aspect-Oriented Programming), 即 <strong>面向切面编程</strong>, 它与 OOP( Object-Oriented Programming, 面向对象编程) 相辅相成, 提供了与 OOP 不同的抽象软件结构的视角.<br>在 OOP 中, 我们以类(class)作为我们的基本单元, 而 AOP 中的基本单元是 <strong>Aspect(切面)</strong></p>
<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><h4 id="Aspect-切面"><a href="#Aspect-切面" class="headerlink" title="Aspect(切面)"></a>Aspect(切面)</h4><p><code>aspect</code> 由 <code>pointcount</code> 和 <code>advice</code> 组成, 它既包含了横切逻辑的定义, 也包括了连接点的定义. Spring AOP就是负责实施切面的框架, 它将切面所定义的横切逻辑织入到切面所指定的连接点中.<br>AOP的工作重心在于如何将增强织入目标对象的连接点上, 这里包含两个工作: </p>
<ol>
<li><p>如何通过 pointcut 和 advice 定位到特定的 joinpoint 上 </p>
</li>
<li><p>如何在 advice 中编写切面代码. </p>
</li>
</ol>
<p><strong>可以简单地认为, 使用 @Aspect 注解的类就是切面.</strong></p>
<h4 id="advice-增强"><a href="#advice-增强" class="headerlink" title="advice(增强)"></a>advice(增强)</h4><p>由 aspect 添加到特定的 join point(即满足 point cut 规则的 join point) 的一段代码.<br>许多 AOP框架, 包括 Spring AOP, 会将 advice 模拟为一个拦截器(interceptor), 并且在 join point 上维护多个 advice, 进行层层拦截.<br>例如 HTTP 鉴权的实现, 我们可以为每个使用 RequestMapping 标注的方法织入 advice, 当 HTTP 请求到来时, 首先进入到 advice 代码中, 在这里我们可以分析这个 HTTP 请求是否有相应的权限, 如果有, 则执行 Controller, 如果没有, 则抛出异常. 这里的 advice 就扮演着鉴权拦截器的角色了. </p>
<h4 id="连接点-join-point"><a href="#连接点-join-point" class="headerlink" title="连接点(join point)"></a>连接点(join point)</h4><blockquote>
<p>a point during the execution of a program, such as the execution of a method or the handling of an exception. In Spring AOP, a join point always represents a method execution. </p>
</blockquote>
<p>程序运行中的一些时间点, 例如一个方法的执行, 或者是一个异常的处理.<br><code>在 Spring AOP 中, join point 总是方法的执行点, 即只有方法连接点.</code></p>
<h4 id="切点-point-cut"><a href="#切点-point-cut" class="headerlink" title="切点(point cut)"></a>切点(point cut)</h4><p>匹配 join point 的谓词(a predicate that matches join points).<br>Advice 是和特定的 point cut 关联的, 并且在 point cut 相匹配的 join point 中执行.<br><code>在 Spring 中, 所有的方法都可以认为是 joinpoint, 但是我们并不希望在所有的方法上都添加 Advice, 而 pointcut 的作用就是提供一组规则(使用 AspectJ pointcut expression language 来描述) 来匹配joinpoint, 给满足规则的 joinpoint 添加 Advice.</code></p>
<h4 id="关于join-point-和-point-cut-的区别"><a href="#关于join-point-和-point-cut-的区别" class="headerlink" title="关于join point 和 point cut 的区别"></a>关于join point 和 point cut 的区别</h4><p>在 Spring AOP 中, 所有的方法执行都是 join point. 而 point cut 是一个描述信息, 它修饰的是 join point, 通过 point cut, 我们就可以确定哪些 join point 可以被织入 Advice. 因此 join point 和 point cut 本质上就是两个不同纬度上的东西.<br><code>advice 是在 join point 上执行的, 而 point cut 规定了哪些 join point 可以执行哪些 advice</code></p>
<h4 id="introduction"><a href="#introduction" class="headerlink" title="introduction"></a>introduction</h4><p>为一个类型添加额外的方法或字段. Spring AOP 允许我们为 <code>目标对象</code> 引入新的接口(和对应的实现). 例如我们可以使用 introduction 来为一个 bean 实现 IsModified 接口, 并以此来简化 caching 的实现. </p>
<h4 id="目标对象-Target"><a href="#目标对象-Target" class="headerlink" title="目标对象(Target)"></a>目标对象(Target)</h4><p>织入 advice 的目标对象. 目标对象也被称为 <code>advised object</code>.<br><code>因为 Spring AOP 使用运行时代理的方式来实现 aspect, 因此 adviced object 总是一个代理对象(proxied object)</code><br><code>注意, adviced object 指的不是原来的类, 而是织入 advice 后所产生的代理类.</code></p>
<h4 id="AOP-proxy"><a href="#AOP-proxy" class="headerlink" title="AOP proxy"></a>AOP proxy</h4><p>一个类被 AOP 织入 advice, 就会产生一个结果类, 它是融合了原类和增强逻辑的代理类.<br>在 Spring AOP 中, 一个 AOP 代理是一个 JDK 动态代理对象或 CGLIB 代理对象. </p>
<h4 id="织入-Weaving"><a href="#织入-Weaving" class="headerlink" title="织入(Weaving)"></a>织入(Weaving)</h4><p>将 aspect 和其他对象连接起来, 并创建 adviced object 的过程.<br>根据不同的实现技术, AOP织入有三种方式: </p>
<ul>
<li><p>编译器织入, 这要求有特殊的Java编译器. </p>
</li>
<li><p>类装载期织入, 这需要有特殊的类装载器. </p>
</li>
<li><p>动态代理织入, 在运行期为目标类添加增强(Advice)生成子类的方式.<br>Spring 采用动态代理织入, 而AspectJ采用编译器织入和类装载期织入. </p>
</li>
</ul>
<h3 id="advice-的类型"><a href="#advice-的类型" class="headerlink" title="advice 的类型"></a>advice 的类型</h3><ul>
<li><p>before advice, 在 join point 前被执行的 advice. 虽然 before advice 是在 join point 前被执行, 但是它并不能够阻止 join point 的执行, 除非发生了异常(即我们在 before advice 代码中, 不能人为地决定是否继续执行 join point 中的代码) </p>
</li>
<li><p>after return advice, 在一个 join point 正常返回后执行的 advice </p>
</li>
<li><p>after throwing advice, 当一个 join point 抛出异常后执行的 advice </p>
</li>
<li><p>after(final) advice, 无论一个 join point 是正常退出还是发生了异常, 都会被执行的 advice. </p>
</li>
<li><p>around advice, 在 join point 前和 joint point 退出后都执行的 advice. 这个是最常用的 advice. </p>
</li>
</ul>
<h3 id="关于-AOP-Proxy"><a href="#关于-AOP-Proxy" class="headerlink" title="关于 AOP Proxy"></a>关于 AOP Proxy</h3><p>Spring AOP 默认使用标准的 JDK 动态代理(dynamic proxy)技术来实现 AOP 代理, 通过它, 我们可以为任意的接口实现代理.<br><code>如果需要为一个类实现代理, 那么可以使用 CGLIB 代理.</code> 当一个业务逻辑对象没有实现接口时, 那么Spring AOP 就默认使用 CGLIB 来作为 AOP 代理了. 即如果我们需要为一个方法织入 advice, 但是这个方法不是一个接口所提供的方法, 则此时 Spring AOP 会使用 CGLIB 来实现动态代理. 鉴于此, Spring AOP 建议基于接口编程, 对接口进行 AOP 而不是类. </p>
<h2 id="彻底理解-aspect-join-point-point-cut-advice"><a href="#彻底理解-aspect-join-point-point-cut-advice" class="headerlink" title="彻底理解 aspect, join point, point cut, advice"></a>彻底理解 aspect, join point, point cut, advice</h2><p>看完了上面的理论部分知识, 我相信还是会有不少朋友感觉到 AOP 的概念还是很模糊, 对 AOP 中的各种概念理解的还不是很透彻. 其实这很正常, 因为 AOP 中的概念是在是太多了, 我当时也是花了老大劲才梳理清楚的.<br>下面我以一个简单的例子来比喻一下 AOP 中 aspect, jointpoint, pointcut 与 advice 之间的关系. </p>
<p>让我们来假设一下, 从前有一个叫爪哇的小县城, 在一个月黑风高的晚上, 这个县城中发生了命案. 作案的凶手十分狡猾, 现场没有留下什么有价值的线索. 不过万幸的是, 刚从隔壁回来的老王恰好在这时候无意中发现了凶手行凶的过程, 但是由于天色已晚, 加上凶手蒙着面, 老王并没有看清凶手的面目, 只知道凶手是个男性, 身高约七尺五寸. 爪哇县的县令根据老王的描述, 对守门的士兵下命令说: 凡是发现有身高七尺五寸的男性, 都要抓过来审问. 士兵当然不敢违背县令的命令, 只好把进出城的所有符合条件的人都抓了起来. </p>
<p>来让我们看一下上面的一个小故事和 AOP 到底有什么对应关系.<br>首先我们知道, 在 Spring AOP 中 join point 指代的是所有方法的执行点, 而 point cut 是一个描述信息, 它修饰的是 join point, 通过 point cut, 我们就可以确定哪些 join point 可以被织入 Advice. 对应到我们在上面举的例子, 我们可以做一个简单的类比, join point 就相当于 <strong>爪哇的小县城里的百姓</strong>, point cut 就相当于 <strong>老王所做的指控, 即凶手是个男性, 身高约七尺五寸</strong>, 而 advice 则是施加在符合老王所描述的嫌疑人的动作: <strong>抓过来审问</strong>.<br>为什么可以这样类比呢? </p>
<ul>
<li><p>join point –&gt; 爪哇的小县城里的百姓: 因为根据定义, join point 是所有可能被织入 advice 的候选的点, 在 Spring AOP中, 则可以认为所有方法执行点都是 join point. 而在我们上面的例子中, 命案发生在小县城中, 按理说在此县城中的所有人都有可能是嫌疑人. </p>
</li>
<li><p>point cut –&gt; 男性, 身高约七尺五寸: 我们知道, 所有的方法(joint point) 都可以织入 advice, 但是我们并不希望在所有方法上都织入 advice, 而 pointcut 的作用就是提供一组规则来匹配joinpoint, 给满足规则的 joinpoint 添加 advice. 同理, 对于县令来说, 他再昏庸, 也知道不能把县城中的所有百姓都抓起来审问, 而是根据<code>凶手是个男性, 身高约七尺五寸</code>, 把符合条件的人抓起来. 在这里 <code>凶手是个男性, 身高约七尺五寸</code> 就是一个修饰谓语, 它限定了凶手的范围, 满足此修饰规则的百姓都是嫌疑人, 都需要抓起来审问. </p>
</li>
<li><p>advice –&gt; 抓过来审问, advice 是一个动作, 即一段 Java 代码, 这段 Java 代码是作用于 point cut 所限定的那些 join point 上的. 同理, 对比到我们的例子中, <code>抓过来审问</code> 这个动作就是对作用于那些满足 <code>男性, 身高约七尺五寸</code> 的<code>爪哇的小县城里的百姓</code>. </p>
</li>
<li><p>aspect: aspect 是 point cut 与 advice 的组合, 因此在这里我们就可以类比: <strong>“根据老王的线索, 凡是发现有身高七尺五寸的男性, 都要抓过来审问”</strong> 这一整个动作可以被认为是一个 aspect. </p>
</li>
</ul>
<hr>
<p>或则我们也可以从语法的角度来简单类比一下. 我们在学英语时, 经常会接触什么 <code>定语</code>, <code>被动句</code> 之类的概念, 那么可以做一个不严谨的类比, 即 <code>joinpoint</code> 可以认为是一个 <code>宾语</code>, 而 <code>pointcut</code> 则可以类比为修饰 <code>joinpoint</code> 的定语, 那么整个 <code>aspect</code> 就可以描述为: <code>满足 pointcut 规则的 joinpoint 会被添加相应的 advice 操作.</code></p>
<h2 id="AspectJ-支持"><a href="#AspectJ-支持" class="headerlink" title="@AspectJ 支持"></a>@AspectJ 支持</h2><p><strong>@AspectJ</strong> 是一种使用 Java 注解来实现 AOP 的编码风格.<br>@AspectJ 风格的 AOP 是 AspectJ Project 在 AspectJ 5 中引入的, 并且 Spring 也支持@AspectJ 的 AOP 风格. </p>
<h3 id="使能-AspectJ-支持"><a href="#使能-AspectJ-支持" class="headerlink" title="使能 @AspectJ 支持"></a>使能 @AspectJ 支持</h3><p>@AspectJ 可以以 XML 的方式或以注解的方式来使能, 并且不论以哪种方式使能@ASpectJ, 我们都必须保证 aspectjweaver.jar 在 classpath 中. </p>
<h4 id="使用-Java-Configuration-方式使能-AspectJ"><a href="#使用-Java-Configuration-方式使能-AspectJ" class="headerlink" title="使用 Java Configuration 方式使能@AspectJ"></a>使用 Java Configuration 方式使能@AspectJ</h4><pre><code>@Configuration
@EnableAspectJAutoProxy
public class AppConfig {
}
</code></pre><h4 id="使用-XML-方式使能-AspectJ"><a href="#使用-XML-方式使能-AspectJ" class="headerlink" title="使用 XML 方式使能@AspectJ"></a>使用 XML 方式使能@AspectJ</h4><pre><code>&lt;aop:aspectj-autoproxy/&gt;
</code></pre><h3 id="定义-aspect-切面"><a href="#定义-aspect-切面" class="headerlink" title="定义 aspect(切面)"></a>定义 aspect(切面)</h3><p>当使用注解 <strong>@Aspect</strong> 标注一个 Bean 后, 那么 Spring 框架会自动收集这些 Bean, 并添加到 Spring AOP 中, 例如: </p>
<pre><code>@Component
@Aspect
public class MyTest {
}
</code></pre><p><code>注意, 仅仅使用@Aspect 注解, 并不能将一个 Java 对象转换为 Bean, 因此我们还需要使用类似 @Component 之类的注解.</code><br><code>注意, 如果一个 类被@Aspect 标注, 则这个类就不能是其他 aspect 的 **advised object** 了, 因为使用 @Aspect 后, 这个类就会被排除在 auto-proxying 机制之外.</code></p>
<h3 id="声明-pointcut"><a href="#声明-pointcut" class="headerlink" title="声明 pointcut"></a>声明 pointcut</h3><p>一个 pointcut 的声明由两部分组成: </p>
<ul>
<li><p>一个方法签名, 包括方法名和相关参数 </p>
</li>
<li><p>一个 pointcut 表达式, 用来指定哪些方法执行是我们感兴趣的(即因此可以织入 advice). </p>
</li>
</ul>
<p>在@AspectJ 风格的 AOP 中, 我们使用一个方法来描述 pointcut, 即: </p>
<pre><code>@Pointcut(&quot;execution(* com.xys.service.UserService.*(..))&quot;) // 切点表达式
private void dataAccessOperation() {} // 切点前面
</code></pre><p><code>这个方法必须无返回值.</code><br><code>这个方法本身就是 pointcut signature, pointcut 表达式使用@Pointcut 注解指定.</code><br>上面我们简单地定义了一个 pointcut, 这个 pointcut 所描述的是: 匹配所有在包 <strong>com.xys.service.UserService</strong> 下的所有方法的执行. </p>
<h4 id="切点标志符-designator"><a href="#切点标志符-designator" class="headerlink" title="切点标志符(designator)"></a>切点标志符(designator)</h4><p>AspectJ5 的切点表达式由标志符(designator)和操作参数组成. 如 “execution( _greetTo(..))” 的切点表达式, <strong>execution</strong> 就是 标志符, 而圆括号里的_ greetTo(..) 就是操作参数 </p>
<h5 id="execution"><a href="#execution" class="headerlink" title="execution"></a>execution</h5><p>匹配 join point 的执行, 例如 “execution(* hello(..))” 表示匹配所有目标类中的 hello() 方法. 这个是最基本的 pointcut 标志符. </p>
<h5 id="within"><a href="#within" class="headerlink" title="within"></a>within</h5><p>匹配特定包下的所有 join point, 例如 <code>within(com.xys.*)</code> 表示 com.xys 包中的所有连接点, 即包中的所有类的所有方法. 而 <code>within(com.xys.service.*Service)</code> 表示在 com.xys.service 包中所有以 Service 结尾的类的所有的连接点. </p>
<h5 id="this-与-target"><a href="#this-与-target" class="headerlink" title="this 与 target"></a>this 与 target</h5><p>this 的作用是匹配一个 bean, 这个 bean(Spring AOP proxy) 是一个给定类型的实例(instance of). 而 target 匹配的是一个目标对象(target object, 即需要织入 advice 的原始的类), 此对象是一个给定类型的实例(instance of). </p>
<h5 id="bean"><a href="#bean" class="headerlink" title="bean"></a>bean</h5><p>匹配 bean 名字为指定值的 bean 下的所有方法, 例如: </p>
<pre><code>bean(*Service) // 匹配名字后缀为 Service 的 bean 下的所有方法
bean(myService) // 匹配名字为 myService 的 bean 下的所有方法
</code></pre><h5 id="args"><a href="#args" class="headerlink" title="args"></a>args</h5><p>匹配参数满足要求的的方法.<br>例如: </p>
<pre><code>@Pointcut(&quot;within(com.xys.demo2.*)&quot;)
public void pointcut2() {
}

@Before(value = &quot;pointcut2()  &amp;&amp;  args(name)&quot;)
public void doSomething(String name) {
    logger.info(&quot;---page: {}---&quot;, name);
}

@Service
public class NormalService {
    private Logger logger = LoggerFactory.getLogger(getClass());

    public void someMethod() {
        logger.info(&quot;---NormalService: someMethod invoked---&quot;);
    }


    public String test(String name) {
        logger.info(&quot;---NormalService: test invoked---&quot;);
        return &quot;服务一切正常&quot;;
    }
}
</code></pre><p>当 NormalService.test 执行时, 则 advice <code>doSomething</code> 就会执行, test 方法的参数 name 就会传递到 <code>doSomething</code> 中. </p>
<p>常用例子: </p>
<pre><code>// 匹配只有一个参数 name 的方法
@Before(value = &quot;aspectMethod()  &amp;&amp;  args(name)&quot;)
public void doSomething(String name) {
}

// 匹配第一个参数为 name 的方法
@Before(value = &quot;aspectMethod()  &amp;&amp;  args(name, ..)&quot;)
public void doSomething(String name) {
}

// 匹配第二个参数为 name 的方法
Before(value = &quot;aspectMethod()  &amp;&amp;  args(*, name, ..)&quot;)
public void doSomething(String name) {
}
</code></pre><h5 id="annotation"><a href="#annotation" class="headerlink" title="@annotation"></a>@annotation</h5><p>匹配由指定注解所标注的方法, 例如: </p>
<pre><code>@Pointcut(&quot;@annotation(com.xys.demo1.AuthChecker)&quot;)
public void pointcut() {
}
</code></pre><p>则匹配由注解 <code>AuthChecker</code> 所标注的方法. </p>
<h4 id="常见的切点表达式"><a href="#常见的切点表达式" class="headerlink" title="常见的切点表达式"></a>常见的切点表达式</h4><h5 id="匹配方法签名"><a href="#匹配方法签名" class="headerlink" title="匹配方法签名"></a>匹配方法签名</h5><pre><code>// 匹配指定包中的所有的方法
execution(* com.xys.service.*(..))

// 匹配当前包中的指定类的所有方法
execution(* UserService.*(..))

// 匹配指定包中的所有 public 方法
execution(public * com.xys.service.*(..))

// 匹配指定包中的所有 public 方法, 并且返回值是 int 类型的方法
execution(public int com.xys.service.*(..))

// 匹配指定包中的所有 public 方法, 并且第一个参数是 String, 返回值是 int 类型的方法
execution(public int com.xys.service.*(String name, ..))
</code></pre><h5 id="匹配类型签名"><a href="#匹配类型签名" class="headerlink" title="匹配类型签名"></a>匹配类型签名</h5><pre><code>// 匹配指定包中的所有的方法, 但不包括子包
within(com.xys.service.*)

// 匹配指定包中的所有的方法, 包括子包
within(com.xys.service..*)

// 匹配当前包中的指定类中的方法
within(UserService)


// 匹配一个接口的所有实现类中的实现的方法
within(UserDao+)
</code></pre><h5 id="匹配-Bean-名字"><a href="#匹配-Bean-名字" class="headerlink" title="匹配 Bean 名字"></a>匹配 Bean 名字</h5><pre><code>// 匹配以指定名字结尾的 Bean 中的所有方法
bean(*Service)
</code></pre><h5 id="切点表达式组合"><a href="#切点表达式组合" class="headerlink" title="切点表达式组合"></a>切点表达式组合</h5><pre><code>// 匹配以 Service 或 ServiceImpl 结尾的 bean
bean(*Service || *ServiceImpl)

// 匹配名字以 Service 结尾, 并且在包 com.xys.service 中的 bean
bean(*Service) &amp;&amp; within(com.xys.service.*)
</code></pre><h3 id="声明-advice"><a href="#声明-advice" class="headerlink" title="声明 advice"></a>声明 advice</h3><p>advice 是和一个 pointcut 表达式关联在一起的, 并且会在匹配的 join point 的方法执行的前/后/周围 运行. <code>pointcut 表达式可以是简单的一个 pointcut 名字的引用, 或者是完整的 pointcut 表达式</code>.<br>下面我们以几个简单的 advice 为例子, 来看一下一个 advice 是如何声明的. </p>
<h4 id="Before-advice"><a href="#Before-advice" class="headerlink" title="Before advice"></a>Before advice</h4><pre><code>/**
 * @author xiongyongshun
 * @version 1.0
 * @created 16/9/9 13:13
 */
@Component
@Aspect
public class BeforeAspectTest {
    // 定义一个 Pointcut, 使用 切点表达式函数 来描述对哪些 Join point 使用 advise.
    @Pointcut(&quot;execution(* com.xys.service.UserService.*(..))&quot;)
    public void dataAccessOperation() {
    }
}

@Component
@Aspect
public class AdviseDefine {
    // 定义 advise
    @Before(&quot;com.xys.aspect.PointcutDefine.dataAccessOperation()&quot;)
    public void doBeforeAccessCheck(JoinPoint joinPoint) {
        System.out.println(&quot;*****Before advise, method: &quot; + joinPoint.getSignature().toShortString() + &quot; *****&quot;);
    }
}
</code></pre><p>这里, <strong>@Before</strong> 引用了一个 pointcut, 即 “com.xys.aspect.PointcutDefine.dataAccessOperation()” 是一个 pointcut 的名字.<br>如果我们在 advice 在内置 pointcut, 则可以: </p>
<pre><code>@Component
@Aspect
public class AdviseDefine {
    // 将 pointcut 和 advice 同时定义
    @Before(&quot;within(com.xys.service..*)&quot;)
    public void doAccessCheck(JoinPoint joinPoint) {
        System.out.println(&quot;*****doAccessCheck, Before advise, method: &quot; + joinPoint.getSignature().toShortString() + &quot; *****&quot;);
    }
}
</code></pre><h4 id="around-advice"><a href="#around-advice" class="headerlink" title="around advice"></a>around advice</h4><p>around advice 比较特别, 它可以在一个方法的之前之前和之后添加不同的操作, 并且甚至可以决定何时, 如何, 是否调用匹配到的方法. </p>
<pre><code>@Component
@Aspect
public class AdviseDefine {
    // 定义 advise
    @Around(&quot;com.xys.aspect.PointcutDefine.dataAccessOperation()&quot;)
    public Object doAroundAccessCheck(ProceedingJoinPoint pjp) throws Throwable {
        StopWatch stopWatch = new StopWatch();
        stopWatch.start();
        // 开始
        Object retVal = pjp.proceed();
        stopWatch.stop();
        // 结束
        System.out.println(&quot;invoke method: &quot; + pjp.getSignature().getName() + &quot;, elapsed time: &quot; + stopWatch.getTotalTimeMillis());
        return retVal;
    }
}
</code></pre><p>around advice 和前面的 before advice 差不多, 只是我们把注解 <strong>@Before</strong> 改为了 <strong>@Around</strong> 了. </p>
]]></content>
      
        <categories>
            
            <category> JavaWeb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> AOP </tag>
            
            <tag> javaweb </tag>
            
            <tag> Spring </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[axios使用教程]]></title>
      <url>/2017/09/28/VueJs/axios%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a> 
<h2 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h2><p>1、 利用npm安装<code>npm install axios --save</code><br>2、 利用bower安装<code>bower install axios --save</code><br>3、 直接利用cdn引入<code>&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;</code></p>
<h2 id="二、例子"><a href="#二、例子" class="headerlink" title="二、例子"></a>二、例子</h2><p>1、 发送一个<code>GET</code>请求 </p>
<pre><code>//通过给定的ID来发送请求
axios.get(&#39;/user?ID=12345&#39;)
  .then(function(response){
    console.log(response);
  })
  .catch(function(err){
    console.log(err);
  });
//以上请求也可以通过这种方式来发送
axios.get(&#39;/user&#39;,{
  params:{
    ID:12345
  }
})
.then(function(response){
  console.log(response);
})
.catch(function(err){
  console.log(err);
});
</code></pre><p>2、 发送一个<code>POST</code>请求 </p>
<pre><code>axios.post(&#39;/user&#39;,{
  firstName:&#39;Fred&#39;,
  lastName:&#39;Flintstone&#39;
})
.then(function(res){
  console.log(res);
})
.catch(function(err){
  console.log(err);
});
</code></pre><p>3、 一次性并发多个请求 </p>
<pre><code>function getUserAccount(){
  return axios.get(&#39;/user/12345&#39;);
}
function getUserPermissions(){
  return axios.get(&#39;/user/12345/permissions&#39;);
}
axios.all([getUserAccount(),getUserPermissions()])
  .then(axios.spread(function(acct,perms){
    //当这两个请求都完成的时候会触发这个函数，两个参数分别代表返回的结果
  }))
</code></pre><h2 id="三、axios的API"><a href="#三、axios的API" class="headerlink" title="三、axios的API"></a>三、axios的API</h2><h4 id="（一）-axios可以通过配置（config）来发送请求"><a href="#（一）-axios可以通过配置（config）来发送请求" class="headerlink" title="（一） axios可以通过配置（config）来发送请求"></a>（一） axios可以通过配置（<code>config</code>）来发送请求</h4><p>1、 <code>axios(config)</code></p>
<pre><code>//发送一个`POST`请求
axios({
    method:&quot;POST&quot;,
    url:&#39;/user/12345&#39;,
    data:{
        firstName:&quot;Fred&quot;,
        lastName:&quot;Flintstone&quot;
    }
});
</code></pre><p>2、 <code>axios(url[,config])</code></p>
<pre><code>//发送一个`GET`请求（默认的请求方式）
axios(&#39;/user/12345&#39;);
</code></pre><h4 id="（二）、-请求方式的别名，这里对所有已经支持的请求方式都提供了方便的别名"><a href="#（二）、-请求方式的别名，这里对所有已经支持的请求方式都提供了方便的别名" class="headerlink" title="（二）、 请求方式的别名，这里对所有已经支持的请求方式都提供了方便的别名"></a>（二）、 请求方式的别名，这里对所有已经支持的请求方式都提供了方便的别名</h4><pre><code>axios.request(config);

axios.get(url[,config]);

axios.delete(url[,config]);

axios.head(url[,config]);

axios.post(url[,data[,config]]);

axios.put(url[,data[,config]])

axios.patch(url[,data[,config]])
</code></pre><ul>
<li>注意：当我们在使用别名方法的时候，<code>url,method,data</code>这几个参数不需要在配置中声明</li>
</ul>
<h4 id="（三）、-并发请求（concurrency）-即是帮助处理并发请求的辅助函数"><a href="#（三）、-并发请求（concurrency）-即是帮助处理并发请求的辅助函数" class="headerlink" title="（三）、 并发请求（concurrency）,即是帮助处理并发请求的辅助函数"></a>（三）、 并发请求（concurrency）,即是帮助处理并发请求的辅助函数</h4><pre><code>//iterable是一个可以迭代的参数如数组等
axios.all(iterable)
//callback要等到所有请求都完成才会执行
axios.spread(callback)
</code></pre><h4 id="（四）、创建一个axios实例，并且可以自定义其配置"><a href="#（四）、创建一个axios实例，并且可以自定义其配置" class="headerlink" title="（四）、创建一个axios实例，并且可以自定义其配置"></a>（四）、创建一个<code>axios</code>实例，并且可以自定义其配置</h4><p>1、 <code>axios.create([config])</code></p>
<pre><code>var instance = axios.create({
  baseURL:&quot;https://some-domain.com/api/&quot;,
  timeout:1000,
  headers: {&#39;X-Custom-Header&#39;:&#39;foobar&#39;}
});
</code></pre><p>2、 实例的方法 </p>
<ul>
<li><p>一下是实例方法，注意已经定义的配置将和利用create创建的实例的配置合并</p>
<p>axios#request(config)</p>
<p>axios#get(url[,config])</p>
<p>axios#delete(url[,config])</p>
<p>axios#head(url[,config])</p>
<p>axios#post(url[,data[,config]])</p>
<p>axios#put(url[,data[,config]])</p>
<p>axios#patch(url[,data[,config]])</p>
</li>
</ul>
<h2 id="四、请求的配置（request-config）"><a href="#四、请求的配置（request-config）" class="headerlink" title="四、请求的配置（request config）"></a>四、请求的配置（request config）</h2><ul>
<li><p>以下就是请求的配置选项，只有<code>url</code>选项是必须的，如果<code>method</code>选项未定义，那么它默认是以<code>GET</code>的方式发出请求</p>
<p>{<br>  //<code>url</code>是请求的服务器地址<br>  url:’/user’,<br>  //<code>method</code>是请求资源的方式<br>  method:’get’//default<br>  //如果<code>url</code>不是绝对地址，那么<code>baseURL</code>将会加到<code>url</code>的前面<br>  //当<code>url</code>是相对地址的时候，设置<code>baseURL</code>会非常的方便<br>  baseURL:’<a href="https://some-domain.com/api/" target="_blank" rel="external">https://some-domain.com/api/</a>‘,<br>  //<code>transformRequest</code>选项允许我们在请求发送到服务器之前对请求的数据做出一些改动<br>  //该选项只适用于以下请求方式：<code>put/post/patch</code><br>  //数组里面的最后一个函数必须返回一个字符串、-一个<code>ArrayBuffer</code>或者<code>Stream</code><br>  transformRequest:[function(data){</p>
<pre><code>//在这里根据自己的需求改变数据
return data;
</code></pre><p>  }],<br>  //<code>transformResponse</code>选项允许我们在数据传送到<code>then/catch</code>方法之前对数据进行改动<br>  transformResponse:[function(data){</p>
<pre><code>//在这里根据自己的需求改变数据
return data;
</code></pre><p>  }],<br>  //<code>headers</code>选项是需要被发送的自定义请求头信息<br>  headers: {‘X-Requested-With’:’XMLHttpRequest’},<br>  //<code>params</code>选项是要随请求一起发送的请求参数—-一般链接在URL后面<br>  //他的类型必须是一个纯对象或者是URLSearchParams对象<br>  params: {</p>
<pre><code>ID:12345
</code></pre><p>  },<br>  //<code>paramsSerializer</code>是一个可选的函数，起作用是让参数（params）序列化<br>  //例如(<a href="https://www.npmjs.com/package/qs,http://api.jquery.com/jquery.param" target="_blank" rel="external">https://www.npmjs.com/package/qs,http://api.jquery.com/jquery.param</a>)<br>  paramsSerializer: function(params){</p>
<pre><code>return Qs.stringify(params,{arrayFormat:&#39;brackets&#39;})
</code></pre><p>  },<br>  //<code>data</code>选项是作为一个请求体而需要被发送的数据<br>  //该选项只适用于方法：<code>put/post/patch</code><br>  //当没有设置<code>transformRequest</code>选项时dada必须是以下几种类型之一<br>  //string/plain/object/ArrayBuffer/ArrayBufferView/URLSearchParams<br>  //仅仅浏览器：FormData/File/Bold<br>  //仅node:Stream<br>  data {</p>
<pre><code>firstName:&quot;Fred&quot;
</code></pre><p>  },<br>  //<code>timeout</code>选项定义了请求发出的延迟毫秒数<br>  //如果请求花费的时间超过延迟的时间，那么请求会被终止</p>
<p>  timeout:1000,<br>  //<code>withCredentails</code>选项表明了是否是跨域请求</p>
<p>  withCredentials:false,//default<br>  //<code>adapter</code>适配器选项允许自定义处理请求，这会使得测试变得方便<br>  //返回一个promise,并提供验证返回<br>  adapter: function(config){</p>
<pre><code>/*..........*/
</code></pre><p>  },<br>  //<code>auth</code>表明HTTP基础的认证应该被使用，并提供证书<br>  //这会设置一个authorization头（header）,并覆盖你在header设置的Authorization头信息<br>  auth: {</p>
<pre><code>username:&quot;zhangsan&quot;,
password: &quot;s00sdkf&quot;
</code></pre><p>  },<br>  //返回数据的格式<br>  //其可选项是arraybuffer,blob,document,json,text,stream<br>  responseType:’json’,//default<br>  //<br>  xsrfCookieName: ‘XSRF-TOKEN’,//default<br>  xsrfHeaderName:’X-XSRF-TOKEN’,//default<br>  //<code>onUploadProgress</code>上传进度事件<br>  onUploadProgress:function(progressEvent){</p>
<pre><code>//下载进度的事件
</code></pre><p>onDownloadProgress:function(progressEvent){<br>}<br>  },<br>  //相应内容的最大值<br>  maxContentLength:2000,<br>  //<code>validateStatus</code>定义了是否根据http相应状态码，来resolve或者reject promise<br>  //如果<code>validateStatus</code>返回true(或者设置为<code>null</code>或者<code>undefined</code>),那么promise的状态将会是resolved,否则其状态就是rejected<br>  validateStatus:function(status){</p>
<pre><code>return status &gt;= 200 &amp;&amp; status &lt;300;//default
</code></pre><p>  },<br>  //<code>maxRedirects</code>定义了在nodejs中重定向的最大数量<br>  maxRedirects: 5,//default<br>  //<code>httpAgent/httpsAgent</code>定义了当发送http/https请求要用到的自定义代理<br>  //keeyAlive在选项中没有被默认激活<br>  httpAgent: new http.Agent({keeyAlive:true}),<br>  httpsAgent: new https.Agent({keeyAlive:true}),<br>  //proxy定义了主机名字和端口号，<br>  //<code>auth</code>表明http基本认证应该与proxy代理链接，并提供证书<br>  //这将会设置一个<code>Proxy-Authorization</code> header,并且会覆盖掉已经存在的<code>Proxy-Authorization</code>  header<br>  proxy: {</p>
<pre><code>host:&#39;127.0.0.1&#39;,
port: 9000,
auth: {
  username:&#39;skda&#39;,
  password:&#39;radsd&#39;
}
</code></pre><p>  },<br>  //<code>cancelToken</code>定义了一个用于取消请求的cancel token<br>  //详见cancelation部分<br>  cancelToken: new cancelToken(function(cancel){</p>
<p>  })<br>}</p>
</li>
</ul>
<h2 id="五、请求返回的内容"><a href="#五、请求返回的内容" class="headerlink" title="五、请求返回的内容"></a>五、请求返回的内容</h2><pre><code>{

  data:{},
  status:200,
  //从服务器返回的http状态文本
  statusText:&#39;OK&#39;,
  //响应头信息
  headers: {},
  //`config`是在请求的时候的一些配置信息
  config: {}
}
</code></pre><ul>
<li><p>你可以这样来获取响应信息</p>
<p>axios.get(‘/user/12345’)<br>  .then(function(res){</p>
<pre><code>console.log(res.data);
console.log(res.status);
console.log(res.statusText);
console.log(res.headers);
console.log(res.config);
</code></pre><p>  })</p>
</li>
</ul>
<h2 id="六、默认配置"><a href="#六、默认配置" class="headerlink" title="六、默认配置"></a>六、默认配置</h2><ul>
<li>你可以设置默认配置，对所有请求都有效</li>
</ul>
<p>1、 全局默认配置 </p>
<pre><code>axios.defaults.baseURL = &#39;http://api.exmple.com&#39;;
axios.defaults.headers.common[&#39;Authorization&#39;] = AUTH_TOKEN;
axios.defaults.headers.post[&#39;content-Type&#39;] = &#39;appliction/x-www-form-urlencoded&#39;;
</code></pre><p>2、 自定义的实例默认设置 </p>
<pre><code>//当创建实例的时候配置默认配置
var instance = axios.create({
    baseURL: &#39;https://api.example.com&#39;
});

//当实例创建时候修改配置
instance.defaults.headers.common[&quot;Authorization&quot;] = AUTH_TOKEN;
</code></pre><p>3、 配置中的有优先级 </p>
<ul>
<li><p>config配置将会以优先级别来合并，顺序是lib/defauts.js中的默认配置，然后是实例中的默认配置，最后是请求中的config参数的配置，越往后等级越高，后面的会覆盖前面的例子。</p>
<p>//创建一个实例的时候会使用libray目录中的默认配置<br>//在这里timeout配置的值为0，来自于libray的默认值<br>var instance = axios.create();<br>//回覆盖掉library的默认值<br>//现在所有的请求都要等2.5S之后才会发出<br>instance.defaults.timeout = 2500;<br>//这里的timeout回覆盖之前的2.5S变成5s<br>instance.get(‘/longRequest’,{<br>  timeout: 5000<br>});</p>
</li>
</ul>
<h2 id="七、拦截器"><a href="#七、拦截器" class="headerlink" title="七、拦截器"></a>七、拦截器</h2><ul>
<li><p>你可以在请求、响应在到达<code>then/catch</code>之前拦截他们</p>
<p>//添加一个请求拦截器<br>axios.interceptors.request.use(function(config){<br>  //在请求发出之前进行一些操作<br>  return config;<br>},function(err){<br>  //Do something with request error<br>  return Promise.reject(error);<br>});<br>//添加一个响应拦截器<br>axios.interceptors.response.use(function(res){<br>  //在这里对返回的数据进行处理<br>  return res;<br>},function(err){<br>  //Do something with response error<br>  return Promise.reject(error);<br>})</p>
</li>
</ul>
<p>2、取消拦截器 </p>
<pre><code>var myInterceptor = axios.interceptor.request.use(function(){/*....*/});
axios.interceptors.request.eject(myInterceptor);
</code></pre><p>3、 给自定义的axios实例添加拦截器 </p>
<pre><code>var instance = axios.create();
instance.interceptors.request.use(function(){})
</code></pre><h2 id="八、错误处理"><a href="#八、错误处理" class="headerlink" title="八、错误处理"></a>八、错误处理</h2><pre><code>axios.get(&#39;/user/12345&#39;)
  .catch(function(error){
    if(error.response){
      //请求已经发出，但是服务器响应返回的状态吗不在2xx的范围内
      console.log(error.response.data);
      console.log(error.response.status);
      console.log(error.response.header);
    }else {
      //一些错误是在设置请求的时候触发
      console.log(&#39;Error&#39;,error.message);
    }
    console.log(error.config);
  });
</code></pre><h2 id="九、取消"><a href="#九、取消" class="headerlink" title="九、取消"></a>九、取消</h2><ul>
<li>你可以通过一个<code>cancel token</code>来取消一个请求</li>
</ul>
<ol>
<li><p>你可以通过<code>CancelToken.source</code>工厂函数来创建一个<code>cancel token</code></p>
<p>var CancelToken = axios.CancelToken;<br>var source = CancelToken.source();</p>
<p>axios.get(‘/user/12345’,{<br> cancelToken: source.token<br>}).catch(function(thrown){<br> if(axios.isCancel(thrown)){<br>   console.log(‘Request canceled’,thrown.message);<br> }else {<br>   //handle error<br> }<br>});</p>
<p>//取消请求（信息的参数可以设置的）<br>source.cance(“操作被用户取消”);</p>
</li>
</ol>
<ol>
<li><p>你可以给cancelToken构造函数传递一个executor function来创建一个cancel token:</p>
<p>var cancelToken = axios.CancelToken;<br>var cance;<br>axios.get(‘/user/12345’,{<br> cancelToken: new CancelToken(function(c){<br>   //这个executor函数接受一个cancel function作为参数<br>   cancel = c;<br> })<br>})<br>//取消请求<br>cancel();</p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> VueJs </category>
            
        </categories>
        
        
        <tags>
            
            <tag> axios </tag>
            
            <tag> fronted </tag>
            
            <tag> vuejs </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hibernate annotation映射详解]]></title>
      <url>/2017/09/20/JavaWeb/Hibernate%20annotation%E6%98%A0%E5%B0%84%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a> 
<p>基于xml的配置： </p>
<p>实体+实体.hbm.xml+hibernate.cfg.xml </p>
<p>基于annotation的配置： </p>
<p>实体+hibernate.cfg.xml </p>
<p>如下：  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/2551166-e06b86942fd9ea74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">  </p>
<p>实体  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/2551166-19bd8dd7a07a959b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">  </p>
<p>hibernate.cfg.xml </p>
<hr>
<hr>
<hr>
<h2 id="OneToMany的双向配置："><a href="#OneToMany的双向配置：" class="headerlink" title="OneToMany的双向配置："></a>OneToMany的双向配置：</h2><p><img src="http://upload-images.jianshu.io/upload_images/2551166-36c774089c039f32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">  </p>
<p>one </p>
<p>其中的注解配置是： </p>
<p>@Entity </p>
<p>@Table(name=”t_classroom”) </p>
<p>@Id  </p>
<p>@GeneratedValue </p>
<p>@OneToMany(mappedBy =”classroom”)//指定由对端来维护关系  </p>
<p>@LazyCollection(LazyCollectionOption.EXTRA)//相当于lazy=exta让其智能化 </p>
<p><img src="http://upload-images.jianshu.io/upload_images/2551166-16b3d90ecfc605b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">  </p>
<p>Many  </p>
<p>其中的注解配置是：  </p>
<p>@Entity  </p>
<p>@Table(name=”t_student”) </p>
<p>@Id  </p>
<p>@GeneratedValue </p>
<p>@ManyToOne(fetch = FetchType.LAZY)//启用延迟加载策略  </p>
<p>@JoinColumn(name=”cid”)//指定由这一端来维护关系，不让它生成中间表 </p>
<hr>
<hr>
<hr>
<h2 id="OneToOne的双向配置："><a href="#OneToOne的双向配置：" class="headerlink" title="OneToOne的双向配置："></a>OneToOne的双向配置：</h2><p><img src="http://upload-images.jianshu.io/upload_images/2551166-ba07e93237457d99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">  </p>
<p>不维护关系的一方  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/2551166-e9c7b3c319a62c15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">  </p>
<p>维护关系的一方  </p>
<p>其中的注解配置为： </p>
<p>@Entity  </p>
<p>@Table(name=”t_idcard”) </p>
<p>@Id </p>
<p>@GeneratedValue </p>
<p>@OneToOne(mappedBy =”person”)//指定不由这端来维护关系，由对端来维护关系  </p>
<p>其中的注解配置为： </p>
<p>@Entity  </p>
<p>@Table(name=”t_idcard”)  </p>
<p>@Id  </p>
<p>@GeneratedValue </p>
<p>@OneToOne  </p>
<p>@JoinColumn(name =”pid”)//指定由这一端来维护关系 </p>
<hr>
<hr>
<hr>
<h2 id="ManyToMany双向配置："><a href="#ManyToMany双向配置：" class="headerlink" title="ManyToMany双向配置："></a>ManyToMany双向配置：</h2><p><img src="http://upload-images.jianshu.io/upload_images/2551166-50973cd6b727aa6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">  </p>
<p>不维护关系的一方  </p>
<p>其中的注解配置： </p>
<p>@Entity  </p>
<p>@Table(name=”t_admin”) </p>
<p>@Id  </p>
<p>@GeneratedValue </p>
<p>@ManyToMany(mappedBy =”admins”)//指明不维护关系  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/2551166-0f8eb127be92c852.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">  </p>
<p>维护关系的一方  </p>
<p>@Entity </p>
<p>@Table(name=”t_admin”) </p>
<p>@Id </p>
<p>@GeneratedValue </p>
<p>@ManyToMany  </p>
<p>@JoinTable(name=”t_role_admin”,joinColumns = {@JoinColumn(name=”rid”)}, </p>
<p>inverseJoinColumns = {@JoinColumn(name =”aid”)}) </p>
<p>//指定生成的中间表的属性 </p>
<hr>
<hr>
<hr>
<p>两个ManyToOne代替ManyToMany </p>
<p><img src="http://upload-images.jianshu.io/upload_images/2551166-08ea281104079442.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">  </p>
<p>teacher </p>
<p>配置文件是： </p>
<p>@Entity  </p>
<p>@Table(name=”t_teacher_course”) </p>
<p>@Id </p>
<p>@GeneratedValue </p>
<p>@OneToMany(mappedBy =”teacher”) </p>
<p>@LazyCollection(LazyCollectionOption.EXTRA) </p>
<p><img src="http://upload-images.jianshu.io/upload_images/2551166-cba89369b945f443.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">  </p>
<p>course </p>
<p>配置文件时：  </p>
<p>@Entity  </p>
<p>@Table(name=”t_teacher_course”) </p>
<p>@Id </p>
<p>@GeneratedValue </p>
<p>@OneToMany(mappedBy =”teacher”) </p>
<p>@LazyCollection(LazyCollectionOption.EXTRA) </p>
<p><img src="http://upload-images.jianshu.io/upload_images/2551166-10dc02cb2bc9577c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">  </p>
<p>teachercourse </p>
<p>配置文件时：  </p>
<p>@Entity  </p>
<p>@Table(name=”t_teacher_course”) </p>
<p>@Id </p>
<p>@GeneratedValue </p>
<p>@ManyToOne  </p>
<p>@JoinColumn(name=”tid”) </p>
<p>@ManyToOne  </p>
<p>@JoinColumn(name=”cid”) </p>
]]></content>
      
        <categories>
            
            <category> JavaWeb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javaweb </tag>
            
            <tag> hibernate </tag>
            
            <tag> annotation </tag>
            
            <tag> reflect </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hibernate annotation主键生成策略]]></title>
      <url>/2017/09/20/JavaWeb/Hibernate%E6%B3%A8%E8%A7%A3%E4%B8%BB%E9%94%AE%E7%AD%96%E7%95%A5/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a> 
<p>Hibernate 默认总共支持 13 种生成策略 :  </p>
<ol>
<li><p>increment        2.  identity        3. sequence </p>
</li>
<li><p>hilo                  5. seqhilo         6. uuid </p>
</li>
<li><p>uuid.hex          8. guid             9. native </p>
</li>
<li><p>assigned       11. select         12. foreign        13. sequence-identity </p>
</li>
</ol>
<p>下面介绍几个较为常用的策略 :  </p>
<p>① identity [ 自然递增 ] </p>
<p> 支持 DB2，MySQL，SQL Server，Sybase 和HypersonicSQL 数据库， 用于为 long 或 short 或 int 类型生成唯一标识。它依赖于底层不同的数据库，与 Hibernate 和 程序员无关。 </p>
<p>注解示例 :  </p>
<p>@Id </p>
<p>@GenericGenerator(name = “idGenerator”, strategy = “identity”) </p>
<p>@GeneratedValue(generator = “idGenerator”) </p>
<p>② sequence [ 序列 ] </p>
<p>支持 Oracle，DB2，PostgreSql，SAPDb 等数据库，用于为 long 或 short 或 int 类型生成唯一标识。它需要底层数据库的支持， 并由数据库来维护这个 sequence 序列。 </p>
<p>注解示例 :  </p>
<p>@Id </p>
<p>@GenericGenerator(name = “idGenerator”, strategy = “sequence”, parameters = {@Parameter(name = “sequence”,value=”seq_name”)}) </p>
<p>@GeneratedValue(generator = “idGenerator”) </p>
<p>注意 : 该策略要求设定序列名，否则 hibernate 将无法找到，这将引致抛出异常 : </p>
<p>org.hibernate.exception.SQLGrammarException: could not get next sequence value </p>
<p>③ native </p>
<p>需底层数据库的支持，对于 MySQL，SQL Server 采用 identity 的生成策略，对于 Oracle，则采用 sequence 策略。 </p>
<p>注解示例 : </p>
<p>@Id </p>
<p>@GenericGenerator(name = “idGenerator”, strategy = “native”) </p>
<p>@GeneratedValue(generator = “idGenerator”) </p>
<p>④ increment [ 自然递增 ] </p>
<p>与 identity 策略不同的是，该策略不依赖于底层数据库，而依赖于 hibernate 本身，用于为 long 或 short 或 int 类型生成唯一标识。 </p>
<p>主键计数器是由 hibernate 的一个实例来维护，每次自增量为 1，但在集群下不能使用该策略，否则将引起主键冲突的情况，该策略适用于所有关系型数据库使用。 </p>
<p>注解示例 : </p>
<p>@Id </p>
<p>@GenericGenerator(name = “idGenerator”, strategy = “increment”) </p>
<p>@GeneratedValue(generator = “idGenerator”) </p>
<p>⑤ uuid [ 32位16进制数的字符串 ] </p>
<p>采用128位UUID算法生成主键，能够保证网络环境下的主键唯一性，也就能够保证在不同数据库及不同服务器下主键的唯一性。 </p>
<p>uuid 最终被编码成一个32位16进制数的字符串，占用的存储空间较大。用于为 String 类型生成唯一标识，适用于所有关系型数据库。 </p>
<p>注解示例 : </p>
<p>@Id </p>
<p>@GenericGenerator(name = “idGenerator”, strategy = “uuid”) </p>
<p>@GeneratedValue(generator = “idGenerator”) </p>
<p>⑤ assigned [ 手工分配主键ID值 ] </p>
<p>该策略要求程序员必须自己维护和管理主键，当有数据需要存储时，程序员必须自己为该数据分配指定一个主键ID值，如果该数据没有被分配主键ID值或分配的值存在重复，则该数据都将无法被持久化且会引起异常的抛出。 </p>
<p>注解示例 : </p>
<p>@Id </p>
<p>@GenericGenerator(name = “idGenerator”, strategy = “assigned”) </p>
<p>@GeneratedValue(generator = “idGenerator”) </p>
]]></content>
      
        <categories>
            
            <category> JavaWeb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javaweb </tag>
            
            <tag> hibernate </tag>
            
            <tag> annotation </tag>
            
            <tag> primary key </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Ubuntu 14.04 配置iptables防火墙]]></title>
      <url>/2017/08/22/%E9%82%A3%E4%BA%9B%E5%B9%B4%E5%80%92%E8%85%BE%E8%BF%87%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8/Ubuntu%E9%85%8D%E7%BD%AE%E9%98%B2%E7%81%AB%E5%A2%99/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a> 
<blockquote>
<p>Ubuntu默认安装是没有开启任何防火墙的，为了服务器的安全，建议大家安装启用防火墙设置，这里推荐使用iptables防火墙.如果mysql启本地使用,可以不用打开3306端口. </p>
</blockquote>
<p><code># whereis iptables</code> #查看系统是否安装防火墙可以看到: </p>
<pre><code>iptables: /sbin/iptables /usr/share/iptables /usr/share/man/man8/iptables.8.gz #表示已经安装iptables
apt-get install iptables #如果默认没有安装，请运行此命令安装防火墙
</code></pre><p><code># iptables -L</code> #查看防火墙配置信息，显示如下: </p>
<pre><code>Chain INPUT (policy ACCEPT)
target prot opt source destination
Chain FORWARD (policy ACCEPT)
target prot opt source destination
Chain OUTPUT (policy ACCEPT)
target prot opt source destination
</code></pre><p><code># vi /etc/iptables.rules</code></p>
<p>添加以下内容(备注:80是指web服务器端口,3306是指MySQL数据库链接端口,22是指SSH远程管理端口.) </p>
<pre><code>*filter
:INPUT DROP [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
:syn-flood - [0:0]
-A INPUT -i lo -j ACCEPT
-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT
-A INPUT -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT
-A INPUT -p tcp -m state --state NEW -m tcp --dport 80 -j ACCEPT
-A INPUT -p tcp -m state --state NEW -m tcp --dport 443 -j ACCEPT
-A INPUT -p icmp -m limit --limit 100/sec --limit-burst 100 -j ACCEPT
-A INPUT -p icmp -m limit --limit 1/s --limit-burst 10 -j ACCEPT
-A INPUT -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -j syn-flood
-A INPUT -j REJECT --reject-with icmp-host-prohibited
-A syn-flood -p tcp -m limit --limit 3/sec --limit-burst 6 -j RETURN
-A syn-flood -j REJECT --reject-with icmp-port-unreachable
COMMIT
</code></pre><p><code># iptables-restore &lt; /etc/iptables.rules</code> #使防火墙规则生效 </p>
<p><code># vi /etc/network/if-pre-up.d/iptables</code> #创建文件，添加以下内容，使防火墙开机启动 </p>
<pre><code>#!/bin/bash
iptables-restore &lt; /etc/iptables.rules
</code></pre><p><code># chmod +x /etc/network/if-pre-up.d/iptables</code> #添加执行权限 </p>
<p><code># iptables -L -n</code>查看规则是否生效. </p>
]]></content>
      
        <categories>
            
            <category> 那些年倒腾过的服务器 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> iptables </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift中你应该知道的一些有用的tips]]></title>
      <url>/2017/08/03/iOS/Swift%E4%B8%AD%E6%9C%89%E7%94%A8%E7%9A%84tips/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a>                           
<p>本文主要的知识点有： </p>
<ul>
<li>@noescape和@autoclosure</li>
<li>内联lazy属性</li>
<li>函数柯里化</li>
<li>可变参数</li>
<li>dynamic关键字</li>
<li>一些特殊的字面量</li>
<li>循环标签</li>
</ul>
<h2 id="noescape和-autoclosure"><a href="#noescape和-autoclosure" class="headerlink" title="@noescape和@autoclosure"></a>@noescape和@autoclosure</h2><p>关于这两个关键字的含义，在我此前的文章——<a href="http://www.jianshu.com/p/f9ba4c41d9c7" target="_blank" rel="external">第六章——函数(自动闭包和内存)</a>中已经有详细的解释，这里就简单总结概括一下： </p>
<ul>
<li>@noescape：这个关键字告诉编译器，参数闭包只能在函数内部使用。它不能被赋值给临时变量，不能异步调用，也不能作为未标记为@noescape的参数传递给其他函数。总之您可以放心，它无法在这个函数作用域之外使用。 </li>
</ul>
<p>除了安全性上的保证，swift还会为标记为@noescape的参数做一些优化，闭包内访问类的成员时您还可以省去<code>self.</code>的语法。 </p>
<ul>
<li>@autoclosure：这个关键字将表达式封装成闭包，优点在于延迟了表达式的执行，缺点是如果滥用会导致代码可读性降低。 </li>
</ul>
<h2 id="内联lazy属性"><a href="#内联lazy属性" class="headerlink" title="内联lazy属性"></a>内联lazy属性</h2><p>标记为lazy的属性在对象初始化时不会被创建，它直到第一次被访问时才会创建，通常情况下它是这样实现的： </p>
<pre><code>class PersonOld {
    lazy var expensiveObject: ExpensiveObject = {
        return self.createExpensiveObject()    // 传统实现方式
    }()

    private func createExpensiveObject() -&gt; ExpensiveObject {
        return ExpensiveObject()
    }
}
</code></pre><p>lazy属性本质上是一个闭包，闭包中的表达式只会调用一次。需要强调的是，虽然这个闭包中捕获了<code>self</code>，但是这样做并不会导致循环引用，猜测是Swift自动把<code>self</code>标记为unowned了。 </p>
<p>这样的写法其实可以进行简化，简化后的实现如下： </p>
<pre><code>class Person {
    lazy var expensiveObject: ExpensiveObject = self.createExpensiveObject()

    private func createExpensiveObject() -&gt; ExpensiveObject {
        return ExpensiveObject()
    }
}
</code></pre><h2 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h2><p>函数柯里化也是一个老生常谈的问题了，我的这篇文章——<a href="http://www.jianshu.com/p/b2d21b85a387" target="_blank" rel="external">第六章——函数（函数的便捷性）</a>对其有比较详细的解释。 </p>
<p>简单来说，柯里化函数处理一个参数，然后返回一个函数处理剩下来的所有参数。直观上来看，它避免了很多括号的嵌套，提高了代码的简洁性和可读性，比如这个函数： </p>
<pre><code>func fourChainedFunctions(a: Int) -&gt; (Int -&gt; (Int -&gt; (Int -&gt; Int))) {
    return { b in
        return { c in
            return { d in
                return a + b + c + d
            }
        }
    }
}
fourChainedFunctions(1)(2)(3)(4)
</code></pre><p>对比一下它的柯里化版本： </p>
<pre><code>func fourChainedFunctions(a: Int)(b: Int)(c: Int)(d: Int) -&gt; Int {
    return a + b + c + d
}
</code></pre><p>不过在 Swift 3.0 中，这种柯里化语法会被移除，你需要使用之前完整的函数声明。感谢 <a href="http://www.jianshu.com/users/88a056103c02/latest_articles" target="_blank" rel="external">@没故事的卓同学</a> 指出。 </p>
<p>您可以在<a href="https://github.com/apple/swift-evolution" target="_blank" rel="external">Swift Programming Language Evolution</a>中查看更多细节： </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1171077-9bca1d7f34b2916d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">  </p>
<p>或者您也可以点击这篇文章查看更多细节——<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0002-remove-currying.md" target="_blank" rel="external">Removing currying func declaration syntax</a></p>
<h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>如果在参数类型后面加上三个”.”，表示参数的数量是可变的，如果您有过Java编程的经验，对此应该会比较熟悉： </p>
<pre><code>func printEverythingWithAKrakenEmojiInBetween(objectsToPrint: Any...) {
    for object in objectsToPrint {
        print(&quot;\(object)🐙&quot;)
    }
}
printEverythingWithAKrakenEmojiInBetween(&quot;Hey&quot;, &quot;Look&quot;, &quot;At&quot;, &quot;Me&quot;, &quot;!&quot;)
</code></pre><p>此时，参数可以当做<code>SequenceType</code>类型来使用，也就是说可以使用<code>for in</code>语法遍历其中的每一个参数。 </p>
<p>可变参数并不是什么罕见的语法，比如<code>print</code>函数就是用了可变参数，更多详细的分析请移步：<a href="http://www.jianshu.com/p/abb55919c453" target="_blank" rel="external">你其实真的不懂print(“Hello,world”)</a></p>
<h2 id="dynamic关键字"><a href="#dynamic关键字" class="headerlink" title="dynamic关键字"></a>dynamic关键字</h2><p>如果您有过OC的开发经验，那一定会对OC中@dynamic关键字比较熟悉，它告诉编译器不要为属性合成getter和setter方法。 </p>
<p>Swift中也有dynamic关键字，它可以用于修饰变量或函数，它的意思也与OC完全不同。它告诉编译器使用动态分发而不是静态分发。OC区别于其他语言的一个特点在于它的动态性，任何方法调用实际上都是消息分发，而Swift则尽可能做到静态分发。 </p>
<p>因此，标记为dynamic的变量/函数会隐式的加上@objc关键字，它会使用OC的runtime机制。 </p>
<p>虽然静态分发在效率上可能更好，不过一些app分析统计的库需要依赖动态分发的特性，动态的添加一些统计代码，这一点在Swift的静态分发机制下很难完成。这种情况下，虽然使用dynamic关键字会牺牲因为使用静态分发而获得的一些性能优化，但也依然是值得的。 </p>
<pre><code>class Kraken {
    dynamic var imADynamicallyDispatchedString: String

    dynamic func imADynamicallyDispatchedFunction() {
        //Hooray for dynamic dispatch!
    }
}
</code></pre><p>使用动态分发，您可以更好的与OC中runtime的一些特性（如CoreData，KVC/KVO）进行交互，不过如果您不能确定变量或函数会被动态的修改、添加或使用了Method-Swizzle，那么就不应该使用dynamic关键字，否则有可能程序崩溃。 </p>
<h2 id="特殊的字面量"><a href="#特殊的字面量" class="headerlink" title="特殊的字面量"></a>特殊的字面量</h2><p>在开发或调试过程中如果能用好下面这四个字面量，将会起到事半功倍的效果： </p>
<ul>
<li><strong>FILE</strong>：当前代码在那个文件中</li>
<li><strong>FUNCTION</strong>：当前代码在该文件的那个函数中</li>
<li><strong>LINE</strong>：当前代码在该文件的第多少行</li>
<li><strong>COLUMN</strong>：当前代码在改行的多少列</li>
</ul>
<p>举个实际例子，您可以在demo中运行体验一番： </p>
<pre><code>func specialLitertalExpression() {
    print(__FILE__)
    print(__FUNCTION__)
    print(__LINE__)
    print(__COLUMN__)   // 输出结果为11，因为有4个空格，print是五个字符，还有一个左括号。
}
</code></pre><p>一般情况下最常用的字面量是<code>__FUNCTION__</code>，它可以很容易让程序员明白自己调用的方法的方法名。 </p>
<h2 id="循环标签"><a href="#循环标签" class="headerlink" title="循环标签"></a>循环标签</h2><p>通常意义上的循环标签主要是<code>continue</code>和<code>break</code>，不过swift在此基础上做了一些拓展，比如下面这段代码： </p>
<pre><code>let firstNames = [&quot;Neil&quot;,&quot;Kt&quot;,&quot;Bob&quot;]
let lastNames = [&quot;Zhou&quot;,&quot;Zhang&quot;,&quot;Wang&quot;,&quot;Li&quot;]
for firstName in firstNames {
    var isFound = false
    for lastName in lastNames {
        if firstName == &quot;Kt&quot; &amp;&amp; lastName == &quot;Zhang&quot; {
            isFound = true
            break
        }
        print(firstName + &quot; &quot; + lastName)
    }

    if isFound {
        break
    }
}
</code></pre><p>目的是希望找到分别在两个数组中找到字符串”Kt”和”Zhang”，在此之前会打印所有遍历到的字符。 </p>
<p>在结束内层循环后，我希望外层循环也随之立刻停止，为了实现这个功能，我不得不引入了<code>isFound</code>参数。然而实际上我需要的只是可以指定停止哪个循环而已： </p>
<pre><code>outsideloop: for firstName in firstNames {
    innerloop: for lastName in lastNames {
        if firstName == &quot;Kt&quot; &amp;&amp; lastName == &quot;Zhang&quot; {
            break outsideloop    //人为指定break外层循环
        }
        print(firstName + &quot; &quot; + lastName)
    }
}
</code></pre><p>以上两段代码等价，可以看到使用了循环标签后，代码明显简洁了很多。 </p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> tips </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[利用 Django REST framework 编写 RESTful API]]></title>
      <url>/2017/07/26/Python/%20Django%20REST%20framework/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a>                           
<p>最近在玩 Django，不得不说 rest_framework 真乃一大神器，可以轻易的甚至自动化的搞定很多事情，比如：</p>
<ul>
<li>自动生成符合 RESTful 规范的 API<ul>
<li>支持 OPTION、HEAD、POST、GET、PATCH、PUT、DELETE</li>
<li>根据 <code>Content-Type</code> 来动态的返回数据类型（如 text、json）</li>
</ul>
</li>
<li>生成 browserable 的交互页面（自动为 API 生成非常友好的浏览器页面）</li>
<li>非常细粒度的权限管理（可以细粒度到 field 级别）</li>
</ul>
<p>_示意图_</p>
<p><img src="http://7s1ruy.com1.z0.glb.clouddn.com/srceen_shot%202015-07-20%20%E4%B8%8B%E5%8D%889.36.48.png" alt="技术分享"></p>
<hr>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code>$ pip install djangorestframework
$ pip install markdown
</code></pre><hr>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Django Rest framework 的流程大概是这样的 </p>
<p><img src="http://7s1ruy.com1.z0.glb.clouddn.com/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%9A%84%E8%A1%A8%E5%8D%95.jpg" alt="技术分享"></p>
<ol>
<li>建立 Models</li>
<li>依靠 Serialiers 将数据库取出的数据 Parse 为 API 的数据（可用于返回给客户端，也可用于浏览器显示）</li>
<li>ViewSet 是一个 views 的集合，根据客户端的请求（GET、POST等），返回 Serialiers 处理的数据<ul>
<li>权限 Premissions 也在这一步做处理</li>
</ul>
</li>
<li>ViewSet 可在 Routers 进行注册，注册后会显示在 Api Root 页上</li>
<li>在 urls 里注册 ViewSet 生成的 view，指定监听的 url</li>
</ol>
<p>希望全面细致了解的人请移步去看官方文档，我这里就不一步步的细说了，而是分块来进行介绍 </p>
<hr>
<h2 id="准备工作-amp-Models"><a href="#准备工作-amp-Models" class="headerlink" title="准备工作 &amp; Models"></a>准备工作 &amp; Models</h2><p>让我们来写个小项目练练手 </p>
<ol>
<li>先用 <code>manage.py startproject rest</code> 来生成一个项目</li>
<li>再用 <code>manage.py createsuperuser</code> 创建用户（后面权限管理会用到）</li>
<li>初始化数据库 <code>manage.py migrate</code></li>
</ol>
<p>然后当然是编写 models，为了展示 rest_framework 的强大之处，我给 models 定义了一个自定义的 field </p>
<pre><code># myproject/myapp/models.py


#! /usr/bin/env python
# -*- coding: utf-8
from __future__ import unicode_literals, absolute_import
import cPickle as pickle

from django.db import models
from django.contrib.auth.models import User


class SerializedField(models.TextField):

    &quot;&quot;&quot;序列化域
    用 pickle 来实现存储 Python 对象
    &quot;&quot;&quot;
    __metaclass__ = models.SubfieldBase  # 必须指定该 metaclass 才能使用 to_python

    def validate(self, val):
        raise isinstance(val, basestring)

    def to_python(self, val):
        &quot;&quot;&quot;从数据库中取出字符串，解析为 python 对象&quot;&quot;&quot;
        if val and isinstance(val, unicode):
            return pickle.loads(val.encode(‘utf-8‘))

        return val

    def get_prep_value(self, val):
        &quot;&quot;&quot;将 python object 存入数据库&quot;&quot;&quot;
        return pickle.dumps(val)


class MyModel(models.Model):

    created_at = models.DateTimeField(auto_now_add=True)
    # 注意这里建立了一个外键
    owner = models.ForeignKey(User, related_name=‘mymodels‘)
    field = models.CharField(max_length=100)
    options = SerializedField(max_length=1000, default={})
</code></pre><hr>
<h2 id="Serializers"><a href="#Serializers" class="headerlink" title="Serializers"></a>Serializers</h2><p>定义好了 Models，我们可以开始写 Serializers，这个相当于 Django 的 Form </p>
<pre><code># myproject/myapp/serializers.py

#! /usr/bin/env python
# -*- coding: utf-8
from __future__ import unicode_literals, absolute_import
import json

from django.contrib.auth.models import User
from rest_framework import serializers

from ..models import MyModel
from .fields import MyCustField


class MyCustField(serializers.CharField):
    &quot;&quot;&quot;为 Model 中的自定义域额外写的自定义 Serializer Field&quot;&quot;&quot;

    def to_representation(self, obj):
        &quot;&quot;&quot;将从 Model 取出的数据 parse 给 Api&quot;&quot;&quot;
        return obj

    def to_internal_value(self, data):
        &quot;&quot;&quot;将客户端传来的 json 数据 parse 给 Model&quot;&quot;&quot;
        return json.loads(data.encode(‘utf-8‘))


class UserSerializer(serializers.ModelSerializer):

    class Meta:
        model = User  # 定义关联的 Model
        fields = (‘id‘, ‘username‘, ‘mymodels‘)  # 指定返回的 fields

    # 这句话的作用是为 MyModel 中的外键建立超链接，依赖于 urls 中的 name 参数
    # 不想要这个功能的话完全可以注释掉
    mymodels = serializers.HyperlinkedRelatedField(
        many=True, queryset=MyModel.objects.all(),
        view_name=‘model-detail‘
    )


class MySerializer(serializers.ModelSerializer):

    options = MyCustField(
        max_length=1000, style={‘base_template‘: ‘textarea.html‘},
    )

    class Meta:
        model = MyModel
        fields = (‘id‘, ‘owner‘, ‘field‘, ‘options‘)
        read_only_fields = (‘owner‘,)  # 指定只读的 field

    def create(self, validated_data):
        &quot;&quot;&quot;响应 POST 请求&quot;&quot;&quot;
        # 自动为用户提交的 model 添加 owner
        validated_data[‘owner‘] = self.context[‘request‘].user
        return MyModel.objects.create(**validated_data)

    def update(self, instance, validated_data):
        &quot;&quot;&quot;响应 PUT 请求&quot;&quot;&quot;
        instance.field = validated_data.get(‘field‘, instance.field)
        instance.save()
        return instance
</code></pre><hr>
<h2 id="ViewSet"><a href="#ViewSet" class="headerlink" title="ViewSet"></a>ViewSet</h2><p>定义好了 Serializers，就可以开始写 viewset 了 </p>
<p>其实 viewset 反而是最简单的部分，rest_framework 原生提供了四种 ViewSet </p>
<ul>
<li><code>ViewSet</code></li>
<li><code>GenericViewSet</code><ul>
<li>继承于 <code>GenericAPIView</code></li>
</ul>
</li>
<li><code>ModelViewSet</code><ul>
<li>自身提供了六种方法</li>
<li><code>list</code></li>
<li><code>create</code></li>
<li><code>retrieve</code></li>
<li><code>update</code></li>
<li><code>partial_update</code></li>
<li><code>destroy</code></li>
</ul>
</li>
<li><code>ReadOnlyModelViewSet</code></li>
</ul>
<p>我比较喜欢用 <code>ModelViewSet</code>，然后再用 Premissions 来管理权限 </p>
<pre><code># myproject/myapp/views.py

#! /usr/bin/env python
# -*- coding: utf-8
from __future__ import unicode_literals, absolute_import

from django.contrib.auth.models import User
from rest_framework import permissions, viewsets, renderers
from rest_framework.decorators import (
    permission_classes, detail_route
)
from rest_framework.response import Response

from .serializers import MySerializer, UserSerializer
from .models import MyModel


class UserViewSet(viewsets.ModelViewSet):
    queryset = User.objects.all()
    serializer_class = UserSerializer
    # 指定权限，下面马上讲到
    permission_classes = (permissions.IsAuthenticated,)


class ModelViewSet(viewsets.ModelViewSet):
    queryset = MyModel.objects.all()
    serializer_class = MySerializer
    permission_classes = (permissions.IsAuthenticatedOrReadOnly,)

    @detail_route(renderer_classes=[renderers.StaticHTMLRenderer])
    def plaintext(self, request, *args, **kwargs):
        &quot;&quot;&quot;自定义 Api 方法&quot;&quot;&quot;
        model = self.get_object()
        return Response(repr(model))
</code></pre><p>我在 ModelViewSet 中自定义了方法 plaintext，rest_framework 中对于自定义的 viewset 方法提供了两种装饰器 </p>
<ul>
<li><code>list_route</code></li>
<li><code>detail_route</code></li>
</ul>
<p>区别就是 <code>list_route</code> 的参数不包含 <code>pk</code>（对应 list），而 <code>detail_route</code> 包含<code>pk</code>（对应 retrieve） </p>
<p>看一段代码就懂了 </p>
<pre><code>@list_route(methods=[‘post‘, ‘delete‘])
def custom_handler(self, request):
    pass


@detail_route(methods=[‘get‘])
def custom_handler(self, request, pk=None):
    pass
</code></pre><hr>
<h2 id="Filters"><a href="#Filters" class="headerlink" title="Filters"></a>Filters</h2><p>前面根据 serializers 和 viewset 我们已经可以很好的提供数据接口和展示了。但是有时候我们需要通过 url参数 来对数据进行一些排序或过滤的操作，为此，rest-framwork 提供了 filters 来满足这一需求。 </p>
<h3 id="全局filter"><a href="#全局filter" class="headerlink" title="全局filter"></a>全局filter</h3><p>可以在 settings 里指定应用到全局的 filter： </p>
<pre><code>REST_FRAMEWORK = {
    ‘DEFAULT_FILTER_BACKENDS‘: (‘rest_framework.filters.DjangoFilterBackend‘,)
}
</code></pre><h3 id="viewset-的-filter"><a href="#viewset-的-filter" class="headerlink" title="viewset 的 filter"></a>viewset 的 filter</h3><p>也可以为 viewset 分别指定 filter，方法就是在定义 viewset 的时候定义一个名为<code>filter_backend</code> 的类变量： </p>
<pre><code>class UserListView(generics.ListAPIView):
    queryset = User.objects.all()
    serializer = UserSerializer
    filter_backends = (filters.DjangoFilterBackend,)
</code></pre><h3 id="默认的-filter"><a href="#默认的-filter" class="headerlink" title="默认的 filter"></a>默认的 filter</h3><p>rest-framework 提供了几个原生的 filter： </p>
<ul>
<li><p>SearchFilter</p>
<p>filter_backends = (filters.SearchFilter,)<br>search_fields = (‘username‘, ‘email‘)  # 指定搜索的域</p>
</li>
</ul>
<p>请求 <code>http://example.com/api/users?search=russell</code>。 </p>
<ul>
<li><p>OrderingFilter</p>
<p>filter_backends = (filters.OrderingFilter,)<br>ordering_fields = (‘username‘, ‘email‘)</p>
</li>
</ul>
<p>请求 <code>http://example.com/api/users?ordering=account,-username</code>。 </p>
<h3 id="自定义-filter"><a href="#自定义-filter" class="headerlink" title="自定义 filter"></a>自定义 filter</h3><p>自定义 filter 非常简单，只需要定义 <code>filter_queryset(self, request, queryset, view)</code> 方法，并返回一个 queryset 即可。 </p>
<p>直接贴一个我写的例子： </p>
<pre><code>class NodenameFilter(filters.BaseFilterBackend):

    &quot;&quot;&quot;根据 nodename 来删选
      [nodename]: NeiWang
    &quot;&quot;&quot;

    def filter_queryset(self, request, queryset, view):
        nodename = request.QUERY_PARAMS.get(‘nodename‘)
        if nodename:
            return queryset.filter(nodename=nodename)
        else:
            return queryset
</code></pre><p>如果参数匹配有误，想要抛出异常的话，也可以自定义 APIError，举个例子： </p>
<pre><code>from rest_framework.exceptions import APIException


class FilterError(APIException):
    status_code = 406
    default_detail = ‘Query arguments error!‘
</code></pre><p>然后在 viewset 里直接抛出 <code>raise FilterError</code> 即可。 </p>
<hr>
<h2 id="Premissions"><a href="#Premissions" class="headerlink" title="Premissions"></a>Premissions</h2><p>顾名思义就是权限管理，用来给 ViewSet 设置权限，使用 premissions 可以方便的设置不同级别的权限： </p>
<ul>
<li>全局权限控制</li>
<li>ViewSet 的权限控制</li>
<li>Method 的权限</li>
<li>Object 的权限</li>
</ul>
<p>被 premission 拦截的请求会有如下的返回结果： </p>
<ul>
<li>当用户已登录，但是被 premissions 限制，会返回 <code>HTTP 403 Forbidden</code></li>
<li>当用户未登录，被 premissions 限制会返回 <code>HTTP 401 Unauthorized</code></li>
</ul>
<h3 id="默认的权限"><a href="#默认的权限" class="headerlink" title="默认的权限"></a>默认的权限</h3><p>rest_framework 中提供了七种权限 </p>
<ul>
<li><code>AllowAny</code> # 无限制</li>
<li><code>IsAuthenticated</code> # 登陆用户</li>
<li><code>IsAdminUser</code> # Admin 用户</li>
<li><code>IsAuthenticatedOrReadOnly</code> # 非登录用户只读</li>
<li><code>DjangoModelPermissions</code> # 以下都是根据 Django 的 ModelPremissions</li>
<li><code>DjangoModelPermissionsOrAnonReadOnly</code></li>
<li><code>DjangoObjectPermissions</code></li>
</ul>
<h3 id="全局权限控制"><a href="#全局权限控制" class="headerlink" title="全局权限控制"></a>全局权限控制</h3><p>在 settings.py 中可以设置全局默认权限 </p>
<pre><code># settings.py

REST_FRAMEWORK = {
    ‘DEFAULT_PERMISSION_CLASSES‘: (
        ‘rest_framework.permissions.AllowAny‘,
    ),
}
</code></pre><h3 id="ViewSet-的权限"><a href="#ViewSet-的权限" class="headerlink" title="ViewSet 的权限"></a>ViewSet 的权限</h3><p>可以设置 <code>permission_classes</code> 的类属性来给 viewset 设定权限，restframework 会检查元组内的每一个 premission，必须要全部通过才行。 </p>
<pre><code>class UserViewSet(viewsets.ReadOnlyModelViewSet):
    queryset = User.objects.all()
    serializer_class = UserSerializer
    # 设置权限，是一个元组
    permission_classes = (permissions.IsAuthenticated,)
</code></pre><h3 id="自定义权限"><a href="#自定义权限" class="headerlink" title="自定义权限"></a>自定义权限</h3><p>Premissions 可以非常方便的定制，比如我就自己写了一个只允许 owner 编辑的权限 </p>
<pre><code># myproject/myapp/premissions.py

#! /usr/bin/env python
# -*- coding: utf-8
from __future__ import unicode_literals, absolute_import

from rest_framework import permissions


class IsOwnerOrReadOnly(permissions.BasePermission):

    def has_permission(self, request, view):
        &quot;&quot;&quot;针对每一次请求的权限检查&quot;&quot;&quot;
        if request.method in permissions.SAFE_METHODS:
            return True

    def has_object_permission(self, request, view, obj):
        &quot;&quot;&quot;针对数据库条目的权限检查，返回 True 表示允许&quot;&quot;&quot;
        # 允许访问只读方法
        if request.method in permissions.SAFE_METHODS:
            return True

        # 非安全方法需要检查用户是否是 owner
        return obj.owner == request.user
</code></pre><hr>
<h2 id="urls-amp-routers"><a href="#urls-amp-routers" class="headerlink" title="urls &amp; routers"></a>urls &amp; routers</h2><pre><code># myproject/myapp/urls.py

#! /usr/bin/env python
# -*- coding: utf-8
from __future__ import unicode_literals, absolute_import

from django.conf.urls import url, patterns, include
from rest_framework.routers import DefaultRouter

from . import views


# as_view 方法生成 view
# 可以非常方便的指定 `{Http Method: View Method}`
user_detail = views.UserViewSet.as_view({‘get‘: ‘retrieve‘})
user_list = views.UserViewSet.as_view({‘get‘: ‘list‘, ‘post‘: ‘create‘})

# plaintext 是我的自定义方法，也可以非常方便的指定
modal_plain = views.ModelViewSet.as_view({‘get‘: ‘plaintext‘})
model_detail = views.ModelViewSet.as_view({‘get‘: ‘retrieve‘, ‘post‘: ‘create‘})
model_list = views.ModelViewSet.as_view({‘get‘: ‘list‘, ‘post‘: ‘create‘})

# router 的作用就是自动生成 Api Root 页面
router = DefaultRouter()
router.register(r‘models‘, views.ModelViewSet)
router.register(r‘users‘, views.UserViewSet)


# 不要忘了把 views 注册到 urls 中
urlpatterns = patterns(
    ‘‘,
    url(r‘^‘, include(router.urls)),  # Api Root
    url(r‘^api-auth/‘, include(‘rest_framework.urls‘, namespace=‘rest_framework‘)),
    url(r‘^models/(?P&lt;pk&gt;[0-9]+)/$‘, model_detail, name=‘model-detail‘),
    url(r‘^models/(?P&lt;pk&gt;[0-9]+)/plain/$‘, modal_plain, name=‘model-plain‘),
    url(r‘^models/$‘, model_list, name=‘model-list‘),
    url(r‘^users/$‘, user_list, name=‘user-list‘),
    url(r‘^users/(?P&lt;pk&gt;[0-9]+)/$‘, user_detail, name=‘user-detail‘),
)
</code></pre><hr>
<p>时间仓促，就介绍这些，以后有空再介绍一下在 Django 用 JWT 作为身份凭证。下面是一些效果图 </p>
<ul>
<li>Api Root</li>
</ul>
<p><img src="http://7s1ruy.com1.z0.glb.clouddn.com/srceen_shot%202015-07-20%20%E4%B8%8B%E5%8D%8810.47.10.png" alt="技术分享"></p>
<ul>
<li>Users</li>
</ul>
<p><img src="http://7s1ruy.com1.z0.glb.clouddn.com/srceen_shot%202015-07-20%20%E4%B8%8B%E5%8D%8810.48.50.png" alt="技术分享"></p>
<hr>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2>]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Django REST framework </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[跟着 Github 学习 Restful HTTP API 设计]]></title>
      <url>/2017/07/26/Python/Restful%20HTTP%20API%20/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a> 
<p>近几年提供 <code>HTTP API</code> 服务的公司越来越多，许多公司都把 API 作为产品重要的一部分，作为服务提供出去。而微服务的兴起，也让企业内部开始重视和频繁使用 HTTP API 。好的 <code>HTTP API</code> 设计容易理解、符合 RFC 标准、提供使用者便利的功能，其中经常被拿来作为教科书典范的当属 <a href="https://developer.github.com/v3/" target="_blank" rel="external">Github API</a>。这篇文章就通过 <code>Github API</code> 总结了一些非常好的设计原则，可以作为以后要编写 HTTP API 的参考。 </p>
<p>注意：这篇文章只讨论设计原则，不是强制要求（API 设计者可以根据实际情况实现部分内容，甚至实现出和某些原则相反的内容），也不会给出实现的思路和细节。 </p>
<h2 id="1-使用-HTTPS"><a href="#1-使用-HTTPS" class="headerlink" title="1. 使用 HTTPS"></a>1. 使用 HTTPS</h2><p>这个和 Restful API 本身没有很大的关系，但是对于增加网站的安全是非常重要的。特别如果你提供的是公开 API，用户的信息泄露或者被攻击会严重影响网站的信誉。 </p>
<p>NOTE：不要让非SSL的url访问重定向到SSL的url。 </p>
<h2 id="2-API-地址和版本"><a href="#2-API-地址和版本" class="headerlink" title="2. API 地址和版本"></a>2. API 地址和版本</h2><p>在 <code>url</code> 中指定 API 的版本是个很好地做法。如果 API 变化比较大，可以把 API 设计为子域名，比如 <code>https://api.github.com/v3</code>；也可以简单地把版本放在路径中，比如 <code>https://example.com/api/v1</code>。 </p>
<h2 id="3-schema"><a href="#3-schema" class="headerlink" title="3. schema"></a>3. schema</h2><p>对于响应返回的格式，JSON 因为它的可读性、紧凑性以及多种语言支持等优点，成为了 HTTP API 最常用的返回格式。因此，最好采用 JSON 作为返回内容的格式。如果用户需要其他格式，比如 <code>xml</code>，应该在请求头部 <code>Accept</code> 中指定。对于不支持的格式，服务端需要返回正确的 status code，并给出详细的说明。 </p>
<h2 id="4-以资源为中心的-URL-设计"><a href="#4-以资源为中心的-URL-设计" class="headerlink" title="4. 以资源为中心的 URL 设计"></a>4. 以资源为中心的 URL 设计</h2><p>资源是 <code>Restful API</code> 的核心元素，所有的操作都是针对特定资源进行的。而资源就是 <code>URL</code>（Uniform Resoure Locator）表示的，所以简洁、清晰、结构化的 URL 设计是至关重要的。Github 可以说是这方面的典范，下面我们就拿 <code>repository</code> 来说明。 </p>
<pre><code>/users/:username/repos
/users/:org/repos
/repos/:owner/:repo
/repos/:owner/:repo/tags
/repos/:owner/:repo/branches/:branch
</code></pre><p>我们可以看到几个特性： </p>
<ul>
<li>资源分为单个文档和集合，尽量使用复数来表示资源，单个资源通过添加 id 或者 name 等来表示</li>
<li>一个资源可以有多个不同的 URL</li>
<li>资源可以嵌套，通过类似目录路径的方式来表示，以体现它们之间的关系</li>
</ul>
<p><strong>NOTE</strong>: 根据RFC3986定义，URL是大小写敏感的。所以为了避免歧义，尽量使用小写字母。 </p>
<h2 id="5-使用正确的-Method"><a href="#5-使用正确的-Method" class="headerlink" title="5. 使用正确的 Method"></a>5. 使用正确的 Method</h2><p>有了资源的 URL 设计，所有针对资源的操作都是使用 HTTP 方法指定的。比较常用的方法有： </p>
<p>Verb描述</p>
<p>HEAD<br>只获取某个资源的头部信息。比如只想了解某个文件的大小，某个资源的修改日期等 </p>
<p>GET<br>获取资源 </p>
<p>POST<br>创建资源 </p>
<p>PATCH<br>更新资源的部分属性。因为 PATCH 比较新，而且规范比较复杂，所以真正实现的比较少，一般都是用 POST 替代 </p>
<p>PUT<br>替换资源，客户端需要提供新建资源的所有属性。如果新内容为空，要设置 <code>Content-Length</code> 为 0，以区别错误信息 </p>
<p>DELETE<br>删除资源 </p>
<p>比如： </p>
<pre><code>GET /repos/:owner/:repo/issues
GET /repos/:owner/:repo/issues/:number
POST /repos/:owner/:repo/issues
PATCH /repos/:owner/:repo/issues/:number
DELETE /repos/:owner/:repo
</code></pre><p>NOTE：更新和创建操作应该返回最新的资源，来通知用户资源的情况；删除资源一般不会返回内容。 </p>
<h3 id="不符合-CRUD-的情况"><a href="#不符合-CRUD-的情况" class="headerlink" title="不符合 CRUD 的情况"></a>不符合 CRUD 的情况</h3><p>在实际资源操作中，总会有一些不符合 <code>CRUD</code>（Create-Read-Update-Delete） 的情况，一般有几种处理方法。 </p>
<h4 id="使用-POST"><a href="#使用-POST" class="headerlink" title="使用 POST"></a>使用 POST</h4><p>为需要的动作增加一个 endpoint，使用 POST 来执行动作，比如 <code>POST /resend</code> 重新发送邮件。 </p>
<h4 id="增加控制参数"><a href="#增加控制参数" class="headerlink" title="增加控制参数"></a>增加控制参数</h4><p>添加动作相关的参数，通过修改参数来控制动作。比如一个博客网站，会有把写好的文章“发布”的功能，可以用上面的 <code>POST /articles/{:id}/publish</code> 方法，也可以在文章中增加 <code>published:boolean</code> 字段，发布的时候就是更新该字段 <code>PUT /articles/{:id}?published=true</code></p>
<h4 id="把动作转换成资源"><a href="#把动作转换成资源" class="headerlink" title="把动作转换成资源"></a>把动作转换成资源</h4><p>把动作转换成可以执行 <code>CRUD</code> 操作的资源， github 就是用了这种方法。 </p>
<p>比如“喜欢”一个 gist，就增加一个 <code>/gists/:id/star</code> 子资源，然后对其进行操作：“喜欢”使用 <code>PUT /gists/:id/star</code>，“取消喜欢”使用 <code>DELETE /gists/:id/star</code> 。 </p>
<p>另外一个例子是 <code>Fork</code>，这也是一个动作，但是在 gist 下面增加 <code>forks</code>资源，就能把动作变成 <code>CRUD</code> 兼容的：<code>POST /gists/:id/forks</code> 可以执行用户 fork 的动作。 </p>
<h2 id="6-Query-让查询更自由"><a href="#6-Query-让查询更自由" class="headerlink" title="6. Query 让查询更自由"></a>6. Query 让查询更自由</h2><p>比如查询某个 repo 下面 issues 的时候，可以通过以下参数来控制返回哪些结果： </p>
<ul>
<li>state：issue 的状态，可以是 <code>open</code>，<code>closed</code>，<code>all</code></li>
<li>since：在指定时间点之后更新过的才会返回</li>
<li>assignee：被 assign 给某个 user 的 issues</li>
<li>sort：选择排序的值，可以是 <code>created</code>、<code>updated</code>、<code>comments</code></li>
<li>direction：排序的方向，升序（asc）还是降序（desc）</li>
<li>……</li>
</ul>
<h2 id="7-分页-Pagination"><a href="#7-分页-Pagination" class="headerlink" title="7. 分页 Pagination"></a>7. 分页 Pagination</h2><p>当返回某个资源的列表时，如果要返回的数目特别多，比如 github 的 <code>/users</code>，就需要使用分页分批次按照需要来返回特定数量的结果。 </p>
<p>分页的实现会用到上面提到的 url query，通过两个参数来控制要返回的资源结果： </p>
<ul>
<li>per_page：每页返回多少资源，如果没提供会使用预设的默认值；这个数量也是有一个最大值，不然用户把它设置成一个非常大的值（比如 <code>99999999</code>）也失去了设计的初衷</li>
<li>page：要获取哪一页的资源，默认是第一页</li>
</ul>
<p>返回的资源列表为 <code>[(page-1)*per_page, page*per_page)</code>。github API 文档中还提到一个很好的点，相关的分页信息还可以存放到 <code>Link</code> 头部，这样客户端可以直接得到诸如<code>下一页</code>、<code>最后一页</code>、<code>上一页</code>等内容的 url 地址，而不是自己手动去计算和拼接。 </p>
<h2 id="8-选择合适的状态码"><a href="#8-选择合适的状态码" class="headerlink" title="8. 选择合适的状态码"></a>8. 选择合适的状态码</h2><p>HTTP 应答中，需要带一个很重要的字段：<code>status code</code>。它说明了请求的大致情况，是否正常完成、需要进一步处理、出现了什么错误，对于客户端非常重要。状态码都是三位的整数，大概分成了几个区间： </p>
<ul>
<li><code>2XX</code>：请求正常处理并返回</li>
<li><code>3XX</code>：重定向，请求的资源位置发生变化</li>
<li><code>4XX</code>：客户端发送的请求有错误</li>
<li><code>5XX</code>：服务器端错误</li>
</ul>
<p>在 HTTP API 设计中，经常用到的状态码以及它们的意义如下表： </p>
<p>状态码Label解释</p>
<p>200<br>OK<br>请求成功接收并处理，一般响应中都会有 body </p>
<p>201<br>Created<br>请求已完成，并导致了一个或者多个资源被创建，最常用在 POST 创建资源的时候 </p>
<p>202<br>Accepted<br>请求已经接收并开始处理，但是处理还没有完成。一般用在异步处理的情况，响应 body 中应该告诉客户端去哪里查看任务的状态 </p>
<p>204<br>No Content<br>请求已经处理完成，但是没有信息要返回，经常用在 PUT 更新资源的时候（客户端提供资源的所有属性，因此不需要服务端返回）。如果有重要的 metadata，可以放到头部返回 </p>
<p>301<br>Moved Permanently<br>请求的资源已经永久性地移动到另外一个地方，后续所有的请求都应该直接访问新地址。服务端会把新地址写在 <code>Location</code> 头部字段，方便客户端使用。允许客户端把 POST 请求修改为 GET。 </p>
<p>304<br>Not Modified<br>请求的资源和之前的版本一样，没有发生改变。用来缓存资源，和条件性请求（conditional request）一起出现 </p>
<p>307<br>Temporary Redirect<br>目标资源暂时性地移动到新的地址，客户端需要去新地址进行操作，但是<strong>不能</strong>修改请求的方法。 </p>
<p>308<br>Permanent Redirect<br>和 301 类似，除了客户端<strong>不能</strong>修改原请求的方法 </p>
<p>400<br>Bad Request<br>客户端发送的请求有错误（请求语法错误，body 数据格式有误，body 缺少必须的字段等），导致服务端无法处理 </p>
<p>401<br>Unauthorized<br>请求的资源需要认证，客户端没有提供认证信息或者认证信息不正确 </p>
<p>403<br>Forbidden<br>服务器端接收到并理解客户端的请求，但是客户端的权限不足。比如，普通用户想操作只有管理员才有权限的资源。 </p>
<p>404<br>Not Found<br>客户端要访问的资源不存在，链接失效或者客户端伪造 URL 的时候回遇到这个情况 </p>
<p>405<br>Method Not Allowed<br>服务端接收到了请求，而且要访问的资源也存在，但是不支持对应的方法。服务端<strong>必须</strong>返回 <code>Allow</code> 头部，告诉客户端哪些方法是允许的 </p>
<p>415<br>Unsupported Media Type<br>服务端不支持客户端请求的资源格式，一般是因为客户端在 <code>Content-Type</code> 或者 <code>Content-Encoding</code> 中申明了希望的返回格式，但是服务端没有实现。比如，客户端希望收到 <code>xml</code>返回，但是服务端支持 <code>Json</code></p>
<p>429<br>Too Many Requests<br>客户端在规定的时间里发送了太多请求，在进行限流的时候会用到 </p>
<p>500<br>Internal Server Error<br>服务器内部错误，导致无法完成请求的内容 </p>
<p>503<br>Service Unavailable<br>服务器因为负载过高或者维护，暂时无法提供服务。服务器端应该返回 <code>Retry-After</code> 头部，告诉客户端过一段时间再来重试 </p>
<p>上面这些状态码覆盖了 API 设计中大部分的情况，如果对某个状态码不清楚或者希望查看更完整的列表，可以参考 <a href="https://httpstatuses.com/" target="_blank" rel="external">HTTP Status Code</a> 这个网站，或者 <a href="https://tools.ietf.org/html/rfc7231#section-6" target="_blank" rel="external">RFC7231 Response Status Codes</a> 的内容。 </p>
<h2 id="9-错误处理：给出详细的信息"><a href="#9-错误处理：给出详细的信息" class="headerlink" title="9. 错误处理：给出详细的信息"></a>9. 错误处理：给出详细的信息</h2><p>如果出错的话，在 response body 中通过 <code>message</code> 给出明确的信息。 </p>
<p>比如客户端发送的请求有错误，一般会返回 <code>4XX Bad Request</code> 结果。这个结果很模糊，给出错误 message 的话，能更好地让客户端知道具体哪里有问题，进行快速修改。 </p>
<ul>
<li>如果请求的 JSON 数据无法解析，会返回 <code>Problems parsing JSON</code></li>
<li>如果缺少必要的 filed，会返回 <code>422 Unprocessable Entity</code>，除了 message 之外，还通过 <code>errors</code> 给出了哪些 field 缺少了，能够方便调用方快速排错</li>
</ul>
<p>基本的思路就是尽可能提供更准确的错误信息：比如数据不是正确的 json，缺少必要的字段，字段的值不符合规定…… 而不是直接说“请求错误”之类的信息。 </p>
<h2 id="10-验证和授权"><a href="#10-验证和授权" class="headerlink" title="10. 验证和授权"></a>10. 验证和授权</h2><p>一般来说，让任何人随意访问公开的 API 是不好的做法。验证和授权是两件事情： </p>
<ul>
<li>验证（Authentication）是为了确定用户是其申明的身份，比如提供账户的密码。不然的话，任何人伪造成其他身份（比如其他用户或者管理员）是非常危险的</li>
<li>授权（Authorization）是为了保证用户有对请求资源特定操作的权限。比如用户的私人信息只能自己能访问，其他人无法看到；有些特殊的操作只能管理员可以操作，其他用户有只读的权限等等</li>
</ul>
<p>如果没有通过验证（提供的用户名和密码不匹配，token 不正确等），需要返回 <a href="https://httpstatuses.com/401" target="_blank" rel="external"><strong>401 Unauthorized</strong></a>状态码，并在 body 中说明具体的错误信息；而没有被授权访问的资源操作，需要返回 <a href="https://httpstatuses.com/403" target="_blank" rel="external"><strong>403 Forbidden</strong></a> 状态码，还有详细的错误信息。 </p>
<p><strong>NOTE</strong>：Github API 对某些用户未被授权访问的资源操作返回 <a href="https://httpstatuses.com/404" target="_blank" rel="external"><strong>404 Not Found</strong></a>，目的是为了防止私有资源的泄露（比如黑客可以自动化试探用户的私有资源，返回 403 的话，就等于告诉黑客用户有这些私有的资源）。 </p>
<h2 id="11-限流-rate-limit"><a href="#11-限流-rate-limit" class="headerlink" title="11. 限流 rate limit"></a>11. 限流 rate limit</h2><p>如果对访问的次数不加控制，很可能会造成 API 被滥用，甚至被 <a href="https://en.wikipedia.org/wiki/Denial-of-service_attack" target="_blank" rel="external">DDos 攻击</a>。根据使用者不同的身份对其进行限流，可以防止这些情况，减少服务器的压力。 </p>
<p>对用户的请求限流之后，要有方法告诉用户它的请求使用情况，<code>Github API</code> 使用的三个相关的头部： </p>
<ul>
<li><code>X-RateLimit-Limit</code>: 用户每个小时允许发送请求的最大值</li>
<li><code>X-RateLimit-Remaining</code>：当前时间窗口剩下的可用请求数目</li>
<li><code>X-RateLimit-Rest</code>: 时间窗口重置的时候，到这个时间点可用的请求数量就会变成 <code>X-RateLimit-Limit</code> 的值</li>
</ul>
<p>如果允许没有登录的用户使用 API（可以让用户试用），可以把 <code>X-RateLimit-Limit</code> 的值设置得很小，比如 Github 使用的 <code>60</code>。没有登录的用户是按照请求的 IP 来确定的，而登录的用户按照认证后的信息来确定身份。 </p>
<p>对于超过流量的请求，可以返回 <a href="https://httpstatuses.com/429" target="_blank" rel="external"><strong>429 Too many requests</strong></a> 状态码，并附带错误信息。而 <code>Github API</code> 返回的是 <a href="https://httpstatuses.com/403" target="_blank" rel="external"><strong>403 Forbidden</strong></a>，虽然没有 <code>429</code> 更准确，也是可以理解的。 </p>
<p>Github 更进一步，提供了不影响当然 <code>RateLimit</code> 的请求查看当前 <code>RateLimit</code> 的接口 <a href="https://developer.github.com/v3/rate_limit/" target="_blank" rel="external"><strong>GET /rate_limit</strong></a>。 </p>
<h2 id="12-Hypermedia-API"><a href="#12-Hypermedia-API" class="headerlink" title="12. Hypermedia API"></a>12. Hypermedia API</h2><p>Restful API 的设计最好做到 Hypermedia：在返回结果中提供相关资源的链接。这种设计也被称为 <a href="http://en.wikipedia.org/wiki/HATEOAS" target="_blank" rel="external">HATEOAS</a>。这样做的好处是，用户可以根据返回结果就能得到后续操作需要访问的地址。 </p>
<p>比如访问 <a href="https://api.github.com/" target="_blank" rel="external">api.github.com</a>，就可以看到 Github API 支持的资源操作。 </p>
<h2 id="13-编写优秀的文档"><a href="#13-编写优秀的文档" class="headerlink" title="13. 编写优秀的文档"></a>13. 编写优秀的文档</h2><p>API 最终是给人使用的，不管是公司内部，还是公开的 API 都是一样。即使我们遵循了上面提到的所有规范，设计的 API 非常优雅，用户还是不知道怎么使用我们的 API。最后一步，但非常重要的一步是：为你的 API 编写优秀的文档。 </p>
<p>对每个请求以及返回的参数给出说明，最好给出一个详细而完整地示例，提醒用户需要注意的地方……反正目标就是用户可以根据你的文档就能直接使用 API，而不是要发邮件给你，或者跑到你的座位上问你一堆问题。 </p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://developer.github.com/v3/" target="_blank" rel="external">Github API v3</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html" target="_blank" rel="external">RESTful API 设计指南</a></li>
<li><a href="http://wangwei.info/about-rest-api/" target="_blank" rel="external">REST接口设计规范</a></li>
<li><a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm" target="_blank" rel="external">Restful API 首次被提出的论文：Architectural Styles and the Design of Network-based Software Architectures</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Restful Framework </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Kindeditor在Django中使用]]></title>
      <url>/2017/07/20/Python/Kindeditor%E5%9C%A8Django%E4%B8%AD%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a> 
<hr>
<p>一路走来，DJango也用了挺久了，自己也做了一些基于Django的小项目，具体可看github，但是Django默认的admin后台编辑文本框实在是太丑了，而且单一，其实在很久之前就想写这篇文章了，但是由于种种原因拖延到了现在，终于下定了决心来写，现在时间是00:17。 </p>
<hr>
<p>官网地址是：[<a href="http://kindeditor.net][5" target="_blank" rel="external">http://kindeditor.net][5</a>]<br>目前最新版本是4.1.1，我现在做这个东西是用python3.5 ，django 1.10.4 ，三者之间完全兼容<br>看一张效果图吧：  </p>
<p><img src="http://img.blog.csdn.net/20170326235323922?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvR2FtZXJfZ3l0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="http://kindeditor.net"></p>
<hr>
<h2 id="1：下载该文件，解压至相应的js文件目录"><a href="#1：下载该文件，解压至相应的js文件目录" class="headerlink" title="1：下载该文件，解压至相应的js文件目录"></a>1：下载该文件，解压至相应的js文件目录</h2><p>例如我的目录是：<br><img src="http://img.blog.csdn.net/20170326235519253?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvR2FtZXJfZ3l0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里我删除了多余的文件，因为是python项目，其他的都用不到，所以选择删除，节省空间 "></p>
<h2 id="2：settings-py和urls-py配置"><a href="#2：settings-py和urls-py配置" class="headerlink" title="2：settings.py和urls.py配置"></a>2：settings.py和urls.py配置</h2><p>在项目的settings.py 中设置MEDIA_ROOT 目录<br>eg： </p>
<blockquote>
<p>#文件上传配置<br>MEDIA_ROOT = os.path.join(BASE_DIR,’uploads’) </p>
</blockquote>
<p>项目的根urls.py 配置<br>eg： </p>
<pre><code>url(r&#39;^admin/uploads/(?P&lt;dir_name&gt;[^/]+)$&#39;, upload_image, name=&#39;upload_image&#39;),
url(r&quot;^uploads/(?P&lt;path&gt;.*)$&quot;, views.static.serve, {&quot;document_root&quot;: settings.MEDIA_ROOT, }),
</code></pre><h2 id="3：编写upload-py文件"><a href="#3：编写upload-py文件" class="headerlink" title="3：编写upload.py文件"></a>3：编写upload.py文件</h2><p>该文件存放于项目的根目录同名文件夹下，eg： </p>
<p><img src="http://img.blog.csdn.net/20170327000237410?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvR2FtZXJfZ3l0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>upload.py：主要是对上传的图片做一些限制 </p>
<pre><code>from django.http import HttpResponse
from django.conf import settings
from django.views.decorators.csrf import csrf_exempt
import os
import uuid
import json
import datetime as dt

@csrf_exempt
def upload_image(request, dir_name):





    result = {&quot;error&quot;: 1, &quot;message&quot;: &quot;上传出错&quot;}
    files = request.FILES.get(&quot;imgFile&quot;, None)
    if files:
        result =image_upload(files, dir_name)
    return HttpResponse(json.dumps(result), content_type=&quot;application/json&quot;)


def upload_generation_dir(dir_name):
    today = dt.datetime.today()
    dir_name = dir_name + &#39;/%d/%d/&#39; %(today.year,today.month)
    if not os.path.exists(settings.MEDIA_ROOT):
        os.makedirs(settings.MEDIA_ROOT)
    return dir_name


def image_upload(files, dir_name):

    allow_suffix =[&#39;jpg&#39;, &#39;png&#39;, &#39;jpeg&#39;, &#39;gif&#39;, &#39;bmp&#39;]
    file_suffix = files.name.split(&quot;.&quot;)[-1]
    if file_suffix not in allow_suffix:
        return {&quot;error&quot;: 1, &quot;message&quot;: &quot;图片格式不正确&quot;}
    relative_path_file = upload_generation_dir(dir_name)
    path=os.path.join(settings.MEDIA_ROOT, relative_path_file)
    if not os.path.exists(path): 
        os.makedirs(path)
    file_name=str(uuid.uuid1())+&quot;.&quot;+file_suffix
    path_file=os.path.join(path, file_name)
    file_url = settings.MEDIA_URL + relative_path_file + file_name
    open(path_file, &#39;wb&#39;).write(files.file.read())
    return {&quot;error&quot;: 0, &quot;url&quot;: file_url}
</code></pre><h2 id="4：config-js-配置"><a href="#4：config-js-配置" class="headerlink" title="4：config.js 配置"></a>4：config.js 配置</h2><p>该配置文件主要是对django admin后台作用的，比如说我们现在有一个news的app，我们需要对该模块下的 news类的content加上富文本编辑器，这里需要做两步 </p>
<p>第一：在news 的admin.py中加入 </p>
<pre><code>class Media:
    js = (
        &#39;/static/js/kindeditor-4.1.10/kindeditor-min.js&#39;,
        &#39;/static/js/kindeditor-4.1.10/lang/zh_CN.js&#39;,
        &#39;/static/js/kindeditor-4.1.10/config.js&#39;,
    )
</code></pre><p>第二：config.js 中配置<br>上边说了我们是要对news的content加上富文本编辑器，那么我们首先要定位到该文本框的name属性，鼠标右键查看源代码，如下红线标示：<br><img src="http://img.blog.csdn.net/20170327001347482?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvR2FtZXJfZ3l0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>config.js 中加入： </p>
<pre><code>KindEditor.ready(function(K) {
    K.create(&#39;textarea[name=&quot;new_content&quot;]&#39;, {
        width : &quot;800px&quot;,
        height : &quot;500px&quot;,
        uploadJson: &#39;/admin/uploads/kindeditor&#39;,
    });
});
</code></pre><hr>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> kindeditor </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[docker django+mysql开发环境]]></title>
      <url>/2017/07/05/Python/django+mysql/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a> 
<p>使用docker来搭建开发环境不仅能够跟我们主机的已有的各种软件配置隔离，而且也能够很方便地分发给别人，从而使团队能够在统一的开发环境下快速开始开发、测试和部署。本文采用Docker的docker-compose来搭建python2.7+django1.7.5+mysql的web开发环境，希望可以给需要的同学参考。 </p>
<h2 id="1、项目目录"><a href="#1、项目目录" class="headerlink" title="1、项目目录"></a>1、项目目录</h2><p>创建工程目录mysite </p>
<pre><code>yhc@yhc-E540:~/workspaces/docker$ mkdir mysite &amp;&amp; cd mysite
</code></pre><p>创建以下2个目录（这里为方便放置各个文件，可以根据需要自己组织，后面配置文件做相应修改即可） </p>
<pre><code>yhc@yhc-E540:~/workspaces/docker/mysite$ mkdir db mysite
</code></pre><h2 id="2、配置文件"><a href="#2、配置文件" class="headerlink" title="2、配置文件"></a>2、配置文件</h2><p>（1）Dockerfile </p>
<p>Dockerfile包含创建镜像所需要的全部指令。在项目根目录下创建<code>Dockerfile</code>文件，其内容如下： </p>
<pre><code>FROM python:2.7
ENV PYTHONUNBUFFERED 1
RUN mkdir /code
RUN mkdir /code/db
WORKDIR /code
ADD ./mysite/requirements.txt /code/
RUN pip install -r requirements.txt
ADD . /code/
</code></pre><p>第1行的<code>FROM</code>指令表示新的镜像将基于python:2.7的镜像来构建<br>第2行的<code>ENV</code>为环境变量（PYTHONUNBUFFERED见<a href="https://docs.python.org/2/using/cmdline.html" target="_blank" rel="external">这里</a>）<br>第3行的<code>RUN</code>指令表示在镜像内新建/code目录<br>第4行指定指定RUN、CMD与ENTRYPOINT命令的工作目录<br>第5行是将<code>./mysite/requirements.txt</code>文件添加到刚才新建的code目录中<br>第6行运行<code>pip</code>安装所需的软件 </p>
<p>Dockerfile详细可以参见《<a href="http://yuedu.baidu.com/ebook/d817967416fc700abb68fca1" target="_blank" rel="external">Docker入门实战</a>》<br>以及<a href="http://docs.docker.com/reference/builder/" target="_blank" rel="external">官方参考</a></p>
<p>（2）docker-compose.yml </p>
<p>之前的Dockerfile定义了一个应用，而使用compose，可以在一个文件里，定义多容器的应用。该YAML配置语言，用于描述和组装多容器的分布式应用。在项目根目录创建<code>docker-compose.yml</code>文件，其内容如下： </p>
<pre><code>db:
  image: mysql
  expose:
    - &quot;3306&quot;
  volumes:
    - ./db:/var/lib/mysql
  environment:
    - MYSQL_DATABASE=mysitedb
    - MYSQL_ROOT_PASSWORD=11111111  

web:
  build: .
  command: python ./mysite/manage.py runserver 0.0.0.0:8000
  volumes:
    - .:/code
  ports:
    - &quot;8000:8000&quot;
  links:
    - db
</code></pre><p>db标签：<br>images表示使用mysql镜像<br>expose表示暴露端口3306，但不发布到宿主机上<br>volume表示挂载宿主机的路径作为卷，冒号左边为宿主机路径，右边为镜像内路径<br>environment为环境变量，每个容器都有自己定义的环境变量，具体查看<a href="https://github.com/docker-library/docs" target="_blank" rel="external">镜像手册</a>中的mysql </p>
<p>web标签：<br>build指定建立Dockerfile路径<br>command将覆盖默认的命令<br>ports指定主机开放的端口<br>links指向其他容器中的服务 </p>
<p>更多该配置文件参见<a href="http://docs.docker.com/compose/yml/" target="_blank" rel="external">这里</a></p>
<p>（3）requirements.txt </p>
<p>在子目录mysite下<code>requirements.txt</code>文件，该文件内容如下: </p>
<pre><code>django==1.7.5
MySQL-python
</code></pre><h2 id="3、构建镜像"><a href="#3、构建镜像" class="headerlink" title="3、构建镜像"></a>3、构建镜像</h2><p>在项目根目录执行以下命令 </p>
<pre><code>yhc@yhc-E540:~/workspaces/docker/mysite$ docker-compose build
db uses an image, skipping
Building web...
Step 0 : FROM python:2.7
 ---&gt; d833e0b23482
Step 1 : ENV PYTHONUNBUFFERED 1
 ---&gt; Using cache
 ---&gt; df633fc1ab0e
Step 2 : RUN mkdir /code
 ---&gt; Using cache
 ---&gt; 49bb20e37bfc
Step 3 : WORKDIR /code
 ---&gt; Using cache
 ---&gt; f84fca46a343
Step 4 : ADD ./mysite/requirements.txt /code/
 ---&gt; e8f756bed13e
Removing intermediate container 91e677d50cd4
Step 5 : RUN pip install -r requirements.txt
 ---&gt; Running in 7eb86e071025
Collecting django==1.7.5 (from -r requirements.txt (line 1))
  Downloading Django-1.7.5-py2.py3-none-any.whl (7.4MB)
Collecting MySQL-python (from -r requirements.txt (line 2))
  Downloading MySQL-python-1.2.5.zip (108kB)
Installing collected packages: django, MySQL-python
  Running setup.py install for MySQL-python
Successfully installed MySQL-python-1.2.5 django-1.7.5
 ---&gt; 3e5c9b891397
Removing intermediate container 7eb86e071025
Step 6 : ADD . /code/
 ---&gt; 251dea7e2af2
Removing intermediate container b4b0c2b08538
Successfully built 251dea7e2af2
</code></pre><p>如果本地没有python和mysql镜像的话下载需要多等待一些时间。完成之后就构建好了python+django+mysql的镜像。 </p>
<h2 id="4、创建django工程"><a href="#4、创建django工程" class="headerlink" title="4、创建django工程"></a>4、创建django工程</h2><p>执行以下命令 </p>
<pre><code>yhc@yhc-E540:~/workspaces/docker/mysite$ docker-compose run web django-admin.py startproject mysite ./mysite
Starting dockermysite_db_1...
</code></pre><p>完成之后就在子目录mysite下创建了一个新的django工程<br>因为在镜像内是以root权限创建的，所以宿主机中对工程文件无法进行更改，这里修改一下权限 </p>
<pre><code>yhc@yhc-E540:~/workspaces/docker/mysite$ sudo chmod -R 777 mysite/
</code></pre><p>修改<code>setttings.py</code>文件中数据库配置 </p>
<pre><code>DATABASES = {
    &#39;default&#39;: {
        &#39;ENGINE&#39;: &#39;django.db.backends.mysql&#39;,
        &#39;NAME&#39;: &#39;mysitedb&#39;,
        &#39;USER&#39;: &#39;root&#39;,
        &#39;PASSWORD&#39;: &#39;11111111&#39;,
        &#39;HOST&#39;: &#39;db&#39;,
        &#39;PORT&#39;: 3306,
    }
}
</code></pre><h2 id="5、运行"><a href="#5、运行" class="headerlink" title="5、运行"></a>5、运行</h2><pre><code>yhc@yhc-E540:~/workspaces/docker/mysite$ docker-compose up
</code></pre><p>![这里写图片描述][6]</p>
<p>   [6]: <a href="http://img.blog.csdn.net/20150513192620732" target="_blank" rel="external">http://img.blog.csdn.net/20150513192620732</a> ()</p>
<p>浏览器地址栏中输入：<a href="http://127.0.0.1:8000/" target="_blank" rel="external">http://127.0.0.1:8000/</a><br>可以看到成功运行 </p>
<p>![这里写图片描述][8]</p>
<p>   [8]: <a href="http://img.blog.csdn.net/20150513192443902" target="_blank" rel="external">http://img.blog.csdn.net/20150513192443902</a> ()</p>
<h2 id="6、打包镜像"><a href="#6、打包镜像" class="headerlink" title="6、打包镜像"></a>6、打包镜像</h2><p>（1）查看镜像 </p>
<pre><code>yhc@yhc-E540:~/workspaces/docker/mysite$ docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
mysite_web          latest              251dea7e2af2        8 minutes ago       783 MB
python              2.7                 d833e0b23482        13 days ago         747.9 MB
postgres            latest              b733b00eb1ae        13 days ago         213.9 MB
mysql               latest              56f320bd6adc        3 weeks ago         282.9 MB
</code></pre><p>（2）打包 </p>
<pre><code>yhc@yhc-E540:~/workspaces/docker/mysite$ docker save -o docker-mysite-image.tar.gz mysite_web
yhc@yhc-E540:~/workspaces/docker/mysite$ ls
db  docker-compose.yml  Dockerfile  docker-mysite-image.tar.gz  mysite
</code></pre><p>最后目录如下所示 </p>
<pre><code>yhc@yhc-E540:~/workspaces/docker/mysite$ tree
.
├── db
│   ├── auto.cnf
│   ├── ibdata1
│   ├── ib_logfile0
│   ├── ib_logfile1
│   ├── mysitedb [error opening dir]
│   ├── mysql [error opening dir]
│   └── performance_schema [error opening dir]
├── docker-compose.yml
├── Dockerfile
├── docker-mysite-image.tar.gz
└── mysite
    ├── manage.py
    ├── mysite
    │   ├── __init__.py
    │   ├── __init__.pyc
    │   ├── settings.py
    │   ├── settings.pyc
    │   ├── urls.py
    │   ├── urls.pyc
    │   ├── wsgi.py
    │   └── wsgi.pyc
    └── requirements.txt

6 directories, 17 files
</code></pre><h2 id="7、加载镜像"><a href="#7、加载镜像" class="headerlink" title="7、加载镜像"></a>7、加载镜像</h2><p>​镜像打包好后就可以分发给别的其他的开发人员，只需要加载镜像即可。<br>这里在本机进行测试镜像的加载，首先将原来的镜像删除了 </p>
<pre><code>yhc@yhc-E540:~/workspaces/docker/mysite$ docker rmi -f mysite_web
Untagged: mysite_web:latest
Deleted: 251dea7e2af26522b9e74612163972cb0aca2ec071e7b1696d815097db105770
Deleted: 3e5c9b8913971f90b4c94e8b0e04ed4dc2a09da6261fe0a9b3dffa7b0392ce92
Deleted: e8f756bed13e2172a8f522b93728f6aca75795bec0bb032ba154003f4a15b440
</code></pre><p>运行看看 </p>
<pre><code>yhc@yhc-E540:~/workspaces/docker/mysite$ docker-compose up
Recreating mysite_db_1...
Recreating mysite_web_1...
No such image: mysite_web:latest (tag: latest)
</code></pre><p>发现无法运行了<br>​接下来加载镜像 </p>
<pre><code>yhc@yhc-E540:~/workspaces/docker/mysite$ docker load -i docker-mysite-image.tar.gz
</code></pre><p>​再次运行 </p>
<pre><code>yhc@yhc-E540:~/workspaces/docker/mysite$ docker-compose up
</code></pre><p>​ok没问题了～ </p>
<h2 id="8、其他"><a href="#8、其他" class="headerlink" title="8、其他"></a>8、其他</h2><p>还可以运行python shell，命令如下： </p>
<pre><code>yhc@yhc-E540:~/workspaces/docker/mysite$ docker-compose run web mysite/manage.py shell
</code></pre><p>注意按照自己目录结构修改manage.py的位置 </p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> django </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基于docker的django开发环境搭建]]></title>
      <url>/2017/07/02/Python/docker%20django%E7%8E%AF%E5%A2%83/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a> 
<p>本文主要是作为官方<a href="https://docs.docker.com/compose/django/" target="_blank" rel="external">Quickstart: Compose and Django</a>的导读，如果你当下还没了解过Docker，但想知道如何利用Docker来管理自己本地的开发环境，并统一开发和测试的环境,那你可以参考以下内容。 </p>
<h3 id="需求："><a href="#需求：" class="headerlink" title="需求："></a>需求：</h3><p>使用Docker搭建Django开发环境，即本地只需要有python代码即可。 </p>
<h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识:"></a>预备知识:</h3><p>Docker作为容器，和传统虚拟机是不一样的，如下图所示，它是基于Docker Engine的一个容器，且在这一层次上是相互隔离的，而传统虚拟化则是要虚拟化整个系统，因此理论上Docker容器可以更有效的利用资源，你可以很容易在本地环境搭建多服务的复杂系统环境。本篇以一台web服务器及一台数据库服务器为例，当然也可以搭建更复杂的，比如加入一台redis机器等等。  </p>
<p><img src="https://yeasy.gitbooks.io/docker_practice/content/_images/docker.png" alt="Docker%u7ED3%u6784">  </p>
<p>Docker结构 </p>
<p>更多Docker介绍可以看开源版本的<a href="https://yeasy.gitbooks.io/docker_practice/content/introduction/what.html" target="_blank" rel="external">《Docker 从入门到实践》</a>， 内容可能已经有点老，但是基本上还是作为参考。<br>更多，等新，等详细的解释看官方介绍<a href="https://www.docker.com/what-container" target="_blank" rel="external">What is a Cantainer</a></p>
<p><strong>容器</strong>是基于一个<strong>镜像</strong>(image)建立的，比如本地有一个ubuntu的镜像，我们可以基于该镜像去新建多个容器实例，而它们之间可以做到互联，与本地机器的文件共享等。从而可以达到前文提到的，快速在本地搭建一个多服务器的复杂环境。<br>用户可以很方便地对容器进行启动、停止、删除等操作。一个基本的容器启动例子如下，它在启动一个容器后，打印一条Hello world </p>
<pre><code>sudo docker run ubuntu:14.04 /bin/echo &#39;Hello world&#39;
</code></pre><p>镜像被<strong><a href="https://yeasy.gitbooks.io/docker_practice/content/repository/" target="_blank" rel="external">仓库</a></strong>统一管理，Docker官方有自己的仓库Docker Hub，国内可以使用阿里云的镜像仓库，我用的是阿里的，需要在阿里后台生成自己的私有地址，然后在Docker中配置。从镜像仓库获取镜像到本地后，就可以基于镜像新建容器使用了。<br>当然也可以搭建自己的私有仓库，在团队或公司内部使用。 </p>
<p><strong>镜像定制</strong>，当仓库中的官方镜像无法满足需求时，就需要自定义镜像，所有的自定义镜像都可以上传到仓库中，共享给其他用户。Docker镜像的定制主要通过Dockerfile指令文件实现，在指令文件中实现自己的需求即可，比如使用COPY命令将本机文件复制到容器中等。 </p>
<p>[Docker Compose][6]，安装最新的Docker，默认已经包含这个工具，主要用于定义及启动多容器的场景(当前例子基于此工具)，它需要一个docker-compose.yml文件来配置需要启动的容器及相关配置，然后就可以用下述语句新建及启动配置文件中的多容器 </p>
<pre><code>   [6]: https://docs.docker.com/compose/
</code></pre><p>docker-compose up</p>
<p>docker-compose.yml实例： </p>
<pre><code>version: &#39;2&#39;
 services:
   db:  //数据库容器
     image: postgres
   web:  //web服务器容器
     build: .
     command: python manage.py runserver 0.0.0.0:8000
     volumes:   //挂载本地机器文件夹
       - .:/code
     ports:
       - &quot;8000:8000&quot;
     depends_on:
       - db
</code></pre><h3 id="搭建Django开发环境："><a href="#搭建Django开发环境：" class="headerlink" title="搭建Django开发环境："></a>搭建Django开发环境：</h3><p><strong>Step 1</strong>: Define the project components </p>
<p>这个步骤主要是定义project的内容，这里的“project”指我们要搭建的基于Docker的Django开发环境，具体会包含Docker容器配置文件Dockerfile，Django环境需要的requirements.txt配置，docker-compose.yml配置 </p>
<p>Dockerfile 实例： </p>
<pre><code> FROM python:2.7   注：基础镜像
 ENV PYTHONUNBUFFERED 1
 RUN mkdir /code
 WORKDIR /code     注：切换工作上下文
 ADD requirements.txt /code/    
 RUN pip install -r requirements.txt 注：安装python依赖
 ADD . /code/
</code></pre><p><strong>Step 2</strong>：Create a Django project </p>
<p>官方例子是用docker-compose命令运行web服务器(docker-compose.yml配置了web和db两个容器)，然后调用django-admn新建Django项目，由于挂在了本地目录到容器内部，因此当前命令生成的django项目文件能在本地机器目录直接访问。 </p>
<pre><code> docker-compose run web django-admin.py startproject composeexample .
</code></pre><p>注意，此时的web容器已经包含django环境了，因为在web容器的Dockerfile文件配置了python环境搭建的命令，如下所示： </p>
<pre><code>RUN pip install -r requirements.txt
</code></pre><p>对于实际工作项目，我们只需在对应的本地机器目录(即运行docker-compose命令的上下文目录)准备好项目代码即可 </p>
<pre><code> $ ls -l
 drwxr-xr-x 2 root   root   composeexample   注：该项目文件可以是实际工作代码文件夹
 -rw-rw-r-- 1 user   user   docker-compose.yml
 -rw-rw-r-- 1 user   user   Dockerfile
 -rwxr-xr-x 1 root   root   manage.py
 -rw-rw-r-- 1 user   user   requirements.txt
</code></pre><p><strong>Step 3</strong>：Connect the database </p>
<p>这里主要就是设置Django框架下的settings.py文件，注意HOST名字使用 </p>
<pre><code>DATABASES = {
     &#39;default&#39;: {
         &#39;ENGINE&#39;: &#39;django.db.backends.postgresql&#39;,
         &#39;NAME&#39;: &#39;postgres&#39;,
         &#39;USER&#39;: &#39;postgres&#39;,
         &#39;HOST&#39;: &#39;db&#39;,  //另一个容器的名字
         &#39;PORT&#39;: 5432,
     }
 }
</code></pre><p>最后就是再次使用docker-compose新建并启动多个容器 </p>
<pre><code>$ docker-compose up
</code></pre><p><img src="https://docs.docker.com/compose/images/django-it-worked.png" alt="Django%u9875%u9762">  </p>
<p>Django页面 </p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> docker-compose </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用Vultr搭建ShadowSocks教程]]></title>
      <url>/2017/07/01/%E9%82%A3%E4%BA%9B%E5%B9%B4%E5%80%92%E8%85%BE%E8%BF%87%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8/vultr%E6%90%AD%E5%BB%BAss/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a> 
<h2 id="使用Vultr搭建ShadowSocks教程"><a href="#使用Vultr搭建ShadowSocks教程" class="headerlink" title="使用Vultr搭建ShadowSocks教程"></a>使用Vultr搭建ShadowSocks教程</h2><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>本地发起连接请求，由远程服务器响应后然后将我们需要的数据返回到本地。 </p>
<p>最低消费 </p>
<p>  2.5美元/月 </p>
<h2 id="网速自测"><a href="#网速自测" class="headerlink" title="网速自测"></a>网速自测</h2><p>经过我个人测试后选择的Dallas节点，浏览youtube视频，网速能达到1MB/s<br>，玩美服lol的延迟是200ms-250ms，这个速度已经很不错了，具体分析参考<a href="http://www.vpnps.com/usa_vpn_ping.html" target="_blank" rel="external">《国内连接美国VPN延迟(PING)多少算正常？》</a>。 </p>
<p>PS：浏览其他人的博客都推荐的是LosAngeles节点，具体的自己通过测试后拿主意吧，懒得测试就选洛杉矶节点吧。 </p>
<p>了解更多，请戳<a href="https://www.v2ex.com/t/276585" target="_blank" rel="external">Vultr 节点哪个比较快？</a></p>
<h2 id="知识储备"><a href="#知识储备" class="headerlink" title="知识储备"></a>知识储备</h2><ol>
<li>懂Linux最好，不懂就按照下面操作来吧</li>
<li>肯折腾</li>
<li>懂英语，不懂的话…搭建SS（Shadow Socks）干吗？</li>
</ol>
<h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><h3 id="购买服务器"><a href="#购买服务器" class="headerlink" title="购买服务器"></a>购买服务器</h3><ol>
<li>打开<a href="http://www.vultr.com/?ref=7123587" target="_blank" rel="external">链接1：我的夏季促销推广链接</a>，无效的话尝试 <a href="http://www.vultr.com/?ref=7123587" target="_blank" rel="external">链接2：我的普通推广链接</a>。<br>这两个都指向官网，信不过我的自己去百度搜索vultr官网。【更多信息见最后的Vlutr服务器链接详细说明】 </li>
</ol>
<ol>
<li><p>注册账号并验证邮箱。 </p>
</li>
<li><p>测试速度或直接选择洛杉矶节点，<a href="https://www.vultr.com/faq/" target="_blank" rel="external">测试节点网速请戳我并拉到页面最下面</a>。如果感觉不满意，去试试其他的服务器提供商比如搬瓦工等等，个人感觉vultr还可以。</p>
</li>
<li>充值，点击左侧的Billing，最低五美元，这一步因人而异。我个人选择使用Paypal支付的$5。</li>
<li>搭建服务器，点击左侧的Servers，依次选择Server Location——你测试的最快的或者洛杉矶；Server Type——Cent OS7 x64（这个我可以提供技术支持，本文基于CentOS 7 x64）或其他你懂的；Server Size——只是搭建ss，选第一个就够了($5/mon)；其他的选填。然后点击右下角的Deploy Now。稍等片刻，服务器就可以装好了。</li>
<li>装好后，你可以看到如下界面：</li>
</ol>
<p><img src="https://static.oschina.net/uploads/img/201703/04105521_mL6K.png" alt=""></p>
<p>servers </p>
<p>点击可以查看服务器的相关信息： </p>
<p><img src="https://static.oschina.net/uploads/img/201703/04105521_SgBL.png" alt=""></p>
<p>server information </p>
<p>接下来操作需要的信息是IP Address，Username和Password。这个页面不要关，一会直接复制粘贴相关信息。 </p>
<h3 id="远程连接服务器"><a href="#远程连接服务器" class="headerlink" title="远程连接服务器"></a>远程连接服务器</h3><blockquote>
<p>方法①点击刚才的网页的右上角的五个按钮最左边的View Console进行操作。 </p>
<p>方法②下载Xshell进行操作，建议后者，方面使用（主要是支持复制粘贴）管理。 </p>
</blockquote>
<p>以Xshell为例。 </p>
<ol>
<li>下载安装Xshell。</li>
<li>安装完成后新建会话（Alt+N）。依次填写图中信息。<br>名称可以是Vultr或者其他，协议选择SSH，主机填写之前的IP Address，端口号选择22。</li>
</ol>
<p><img src="https://static.oschina.net/uploads/img/201703/04105522_g2pw.png" alt=""></p>
<p>连接 </p>
<p>点击左侧的用户身份验证，填写信息。方法选择Password，用户名为之前的Username（一般都是root），密码为之前的Password（这个建议直接复制粘贴过来，系统给的有点复杂） </p>
<p><img src="https://static.oschina.net/uploads/img/201703/04105522_X2Iw.png" alt=""></p>
<p>用户身份验证 </p>
<p>填写完之后点击确定。然后点击连接。出现其他提示的话选择接受就可以了。这时你就可以看到一个命令控制台了。这时就算连接成功了。 </p>
<h3 id="搭建-Shadowsocks-服务"><a href="#搭建-Shadowsocks-服务" class="headerlink" title="搭建 Shadowsocks 服务"></a>搭建 Shadowsocks 服务</h3><h4 id="安装组件"><a href="#安装组件" class="headerlink" title="安装组件"></a>安装组件</h4><pre><code>$ yum install m2crypto python-setuptools
$ easy_install pip
$ pip install shadowsocks
</code></pre><h4 id="安装完成后配置服务器参数"><a href="#安装完成后配置服务器参数" class="headerlink" title="安装完成后配置服务器参数"></a>安装完成后配置服务器参数</h4><pre><code>$ vi  /etc/shadowsocks.json
</code></pre><p>写入如下配置: </p>
<pre><code>{
    &quot;server&quot;:&quot;0.0.0.0&quot;,
    &quot;server_port&quot;:443,
    &quot;local_address&quot;: &quot;127.0.0.1&quot;,
    &quot;local_port&quot;:1080,
    &quot;password&quot;:&quot;123456&quot;,
    &quot;timeout&quot;:300,
    &quot;method&quot;:&quot;aes-256-cfb&quot;,
    &quot;fast_open&quot;: false
}
</code></pre><p>多端口的如下： </p>
<pre><code>{
    &quot;server&quot;:&quot;0.0.0.0&quot;,
    &quot;local_address&quot;: &quot;127.0.0.1&quot;,
    &quot;local_port&quot;:1080,
    &quot;port_password&quot;: {
         &quot;443&quot;: &quot;443&quot;,
         &quot;8888&quot;: &quot;8888&quot;
     },
    &quot;timeout&quot;:300,
    &quot;method&quot;:&quot;aes-256-cfb&quot;,
    &quot;fast_open&quot;: false
}
</code></pre><p>其中server字段与local_address填写之前的IP Address。password是自己用于连接这个shadow socks的密码，自定义就好。<br>其他的不需要更改。 </p>
<p>然后保存退出。 </p>
<p>vi 的命令: 按 “i” 进入编辑模式，编辑后按 “esc” 退出编辑模式， 输入 “:wq” 保存退出vi。 </p>
<h3 id="配置防火墙"><a href="#配置防火墙" class="headerlink" title="配置防火墙"></a>配置防火墙</h3><p>这一步主要是为了提高系统安全性。 </p>
<pre><code># 安装防火墙
$ yum install firewalld
# 启动防火墙
$ systemctl start firewalld
</code></pre><h4 id="开启防火墙相应的端口"><a href="#开启防火墙相应的端口" class="headerlink" title="开启防火墙相应的端口"></a>开启防火墙相应的端口</h4><p>方法一(推荐) </p>
<pre><code># 端口号是你自己设置的端口
$ firewall-cmd --permanent --zone=public --add-port=443/tcp
$ firewall-cmd --reload
</code></pre><p>方法二（麻烦，没必要） </p>
<p>新建文件ss.xml </p>
<pre><code>$ vi /usr/lib/firewalld/services/ss.xml
</code></pre><p>粘贴下面的代码 </p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;service&gt;
  &lt;short&gt;SS&lt;/short&gt;
  &lt;description&gt;Shadowsocks port
  &lt;/description&gt;
  &lt;port protocol=&quot;tcp&quot; port=&quot;443&quot;/&gt;
&lt;/service&gt;
</code></pre><p>保存退出。 </p>
<p>开启端口，重启firewalld 服务，下面的ss是上述的文件的名字，区分大小写 </p>
<pre><code>$ firewall-cmd --permanent --add-service=ss
$ firewall-cmd --reload
</code></pre><h3 id="启动-Shadowsocks-服务"><a href="#启动-Shadowsocks-服务" class="headerlink" title="启动 Shadowsocks 服务"></a>启动 Shadowsocks 服务</h3><pre><code>$ ssserver -c /etc/shadowsocks.json
</code></pre><p>如果想干点其他的实现后台运行，使用 </p>
<pre><code>$ nohup ssserver -c /etc/shadowsocks.json &amp;
</code></pre><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p>这样服务器就搭建好了。<a href="http://ssspeed.net/cms/help" target="_blank" rel="external">全平台的连接方法戳我</a>。 </p>
<h3 id="PC连接"><a href="#PC连接" class="headerlink" title="PC连接"></a>PC连接</h3><p>下载Shadow Socks客户端。<a href="http://ssspeed.net/index/download" target="_blank" rel="external">SS加速器客户端下载</a><br>选择适合的版本，下载并解压运行。 </p>
<p>填写信息:服务器地址，端口号，密码，加密方式与代理端口默认即可 </p>
<p><img src="https://static.oschina.net/uploads/img/201703/04105522_sfWq.png" alt=""></p>
<p>SS信息填写 </p>
<p>填写完之后点击确定，然后到托盘中右键选择开启”启用系统代理”。 </p>
<h3 id="iOS连接"><a href="#iOS连接" class="headerlink" title="iOS连接"></a>iOS连接</h3><p>在App Store下载Wingy。 </p>
<p>填写信息:服务器，端口，密码，代理模式，加密方式默认即可。 </p>
<p><img src="https://static.oschina.net/uploads/img/201703/04105522_WJOl.png" alt=""></p>
<p>Wingy信息填写 </p>
<h3 id="MacOS连接"><a href="#MacOS连接" class="headerlink" title="MacOS连接"></a>MacOS连接</h3><p><a href="http://ssspeed.net/cms/22" target="_blank" rel="external">官方教程</a></p>
<h3 id="Android连接"><a href="#Android连接" class="headerlink" title="Android连接"></a>Android连接</h3><p><a href="http://ssspeed.net/cms/26" target="_blank" rel="external">官方教程</a></p>
<h2 id="国外站点"><a href="#国外站点" class="headerlink" title="国外站点"></a>国外站点</h2><p><a href="http://www.google.com/" target="_blank" rel="external">Google</a></p>
<p><a href="http://www.youtube.com/" target="_blank" rel="external">Youtube</a></p>
<p><a href="http://www.facebook.com/" target="_blank" rel="external">Facebook</a></p>
<p>如果以上没有问题的话，这时候你就可以畅游外面的世界了。点击上述链接测试吧。 </p>
<h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><p>_本文原创来自：<a href="https://www.vultrclub.com/174.html_" target="_blank" rel="external">https://www.vultrclub.com/174.html_</a></p>
<p>一般而言，服务器本身的速度是决定我们项目打开速度、下载速度的关键，但是我们也可以借助第三方软件工具等提高加速效果，比如我们肯定很多人都熟悉的锐速、Net-Speeder可以双倍发包流量，可以减少超时和提高下载速度。这不在前一段时间，来自大名鼎鼎的谷歌发布开源<a href="https://www.vultrclub.com/tag/google-bbr/" target="_blank" rel="external">Google BBR</a>工具，可以提高发包数据量，起到加速作用。 </p>
<p>这里，我们也在<a href="https://www.vultrclub.com/" target="_blank" rel="external">Vultr VPS</a>中安装Google BBR工具，因为是支持KVM和XEN架构的，我们的VULTR都是KVM架构所以肯定支持，但是由于内核的问题，我们需要调试和安装必备的内核和组件才 可以使用，我们一起安装试试吧。 </p>
<p>第一、准备工作 </p>
<p>这里我选择使用Vultr美国洛杉矶机房5美金月付方案，系统采用CENTOS7 64BIT。很多人要问为什么不选择速度较好的日本机房，因为日本机房虽然目前用NTT线路，PING速度看着还可以，但是稳定性不行，所以我不选择，尤其是晚上速度很差。 </p>
<p>第二、查看当前核心 </p>
<p>uname -r </p>
<p>这里我们看到当前CENTOS7核心是3.10.0-514.2.2.el7.x86_64，这个核心是不可以安装BBR的。 </p>
<p>第三、更新内核 </p>
<p>rpm –import <a href="https://www.elrepo.org/RPM-GPG-KEY-elrepo.org" target="_blank" rel="external">https://www.elrepo.org/RPM-GPG-KEY-elrepo.org</a> </p>
<p>rpm -Uvh <a href="http://www.elrepo.org/elrepo-release-7.0-2.el7.elrepo.noarch.rpm" target="_blank" rel="external">http://www.elrepo.org/elrepo-release-7.0-2.el7.elrepo.noarch.rpm</a> </p>
<p>安装4.9.0内核 </p>
<p>yum –enablerepo=elrepo-kernel install kernel-ml -y </p>
<p>我们要知道，BBR目前只支持4.9.0内核，其他内核是不行的，需要更换内核才可以。 </p>
<p>第四、检查内核是否更新 </p>
<p>rpm -qa | grep kernel </p>
<p>我们看到了有4.9.0内核，需要启动才可以。 </p>
<p>grub2-set-default 1 </p>
<p>然后重启 </p>
<p>shutdown -r now </p>
<p>第五、检查是否生效 </p>
<p>uname -r </p>
<p>检查当前内核是不是4.9.4-1.el7.elrepo.x86_64. </p>
<p>看来内核是搞定了，我们那就开始安装BBR了。 </p>
<p>第六、安装Google BBR </p>
<p>echo ‘net.core.default_qdisc=fq’ | sudo tee -a /etc/sysctl.conf </p>
<p>echo ‘net.ipv4.tcp_congestion_control=bbr’ | sudo tee -a /etc/sysctl.conf </p>
<p>sysctl -p </p>
<p>第七、检查BBR是否成功 </p>
<p>sysctl net.ipv4.tcp_available_congestion_control </p>
<p>执行命令，看看是否是提示”net.ipv4.tcp_available_congestion_control = bbr cubic reno” </p>
<p>sysctl -n net.ipv4.tcp_congestion_control </p>
<p>执行命令，是否提示bbr </p>
<p>lsmod | grep bbr </p>
<p>执行命令，是否看到BBR提示。 </p>
<p>能看到上面提示，就说明BBR安装成功。后面，我们再去安装需要的工具，比如SS或者其他项目，速度上是有明显提升的。 </p>
]]></content>
      
        <categories>
            
            <category> 那些年倒腾过的服务器 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> shadowsocks </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MarkDown 语法入门]]></title>
      <url>/2017/07/01/%E6%9D%82%E8%AE%B0/MarkDown%20%E8%AF%AD%E6%B3%95%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a> 
<h4 id="导语："><a href="#导语：" class="headerlink" title="导语："></a>导语：</h4><blockquote>
<p><a href="http://zh.wikipedia.org/wiki/Markdown" target="_blank" rel="external">Markdown</a> 是一种轻量级的<strong>「标记语言」</strong>，它的优点很多，目前也被越来越多的写作爱好者，撰稿者广泛使用。看到这里请不要被<strong>「标记」</strong>、<strong>「语言」</strong>所迷惑，Markdown 的语法十分简单。常用的标记符号也不超过十个，这种相对于更为复杂的 HTML 标记语言来说，Markdown 可谓是十分轻量的，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。 </p>
</blockquote>
<p><img src="http://ww3.sinaimg.cn/large/6aee7dbbjw1eqft66xcg3j21kw12mdub.jpg" alt="Ulysses for Mac">  </p>
<p><a href="http://www.ulyssesapp.com" target="_blank" rel="external">Ulysses for Mac</a></p>
<h2 id="一，认识-Markdown"><a href="#一，认识-Markdown" class="headerlink" title="一，认识 Markdown"></a>一，认识 Markdown</h2><p>在刚才的导语里提到，Markdown 是一种用来写作的轻量级<strong>「标记语言」</strong>，它用简洁的语法代替排版，而不像一般我们用的字处理软件 _Word_ 或 _Pages_ 有大量的排版、字体设置。它使我们专心于码字，用「标记」语法，来代替常见的排版格式。例如此文从内容到格式，甚至插图，键盘就可以通通搞定了。目前来看，支持 Markdown 语法的编辑器有很多，包括很多网站（例如<a href="http://jianshu.io" target="_blank" rel="external">简书</a>）也支持了 Markdown 的文字录入。Markdown 从写作到完成，导出格式随心所欲，你可以导出 HTML 格式的文件用来网站发布，也可以十分方便的导出 PDF 格式，这种格式写出的简历更能得到 HR 的好感。甚至可以利用 <a href="http://www.getcloudapp.com" target="_blank" rel="external">CloudApp</a> 这种云服务工具直接上传至网页用来分享你的文章，全球最大的轻博客平台 <a href="http://te1ee.tumblr.com" target="_blank" rel="external">Tumblr</a>，也支持 Mou 这类 Markdown 工具的直接上传。 </p>
<h3 id="Markdown-官方文档"><a href="#Markdown-官方文档" class="headerlink" title="Markdown 官方文档"></a>Markdown 官方文档</h3><blockquote>
<p>这里可以看到官方的 Markdown 语法规则文档，当然，<strong>后文我也会用自己的方式阐述这些语法的具体用法</strong>。 </p>
<ul>
<li><a href="http://daringfireball.net/projects/markdown/syntax" target="_blank" rel="external">_创始人 John Gruber 的 Markdown 语法说明_</a></li>
<li><a href="http://wowubuntu.com/markdown/#list" target="_blank" rel="external">_Markdown 中文版语法说明_</a></li>
</ul>
</blockquote>
<h3 id="使用-Markdown-的优点"><a href="#使用-Markdown-的优点" class="headerlink" title="使用 Markdown 的优点"></a>使用 Markdown 的优点</h3><ul>
<li>专注你的文字内容而不是排版样式，安心写作。</li>
<li>轻松的导出 HTML、PDF 和本身的 .md 文件。</li>
<li>纯文本内容，兼容所有的文本编辑器与字处理软件。</li>
<li>随时修改你的文章版本，不必像字处理软件生成若干文件版本导致混乱。</li>
<li>可读、直观、学习成本低。</li>
</ul>
<h3 id="使用-Markdown-的误区"><a href="#使用-Markdown-的误区" class="headerlink" title="使用 Markdown 的误区"></a>使用 Markdown 的误区</h3><blockquote>
<p>_We believe that writing is about content, about what you want to say – not about fancy formatting._<br>我们坚信写作写的是内容，所思所想，而不是花样格式。<br>— _Ulysses for Mac_</p>
</blockquote>
<ul>
<li>Markdown 旨在简洁、高效，也由于 Markdown 的易读易写，人们用不同的编程语言实现了多个版本的解析器和生成器，这就导致了目前不同的 Markdown 工具集成了不同的功能（基础功能大致相同），例如流程图与时序图，复杂表格与复杂公式的呈现，虽然功能的丰富并没有什么本质的缺点，但终归有些背离初衷，何况在编写的过程中很费神，不如使用专业的工具撰写来的更有效率，所以如果你需实现复杂功能，专业的图形界面工具会更加方便。<strong>当然，如果你对折腾这些不同客户端对 Markdown 的定制所带来高阶功能感到愉悦的话，那也是无可厚非的。</strong></li>
</ul>
<p><img src="http://ww2.sinaimg.cn/large/6aee7dbbgw1eq320claw3j21kw0kjdpc.jpg" alt="flowchart.js on Github（使用 Markdown 绘制流程图）">  </p>
<p><a href="https://github.com/adrai/flowchart.js" target="_blank" rel="external">flowchart.js on Github（使用 Markdown 绘制流程图）</a></p>
<h3 id="我该用什么工具？"><a href="#我该用什么工具？" class="headerlink" title="我该用什么工具？"></a>我该用什么工具？</h3><p><img src="http://mouapp.com/Mou_128.png" alt="Mou for Mac">  </p>
<p>Mou for Mac </p>
<ul>
<li>在 Mac OS X 上，我强烈建议你用 <a href="http://mouapp.com" target="_blank" rel="external">Mou</a> 这款免费且十分好用的 Markdown 编辑器，它支持<strong>实时预览</strong>，既左边是你编辑 Markdown 语言，右边会实时的生成预览效果。不仅如此，Mou 还有一些有趣的偏好设置（_Preference_），例如主题（_Themes_）与样式（_CSS_），它们可以配置出定制化的文本编辑效果与导出效果，如果你对自带的主题与样式不满意还可以到 <a href="https://github.com/search?utf8=%E2%9C%93&amp;q=Mou" target="_blank" rel="external">GitHub</a> 上搜索其它爱好者为 Mou 编写的更多主题样式，导入的方式可以在偏好设置的 Themes 或 CSS 选项中 选择 reload。</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/6aee7dbbgw1effcq2gx92j210j0ustj7.jpg" alt="Mou 的编写与预览窗口">  </p>
<p>Mou 的编写与预览窗口 </p>
<p>如果你从事文字工作，我强烈建议你购买 _<a href="http://www.ulyssesapp.com" target="_blank" rel="external">Ulysses for Mac</a>_，这款软件入围了苹果 Mac App Store 的 _The Best of 2013_。它支持更多的写作格式、多文档的支持。Mou，iA writer 这些软件都是基于单文档的管理方式，而 Ulysses 支持 Folder、Filter 的管理，一个 Folder 里面可以创建多个 Sheet，Sheet 之间也可以进行 Combine 处理。 </p>
<p><img src="http://ww1.sinaimg.cn/large/6aee7dbbjw1eqgrj7suqoj217a0aiq4u.jpg" alt="Mac 上一些 Markdown 编辑器">  </p>
<p>Mac 上一些 Markdown 编辑器 </p>
<ul>
<li>由于笔者很少接触 Windows，Windows 下的 Markdown 没有过多涉猎，经朋友介绍，有两款还算不错，一款叫做 <a href="http://www.markdownpad.com" target="_blank" rel="external">MarkdownPad</a> ，另一款叫做 <a href="http://code52.org/DownmarkerWPF/" target="_blank" rel="external">MarkPad</a>。 </li>
</ul>
<ul>
<li><p>iOS 端很多 app 早已经支持了 Markdown 录入，例如 Drafts，Day One，iA writer 等，另外 Ulysses for iPad 现在已经上架，可以说是 iOS 平台最好的编辑器了。 </p>
</li>
<li><p>在 Web端，我强烈推荐<a href="http://jianshu.io" target="_blank" rel="external">简书</a>这款产品，上面有无数热爱文字的人在不停的创造，分享。在 Web 端使用 Markdown 没有比简书更舒服的地方了，同样支持左右两栏的实时预览，字体优雅，简洁。 </p>
</li>
</ul>
<p><img src="http://ww2.sinaimg.cn/large/6aee7dbbgw1effdkfijo1j21220nigth.jpg" alt="简书的编辑预览模式">  </p>
<p>简书的编辑预览模式 </p>
<h2 id="二，Markdown-语法的简要规则"><a href="#二，Markdown-语法的简要规则" class="headerlink" title="二，Markdown 语法的简要规则"></a>二，Markdown 语法的简要规则</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p><img src="http://ww1.sinaimg.cn/large/6aee7dbbgw1effeaclhiyj20eh09cwez.jpg" alt="标题">  </p>
<p>标题 </p>
<p>标题是每篇文章都需要也是最常用的格式，在 Markdown 中，如果一段文字被定义为标题，只要在这段文字前加 <code>#</code> 号即可。 </p>
<p><code># 一级标题</code></p>
<p><code>## 二级标题</code></p>
<p><code>### 三级标题</code></p>
<p>以此类推，总共六级标题，建议在井号后加一个空格，这是最标准的 Markdown 语法。 </p>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>熟悉 HTML 的同学肯定知道有序列表与无序列表的区别，在 Markdown 下，列表的显示只需要在文字前加上 <code>-</code> 或 <code>*</code> 即可变为无序列表，有序列表则直接在文字前加<code>1.</code> <code>2.</code> <code>3.</code> 符号要和文字之间加上一个字符的空格。 </p>
<p><img src="http://ww4.sinaimg.cn/large/6aee7dbbgw1effew5aftij20d80bz3yw.jpg" alt="无序列表与有序列表">  </p>
<p>无序列表与有序列表 </p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>如果你需要引用一小段别处的句子，那么就要用引用的格式。 </p>
<blockquote>
<p>例如这样 </p>
</blockquote>
<p>只需要在文本前加入 <code>&gt;</code> 这种尖括号（大于号）即可 </p>
<p><img src="http://ww3.sinaimg.cn/large/6aee7dbbgw1effezhonxlj20e009c3yu.jpg" alt="引用">  </p>
<p>引用 </p>
<h3 id="图片与链接"><a href="#图片与链接" class="headerlink" title="图片与链接"></a>图片与链接</h3><p>插入链接与插入图片的语法很像，区别在一个 <code>!</code>号 </p>
<p>图片为：<code>![](){ImgCap}{/ImgCap}</code></p>
<p>链接为：<code>[]()</code></p>
<p>插入图片的地址需要图床，这里推荐<a href="http://weibotuchuang.sinaapp.com" target="_blank" rel="external">围脖图床修复计划</a> 与 <a href="http://www.getcloudapp.com" target="_blank" rel="external">CloudApp</a> 的服务，生成URL地址即可。 </p>
<p><img src="http://ww2.sinaimg.cn/large/6aee7dbbgw1efffa67voyj20ix0ctq3n.jpg" alt="URL 与图片">  </p>
<p>URL 与图片 </p>
<h3 id="粗体与斜体"><a href="#粗体与斜体" class="headerlink" title="粗体与斜体"></a>粗体与斜体</h3><p>Markdown 的粗体和斜体也非常简单，用两个 <code>*</code> 包含一段文本就是粗体的语法，用一个 <code>*</code> 包含一段文本就是斜体的语法。 </p>
<p>例如：<strong>这里是粗体</strong> _这里是斜体_</p>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>表格是我觉得 Markdown 比较累人的地方，例子如下： </p>
<pre><code>| Tables        | Are           | Cool  |
| ------------- |:-------------:| -----:|
| col 3 is      | right-aligned | $1600 |
| col 2 is      | centered      |   $12 |
| zebra stripes | are neat      |    $1 |
</code></pre><p>这种语法生成的表格如下： </p>
<p>TablesAreCool</p>
<p>col 3 is<br>right-aligned<br>$1600 </p>
<p>col 2 is<br>centered<br>$12 </p>
<p>zebra stripes<br>are neat<br>$1 </p>
<h3 id="代码框"><a href="#代码框" class="headerlink" title="代码框"></a>代码框</h3><p>如果你是个程序猿，需要在文章里优雅的引用代码框，在 Markdown下实现也非常简单，只需要用两个 ` 把中间的代码包裹起来。图例： </p>
<p><img src="http://ww3.sinaimg.cn/large/6aee7dbbgw1effg1lsa97j20lt0a8dgs.jpg" alt="">  </p>
<p>使用 <code>tab</code> 键即可缩进。 </p>
<h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>分割线的语法只需要三个 <code>*</code> 号，例如： </p>
<hr>
<blockquote>
<p>到这里，Markdown 的基本语法在日常的使用中基本就没什么大问题了，只要多加练习，配合好用的工具，写起东西来肯定会行云流水。更多的语法规则，其实 Mou 的 Help 文档栗子很好，当你第一次使用 Mou 时，就会显示该文档。可以用来对用的查找和学习。 </p>
</blockquote>
<p><img src="http://ww3.sinaimg.cn/large/6aee7dbbgw1effgmnpgqlj210j0us44j.jpg" alt="">  </p>
<h2 id="三，相关推荐"><a href="#三，相关推荐" class="headerlink" title="三，相关推荐:"></a><strong>三，相关推荐</strong>:</h2><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a><strong>工具</strong></h3><p>_图床工具用来上传图片获取 URL 地址_</p>
<ul>
<li><a href="http://droplr.com" target="_blank" rel="external">Droplr</a></li>
<li><a href="http://www.getcloudapp.com" target="_blank" rel="external">Cloudapp</a></li>
<li><a href="https://itunes.apple.com/cn/app/yi-xiang/id672522335?mt=12&amp;uo=4" target="_blank" rel="external">ezShare for Mac</a></li>
<li><a href="http://weibotuchuang.sinaapp.com" target="_blank" rel="external">围脖图床修复计划</a></li>
</ul>
<p>_在线好用的Markdown工具，为印象笔记而生_</p>
<ul>
<li><a href="http://maxiang.info" target="_blank" rel="external">马克飞象，专为印象笔记打造的Markdown编辑器，非常推荐</a></li>
</ul>
<h3 id="相关文章阅读："><a href="#相关文章阅读：" class="headerlink" title="相关文章阅读："></a><strong>相关文章阅读</strong>：</h3><ul>
<li><a href="http://jianshu.io/p/qqgjln" target="_blank" rel="external">为什么作家应该用 Markdown 保存自己的文稿</a></li>
</ul>
<ul>
<li><a href="http://www.yangzhiping.com/tech/r-markdown-knitr.html" target="_blank" rel="external">Markdown写作浅谈</a></li>
</ul>
<ul>
<li><a href="http://www.appinn.com/markdown-tools/" target="_blank" rel="external">Markdown 工具补完</a></li>
<li><a href="http://jianshu.io/p/63HYZ6" target="_blank" rel="external">Drafts + Scriptogr.am + Dropbox 打造移动端 Markdown 风格博客</a></li>
<li><a href="http://www.ituring.com.cn/article/23" target="_blank" rel="external">图灵社区，怎样使用Markdown</a></li>
<li><a href="http://news.cnblogs.com/n/139649/" target="_blank" rel="external">为什么我们要学习Markdown的三个理由</a></li>
<li><a href="http://ibuick.me/?p=4093" target="_blank" rel="external">Markdown 语法写作入门指南 by ibuick</a></li>
</ul>
<hr>
]]></content>
      
        <categories>
            
            <category> 杂记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Centos搭建LNMP环境]]></title>
      <url>/2017/06/21/%E9%82%A3%E4%BA%9B%E5%B9%B4%E5%80%92%E8%85%BE%E8%BF%87%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8/Centos%20LNMP/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a> 
<p><strong>1. 安装关联库</strong></p>
<pre><code># mkdir -p /data/tgz
# cd /data/tgz
# yum install wget
# yum install pcre
# yum install openssl*
# yum install tar
# yum -y install gcc gcc-c++ autoconf libjpeg libjpeg-devel libpng libpng-devel freetype freetype-devel libxml2 libxml2-devel zlib zlib-devel glibc glibc-devel glib2 glib2-devel bzip2 bzip2-devel ncurses ncurses-devel curl curl-devel e2fsprogs e2fsprogs-devel krb5 krb5-devel libidn libidn-devel openssl openssl-devel openldap openldap-devel nss_ldap openldap-clients openldap-servers make gd gd2 gd-devel gd2-devel

# ulimit -SHn 65535
# wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.36.tar.gz
# tar zxvf pcre-8.36.tar.gz
# cd pcre-8.36
# ./configure --prefix=/data/apps/pcre
# make &amp;&amp; make install
# cd ../
</code></pre><p><strong>  
</strong></p>
<p><strong>2. 安装nginx</strong>  </p>
<pre><code># /usr/sbin/groupadd nginx
# /usr/sbin/useradd -g nginx nginx

# wget http://nginx.org/download/nginx-1.7.9.tar.gz
# tar zxvf nginx-1.7.9.tar.gz
# cd nginx-1.7.9
# ./configure --user=nginx --group=nginx --prefix=/data/apps/nginx --with-http_stub_status_module --with-http_ssl_module --with-pcre=/data/tgz/pcre-8.36 --with-http_realip_module --with-http_image_filter_module
# make &amp;&amp; make install
# cd ../
</code></pre><p><strong>  
</strong></p>
<p><strong>3. 安装MySQL</strong></p>
<pre><code># /usr/sbin/groupadd mysql
# /usr/sbin/useradd -g mysql mysql

# wget http://dev.mysql.com/get/Downloads/MySQL-5.6/mysql-5.6.25-linux-glibc2.5-x86_64.tar.gz
# tar zxvf mysql-5.6.22-linux-glibc2.5-x86_64.tar.gz
# mv mysql-5.6.22-linux-glibc2.5-x86_64 /data/apps/mysql
</code></pre><p><strong>    配置运行MySQL</strong></p>
<pre><code>1）创建数据库存放目录  


# mkdir -p /data/data/mysql/data
# mkdir -p /data/data/mysql/binlog/
# mkdir -p /data/data/mysql/relaylog/
# chown -R mysql:mysql /data/data/mysql/
# yum install libaio


2）创建mysql配置文件  


# vi /etc/my.cnf


    输入以下内容

[client]
port    = 3306
socket  = /tmp/mysql.sock

[mysqld]
character-set-server = utf8
replicate-ignore-db = mysql
replicate-ignore-db = test
replicate-ignore-db = information_schema
user    = mysql
port    = 3306
socket  = /tmp/mysql.sock
basedir = /data/apps/mysql
datadir = /data/data/mysql/data
log-error = /data/data/mysql/mysql_error.log
pid-file = /data/data/mysql/mysql.pid
open_files_limit    = 10240
back_log = 600
max_connections = 5000
max_connect_errors = 6000
external-locking = FALSE
max_allowed_packet = 32M
sort_buffer_size = 1M
join_buffer_size = 1M
thread_cache_size = 300
#thread_concurrency = 8
query_cache_size = 512M
query_cache_limit = 2M
query_cache_min_res_unit = 2k
default-storage-engine = MyISAM
thread_stack = 192K
transaction_isolation = READ-COMMITTED
tmp_table_size = 246M
max_heap_table_size = 246M
long_query_time = 3
log-slave-updates
log-bin = /data/data/mysql/binlog/binlog
binlog_cache_size = 4M
binlog_format = MIXED
max_binlog_cache_size = 8M
max_binlog_size = 1G
relay-log-index = /data/data/mysql/relaylog/relaylog
relay-log-info-file = /data/data/mysql/relaylog/relaylog
relay-log = /data/data/mysql/relaylog/relaylog
expire_logs_days = 30
key_buffer_size = 256M
read_buffer_size = 1M
read_rnd_buffer_size = 16M
bulk_insert_buffer_size = 64M
myisam_sort_buffer_size = 128M
myisam_max_sort_file_size = 10G
myisam_repair_threads = 1
myisam_recover

interactive_timeout = 120
wait_timeout = 120

skip-name-resolve
#master-connect-retry = 10
slave-skip-errors = 1032,1062,126,1114,1146,1048,1396

server-id = 1

innodb_additional_mem_pool_size = 16M
innodb_buffer_pool_size = 512M
innodb_data_file_path = ibdata1:256M:autoextend
innodb_file_io_threads = 4
innodb_thread_concurrency = 8
innodb_flush_log_at_trx_commit = 2
innodb_log_buffer_size = 16M
innodb_log_file_size = 128M
innodb_log_files_in_group = 3
innodb_max_dirty_pages_pct = 90
innodb_lock_wait_timeout = 120
innodb_file_per_table = 0

slow-query-log-file = /data/data/mysql/slow.log
long_query_time = 10

[mysqldump]
quick
max_allowed_packet = 32M


3）以mysql用户帐号的身份建立数据表 

# /data/apps/mysql/scripts/mysql_install_db --basedir=/data/apps/mysql --datadir=/data/data/mysql/data --user=mysql
# sed -i &quot;s#/usr/local/mysql#/data/apps/mysql#g&quot; /data/apps/mysql/bin/mysqld_safe


4）创建mysql启动，重启，停止shell脚本  


# vi /data/apps/mysql/mysql


    输入以下内容（这里的用户名admin和密码12345678接下来的步骤会创建）

#!/bin/sh

mysql_port=3306
mysql_username=&quot;admin&quot;
mysql_password=&quot;12345678&quot;

function_start_mysql()
{
    printf &quot;Starting MySQL...\n&quot;
    /bin/sh /data/apps/mysql/bin/mysqld_safe --defaults-file=/etc/my.cnf 2&gt;&amp;1 &gt; /dev/null &amp;
}

function_stop_mysql()
{
    printf &quot;Stoping MySQL...\n&quot;
    /data/apps/mysql/bin/mysqladmin -u ${mysql_username} -p${mysql_password} -S /tmp/mysql.sock shutdown
}

function_restart_mysql()
{
    printf &quot;Restarting MySQL...\n&quot;
    function_stop_mysql
    sleep 5
    function_start_mysql
}

function_kill_mysql()
{
    kill -9 $(ps -ef | grep &#39;bin/mysqld_safe&#39; | grep ${mysql_port} | awk &#39;{printf $2}&#39;)
    kill -9 $(ps -ef | grep &#39;libexec/mysqld&#39; | grep ${mysql_port} | awk &#39;{printf $2}&#39;)
}

if [ &quot;$1&quot; = &quot;start&quot; ]; then
    function_start_mysql
elif [ &quot;$1&quot; = &quot;stop&quot; ]; then
    function_stop_mysql
elif [ &quot;$1&quot; = &quot;restart&quot; ]; then
function_restart_mysql
elif [ &quot;$1&quot; = &quot;kill&quot; ]; then
function_kill_mysql
else
    printf &quot;Usage: /data/data/mysql/mysql {start|stop|restart|kill}\n&quot;
fi


5）赋予shell脚本可执行权限  


# chmod +x /data/apps/mysql/mysql


6）启动MySQL  


# /data/apps/mysql/mysql start


7）通过命令行登录管理MySQL服务器（提示输入密码时直接回车） 

# /data/apps/mysql/bin/mysql -uroot -p -S /tmp/mysql.sock


8）输入以下SQL语句，创建一个具有root权限的用户（admin）和密码（12345678） 

&gt; GRANT ALL PRIVILEGES ON *.* TO &#39;admin&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;12345678&#39;;
&gt; GRANT ALL PRIVILEGES ON *.* TO &#39;admin&#39;@&#39;127.0.0.1&#39; IDENTIFIED BY &#39;12345678&#39;;
&gt; quit
</code></pre><p>![blob.png][2]</p>
<p>   [2]: <a href="http://www.vckai.com/static/up/image/20150101/1420523394.png" target="_blank" rel="external">http://www.vckai.com/static/up/image/20150101/1420523394.png</a> ()</p>
<pre><code>9）（可选）重启/停止MySQL 

# /data/apps/mysql/mysql restart
# /data/apps/mysql/mysql stop
</code></pre><p><strong>  
</strong></p>
<p><strong>4. 编译安装PHP依赖库</strong>  </p>
<pre><code># mkdir -p /data/apps/libs/

# wget http://www.ijg.org/files/jpegsrc.v9.tar.gz   
# tar zxvf jpegsrc.v9.tar.gz
# cd jpeg-9/
# ./configure --prefix=/data/apps/libs --enable-shared --enable-static
# make &amp;&amp; make install
# cd ../

# wget http://prdownloads.sourceforge.net/libpng/libpng-1.6.2.tar.gz
# tar zxvf libpng-1.6.2.tar.gz
# cd libpng-1.6.2/
# ./configure --prefix=/data/apps/libs
# make &amp;&amp; make install
# cd ../

# wget http://download.savannah.gnu.org/releases/freetype/freetype-2.4.12.tar.gz
# tar zxvf freetype-2.4.12.tar.gz
# cd freetype-2.4.12/
# ./configure --prefix=/data/apps/libs
# make &amp;&amp; make install
# cd ../


# wget --content-disposition &quot;http://downloads.sourceforge.net/mhash/mhash-0.9.9.9.tar.gz?big_mirror=0&quot;
# wget --content-disposition &quot;http://downloads.sourceforge.net/mcrypt/libmcrypt-2.5.8.tar.gz?big_mirror=0&quot;
# wget --content-disposition &quot;http://downloads.sourceforge.net/mcrypt/mcrypt-2.6.8.tar.gz?big_mirror=0&quot;

# tar zxvf libmcrypt-2.5.8.tar.gz
# cd libmcrypt-2.5.8/
# ./configure --prefix=/data/apps/libs
# make &amp;&amp; make install
# cd libltdl/
# ./configure --prefix=/data/apps/libs --enable-ltdl-install
# make &amp;&amp; make install
# cd ../../

# tar zxvf mhash-0.9.9.9.tar.gz
# cd mhash-0.9.9.9/
# ./configure --prefix=/data/apps/libs
# make &amp;&amp; make install
# cd ../

# vi /etc/ld.so.conf


    在文件末尾添加以下内容  


/data/apps/libs/lib


    重新加载该文件，使其即刻生效  


# ldconfig


# tar zxvf mcrypt-2.6.8.tar.gz
# cd mcrypt-2.6.8/
# export LDFLAGS=&quot;-L/data/apps/libs/lib -L/usr/lib&quot;
# export CFLAGS=&quot;-I/data/apps/libs/include -I/usr/include&quot;
# touch malloc.h
# ./configure --prefix=/data/apps/libs --with-libmcrypt-prefix=/data/apps/libs
# make &amp;&amp; make install
# cd ../
</code></pre><p><strong>  
</strong></p>
<p><strong>5. 安装PHP</strong>  </p>
<pre><code># wget --content-disposition http://cn2.php.net/get/php-5.6.4.tar.gz/from/this/mirror
# tar zxvf php-5.6.4.tar.gz
# cd php-5.6.4/
# export LIBS=&quot;-lm -ltermcap -lresolv&quot;
# export DYLD_LIBRARY_PATH=&quot;/data/apps/mysql/lib/:/lib/:/usr/lib/:/usr/local/lib:/lib64/:/usr/lib64/:/usr/local/lib64&quot;
# export LD_LIBRARY_PATH=&quot;/data/apps/mysql/lib/:/lib/:/usr/lib/:/usr/local/lib:/lib64/:/usr/lib64/:/usr/local/lib64&quot;
# ./configure --prefix=/data/apps/php --with-config-file-path=/data/apps/php/etc --with-mysql=/data/apps/mysql --with-mysqli=/data/apps/mysql/bin/mysql_config --with-iconv-dir --with-freetype-dir=/data/apps/libs --with-jpeg-dir=/data/apps/libs --with-png-dir=/data/apps/libs --with-zlib --with-libxml-dir=/usr --enable-xml --disable-rpath --enable-bcmath --enable-shmop --enable-sysvsem --enable-inline-optimization --with-curl --enable-mbregex --enable-fpm --enable-mbstring --with-mcrypt=/data/apps/libs --with-gd --enable-gd-native-ttf --with-openssl --with-mhash --enable-pcntl --enable-sockets --with-xmlrpc --enable-zip --enable-soap --enable-opcache --with-pdo-mysql --enable-maintainer-zts
# make &amp;&amp; make install
# cp php.ini-development /data/apps/php/etc/php.ini
# cd ../
</code></pre><p><strong>  
</strong></p>
<p><strong>6. 安装PHP扩展</strong></p>
<pre><code># wget http://ftp.gnu.org/gnu/autoconf/autoconf-latest.tar.gz
# tar zxvf autoconf-latest.tar.gz
# cd autoconf-2.69/
# ./configure --prefix=/data/apps/libs
# make &amp;&amp; make install
# cd ../

# wget http://pecl.php.net/get/memcache-2.2.7.tgz
# tar zxvf memcache-2.2.7.tgz
# cd memcache-2.2.7/
# export PHP_AUTOCONF=&quot;/data/apps/libs/bin/autoconf&quot;
# export PHP_AUTOHEADER=&quot;/data/apps/libs/bin/autoheader&quot;
# /data/apps/php/bin/phpize
# ./configure --with-php-config=/data/apps/php/bin/php-config
# make &amp;&amp; make install
# cd ../
</code></pre><p>![blob.png][3]</p>
<p>   [3]: <a href="http://www.vckai.com/static/up/image/20150101/1420527473.png" target="_blank" rel="external">http://www.vckai.com/static/up/image/20150101/1420527473.png</a> ()</p>
<pre><code>1）php.ini配置文件中添加memcache扩展  


# vi /data/apps/php/etc/php.ini


    在文件末尾添加以下内容  


extension_dir=&quot;/data/apps/php/lib/php/extensions/no-debug-zts-20131226/&quot;
extension=memcache.so
</code></pre><p><strong>7. 启动nginx+php</strong></p>
<pre><code>mysql的启动就不在这里多说，可参考上面。  


1）调整nginx配置文件(这里只是最简单的可运行php的nginx的配置,详细的自行)**  
</code></pre><p>**</p>
<pre><code># mv /data/apps/nginx/conf/nginx.conf /data/apps/nginx/conf/nginx.conf.default
# vi /data/apps/nginx/conf/nginx.conf


    输入以下内容  


user  nginx;
worker_processes  1;

events {
    worker_connections  1024;
}

http {
    include       mime.types;
    default_type  application/octet-stream;

    sendfile        on;

    keepalive_timeout  65;

    server {
        listen       80;
        server_name  localhost;
        root /data/www;

        location / {
            index  index.html index.htm index.php;
        }

        location ~ \.php$ {
            fastcgi_pass   127.0.0.1:9000;
            fastcgi_index  index.php;
            include        fastcgi.conf;
        }
    }
}


2）创建web目录 

# mkdir -p /data/www
# chown -R nginx:nginx /data/www


3）启动nginx  


# /data/apps/nginx/sbin/nginx


4）启动php-fpm  


# /data/apps/php/sbin/php-fpm
</code></pre><p>OK，现在已经安装完成了，可以在浏览器中输入<a href="http://localhost" target="_blank" rel="external">http://localhost</a>访问你的网站了！ </p>
]]></content>
      
        <categories>
            
            <category> 那些年倒腾过的服务器 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> lnmp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Alamofire 中文使用指南]]></title>
      <url>/2017/06/14/iOS/Alamofire%20%E4%B8%AD%E6%96%87%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><hr>
<p>Alamofire 4.0 是 Alamofire 最新的一个大版本更新, 一个基于 Swift 的 iOS, tvOS, macOS, watchOS 的 HTTP 网络库. 作为一个大版本更新, 就像语义上那样, 4.0 的 API 引入了一些破坏性修改. </p>
<p>这篇导引旨在帮助大家从 Alamofire 3.x 平滑过渡到最新版本, 同时也解释一下新的设计和结构, 以及功能上的更新.<br><a id="more"></a> </p>
<h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><ul>
<li><p>iOS 8.0+, macOS 10.10.0+, tvOS 9.0+ 以及 watchOS 2.0+ </p>
</li>
<li><p>Xcode 8.1+ </p>
</li>
<li><p>Swift 3.0+ </p>
</li>
</ul>
<p>那些想要在 iOS 8 或者 macOS 10.9 使用 Alamofire 的, 请使用 3.x 版本的最新 release(同时支持 Swift 2.2以及2.3) </p>
<h2 id="升级的好处"><a href="#升级的好处" class="headerlink" title="升级的好处"></a>升级的好处</h2><ul>
<li><strong>完美适配 Swift 3:</strong> 跟进了新的 <a href="https://swift.org/documentation/api-design-guidelines/" target="_blank" rel="external">API 设计规范</a>. </li>
</ul>
<ul>
<li><strong>新的错误处理系统:</strong> 根据提案 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0112-nserror-bridging.md" target="_blank" rel="external">SE-0112</a> 里的新模式, 新增了 <code>AFError</code> 类型. </li>
</ul>
<ul>
<li><p><strong>新的 <code>RequestAdapter</code> 协议:</strong> 可以在初始化 <code>Request</code> 的时候进行快速便捷的适配, 例如在请求头里加入 <code>Authorization</code></p>
</li>
<li><p><strong>新的 <code>RequestRetrier</code> 协议:</strong> 可以检测并且重试失败的 <code>Request</code>, 甚至可以自己根据一系列需求去构建一套验证的解决方案( OAuth1, OAuth2, xAuth, Basic Auth 之类的). </p>
</li>
<li><p><strong>新的 <code>Parameter Encoding</code> 协议:</strong> 取代掉之前的 <code>ParameterEncoding</code> 枚举, 允许你更简单的拓展和自定义, 并且在错误时抛出异常, 而不是简单的返回一个元组. </p>
</li>
<li><p><strong>新的请求类型:</strong> 包括 <code>DataRequest</code>, <code>DownloadRequest</code>, <code>UploadRequest</code> 和 <code>StreamRequest</code>, 实现了特定的进度, 验证和序列化的 API 以及各自的 <code>Request</code> 类型. </p>
</li>
<li><p><strong>新的进度 API:</strong> 包括 <code>downloadProgress</code> 和 <code>uploadProgress</code>, 支持 <code>progress</code> 和 <code>Int64</code> 类型, 并且会在指定的线程运行, 默认为主线程. </p>
</li>
<li><p><strong>更强大的数据验证:</strong> 在验证失败的时候, 包括 <code>data</code> 或者 <code>temporaryURL</code> 和 <code>destinationURL</code> 都可以使用内联的闭包去转化服务器返回的错误信息 </p>
</li>
<li><p><strong>新的下载地址处理:</strong> 你可以获得完整的控制权, 而不是像之前那样只是提供一个 <code>destinationURL</code>, 还得创建临时文件夹, 删掉之前的文件. </p>
</li>
<li><p><strong>新的 <code>Response</code> 类型:</strong> 统一 response 的 API, 并且为所有下载任务提供 <code>temporaryURL</code> 和 <code>downloadURL</code>, 以及其它新平台上的任务属性. </p>
</li>
</ul>
<h2 id="API-破坏性的修改"><a href="#API-破坏性的修改" class="headerlink" title="API 破坏性的修改"></a>API 破坏性的修改</h2><p>Alamofire 4 跟进了 Swift 3 里所有的修改, 包括 <a href="https://swift.org/documentation/api-design-guidelines/" target="_blank" rel="external">API 设计规范</a>. 因此, 几乎所有 Alamofire 的 API 都进行了一定程度的修改. 我们没办法把这些修改全部在文档里列出来, 所以我们会把最常用的那些 API 列出来, 然后告诉大家这些 API 进行了哪些修改, 而不是指望那些有时帮倒忙的编译错误提示. </p>
<h3 id="命名空间的修改"><a href="#命名空间的修改" class="headerlink" title="命名空间的修改"></a>命名空间的修改</h3><p>一些常用的类移到了全局命名空间成为一级类, 让他们更容易使用. </p>
<ul>
<li><p><code>Manager</code> 改为 <code>SessionManager</code></p>
</li>
<li><p><code>Request.TaskDelegate</code> 改为 <code>TaskDelegate</code></p>
</li>
<li><p><code>Request.DataTaskDelegate</code> 改为 <code>DataTaskDelegate</code></p>
</li>
<li><p><code>Request.DownloadTaskDelegate</code> 改为 <code>DownloadTaskDelegate</code></p>
</li>
<li><p><code>Request.UploadTaskDelegate</code> 改为 <code>UploadTaskDelegate</code></p>
</li>
</ul>
<p>我们也重新调整了文件结构和组织模式, 帮助更好的跟进代码. 我们希望这可以让更多用户去了解内部结构和 Alamofire 的具体实现. 只是就是力量. </p>
<h3 id="生成请求"><a href="#生成请求" class="headerlink" title="生成请求"></a>生成请求</h3><p>生成请求是 Alamofire 里最主要的操作, 这里有 3.x 以及 4 的等效代码对比. </p>
<h4 id="Data-Request-Simple-with-URL-string"><a href="#Data-Request-Simple-with-URL-string" class="headerlink" title="Data Request - Simple with URL string"></a>Data Request - Simple with URL string</h4><pre><code>// Alamofire 3
Alamofire.request(.GET, urlString).response { request, response, data, error in
    print(request)
    print(response)
    print(data)
    print(error)
}

// Alamofire 4
Alamofire.request(urlString).response { response in // 默认为 `.get` 方法
    debugPrint(response)
}
</code></pre><h4 id="Data-Request-Complex-with-URL-string"><a href="#Data-Request-Complex-with-URL-string" class="headerlink" title="Data Request - Complex with URL string"></a>Data Request - Complex with URL string</h4><pre><code>// Alamofire 3
let parameters: [String: AnyObject] = [&quot;foo&quot;: &quot;bar&quot;]

Alamofire.request(.GET, urlString, parameters: parameters, encoding: .JSON)
        .progress { bytesRead, totalBytesRead, totalBytesExpectedToRead in
                print(&quot;Bytes: \(bytesRead), Total Bytes: \(totalBytesRead), Total Bytes Expected: \(totalBytesExpectedToRead)&quot;)
        }
        .validate { request, response in
                // 自定义的校验闭包 (访问不到服务器返回的数据)
            return .success
        }
    .responseJSON { response in
                debugPrint(response)
        }

// Alamofire 4
let parameters: Parameters = [&quot;foo&quot;: &quot;bar&quot;]

Alamofire.request(urlString, method: .get, parameters: parameters, encoding: JSONEncoding.default)
        .downloadProgress(queue: DispatchQueue.global(qos: .utility)) { progress in
                print(&quot;进度: \(progress.fractionCompleted)&quot;)
        }
        .validate { request, response, data in
                // 自定义的校验闭包, 现在加上了 `data` 参数(允许你提前转换数据以便在必要时挖掘到错误信息)
            return .success
        }
    .responseJSON { response in
                debugPrint(response)
        }
</code></pre><h4 id="Download-Request-Simple-With-URL-string"><a href="#Download-Request-Simple-With-URL-string" class="headerlink" title="Download Request - Simple With URL string"></a>Download Request - Simple With URL string</h4><pre><code>// Alamofire 3
let destination = DownloadRequest.suggestedDownloadDestination()

Alamofire.download(.GET, urlString, destination: destination).response { request, response, data, error in
      // fileURL 在哪, 怎么获取?
    print(request)
    print(response)
    print(data)
    print(error)
}

// Alamofire 4
let destination = DownloadRequest.suggestedDownloadDestination()

Alamofire.download(urlString, to: destination).response { response in // 默认为 `.get` 方法
    print(response.request)
    print(response.response)
        print(response.temporaryURL)
        print(response.destinationURL)
    print(response.error)
}
</code></pre><h4 id="Download-Request-Simple-With-URLRequest"><a href="#Download-Request-Simple-With-URLRequest" class="headerlink" title="Download Request - Simple With URLRequest"></a>Download Request - Simple With URLRequest</h4><pre><code>// Alamofire 3
let destination = DownloadRequest.suggestedDownloadDestination()

Alamofire.download(urlRequest, destination: destination).validate().responseData { response in
      // fileURL 在哪里, 太难获取了
        debugPrint(response)
}

// Alamofire 4
Alamofire.download(urlRequest, to: destination).validate().responseData { response in
        debugPrint(response)
        print(response.temporaryURL)
        print(response.destinationURL)
}
</code></pre><h4 id="Download-Request-Complex-With-URL-String"><a href="#Download-Request-Complex-With-URL-String" class="headerlink" title="Download Request - Complex With URL String"></a>Download Request - Complex With URL String</h4><pre><code>// Alamofire 3
let fileURL: NSURL
let destination: Request.DownloadFileDestination = { _, _ in fileURL }
let parameters: [String: AnyObject] = [&quot;foo&quot;: &quot;bar&quot;]

Alamofire.download(.GET, urlString, parameters: parameters, encoding: .JSON, to: destination)
        .progress { bytesRead, totalBytesRead, totalBytesExpectedToRead in
                print(&quot;Bytes: \(bytesRead), Total Bytes: \(totalBytesRead), Total Bytes Expected: \(totalBytesExpectedToRead)&quot;)
        }
        .validate { request, response in
                // 自定义的校验实现(获取不到临时下载位置和目标下载位置)
            return .success
        }
        .responseJSON { response in
                print(fileURL) // 只有在闭包捕获了的情况才能获取到, 不够理想
                debugPrint(response)
        }

// Alamofire 4
let fileURL: URL
let destination: DownloadRequest.DownloadFileDestination = { _, _ in
        return (fileURL, [.createIntermediateDirectories, .removePreviousFile])
}
let parameters: Parameters = [&quot;foo&quot;: &quot;bar&quot;]

Alamofire.download(urlString, method: .get, parameters: parameters, encoding: JSONEncoding.default, to: destination)
        .downloadProgress(queue: DispatchQueue.global(qos: .utility)) { progress in
                print(&quot;进度: \(progress.fractionCompleted)&quot;)
        }
        .validate { request, response, temporaryURL, destinationURL in
                // 自定义的校验闭包, 现在包含了 fileURL (必要时可以获取到错误信息)
            return .success
        }
        .responseJSON { response in
                debugPrint(response)
                print(response.temporaryURL)
                print(response.destinationURL)
        }
</code></pre><h4 id="Upload-Request-Simple-With-URL-string"><a href="#Upload-Request-Simple-With-URL-string" class="headerlink" title="Upload Request - Simple With URL string"></a>Upload Request - Simple With URL string</h4><pre><code>// Alamofire 3
Alamofire.upload(.POST, urlString, data: data).response { request, response, data, error in
    print(request)
    print(response)
    print(data)
    print(error)
}

// Alamofire 4
Alamofire.upload(data, to: urlString).response { response in // 默认为 `.post` 方法
    debugPrint(response)
}
</code></pre><h4 id="Upload-Request-Simple-With-URLRequest"><a href="#Upload-Request-Simple-With-URLRequest" class="headerlink" title="Upload Request - Simple With URLRequest"></a>Upload Request - Simple With URLRequest</h4><pre><code>// Alamofire 3
Alamofire.upload(urlRequest, file: fileURL).validate().responseData { response in
        debugPrint(response)
}

// Alamofire 4
Alamofire.upload(fileURL, with: urlRequest).validate().responseData { response in
        debugPrint(response)
}
</code></pre><h4 id="Upload-Request-Complex-With-URL-string"><a href="#Upload-Request-Complex-With-URL-string" class="headerlink" title="Upload Request - Complex With URL string"></a>Upload Request - Complex With URL string</h4><pre><code>// Alamofire 3
Alamofire.upload(.PUT, urlString, file: fileURL)
        .progress { bytes, totalBytes, totalBytesExpected in
                // 这里的进度是上传还是下载的?
                print(&quot;Bytes: \(bytesRead), Total Bytes: \(totalBytesRead), Total Bytes Expected: \(totalBytesExpectedToRead)&quot;)
        }
        .validate { request, response in
                // 自定义的校验实现(获取不到服务端的数据)
            return .success
        }
        .responseJSON { response in
                debugPrint(response)
        }

// Alamofire 4
Alamofire.upload(fileURL, to: urlString, method: .put)
        .uploadProgress(queue: DispatchQueue.global(qos: .utility)) { progress in
                print(&quot;上传进度: \(progress.fractionCompleted)&quot;)
        }
        .downloadProgress { progress in // 默认在主队列调用
                print(&quot;下载进度: \(progress.fractionCompleted)&quot;)
        }
        .validate { request, response, data in
                // 自定义的校验闭包, 现在加上了 `data` 参数(允许你提前转换数据以便在必要时挖掘到错误信息)
            return .success
        }
    .responseJSON { response in
                debugPrint(response)
        }
</code></pre><p>就像你看到的, 有很多 API 破坏性的修改, 但常用的 API 还是沿用了原来的设计, 但现在能够通过一行代码去生成更多更复杂的请求, 保持秩序的同时更加简洁. </p>
<h3 id="URLStringConvertible-协议"><a href="#URLStringConvertible-协议" class="headerlink" title="URLStringConvertible 协议"></a>URLStringConvertible 协议</h3><p><code>URLStringConvertible</code> 协议有两个很小的改变. </p>
<h4 id="URLConvertible"><a href="#URLConvertible" class="headerlink" title="URLConvertible"></a>URLConvertible</h4><p>第一个没什么了不起的”大”改变就是 <code>URLStringConvertible</code> 已经被重命名为 <code>URLConvertible</code>. 在 3.x 里, <code>URLStringConvertible</code> 的定义是这样子的: </p>
<pre><code>public protocol URLStringConvertible {
    var URLString: String { get }
}
</code></pre><p>现在在 Alamofire 4 里, <code>URLConvertible</code> 协议是这样定义的: </p>
<pre><code>public protocol URLConvertible {
    func asURL() throws -&gt; URL
}
</code></pre><p>就像你看到的, <code>URLString</code> 属性完全去掉了, 然后换成了可能会抛出异常的 <code>asURL</code> 方法. 为了解释这样做的原因, 我们先回顾一下. </p>
<p>Alamofire 一个最最常见的问题就是用户忘了对 URL 进行百分号编码, 导致 Alamofire 崩溃掉. 直到现在, 我们(Alamofire 团队)的态度都是 Alamofire 就是这么设计的, 而你的 URL 必须遵守 <a href="https://tools.ietf.org/html/rfc2396" target="_blank" rel="external">RFC 2396 协议</a>. 但这对于社区来说并不那么好, 因为我们更希望 Alamofire 告诉我们的 URL 是不合法的而不是直接 crash 掉. </p>
<p>现在, 回到新的 <code>URLConvertible</code> 协议. Alamofire 之所以不能安全地处理不合规范的 URL 字符串, 事实上是因为 <code>URLStringConvertible</code> 安全性的缺失. Alamofire 不可能知道你是怎么造出一个不合法的 URL. 所以, 如果 <code>URL</code> 不能通通过 <code>URLConvertible</code> 被创建的话, 一个 <code>AFError.invalidURL</code> 的异常就会被抛出. </p>
<p>这个修改(以及其它很多修改都)可以让 Alamofire 安全地处理不合理的 URL, 并且会在回调里抛出异常. </p>
<h4 id="URLRequest-Conformance"><a href="#URLRequest-Conformance" class="headerlink" title="URLRequest Conformance"></a>URLRequest Conformance</h4><p><code>URLRequest</code> 不再遵守 <code>URLStringConvertible</code>, 现在是 <code>URLConvertible</code>. 但这也只是之前版本的一个延展而已, 并不那么重要. 不过这很可能会让 Alamofire 的 API 产生歧义. 因此, <code>URLRequest</code> 不再遵守 <code>URLStringConvertible</code>. </p>
<p>这意味着你不能在代码里像这样子做了: </p>
<pre><code>let urlRequest = URLRequest(url: URL(string: &quot;https://httpbin.org/get&quot;)!)
let urlString = urlRequest.urlString
</code></pre><p>在 Alamofire 4里, 你应该这么做: </p>
<pre><code>let urlRequest = URLRequest(url: URL(string: &quot;https://httpbin.org/get&quot;)!)
let urlString = urlRequest.url?.absoluteString
</code></pre><blockquote>
<p>查看 <a href="https://github.com/Alamofire/Alamofire/pull/1505" target="_blank" rel="external">PR-1505</a> 以获取更多信息. </p>
</blockquote>
<h3 id="URLRequestConvertible"><a href="#URLRequestConvertible" class="headerlink" title="URLRequestConvertible"></a>URLRequestConvertible</h3><p>在 3.x 里, <code>URLRequestConvertible</code> 也会产生相同的歧义问题, 之前的 <code>URLRequestConvertible</code> 是这么定义的: </p>
<pre><code>public protocol URLRequestConvertible {
    var URLRequest: URLRequest { get }
}
</code></pre><p>现在, 在 Alamofire 4 里, 变成了这样子: </p>
<pre><code>public protocol URLRequestConvertible {
    func asURLRequest() throws -&gt; URLRequest
}
</code></pre><p>就像看到的这样, <code>URLRequest</code> 属性被替换成了 <code>asURLRequest</code> 方法, 并且在生成 <code>URLRequest</code> 失败时会抛出异常. </p>
<p>这影响最大的可能是采用了 <code>Router</code> (路由)设计的你, 如果你用了 <code>Router</code>, 那你就不得不去改变, 但会变得更好! 你需要去实现 <code>asURLRequest</code> 方法, 在必要的时候会抛出异常. 你不再需要强制解包数据和参数, 或者在 do-catch 里构建一个 <code>ParameterEncoding</code>. 现在 <code>Router</code> 抛出的任何错误都可以由 Alamofire 帮你处理掉. </p>
<blockquote>
<p>查看 <a href="https://github.com/Alamofire/Alamofire/pull/1505" target="_blank" rel="external">PR-1505</a> 以获取更多信息. </p>
</blockquote>
<h2 id="新功能"><a href="#新功能" class="headerlink" title="新功能"></a>新功能</h2><h3 id="Request-Adapter-请求适配器"><a href="#Request-Adapter-请求适配器" class="headerlink" title="Request Adapter (请求适配器)"></a>Request Adapter (请求适配器)</h3><p><code>RequestAdapter</code> 协议是 Alamofire 4 里的全新功能. </p>
<pre><code>public protocol RequestAdapter {
    func adapt(_ urlRequest: URLRequest) throws -&gt; URLRequest
}
</code></pre><p>它可以让每一个 <code>SessionManager</code> 生成的 <code>Request</code> 都在生成之前被解析并且按照规则适配. 一个使用适配器很典型的场景就是给请求添加一个 <code>Authorization</code> 的请求头. </p>
<pre><code>class AccessTokenAdapter: RequestAdapter {
    private let accessToken: String

    init(accessToken: String) {
        self.accessToken = accessToken
    }

    func adapt(_ urlRequest: URLRequest) throws -&gt; URLRequest {
        var urlRequest = urlRequest

        if urlRequest.urlString.hasPrefix(&quot;https://httpbin.org&quot;) {
            urlRequest.setValue(&quot;Bearer &quot; + accessToken, forHTTPHeaderField: &quot;Authorization&quot;)
        }

        return urlRequest
    }
}

let sessionManager = SessionManager()
sessionManager.adapter = AccessTokenAdapter(accessToken: &quot;1234&quot;)

sessionManager.request(&quot;https://httpbin.org/get&quot;)
</code></pre><p>如果一个 <code>Error</code> 在适配过程中产生的话, 它会逐层抛出, 最后传递到 <code>Request</code> 的请求回调里. </p>
<blockquote>
<p>查看 <a href="https://github.com/Alamofire/Alamofire/pull/1450" target="_blank" rel="external">PR-1450</a> 获取更多信息. </p>
</blockquote>
<h3 id="Request-Retrier-请求重连"><a href="#Request-Retrier-请求重连" class="headerlink" title="Request Retrier (请求重连)"></a>Request Retrier (请求重连)</h3><p><code>RequestRetrier</code> 是 Alamofire 4 的另一个全新协议. </p>
<pre><code>public typealias RequestRetryCompletion = (_ shouldRetry: Bool, _ timeDelay: TimeInterval) -&gt; Void

public protocol RequestRetrier {
    func should(_ manager: SessionManager, retry request: Request, with error: Error, completion: @escaping RequestRetryCompletion)
}
</code></pre><p>它可以在 <code>Request</code> 遇到 <code>Error</code>的时候, 在指定的延迟之后重新发起. </p>
<pre><code>class OAuth2Handler: RequestAdapter, RequestRetrier {
    public func should(_ manager: SessionManager, retry request: Request, with error: Error, completion: RequestRetryCompletion) {
        if let response = request.task.response as? HTTPURLResponse, response.statusCode == 401 {
            completion(true, 1.0) // 1秒后重试
        } else {
            completion(false, 0.0) // 不重连
        }
    }
}

let sessionManager = SessionManager()
sessionManager.retrier = OAuth2Handler()

sessionManager.request(urlString).responseJSON { response in
    debugPrint(response)
}
</code></pre><p>重连器可以让你在检测到 <code>Request</code> 完成并且完成所有 <code>Validation</code> 检测之后再考虑是否重试. 当 <code>RequestAdapter</code> 和 <code>RequestRetrier</code> 一起使用的时候, 你可以给 OAuth1, OAuth2, Basic Auth 创建一套持续更新的校验系统(credential refresh systems), 甚至是快速重试的策略. 可能性是无限的. 想要获取更多关于这个话题的信息和例子, 请查看 README. </p>
<blockquote>
<p>译者注: 这里没太能理解作者的意思, 翻译得不好, 直接放原文:<br>When using both the <code>RequestAdapter</code> and <code>RequestRetrier</code> protocols together, you can create credential refresh systems for OAuth1, OAuth2, Basic Auth and even exponential backoff retry policies. </p>
<p>查看 <a href="https://github.com/Alamofire/Alamofire/pull/1391" target="_blank" rel="external">PR-1391</a> 以及 <a href="https://github.com/Alamofire/Alamofire/pull/1450" target="_blank" rel="external">PR-1450</a> 获取更多信息. </p>
</blockquote>
<h3 id="Task-Metrics"><a href="#Task-Metrics" class="headerlink" title="Task Metrics"></a>Task Metrics</h3><p>在 iOS, tvOS 10 和 macOS 10.12 里, 苹果引入了新的 [URLSessionTaskMetrics][13] API, task metrics 包含了一些 request 和 response 的统计信息, API 跟 Alamofire 的 <code>Timeline</code> 很像, 但提供了许多 Alamofire 里获取不到的统计信息. 我们对这些新的 API 特别兴奋, 但把这些全部都暴露到每一个 <code>Response</code> 类型里意味着这并不容易使用. </p>
<pre><code>   [13]: https://developer.apple.com/reference/foundation/urlsessiontaskmetrics
</code></pre><p>Alamofire.request(urlString).response { response in<br>            debugPrint(response.metrics)<br>    }</p>
<p>有一点很重要的是, 这些 API 只有在 iOS 和 tvOS 10+ 和 macOS 10.12+上才能使用. 所以它是依赖于运行设备的, 你可能需要做可行性检查. </p>
<pre><code>Alamofire.request(urlString).response { response in
    if #available(iOS 10.0, *) {
                debugPrint(response.metrics)
    }
}
</code></pre><blockquote>
<p>查看 <a href="https://github.com/Alamofire/Alamofire/pull/1492" target="_blank" rel="external">PR-1492</a> 获取更多信息. </p>
</blockquote>
<h2 id="Updated-Features-更新的功能"><a href="#Updated-Features-更新的功能" class="headerlink" title="Updated Features 更新的功能"></a>Updated Features 更新的功能</h2><p>Alamofire 4 加强了现有的功能并且加入了很多新功能. 这一章节主要是大概地过一遍功能的更新和使用方式. 如果想要获取更多相关信息, 请点进链接查看相关的 pull request. </p>
<h3 id="Errors-异常"><a href="#Errors-异常" class="headerlink" title="Errors 异常"></a>Errors 异常</h3><p>Alamofire 4 加入了全新的异常系统, 采用了提案 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0112-nserror-bridging.md" target="_blank" rel="external">SE-0112</a> 里提出的新模式. 新的异常系统主要围绕 <code>AFError</code>, 一个继承了 <code>Error</code> 的枚举类型, 包含四个主要的 case. </p>
<ul>
<li><p><code>.invalidURL(url: URLConvertible)</code> - 创建 <code>URL</code> 失败的时候返回一个 <code>URLConvertible</code> 类型的值 </p>
</li>
<li><p><code>.parameterEncodingFailed(reason: ParameterEncodingFailureReason)</code> - 当其中一个参数编码出错的时候就会抛出错误并返回 </p>
</li>
<li><p><code>.multipartEncodingFailed(reason: MultipartEncodingFailureReason)</code> - multipart 编码出错就会抛出错误并返回 </p>
</li>
<li><p><code>.responseValidationFailed(reason: ResponseValidationFailureReason)</code> - 当调用 <code>validate()</code> 抛出错误时捕获然后抛出到外部. </p>
</li>
<li><p><code>.responseSerializationFailed(reason: ResponseSerializationFailureReason)</code> - 返回的数据序列化出错时会抛出异常并返回. </p>
</li>
</ul>
<p>每一个 case 都包含了特定的异常理由, 并且异常理由又是另一个带有具体错误信息的枚举类型. 这会让 Alamofire 更容易识别出错误的来源和原因. </p>
<pre><code>Alamofire.request(urlString).responseJSON { response in
    guard case let .failure(error) = response.result else { return }

    if let error = error as? AFError {
        switch error {
        case .invalidURL(let url):
            print(&quot;无效 URL: \(url) - \(error.localizedDescription)&quot;)
        case .parameterEncodingFailed(let reason):
            print(&quot;参数编码失败: \(error.localizedDescription)&quot;)
            print(&quot;失败理由: \(reason)&quot;)
        case .multipartEncodingFailed(let reason):
            print(&quot;Multipart encoding 失败: \(error.localizedDescription)&quot;)
            print(&quot;失败理由: \(reason)&quot;)
        case .responseValidationFailed(let reason):
            print(&quot;Response 校验失败: \(error.localizedDescription)&quot;)
            print(&quot;失败理由: \(reason)&quot;)

            switch reason {
            case .dataFileNil, .dataFileReadFailed:
                print(&quot;无法读取下载文件&quot;)
            case .missingContentType(let acceptableContentTypes):
                print(&quot;文件类型不明: \(acceptableContentTypes)&quot;)
            case .unacceptableContentType(let acceptableContentTypes, let responseContentType):
                print(&quot;文件类型: \(responseContentType) 无法读取: \(acceptableContentTypes)&quot;)
            case .unacceptableStatusCode(let code):
                print(&quot;请求返回状态码出错: \(code)&quot;)
            }
        case .responseSerializationFailed(let reason):
            print(&quot;请求返回内容序列化失败: \(error.localizedDescription)&quot;)
            print(&quot;失败理由: \(reason)&quot;)
        }

        print(&quot;错误: \(error.underlyingError)&quot;)
    } else if let error = error as? URLError {
        print(&quot;URL 错误: \(error)&quot;)
    } else {
        print(&quot;未知错误: \(error)&quot;)
    }
}
</code></pre><p>新的设计给你的处理方式更多的自由, 可以在你需要的时候深入到最具体的 error. 这也会让原本要四处应对 <code>NSError</code> 的开发者更加轻松地完成工作. 在 Alamofire 里通过使用自定义的 <code>Error</code> 类型, 我们可以看到 <code>Result</code> 和 <code>Response</code> 的泛型参数缩减到了只有一个, 简化了返回数据序列化的逻辑. </p>
<blockquote>
<p>查看 <a href="https://github.com/Alamofire/Alamofire/pull/1419" target="_blank" rel="external">PR-1419</a> 获取更多信息. </p>
</blockquote>
<h3 id="Parameter-Encoding-Protocol-参数编码的协议"><a href="#Parameter-Encoding-Protocol-参数编码的协议" class="headerlink" title="Parameter Encoding Protocol 参数编码的协议"></a>Parameter Encoding Protocol 参数编码的协议</h3><p><code>ParameterEncoding</code> 枚举类型在过去两年很好地解决了问题. 但我们在 Alamofire 4 里想要定位的时候却感觉到了一些局限. </p>
<ul>
<li><p><code>.url</code> 总让人有点迷惑, 因为它是一个 HTTP 协议定义的地址 </p>
</li>
<li><p><code>.urlEncodedInURL</code> 跟 <code>.url</code> 总是会混淆起来, 让人分不清它们行为的区别 </p>
</li>
<li><p><code>.JSON</code> 和 <code>.PropertyList</code> 编码不能自定义编码格式或者写入的方式 </p>
</li>
<li><p><code>.Custom</code> 编码对于用户来说太难掌握 </p>
</li>
</ul>
<p>因为这些原因, 我们决定在 Alamofire 4 把这个枚举去掉! 现在, <code>ParameterEncoding</code> 变成了一个协议, 加入了 <code>Parameters</code> 的类型别名去创建你的参数字典, 并且通过遵守这个协议建立了三个编码结构体 <code>URLEncoding</code>, <code>JSONEncoding</code> 和 <code>PropertyList</code>. </p>
<pre><code>public typealias Parameters = [String: Any]

public protocol ParameterEncoding {
    func encode(_ urlRequest: URLRequestConvertible, with parameters: Parameters?) throws -&gt; URLRequest
}
</code></pre><h4 id="URL-Encoding-参数编码"><a href="#URL-Encoding-参数编码" class="headerlink" title="URL Encoding (参数编码)"></a>URL Encoding (参数编码)</h4><p>新的 <code>URLEncoding</code> 结构体包含了一个 <code>Destination</code> 枚举, 支持三种类型的目标编码 </p>
<ul>
<li><p><code>.methodDependent</code> - 对于 <code>GET</code>, <code>HEAD</code> 和 <code>DELETE</code> 方法使用 query 字符串, 而别的 HTTP 方法则会编码为 HTTP body. </p>
</li>
<li><p><code>.queryString</code> - 设置或者往现有的 queryString 里增加内容 </p>
</li>
<li><p><code>.httpBody</code> - 设置请求的 HTTP body 内容 </p>
</li>
</ul>
<p>这些目标编码格式会让你更容易控制 <code>URLRequest</code> 的参数编码方式. 创建请求依旧使用和之前一样的方式, 不管编码的形式怎样, 都会保持与之前一样的默认行为. </p>
<pre><code>let parameters: Parameters = [&quot;foo&quot;: &quot;bar&quot;]

Alamofire.request(urlString, parameters: parameters) // Encoding =&gt; URLEncoding(destination: .methodDependent)
Alamofire.request(urlString, parameters: parameters, encoding: URLEncoding(destination: .queryString))
Alamofire.request(urlString, parameters: parameters, encoding: URLEncoding(destination: .httpBody))

// Static convenience properties (we&#39;d like to encourage everyone to use this more concise form)
// 便利的静态属性 (我们想鼓励大家使用这种更简洁的形式)
Alamofire.request(urlString, parameters: parameters, encoding: URLEncoding.default)
Alamofire.request(urlString, parameters: parameters, encoding: URLEncoding.queryString)
Alamofire.request(urlString, parameters: parameters, encoding: URLEncoding.httpBody)
</code></pre><h4 id="JSON-Encoding-JSON-编码"><a href="#JSON-Encoding-JSON-编码" class="headerlink" title="JSON Encoding (JSON 编码)"></a>JSON Encoding (JSON 编码)</h4><p>新的 <code>JSONEncoding</code> 结构体开放了让你自定义 JSON 写入形式的接口. </p>
<pre><code>let parameters: Parameters = [&quot;foo&quot;: &quot;bar&quot;]

Alamofire.request(urlString, parameters: parameters, encoding: JSONEncoding(options: []))
Alamofire.request(urlString, parameters: parameters, encoding: JSONEncoding(options: .prettyPrinted))

// Static convenience properties (we&#39;d like to encourage everyone to use this more concise form)
// 便利的静态属性 (我们想鼓励大家使用这种更简洁的形式)
Alamofire.request(urlString, parameters: parameters, encoding: JSONEncoding.default)
Alamofire.request(urlString, parameters: parameters, encoding: JSONEncoding.prettyPrinted)
</code></pre><h4 id="Property-List-Encoding-属性列表编码"><a href="#Property-List-Encoding-属性列表编码" class="headerlink" title="Property List Encoding (属性列表编码)"></a>Property List Encoding (属性列表编码)</h4><p>新的 <code>PropertyListEncoding</code> 结构体允许自定义 plist 的格式和写入选项 </p>
<pre><code>let parameters: Parameters = [&quot;foo&quot;: &quot;bar&quot;]

Alamofire.request(urlString, parameters: parameters, encoding: PropertyListEncoding(format: .xml, options: 0))
Alamofire.request(urlString, parameters: parameters, encoding: PropertyListEncoding(format: .binary, options: 0))

// Static convenience properties (we&#39;d like to encourage everyone to use this more concise form)
// 便利的静态属性 (我们想鼓励大家使用这种更简洁的形式)
Alamofire.request(urlString, parameters: parameters, encoding: PropertyListEncoding.xml)
Alamofire.request(urlString, parameters: parameters, encoding: PropertyListEncoding.binary)
</code></pre><h4 id="Custom-Encoding-自定义编码"><a href="#Custom-Encoding-自定义编码" class="headerlink" title="Custom Encoding 自定义编码"></a>Custom Encoding 自定义编码</h4><p>建立一个自定义的 <code>ParameterEncoding</code> 只要遵守这个协议建立类型即可. 想要获取更多相关例子, 请查看下面的 README </p>
<blockquote>
<p>查看 <a href="https://github.com/Alamofire/Alamofire/pull/1465" target="_blank" rel="external">PR-1465</a> 获取更多信息 </p>
</blockquote>
<h3 id="Request-Subclasses-Request-的子类"><a href="#Request-Subclasses-Request-的子类" class="headerlink" title="Request Subclasses (Request 的子类)"></a>Request Subclasses (Request 的子类)</h3><p>在 Alamofire 4, <code>request</code>, <code>download</code>, <code>upload</code> 和 <code>stream</code> 的 API 不会再返回 <code>Request</code>, 他们会返回特定的 <code>Request</code> 子类. 有下面几个引导我们做出这个改变的现实原因和社区的疑问: </p>
<ul>
<li><p><strong>Progress:</strong> <code>progress</code> 方法的行为会在 upload 请求里会很容易让人迷惑. </p>
<ul>
<li><p><code>progress</code> 在一个 upload 请求里返回的是什么? 上传的进度? 还是返回内容的下载进度? </p>
</li>
<li><p>如果都返回, 那我们怎么区分他们, 在什么时候能知道是到底返回的是哪一个? </p>
</li>
</ul>
</li>
<li><p><strong>Response Serializers:</strong> 返回内容的序列化是为了 data 和 upload 请求设计的, donwload 和 stream 请求并不需要序列化. </p>
<ul>
<li><p>你要怎么才能在下载完成时获取到文件的地址? </p>
</li>
<li><p><code>responseData</code>, <code>responseString</code> 和 <code>responseJSON</code> 对于一个 donwload 请求来说意味着什么? stream 请求呢? </p>
</li>
</ul>
</li>
</ul>
<p>Alamofire 4 现在有四个 <code>Request</code> 的子类, 并且每个字类都有一些特有的 API. 这样就可以让每一个子类能够通过建立 extension 来定制特定类型的请求. </p>
<pre><code>open class Request {
    // 包含了共有的属性, 验证, 和状态方法
    // 遵守 CustomStringConvertible 和 CustomDebugStringConvertible
}

open class DataRequest: Request {
    // 包含了数据流(不要跟 StreamRequest 混淆)和下载进度的方法
}

open class DownloadRequest: Request {
    // 包含了下载位置和选项, 已下载的数据以及进度方法
}

open class UploadRequest: DataRequest {
        // 继承了所有 DataRequest 的方法, 并且包含了上传进度的方法
}

open class StreamRequest: Request {
        // 只继承了 Request, 目前暂时没有任何自定义的 API
}
</code></pre><p>通过这样的切分, Alamofire 现在可以为每一个类型的请求自定义相关的 API. 这会覆盖到所有可能的需求, 但让我们花点时间来仔细了解一下这会如何改变进度汇报和下载地址. </p>
<blockquote>
<p>查看 <a href="https://github.com/Alamofire/Alamofire/pull/1455" target="_blank" rel="external">PR-1455</a> 获取更多信息 </p>
</blockquote>
<h4 id="Download-and-Upload-Progress-下载和上传你进度"><a href="#Download-and-Upload-Progress-下载和上传你进度" class="headerlink" title="Download and Upload Progress (下载和上传你进度)"></a>Download and Upload Progress (下载和上传你进度)</h4><p>Data, download 和 upload 请求的进度汇报系统完全重新设计了一遍. 每一个请求类型都包含有一个闭包, 每当进度更新的时候, 就会调用闭包并且传入 <code>Progress</code> 类型的参数. 这个闭包会在指定的队列被调用, 默认为主队列. </p>
<p><strong>Data Request 进度</strong></p>
<pre><code>Alamofire.request(urlString)
    .downloadProgress { progress in
        // 默认在主队列调用
        print(&quot;下载进度: \(progress.fractionCompleted)&quot;)
    }
    .responseJSON { response in
        debugPrint(response)
    }
</code></pre><p><strong>Download Request 进度</strong></p>
<pre><code>Alamofire.download(urlString, to: destination)
    .downloadProgress(queue: DispatchQueue.global(qos: .utility)) { progress in
        // 在 .utility 队列里调用
        print(&quot;下载进度: \(progress.fractionCompleted)&quot;)
    }
    .responseJSON { response in
        debugPrint(response)
    }
</code></pre><p><strong>Upload Request 进度</strong></p>
<pre><code>Alamofire.upload(data, to: urlString, withMethod: .post)
    .uploadProgress { progress in
        // 默认在主队列调用
        print(&quot;上传进度: \(progress.fractionCompleted)&quot;)
    }
    .downloadProgress { progress in
        // 默认在主队列调用
        print(&quot;下载进度: \(progress.fractionCompleted)&quot;)
    }
    .responseData { response in
        debugPrint(response)
    }
</code></pre><p>现在很容易就可以区分开 upload request 里的上传和下载进度. </p>
<blockquote>
<p>查看 <a href="https://github.com/Alamofire/Alamofire/pull/1455" target="_blank" rel="external">PR-1455</a> 获取更多信息. </p>
</blockquote>
<h4 id="Download-File-Destinations-文件下载地址"><a href="#Download-File-Destinations-文件下载地址" class="headerlink" title="Download File Destinations 文件下载地址"></a>Download File Destinations 文件下载地址</h4><p>在 Alamofire 3.x, 顺利完成的 download requests 总是会在 <code>destination</code> 回调里把临时文件移动到最终目标文件夹里. 这很方便, 但也同时带来了几个限制: </p>
<ul>
<li><p><code>Forced</code> - API 强制你去提供一个 destination 闭包来移动文件, 即使你验证过后不想移动文件了. </p>
</li>
<li><p><code>Limiting</code> - 没有任何方式可以去调整文件系统移动文件的优先级别. </p>
<ul>
<li><p>如果你需要在移动到目标文件夹之前删掉之前存在的文件呢? </p>
</li>
<li><p>如果你需要在移动临时文件之前创建目录呢? </p>
</li>
</ul>
</li>
</ul>
<p>这些限制都会在 Alamofire 4 里都不复存在. 首先是 optional 的 destination 闭包. 现在, <code>destination</code> 默认为 nil, 意味着文件系统不会移动文件, 并且会返回临时文件的 URL. </p>
<pre><code>Alamofire.download(urlString).responseData { response in
    print(&quot;临时文件的 URL: \(response.temporaryURL)&quot;)
}
</code></pre><blockquote>
<p>我们将会恢复 <code>DownloadResponse</code> 类型, 更多详细信息请查看 Reponse Serializers 章节. </p>
</blockquote>
<h4 id="Download-Options-下载选项"><a href="#Download-Options-下载选项" class="headerlink" title="Download Options 下载选项"></a>Download Options 下载选项</h4><p>另外一个主要的改变是 destination 闭包里面加上了下载选项, 让你可以进行更多文件系统操作. 为了达到目的, 我们建立了一个 <code>DownloadOptions</code> 类型并且添加到 <code>DownloadFileDestination</code> 闭包里. </p>
<pre><code>public typealias DownloadFileDestination = (
    _ temporaryURL: URL,
    _ response: HTTPURLResponse)
    -&gt; (destinationURL: URL, options: DownloadOptions)
</code></pre><p>现阶段支持的两个 <code>DownloadOptions</code> 是: </p>
<ul>
<li><p><code>.createIntermediateDirectories</code> - 如果有指定的下载地址的话, 会为下载地址创建相应的目录 </p>
</li>
<li><p><code>.removePreviousFile</code> - 如果有指定的下载地址的话, 会自动替代掉同名文件 </p>
</li>
</ul>
<p>这两个选项可以像下面这样用: </p>
<pre><code>let destination: DownloadRequest.DownloadFileDestination = { _, _ in
    return (fileURL, [.removePreviousFile, .createIntermediateDirectories])
}

Alamofire.download(urlString, to: destination).response { response in
    debugPrint(response)
}
</code></pre><p>如果一个异常在文件系统操作时抛出的话, <code>DownloadResponse</code> 的 <code>error</code> 就会是 <code>URLError</code> 类型. </p>
<blockquote>
<p>查看 <a href="https://github.com/Alamofire/Alamofire/pull/1462" target="_blank" rel="external">PR-1462</a> 获取更多信息. </p>
</blockquote>
<h3 id="Response-Validation-数据验证"><a href="#Response-Validation-数据验证" class="headerlink" title="Response Validation 数据验证"></a>Response Validation 数据验证</h3><p>在 Alamofire 4 里有几个可以加强数据验证系统的地方. 包括了: </p>
<ul>
<li><p><code>Validation</code> 回调闭包里传入的 <code>data</code></p>
</li>
<li><p><code>Request</code> 子类可以自定义数据验证系统, 例如 download 请求里的 <code>temporaryURL</code> 和 <code>destinationURL</code> 暴露到了回调闭包里 </p>
</li>
</ul>
<p>通过继承 <code>Request</code>, 每一个 <code>Request</code> 的子类都可以自定义一套数据验证的闭包(typealias)和请求的 API. </p>
<h4 id="Data-Request-数据请求"><a href="#Data-Request-数据请求" class="headerlink" title="Data Request 数据请求"></a>Data Request 数据请求</h4><p><code>DataRequest</code> (<code>UploadRequest</code> 的父类)暴露出来的 <code>Validation</code> 目前是这样定义的: </p>
<pre><code>extension DataRequest {
    public typealias Validation = (URLRequest?, HTTPURLResponse, Data?) -&gt; ValidationResult
}
</code></pre><p>直接在闭包里把 <code>Data?</code> 暴露出来, 你就不需要再给 <code>Request</code> 增加一个 extension 去访问这个属性了. 现在你可以直接这样子做: </p>
<pre><code>Alamofire.request(urlString)
    .validate { request, response, data in
        guard let data = data else { return .failure(customError) }

        // 1) 验证返回的数据保证接下来的操作不会出错
        // 2) 如果验证失败, 你可以把错误信息返回出去, 甚至加上自定义的 error

        return .success
    }
    .response { response in
        debugPrint(response)
    }
</code></pre><h4 id="Download-Request-下载请求"><a href="#Download-Request-下载请求" class="headerlink" title="Download Request 下载请求"></a>Download Request 下载请求</h4><p><code>DownloadRequest</code> 里的 <code>Validation</code> 闭包跟 <code>DataRequest</code> 里的很像, 但为了下载任务做了更多的定制. </p>
<pre><code>extension DownloadRequest {
        public typealias Validation = (
            _ request: URLRequest?,
            _ response: HTTPURLResponse,
            _ temporaryURL: URL?,
            _ destinationURL: URL?)
            -&gt; ValidationResult
}
</code></pre><p><code>temporaryURL</code> 和 <code>destinationURL</code> 参数现在让你可以在闭包内直接获取到服务器返回的数据. 这可以让你校验下载好的文件, 在有需要的时候可以抛出一个自定义的错误. </p>
<pre><code>Alamofire.download(urlString)
    .validate { request, response, temporaryURL, destinationURL in
        guard let fileURL = temporaryURL else { return .failure(customError) }

        do {
            let _ = try Data(contentsOf: fileURL)
            return .success
        } catch {
            return .failure(customError)
        }
    }
    .response { response in
        debugPrint(response)
    }
</code></pre><p>通过直接在闭包里暴露服务器返回的数据, 这里面的所有异常都可以在 <code>Validation</code> 闭包里捕获到, 并且可以自定义错误信息. 如果这里获取到的信息和 response 序列化回调里一样的话, response 可以用来处理错误信息而不是简单地把逻辑赋值过来. 具体的例子, 请查看下面的 README. </p>
<blockquote>
<p>查看 <a href="https://github.com/Alamofire/Alamofire/pull/1461" target="_blank" rel="external">PR-1461</a> 获取更多信息. </p>
</blockquote>
<h3 id="Response-Serializers-返回数据序列化"><a href="#Response-Serializers-返回数据序列化" class="headerlink" title="Response Serializers 返回数据序列化"></a>Response Serializers 返回数据序列化</h3><p>Alamofire 3.x 里的序列化系统有这么几个限制: </p>
<ul>
<li><p>序列化的 API 可以用在 download 和 stream 请求里, 但却会导致未知的行为发生 </p>
<ul>
<li><p>怎么在下载成功时获取到文件 URL? </p>
</li>
<li><p><code>responseData</code>, <code>responseString</code> 或者 <code>responseJSON</code> 会在 donwload 请求里产生怎样的行为? stream 请求呢? </p>
</li>
</ul>
</li>
<li><p><code>response</code> API 返回四个参数而不是封装到一个 <code>Response</code> 类型里. </p>
<ul>
<li><p>最大的问题是 API 任何改变都会导致前面行为的变化. </p>
</li>
<li><p>在序列化和反序列化的 API 之间切换会让人迷惑, 同时导致难以 debug 的编译错误. </p>
</li>
</ul>
</li>
</ul>
<p>就像你看到的, Alamofire 3.x 的这一套序列化系统有这么多限制. 所以, 在 Alamofire 4里, <code>Request</code> 类型首先被切分到各个子类里, 这么做给自定义序列化方式, 和自定义 API 留下了空间. 在我们更深入了解序列化方式之前, 我们先了解一下新的 <code>Response</code> 类型 </p>
<h4 id="Default-Data-Response"><a href="#Default-Data-Response" class="headerlink" title="Default Data Response"></a>Default Data Response</h4><p><code>DefaultDataResponse</code> 代表了未被序列化的服务器返回数据. Alamofire 没有做任何处理过的, 只是纯粹地从 <code>SessionDelegate</code> 里获取信息并且包装在一个结构体里面返回. </p>
<pre><code>public struct DefaultDataResponse {
    public let request: URLRequest?
    public let response: HTTPURLResponse?
    public let data: Data?
    public let error: Error?
    public var metrics: URLSessionTaskMetrics? { return _metrics as? URLSessionTaskMetrics }
}
</code></pre><p>下面是你会获得 <code>DataRequest.response</code> 的一种返回. </p>
<pre><code>Alamofire.request(urlString).response { response in
    debugPrint(response)
}

Alamofire.upload(file, to: urlString).response { response in
    debugPrint(response)
}
</code></pre><h4 id="Data-Response"><a href="#Data-Response" class="headerlink" title="Data Response"></a>Data Response</h4><p>泛型 <code>DataResponse</code> 类型跟 Alamofire 3.x 里的 <code>Response</code> 一样, 但内部重构并且包含了新的 <code>metrics</code> 变量. </p>
<pre><code>public struct DataResponse&lt;Value&gt; {
    public let request: URLRequest?
    public let response: HTTPURLResponse?
    public let data: Data?
    public let result: Result&lt;Value&gt;
    public let timeline: Timeline
        public var metrics: URLSessionTaskMetrics? { return _metrics as? URLSessionTaskMetrics }
}
</code></pre><p>使用 <code>DataRequest</code> 和 <code>UploadRequest</code>, 你可以像之前(3.x)那样使用 response 序列化的 API </p>
<pre><code>Alamofire.request(urlString).responseJSON { response in
    debugPrint(response)
    print(response.result.isSuccess)
}

Alamofire.upload(fileURL, to: urlString).responseData { response in
    debugPrint(response)
    print(response.result.isSuccess)
}
</code></pre><h4 id="Default-Download-Response-默认下载请求的-Response-类型"><a href="#Default-Download-Response-默认下载请求的-Response-类型" class="headerlink" title="Default Download Response 默认下载请求的 Response 类型"></a>Default Download Response 默认下载请求的 Response 类型</h4><p>因为 donwload 请求跟 data 和 upload 请求很不一样, 所以 Alamofire 4 包含了自定义的 donwload <code>Response</code> 类型. <code>DefaultDownloadResponse</code> 类型代表未序列化的返回数据, 包含了所有 <code>SessionDelegate</code> 信息的结构体. </p>
<pre><code>public struct DefaultDownloadResponse {
    public let request: URLRequest?
    public let response: HTTPURLResponse?
    public let temporaryURL: URL?
    public let destinationURL: URL?
    public let resumeData: Data?
    public let error: Error?
        public var metrics: URLSessionTaskMetrics? { return _metrics as? URLSessionTaskMetrics }
}
</code></pre><p><code>DefaultDownloadResponse</code> 类型在使用新的 <code>DownloadRequest.response</code> API 时就会被返回. </p>
<pre><code>Alamofire.download(urlString).response { response in
    debugPrint(response)
    print(response.temporaryURL)
}
</code></pre><h4 id="Download-Response"><a href="#Download-Response" class="headerlink" title="Download Response"></a>Download Response</h4><p>新的泛型 <code>DownloadResponse</code> 跟 <code>DataResponse</code> 很像, 但包含了 download 请求特有的信息. <code>DownloadResponse</code> 类型在使用 <code>DownloadRequest</code> 时就会被返回. 这些新的 API 同样也适用于 <code>DataRequest</code>, 一样能够获取临时目录的 url 和目标目录的 url. </p>
<pre><code>Alamofire.download(urlString, to: destination)
    .responseData { response in
        debugPrint(response)
    }
    .responseString { response in
        debugPrint(response)
    }
    .responseJSON { response in
        debugPrint(response)
    }
    .responsePropertyList { response in
        debugPrint(response)
    }
</code></pre><p>新的序列化 API 让文件下载和序列化更加容易完成. </p>
<h4 id="Custom-Response-Serializers-自定义序列化"><a href="#Custom-Response-Serializers-自定义序列化" class="headerlink" title="Custom Response Serializers 自定义序列化"></a>Custom Response Serializers 自定义序列化</h4><p>如果你已经创建了自定义的序列化, 你也许会想要拓展支持 data 和 download 请求, 就像我们在 Alamofire 序列化 API 里面做的一样.. 如果你决定这么做, 可以仔细看一下 Alamofire 怎么在几种 <code>Request</code> 类型里共享序列化方法, 然后把实现写到 <code>Request</code> 里就可以了. 这可以让我们 DRY up 逻辑并且避免重复的代码.(Don’t repeat yourself) </p>
<blockquote>
<p>查看 <a href="https://github.com/Alamofire/Alamofire/pull/1457" target="_blank" rel="external">PR-1457</a> 获取更多信息. </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Alamofire </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[七牛云储存]]></title>
      <url>/2017/06/14/Android/%E4%B8%83%E7%89%9B%E4%BA%91%E5%82%A8%E5%AD%98/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a> 
<ul>
<li><p>初始化<br>一般情况下直接使用默认设置，不用单独配置。 可以配置超时时长、分片上传阀值等。</p>
<p>Configuration config = new Configuration.Builder()</p>
<pre><code>                .chunkSize(256 * 1024)  //分片上传时，每片的大小。 默认 256K
                .putThreshhold(512 * 1024)  // 启用分片上传阀值。默认 512K
                .connectTimeout(10) // 链接超时。默认 10秒
                .responseTimeout(60) // 服务器响应超时。默认 60秒
                .recorder(recorder)  // recorder 分片上传时，已上传片记录器。默认 null
                .recorder(recorder, keyGen)  // keyGen 分片上传时，生成标识符，用于片记录器区分是那个文件的上传记录
                .zone(Zone.zone0) // 设置区域，指定不同区域的上传域名、备用域名、备用IP。默认 Zone.zone0
                .build()
</code></pre><p>// 重用 uploadManager。一般地，只需要创建一个 uploadManager 对象<br>UploadManager uploadManager = new UploadManager(config)</p>
</li>
<li><p>上传文件<br>七牛上传文件主要用到两个方法：<br>一、 UploadManager.put(data, key, token, handler, options);</p>
<p> /**</p>
<ul>
<li><p>UploadManager.put参数说明：<br><em>
</em>@data                  byte[]/String/File    数据，可以是byte数组，文件路径，文件。<br><em>@key                   String                保存在服务器上的资源唯一标识。请参考键值对。
</em>@token                 String                服务器分配的token。<br><em>@completionHandler     UpCompletionHandler   上传回调函数，必填。
</em>@options               UploadOptions         如果需要进度通知、crc校验、中途取消、指定mimeType则需要填写相应字段，详见UploadOptions参数说明。</p>
<pre><code> */
</code></pre><p>二、 UploadOptions(params, mimeType, checkCrc, progressHandler, cancellationSignal);</p>
</li>
</ul>
</li>
</ul>
<pre><code>    /**
     * UploadOptions参数说明：
     * 
     *参数                   类型                   说明
     *params               Map&lt;String, String&gt;  自定义变量，key必须以 x: 开始。
     *mimeType             String               指定文件的mimeType。
     *checkCrc             boolean              是否验证上传文件。
     *progressHandler      UpProgressHandler    上传进度回调。
     *cancellationSignal   UpCancellationSignal 取消上传，当isCancelled()返回true时，不再执行更多上传。
     */
</code></pre><h4 id="现在就比较清楚了"><a href="#现在就比较清楚了" class="headerlink" title="现在就比较清楚了"></a>现在就比较清楚了</h4><p>下面主要是各种上传姿势了  </p>
<ul>
<li>简单上传 </li>
</ul>
<pre><code>UploadManager uploadManager = new UploadManager();
data = &lt;File对象、或 文件路径、或 字节数组&gt;
String key = &lt;指定七牛服务上的文件名，或 null&gt;;
String token = &lt;从服务端SDK获取&gt;;
uploadManager.put(data, key, token,
 /**
  * UpCompletionHandler参数说明
  * 
  *@key        即uploadManager.put(file, key, ...)方法指定的key。
  *@info       http请求的状态信息等，可记入日志。isOK()返回 true表示上传成功。
  *@response   七牛反馈的信息。可从中解析保存在七牛服务的key等信息，具体字段取决于上传策略的设置。
  */
new UpCompletionHandler() {
    @Override
    public void complete(String key, ResponseInfo info, JSONObject res) {

        Log.i(&quot;qiniu&quot;, key + &quot;,\r\n &quot; + info + &quot;,\r\n &quot; + res);
    }
}, null);
</code></pre><ul>
<li>记录上传进度</li>
</ul>
<pre><code>    private void uploadProgress() {

        uploadManager.put(data, key, token, handler,
                new UploadOptions(null, null, false,
                        new UpProgressHandler() {
                            /**
                             * @param key      即uploadManager.put(file, key, ...)方法指定的key
                             * @param percent  进度
                             */
                            public void progress(String key, double percent) {
                                Log.i(&quot;qiniu&quot;, key + &quot;: &quot; + percent);
                            }
                        }, null));

    }
</code></pre><ul>
<li>取消上传<br>内部代码会检测UpCancellationSignal##isCancelled()的返回值，当其返回true时，将停止上传。 可外部维护一个变量isCancelled，当点击取消按钮时，设置isCancelled = true;。如：</li>
</ul>
<pre><code>private volatile boolean isCancelled = false;

uploadManager.put(data, key, token,handler,
    new UploadOptions(null, null, false, progressHandler,
        new UpCancellationSignal(){
            public boolean isCancelled(){
                return isCancelled;
            }
        }));



private void cancell() {
    isCancelled = true;
}
</code></pre><ul>
<li>记录断点</li>
</ul>
<p>分片上传中，可将各个已上传的块记录下来，再次上传时，已上传的部分不用再次上传。 断点记录类需实现 com.qiniu.android.storage.Recorder 接口。已提供保存到文件的 FileRecorder 实现。 </p>
<pre><code>String dirPath = &lt;断点记录文件保存的文件夹位置&gt;
Recorder recorder = new FileRecorder(dirPath);




KeyGenerator keyGen = new KeyGenerator(){
    public String gen(String key, File file){


        return key + &quot;_._&quot; + new StringBuffer(file.getAbsolutePath()).reverse();
    }
};





Configuration config = new Configuration.Builder()


                    .recorder(recorder, keyGen)  
                    .build();

UploadManager uploadManager = new UploadManager(config);

uploadManager.put(data, key, ...)
</code></pre><h3 id="初始化设置和上传文件的基本用法就记录到这啦！"><a href="#初始化设置和上传文件的基本用法就记录到这啦！" class="headerlink" title="初始化设置和上传文件的基本用法就记录到这啦！"></a>初始化设置和上传文件的基本用法就记录到这啦！</h3>]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> qiniu </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[内存管理]]></title>
      <url>/2017/06/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a> 
<p><strong>1. 物理地址和逻辑地址</strong></p>
<p><strong>物理地址</strong>：加载到内存地址寄存器中的地址，内存单元的真正地址。在前端总线上传输的内存地址都是物理内存地址，编号从0开始一直到可用物理内存的最高端。这些数字被北桥(Nortbridge chip)映射到实际的内存条上。物理地址是明确的、最终用在总线上的编号，不必转换，不必分页，也没有特权级检查(no translation, no paging, no privilege checks)。 </p>
<p><strong>逻辑地址</strong>：CPU所生成的地址。逻辑地址是内部和编程使用的、并不唯一。例如，你在进行C语言指针编程中，可以读取指针变量本身值(&amp;操作)，实际上这个值就是逻辑地址，它是相对于你当前进程数据段的地址（偏移地址），不和绝对物理地址相干。 </p>
<p>为什么会有这两种地址？ </p>
<p>个人觉的原因在于逻辑地址分配更加灵活，可以允许不唯一，看起来也较为直观，例如，一段代码中分配数组，逻辑地址上是连续的，然而在物理地址上，这个数组所占用的页可能分散开来，物理地址上就是不连续的，这样对程序的可理解性上有影响。另外，有了逻辑地址这个概念，才能使用虚拟内存技术。 </p>
<p><strong>2. </strong>Paging，分页内存管理方案 </p>
<p>(1) 分页的最大作用就在于：使得进程的物理地址空间可以是非连续的。 </p>
<p>物理内存被划分为一小块一小块，每块被称为帧(Frame)。分配内存时，帧是分配时的最小单位，最少也要给一帧。在逻辑内存中，与帧对应的概念就是页(Page)。 </p>
<p>逻辑地址的表示方式是：前部分是页码后部分是页偏移。 </p>
<p>例如，已知逻辑空间地址为2^m个字节（也就是说逻辑地址的长度是m位），已知页大小是2^n字节。那么一共可以有2^(m-n)个页。因此页码部分会占m-n位，之后的n位，用来存储页偏移。 </p>
<p>举个例子， 页大小为4B，而逻辑内存为32B（8页），逻辑地址0的页号为0，页号0对应帧5，因此逻辑地址映射为物理地址5<em>4+0=20。逻辑地址3映射物理地址5</em>4+3=23。逻辑地址13(4*3+1，页号为3，偏移为1，因此帧号为2)，映射到物理地址9。 </p>
<p><img src="http://images.cnitblog.com/blog/48332/201311/12230204-439af747b09c4d9b9fc18cf69f531141.png" alt=""></p>
<p>采用分页技术不会产生外部碎片(内存都被划分为帧)，但可能产生内部碎片(帧已经是最小单元，因此帧内部可能有空间没有用到)。 </p>
<p>按概率计算下来，每个进程平均可有半个帧大小的内部碎片。 </p>
<p>(2) 页表的硬件实现 </p>
<p>上一小节中写到页表是逻辑地址转化到物理地址的关键所在。那么页表如何存储？ </p>
<p>每个操作系统都有自己的方法来保存页表。绝大多数都会为每个进程分配一个页表。现在由于页表都比较大，所以放在内存中(以往是放在一组专用寄存器里)，其指针存在进程控制块(PCB)里，当进程被调度程序选中投入运行时，系统将其页表指针从进程控制块中取出并送入用户寄存器中。随后可以根据此首地址访问页表。 </p>
<p>页表的存储方式是<strong>TLB(Translation look-aside buffer, 翻译后备缓冲器)</strong>+内存。TLB实际上是一组硬件缓冲所关联的快速内存。若没有TBL，操作系统需要两次内存访问来完成逻辑地址到物理地址的转换，访问页表算一次，在页表中查找算一次。TLB中存储页表中的一小部分条目，条目以键值对方式存储。 </p>
<p><img src="http://images.cnitblog.com/blog/48332/201311/13090353-a81e30238dea4811b9b5382d3eeb0427.png" alt=""></p>
<p>(3) 页表的数据结构 </p>
<p>a. </p>
<p>现有的笔记本电脑，内存地址空间一般为2^32字节以上。对于具有32位逻辑地址空间的计算机系统，如果系统的页大小为4KB(2^12B)，那么页表可以拥有2^(32-12)个，也就是一百多万个条目，假设每个条目占有4B，那每个进程都需要4MB的物理地址空间来存放页表本身。而且，页表本身需要分配在连续内存中。 </p>
<p>为此，<strong>Hierarchical Paging(层次化分页)</strong>被提出，实际上就是将页号分为两部分，第一部分作为索引，第二部分作为页号的偏移。 </p>
<p>以一个4kb页大小的32位系统为例。一个逻辑地址被分为20位的页码和12位的页偏移。因为要对页表进行再分页，所以该页号可分为10位的页码和10位的页偏移。这样一个逻辑地址就表示如下形式： </p>
<p><img src="http://images.cnitblog.com/blog/48332/201311/13090739-306c82d13f914d7197a114eeae246ab5.png" alt=""></p>
<p>地址转换过程如下： </p>
<p><img src="http://images.cnitblog.com/blog/48332/201311/13091011-3f2922b4ed65405b8ccc65b9737fa014.png" alt=""></p>
<p>地址由外向内转换，因此此方法也被称为<strong>forward-mapped page table(向前映射表)</strong>。 </p>
<p>b. Hashed Page Tables 哈希页表 </p>
<p>处理超过32位地址空间的常用方法是使用<strong>hashed page table(哈希页表)</strong>，并以虚拟页码作为哈希值。哈希页表的每一条目都包括一个链表的元素，这些元素哈希成同一位置。每个元素有三个域：虚拟页码，所映射的帧号，指向链表中下一个元素的指针。 </p>
<p>个人看来，哈希页表的地址转换方式，实际上是<strong>Chaining(链接)</strong>方式，也就是一种哈希函数的溢出处理方式(另一种溢出处理方式叫做Open Addressing，开放寻址)，具体过程如下： </p>
<p>逻辑地址需要大于32bit的地址空间来表示，但是操作系统仍只有32bit来表示地址。此时人们便想到虚拟页地址，虚拟地址可以在32bit表示范围之内，然后利用哈希函数完成逻辑地址到虚拟地址的映射，由于虚拟地址更少，哈希函数会出现溢出，这里使用Chaining来解决溢出。 </p>
<p>逻辑地址中的页号(下图中的p)经过哈希函数的计算，算出虚拟地址中的页号，根据虚拟页号可以在哈希表中以O(1)方式寻址，用p与链表中的每一个元素的第一个域相比较。如果匹配，那么相应的帧号就用来形成物理地址。如果不匹配，就对链表中的下一个节点进行比较，以寻找一个匹配的页号。 </p>
<p><img src="http://images.cnitblog.com/blog/48332/201311/13104212-e3957ec532234cbab06e42ac4d1b5311.png" alt=""></p>
<p>c. Inverted page table 反向页表 </p>
<p>时间关系，这段暂时略过。 </p>
<p><strong>3. Segmentation，分段内存管理方案</strong></p>
<p>采用分页内存管理有一个不可避免的问题：用户视角的内存和实际内存的分离。设想一段main函数代码，里面包含Sqrt函数的调用。按照编写者的理解，这段代码运行时，操作系统应该分配内存给：符号表(编译时使用)，栈(存放局部变量与函数参数值)，Sqrt代码段，主函数代码段等。这样，编写者就可以方便地指出：”函数sqrt内存模块的第五条指令”，来定位一个元素。而实际上，由于采用Paging的管理方式，所有的一切都只是散落在物理内存中的各个帧上，并不是以编写者的理解来划分模块。 </p>
<p><img src="http://images.cnitblog.com/blog/48332/201311/13105648-d82857a6bb2a46e38469058978e92f8b.png" alt=""></p>
<p>Segmentation的内存管理方式可以支持这种思路。逻辑地址空间由一组段组成。每个段都有名字和长度。地址指定了段名称和段内偏移。因此用户通过两个量来指定地址：段名称和偏移。段是编号的，通过段号而非段名称来引用。因此逻辑地址由有序对构成： </p>
<p> <segment-number,offset>(&lt;段号s, 段内偏移d&gt;) </segment-number,offset></p>
<p>段偏移d因该在0和段界限之间，如果合法，那么就与基地址相加而得到所需字节在物理内存中的地址。因此段表是一组基地址和界限寄存器对。 </p>
<p><img src="http://images.cnitblog.com/blog/48332/201311/13112137-0cac9e80dbfc4bc7b9e8aa9ae664087c.png" alt=""></p>
<p>例如下图，有5个段，编号0~4，例如段2为400B开始于位置4300，对段2第53字节的引用映射成位置4300+53=4353。而段0字节1222的引用则会触发地址错误，因为该段的仅为1000B长(界限为1000)。 </p>
<p><img src="http://images.cnitblog.com/blog/48332/201311/13112441-167f767f7e1546a5ab123abbd4fad1e2.png" alt=""></p>
<p><strong>4. 合并分段和分页的管理方案</strong></p>
<p>在现有的Intel兼容计算机(x86)上，采用的内存管理方案是分段和分页合并的管理方案。 </p>
<p>在这个方案中，逻辑地址，如前一节中所说，是由一个段标识符加上一个指定段内相对地址的偏移量，表示为 [段标识符：段内偏移量]。 </p>
<p>这样的逻辑地址转换的过程是怎样呢？如下图所示： </p>
<p><img src="http://images.cnitblog.com/blog/48332/201311/15110509-3e98d0a333644e01952e7675ee2dbb71.png" alt=""></p>
<p>当CPU要执行一条引用了内存地址的指令时，转换过程就开始了。第一步是把逻辑地址转换成<strong>线性地址</strong>。但是，为什么不跳过这一步，而让软件直接使用线性地址（或物理地址呢？）原因主要是因为：</p>
<p>(1) Intel的更新是渐进式而非革命式，新的处理器需要兼容和保留过往的设置。具体的原因，博文Memory Translation and Segmentation (<a href="http://blog.csdn.net/drshenlei/article/details/4261909" target="_blank" rel="external">http://blog.csdn.net/drshenlei/article/details/4261909</a>) 中讲的较为清楚。</p>
<p>(2) 如上节所说，采用段内存管理，可以跟方便地进行地址保护(同一类型的地址逻辑地址在一起)。 </p>
<p>下面讲逻辑地址到线性地址的部分。 </p>
<p>在IBM OS/2 32位版本的操作系统，和Intel 386的环境下。操作系统采用的内存分配方式就是分段和分页合并的方式。 </p>
<p>逻辑地址的实际上是一对&lt;选择符，偏移&gt;。 </p>
<p>选择符的内容如下： </p>
<p><img src="http://images.cnitblog.com/blog/48332/201311/15225957-67836817299c459db5405bbc75f15be0.jpg" alt=""></p>
<p>从左开始，13位是索引(或者称为段号)，通过这个索引，可以定位到<strong>段描述符(segment descriptor)</strong>，而段描述符是可以真正记载了有关一个段的位置和大小信息， 以及访问控制的状态信息。段描述符一般由8个字节组成。由于8B较大，而Intel为了保持向后兼容，将段寄存器仍然规定为16-bit(尽管每个段寄存器事实上有一个64-bit长的不可见部分，但对于程序员来说，段寄存器就是16-bit的)，那么很明显，我们无法通过16-bit长度的段寄存器来直接引用64-bit的段描述符。因此在逻辑地址中，只用13bit记录其索引。而真正的段描述符，被放于数组之中。 </p>
<p>这个内存中的数组就叫做<strong>GDT(Global Descriptor Table，全局描述表)</strong>，Intel的设计者门提供了一个寄存器GDTR用来存放GDT的入口地址。程序员将GDT设定在内存中某个位置之后，可以通过LGDT指令将GDT的入口地址装入此寄存器，从此以后，CPU就根据此寄存器中的内容作为GDT的入口来访问GDT了。 </p>
<p>除了GDT之外，还有<strong>LDT(Local Descriptor **</strong>Table，本地描述表)**，但与GDT不同的是，LDT在系统中可以存在多个，每个进程可以拥有自己的LDT。LDT的内存地址在LDTR寄存器中。 </p>
<p>在之前图中的TI位，就是用来表示此索引所指向的段描述符是存于全局描述表中，还是本地描述表中。=0，表示用GDT，=1表示用LDT。 </p>
<p>RPL位，占2bit，是保护信息位，还没有仔细了解过这一块，暂时先不写。 </p>
<p>找到，段描述符后，加上偏移量，便是线性地址。转换过程如下： </p>
<p><img src="http://images.cnitblog.com/blog/48332/201311/15232144-4db8ba86c9564fcab7bab1c90bd9bf10.jpg" alt=""></p>
<p>在Intel 386的环境下，线性地址转换为物理地址的过程，和第二节分页式内存管理中，层次分页中，逻辑地址转换为物理地址的方法类似。如下图。 </p>
<p><img src="http://images.cnitblog.com/blog/48332/201311/15232858-b7f7f3c854a84da2b409e1a6bbe2211d.jpg" alt=""></p>
<p>Intel 80386的地址转换全过程如下图： </p>
<p><img src="http://images.cnitblog.com/blog/48332/201311/15224432-4c36b374c6db48898a6922b98c577313.png" alt=""></p>
<p>内存管理部分是操作系统的核心功能之一，这次将理论部分整理出来，一是为了复习，二也是为了提纲挈领地为深入学习操作系统做准备。 </p>
]]></content>
      
        <categories>
            
            <category> 操作系统 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> cpu </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[UIPopoverPresentationController]]></title>
      <url>/2017/06/12/iOS/UIPopoverPresentationController/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a>
<p>UIPopoverPresentationController 是 iOS8 后新增的，相当于pad端的UIPopOverController，以后我们也可以在iPhone上使用popOver啦。自己写了一个小demo，大概了熟悉了一下用法。后面有开发需求时会详细补充。<br>首先要知道一点是，我们并不需要创建一个UIPopoverPresentationController，他相当于UIViewController的属性，因此我们只需要创建UIViewController即可。<br>举个例子：假设我们要在 ViewController窗体弹窗，弹窗为FirstViewController（kind of UIViewController）我们用两种方式来实现<br>1、在self.view上创建一个button，给button添加弹窗事件；<br>2、在导航栏添加barButtonItem，给其添加弹窗时间。<br>弹窗事件：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token number">1</span>、button
<span class="token punctuation">[</span>objc<span class="token punctuation">]</span> view plain copy
<span class="token operator">-</span> <span class="token punctuation">(</span>void<span class="token punctuation">)</span>buttonClick  
<span class="token punctuation">{</span>  
    <span class="token builtin">FirstViewController</span> <span class="token operator">*</span>firstVC <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token builtin">FirstViewController</span> alloc<span class="token punctuation">]</span> <span class="token keyword">init</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  
    firstVC<span class="token punctuation">.</span>modalPresentationStyle <span class="token operator">=</span> <span class="token builtin">UIModalPresentationPopover</span><span class="token punctuation">;</span>  
    firstVC<span class="token punctuation">.</span>popoverPresentationController<span class="token punctuation">.</span>sourceView <span class="token operator">=</span> popOverButton<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//rect参数是以view的左上角为坐标原点（0，0）  </span>
    firstVC<span class="token punctuation">.</span>popoverPresentationController<span class="token punctuation">.</span>sourceRect <span class="token operator">=</span> popOverButton<span class="token punctuation">.</span>bounds<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//指定箭头所指区域的矩形框范围（位置和尺寸），以view的左上角为坐标原点  </span>
    firstVC<span class="token punctuation">.</span>popoverPresentationController<span class="token punctuation">.</span>permittedArrowDirections <span class="token operator">=</span> <span class="token builtin">UIPopoverArrowDirectionUp</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//箭头方向  </span>
    firstVC<span class="token punctuation">.</span>popoverPresentationController<span class="token punctuation">.</span>delegate <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">;</span>  
    firstVC<span class="token punctuation">.</span>preferredContentSize <span class="token operator">=</span> <span class="token function">CGSizeMake</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">[</span><span class="token keyword">self</span> presentViewController<span class="token punctuation">:</span>firstVC animated<span class="token punctuation">:</span><span class="token constant">YES</span> completion<span class="token punctuation">:</span><span class="token constant">nil</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span>  

<span class="token number">2</span>、barButtonItem
<span class="token punctuation">[</span>objc<span class="token punctuation">]</span> view plain copy
<span class="token operator">-</span> <span class="token punctuation">(</span>void<span class="token punctuation">)</span>rightBarButtonItemClick  
<span class="token punctuation">{</span>  
    <span class="token builtin">FirstViewController</span> <span class="token operator">*</span>firstVC <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token builtin">FirstViewController</span> alloc<span class="token punctuation">]</span><span class="token keyword">init</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  
    firstVC<span class="token punctuation">.</span>modalPresentationStyle <span class="token operator">=</span> <span class="token builtin">UIModalPresentationPopover</span><span class="token punctuation">;</span>  
    <span class="token comment" spellcheck="true">/** 
     *  由于导航上的控件没有指定frame，无法设置sourceView和sourceRect，用下面的。 
     */</span>  
    firstVC<span class="token punctuation">.</span>popoverPresentationController<span class="token punctuation">.</span>barButtonItem <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>navigationItem<span class="token punctuation">.</span>rightBarButtonItem<span class="token punctuation">;</span>  
    firstVC<span class="token punctuation">.</span>popoverPresentationController<span class="token punctuation">.</span>permittedArrowDirections <span class="token operator">=</span> <span class="token builtin">UIPopoverArrowDirectionUp</span><span class="token punctuation">;</span>  
    firstVC<span class="token punctuation">.</span>popoverPresentationController<span class="token punctuation">.</span>delegate <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">;</span>  
    firstVC<span class="token punctuation">.</span>preferredContentSize <span class="token operator">=</span> <span class="token function">CGSizeMake</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">[</span><span class="token keyword">self</span> presentViewController<span class="token punctuation">:</span>firstVC animated<span class="token punctuation">:</span><span class="token constant">YES</span> completion<span class="token punctuation">:</span><span class="token constant">nil</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  
<span class="token comment" spellcheck="true">//    firstVC.popoverPresentationController.passthroughViews = nil;  </span>
<span class="token punctuation">}</span>  
注意几点：
<span class="token number">1</span>、遵守代理：<span class="token builtin">UIPopoverPresentationControllerDelegate</span>
<span class="token number">2</span>、在phone端必须要适配设备，要设置下面代理方法：
<span class="token punctuation">[</span>objc<span class="token punctuation">]</span> view plain copy
<span class="token comment" spellcheck="true">/* For iOS8.0, the only supported adaptive presentation styles are UIModalPresentationFullScreen and UIModalPresentationOverFullScreen. */</span>  
<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token builtin">UIModalPresentationStyle</span><span class="token punctuation">)</span>adaptivePresentationStyleForPresentationController<span class="token punctuation">:</span><span class="token punctuation">(</span><span class="token builtin">UIPresentationController</span> <span class="token operator">*</span><span class="token punctuation">)</span>controller<span class="token punctuation">;</span>  
<span class="token operator">-</span>
</code></pre>
<p>iPhone下默认是UIModalPresentationFullScreen，需要手动设置为UIModalPresentationNone，否则，是普通的present全屏显示，没有弹窗效果。iPad不需要。<br>3、其他设置根据需求翻相关文档即可。<br>demo：<a href="https://github.com/Lynnll/UIPopOverLearning.git" target="_blank" rel="external">https://github.com/Lynnll/UIPopOverLearning.git</a></p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> popover </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Alamofire 4.0 Migration Guide]]></title>
      <url>/2017/06/12/iOS/Alamofire/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a> 
<h1 id="Alamofire-4-0-Migration-Guide"><a href="#Alamofire-4-0-Migration-Guide" class="headerlink" title="Alamofire 4.0 Migration Guide"></a>Alamofire 4.0 Migration Guide</h1><p>Alamofire 4.0 is the latest major release of Alamofire, an HTTP networking library for iOS, tvOS, macOS and watchOS written in Swift. As a major release, following Semantic Versioning conventions, 4.0 introduces API-breaking changes.</p>
<p>This guide is provided in order to ease the transition of existing applications using Alamofire 3.x to the latest APIs, as well as explain the design and structure of new and updated functionality.</p>
<ul>
<li><a href="#requirements">Requirements</a></li>
<li><a href="#benefits-of-upgrading">Benefits of Upgrading</a></li>
<li><a href="#breaking-api-changes">Breaking API Changes</a><ul>
<li><a href="#namespace-changes">Namespace Changes</a></li>
<li><a href="#making-requests">Making Requests</a></li>
<li><a href="#urlstringconvertible">URLStringConvertible</a></li>
<li><a href="#urlrequestconvertible">URLRequestConvertible</a></li>
</ul>
</li>
<li><a href="#new-features">New Features</a><ul>
<li><a href="#request-adapter">Request Adapter</a></li>
<li><a href="#request-retrier">Request Retrier</a></li>
<li><a href="#task-metrics">Task Metrics</a></li>
</ul>
</li>
<li><a href="#updated-features">Updated Features</a><ul>
<li><a href="#errors">Errors</a></li>
<li><a href="#parameter-encoding-protocol">Parameter Encoding Protocol</a></li>
<li><a href="#request-subclasses">Request Subclasses</a></li>
<li><a href="#response-validation">Response Validation</a></li>
<li><a href="#response-serializers">Response Serializers</a></li>
</ul>
</li>
</ul>
<h2 id="Requirements"><a href="#Requirements" class="headerlink" title="Requirements"></a>Requirements</h2><ul>
<li>iOS 8.0+, macOS 10.10.0+, tvOS 9.0+ and watchOS 2.0+</li>
<li>Xcode 8.1+</li>
<li>Swift 3.0+</li>
</ul>
<p>For those of you that would like to use Alamofire on iOS 8 or macOS 10.9, please use the latest tagged 3.x release which supports both Swift 2.2 and 2.3.</p>
<h2 id="Benefits-of-Upgrading"><a href="#Benefits-of-Upgrading" class="headerlink" title="Benefits of Upgrading"></a>Benefits of Upgrading</h2><ul>
<li><strong>Complete Swift 3 Compatibility:</strong> includes the full adoption of the new <a href="https://swift.org/documentation/api-design-guidelines/" target="_blank" rel="external">API Design Guidelines</a>.</li>
<li><strong>New Error System:</strong> uses a new <code>AFError</code> type to adhere to the new pattern proposed in <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0112-nserror-bridging.md" target="_blank" rel="external">SE-0112</a>.</li>
<li><strong>New RequestAdapter Protocol:</strong> allows inspection and adaptation of every <code>URLRequest</code> before instantiating a <code>Request</code> allowing for easy modification of properties like the <code>Authorization</code> header.</li>
<li><strong>New RequestRetrier Protocol:</strong> allows you to inspect and retry any failed <code>Request</code> if necessary allowing you to build custom authentication solutions (OAuth1, OAuth2, xAuth, Basic Auth, etc.) around a set of requests.</li>
<li><strong>New Parameter Encoding Protocol:</strong> replaces the <code>ParameterEncoding</code> enumeration allowing for easier extension and customization and also throws errors on failure instead of returning a tuple.</li>
<li><strong>New Request Types:</strong> include <code>DataRequest</code>, <code>DownloadRequest</code>, <code>UploadRequest</code> and <code>StreamRequest</code> that implement specialized progress, validation and serialization APIs and behaviors per <code>Request</code> type.</li>
<li><strong>New Progress APIs:</strong> include <code>downloadProgress</code> and <code>uploadProgress</code> APIs supporting both <code>Progress</code> and <code>Int64</code> types and called on a specified dispatch queue defaulting to <code>.main</code>.</li>
<li><strong>Enhanced Response Validation:</strong> now includes the <code>data</code> or <code>temporaryURL</code> and <code>destinationURL</code> allowing inline closures to parse the server data for error messages if validation failed.</li>
<li><strong>New Download Destinations:</strong> allow you to have full control over the move operation on the file system by disabling it, removing a previous file and creating intermediate directories.</li>
<li><strong>New Response Types:</strong> unify response API signatures and expose <code>temporaryURL</code> and <code>downloadURL</code> properties for downloads and the all new task metrics on newer platforms.</li>
</ul>
<hr>
<h2 id="Breaking-API-Changes"><a href="#Breaking-API-Changes" class="headerlink" title="Breaking API Changes"></a>Breaking API Changes</h2><p>Alamofire 4 has fully adopted all the new Swift 3 changes and conventions, including the new <a href="https://swift.org/documentation/api-design-guidelines/" target="_blank" rel="external">API Design Guidelines</a>. Because of this, almost every API in Alamofire has been modified in some way. We can’t possibly document every single change, so we’re going to attempt to identify the most common APIs and how they have changed to help you through those sometimes less than helpful compiler errors.</p>
<h3 id="Namespace-Changes"><a href="#Namespace-Changes" class="headerlink" title="Namespace Changes"></a>Namespace Changes</h3><p>Some of the common classes have been moved into the global namespace to make them a bit easier to work with and to make them first class types.</p>
<ul>
<li><code>Manager</code> is now <code>SessionManager</code></li>
<li><code>Request.TaskDelegate</code> is now <code>TaskDelegate</code></li>
<li><code>Request.DataTaskDelegate</code> is now <code>DataTaskDelegate</code></li>
<li><code>Request.DownloadTaskDelegate</code> is now <code>DownloadTaskDelegate</code></li>
<li><code>Request.UploadTaskDelegate</code> is now <code>UploadTaskDelegate</code></li>
</ul>
<p>We’ve also reorganized the file structure and organization patterns significantly to make it easier to follow the code. We hope that this will encourage more users to get to know the internal structure and implementation of Alamofire. Knowledge is power.</p>
<h3 id="Making-Requests"><a href="#Making-Requests" class="headerlink" title="Making Requests"></a>Making Requests</h3><p>Since making requests is certainly the most common operation in Alamofire, here are some examples of Alamofire 3.x requests compared to their new equivalents in Alamofire 4.</p>
<h4 id="Data-Request-Simple-with-URL-string"><a href="#Data-Request-Simple-with-URL-string" class="headerlink" title="Data Request - Simple with URL string"></a>Data Request - Simple with URL string</h4><pre class=" language-swift"><code class="language-swift"><span class="token comment" spellcheck="true">// Alamofire 3</span>
<span class="token builtin">Alamofire</span><span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token constant">GET</span><span class="token punctuation">,</span> urlString<span class="token punctuation">)</span><span class="token punctuation">.</span>response <span class="token punctuation">{</span> request<span class="token punctuation">,</span> response<span class="token punctuation">,</span> data<span class="token punctuation">,</span> error <span class="token keyword">in</span>
    <span class="token function">print</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span>
    <span class="token function">print</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span>
    <span class="token function">print</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
    <span class="token function">print</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// Alamofire 4</span>
<span class="token builtin">Alamofire</span><span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span>urlString<span class="token punctuation">)</span><span class="token punctuation">.</span>response <span class="token punctuation">{</span> response <span class="token keyword">in</span> <span class="token comment" spellcheck="true">// method defaults to `.get`</span>
    <span class="token function">debugPrint</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<h4 id="Data-Request-Complex-with-URL-string"><a href="#Data-Request-Complex-with-URL-string" class="headerlink" title="Data Request - Complex with URL string"></a>Data Request - Complex with URL string</h4><pre class=" language-swift"><code class="language-swift"><span class="token comment" spellcheck="true">// Alamofire 3</span>
<span class="token keyword">let</span> parameters<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">:</span> <span class="token builtin">AnyObject</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"foo"</span><span class="token punctuation">:</span> <span class="token string">"bar"</span><span class="token punctuation">]</span>

<span class="token builtin">Alamofire</span><span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token constant">GET</span><span class="token punctuation">,</span> urlString<span class="token punctuation">,</span> parameters<span class="token punctuation">:</span> parameters<span class="token punctuation">,</span> encoding<span class="token punctuation">:</span> <span class="token punctuation">.</span><span class="token constant">JSON</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span>progress <span class="token punctuation">{</span> bytesRead<span class="token punctuation">,</span> totalBytesRead<span class="token punctuation">,</span> totalBytesExpectedToRead <span class="token keyword">in</span>
        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Bytes: <span class="token interpolation"><span class="token delimiter variable">\(</span>bytesRead<span class="token delimiter variable">)</span></span>, Total Bytes: <span class="token interpolation"><span class="token delimiter variable">\(</span>totalBytesRead<span class="token delimiter variable">)</span></span>, Total Bytes Expected: <span class="token interpolation"><span class="token delimiter variable">\(</span>totalBytesExpectedToRead<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span>validate <span class="token punctuation">{</span> request<span class="token punctuation">,</span> response <span class="token keyword">in</span>
        <span class="token comment" spellcheck="true">// Custom evaluation closure (no access to server data)</span>
        <span class="token keyword">return</span> <span class="token punctuation">.</span>success
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span>responseJSON <span class="token punctuation">{</span> response <span class="token keyword">in</span>
        <span class="token function">debugPrint</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// Alamofire 4</span>
<span class="token keyword">let</span> parameters<span class="token punctuation">:</span> <span class="token builtin">Parameters</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"foo"</span><span class="token punctuation">:</span> <span class="token string">"bar"</span><span class="token punctuation">]</span>

<span class="token builtin">Alamofire</span><span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span>urlString<span class="token punctuation">,</span> method<span class="token punctuation">:</span> <span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">,</span> parameters<span class="token punctuation">:</span> parameters<span class="token punctuation">,</span> encoding<span class="token punctuation">:</span> <span class="token builtin">JSONEncoding</span><span class="token punctuation">.</span><span class="token keyword">default</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">downloadProgress</span><span class="token punctuation">(</span>queue<span class="token punctuation">:</span> <span class="token builtin">DispatchQueue</span><span class="token punctuation">.</span><span class="token function">global</span><span class="token punctuation">(</span>qos<span class="token punctuation">:</span> <span class="token punctuation">.</span>utility<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> progress <span class="token keyword">in</span>
        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Progress: <span class="token interpolation"><span class="token delimiter variable">\(</span>progress<span class="token punctuation">.</span>fractionCompleted<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span>validate <span class="token punctuation">{</span> request<span class="token punctuation">,</span> response<span class="token punctuation">,</span> data <span class="token keyword">in</span>
        <span class="token comment" spellcheck="true">// Custom evaluation closure now includes data (allows you to parse data to dig out error messages if necessary)</span>
        <span class="token keyword">return</span> <span class="token punctuation">.</span>success
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span>responseJSON <span class="token punctuation">{</span> response <span class="token keyword">in</span>
        <span class="token function">debugPrint</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
</code></pre>
<h4 id="Download-Request-Simple-with-URL-string"><a href="#Download-Request-Simple-with-URL-string" class="headerlink" title="Download Request - Simple with URL string"></a>Download Request - Simple with URL string</h4><pre class=" language-swift"><code class="language-swift"><span class="token comment" spellcheck="true">// Alamofire 3</span>
<span class="token keyword">let</span> destination <span class="token operator">=</span> <span class="token builtin">DownloadRequest</span><span class="token punctuation">.</span><span class="token function">suggestedDownloadDestination</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token builtin">Alamofire</span><span class="token punctuation">.</span><span class="token function">download</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token constant">GET</span><span class="token punctuation">,</span> urlString<span class="token punctuation">,</span> destination<span class="token punctuation">:</span> destination<span class="token punctuation">)</span><span class="token punctuation">.</span>response <span class="token punctuation">{</span> request<span class="token punctuation">,</span> response<span class="token punctuation">,</span> data<span class="token punctuation">,</span> error <span class="token keyword">in</span>
    <span class="token comment" spellcheck="true">// What is fileURL...not easy to get</span>
    <span class="token function">print</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span>
    <span class="token function">print</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span>
    <span class="token function">print</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
    <span class="token function">print</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// Alamofire 4</span>
<span class="token keyword">let</span> destination <span class="token operator">=</span> <span class="token builtin">DownloadRequest</span><span class="token punctuation">.</span><span class="token function">suggestedDownloadDestination</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token builtin">Alamofire</span><span class="token punctuation">.</span><span class="token function">download</span><span class="token punctuation">(</span>urlString<span class="token punctuation">,</span> to<span class="token punctuation">:</span> destination<span class="token punctuation">)</span><span class="token punctuation">.</span>response <span class="token punctuation">{</span> response <span class="token keyword">in</span> <span class="token comment" spellcheck="true">// method defaults to `.get`</span>
    <span class="token function">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>request<span class="token punctuation">)</span>
    <span class="token function">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>response<span class="token punctuation">)</span>
    <span class="token function">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>temporaryURL<span class="token punctuation">)</span>
    <span class="token function">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>destinationURL<span class="token punctuation">)</span>
    <span class="token function">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>error<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<h4 id="Download-Request-Simple-with-URL-request"><a href="#Download-Request-Simple-with-URL-request" class="headerlink" title="Download Request - Simple with URL request"></a>Download Request - Simple with URL request</h4><pre class=" language-swift"><code class="language-swift"><span class="token comment" spellcheck="true">// Alamofire 3</span>
<span class="token keyword">let</span> destination <span class="token operator">=</span> <span class="token builtin">DownloadRequest</span><span class="token punctuation">.</span><span class="token function">suggestedDownloadDestination</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token builtin">Alamofire</span><span class="token punctuation">.</span><span class="token function">download</span><span class="token punctuation">(</span>urlRequest<span class="token punctuation">,</span> destination<span class="token punctuation">:</span> destination<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">validate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>responseData <span class="token punctuation">{</span> response <span class="token keyword">in</span>
    <span class="token comment" spellcheck="true">// What is fileURL...not easy to get</span>
    <span class="token function">debugPrint</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// Alamofire 4</span>
<span class="token builtin">Alamofire</span><span class="token punctuation">.</span><span class="token function">download</span><span class="token punctuation">(</span>urlRequest<span class="token punctuation">,</span> to<span class="token punctuation">:</span> destination<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">validate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>responseData <span class="token punctuation">{</span> response <span class="token keyword">in</span>
    <span class="token function">debugPrint</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span>
    <span class="token function">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>temporaryURL<span class="token punctuation">)</span>
    <span class="token function">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>destinationURL<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<h4 id="Download-Request-Complex-with-URL-string"><a href="#Download-Request-Complex-with-URL-string" class="headerlink" title="Download Request - Complex with URL string"></a>Download Request - Complex with URL string</h4><pre class=" language-swift"><code class="language-swift"><span class="token comment" spellcheck="true">// Alamofire 3</span>
<span class="token keyword">let</span> fileURL<span class="token punctuation">:</span> <span class="token constant">NSURL</span>
<span class="token keyword">let</span> destination<span class="token punctuation">:</span> <span class="token builtin">Request</span><span class="token punctuation">.</span><span class="token builtin">DownloadFileDestination</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">_</span><span class="token punctuation">,</span> <span class="token number">_</span> <span class="token keyword">in</span> fileURL <span class="token punctuation">}</span>
<span class="token keyword">let</span> parameters<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">:</span> <span class="token builtin">AnyObject</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"foo"</span><span class="token punctuation">:</span> <span class="token string">"bar"</span><span class="token punctuation">]</span>

<span class="token builtin">Alamofire</span><span class="token punctuation">.</span><span class="token function">download</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token constant">GET</span><span class="token punctuation">,</span> urlString<span class="token punctuation">,</span> parameters<span class="token punctuation">:</span> parameters<span class="token punctuation">,</span> encoding<span class="token punctuation">:</span> <span class="token punctuation">.</span><span class="token constant">JSON</span><span class="token punctuation">,</span> to<span class="token punctuation">:</span> destination<span class="token punctuation">)</span>
    <span class="token punctuation">.</span>progress <span class="token punctuation">{</span> bytesRead<span class="token punctuation">,</span> totalBytesRead<span class="token punctuation">,</span> totalBytesExpectedToRead <span class="token keyword">in</span>
        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Bytes: <span class="token interpolation"><span class="token delimiter variable">\(</span>bytesRead<span class="token delimiter variable">)</span></span>, Total Bytes: <span class="token interpolation"><span class="token delimiter variable">\(</span>totalBytesRead<span class="token delimiter variable">)</span></span>, Total Bytes Expected: <span class="token interpolation"><span class="token delimiter variable">\(</span>totalBytesExpectedToRead<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span>validate <span class="token punctuation">{</span> request<span class="token punctuation">,</span> response <span class="token keyword">in</span>
        <span class="token comment" spellcheck="true">// Custom evaluation implementation (no access to temporary or destination URLs)</span>
        <span class="token keyword">return</span> <span class="token punctuation">.</span>success
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span>responseJSON <span class="token punctuation">{</span> response <span class="token keyword">in</span>
        <span class="token function">print</span><span class="token punctuation">(</span>fileURL<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// Only accessible if captured in closure scope, not ideal</span>
        <span class="token function">debugPrint</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// Alamofire 4</span>
<span class="token keyword">let</span> fileURL<span class="token punctuation">:</span> <span class="token constant">URL</span>
<span class="token keyword">let</span> destination<span class="token punctuation">:</span> <span class="token builtin">DownloadRequest</span><span class="token punctuation">.</span><span class="token builtin">DownloadFileDestination</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">_</span><span class="token punctuation">,</span> <span class="token number">_</span> <span class="token keyword">in</span> 
    <span class="token keyword">return</span> <span class="token punctuation">(</span>fileURL<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">.</span>createIntermediateDirectories<span class="token punctuation">,</span> <span class="token punctuation">.</span>removePreviousFile<span class="token punctuation">]</span><span class="token punctuation">)</span> 
<span class="token punctuation">}</span>
<span class="token keyword">let</span> parameters<span class="token punctuation">:</span> <span class="token builtin">Parameters</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"foo"</span><span class="token punctuation">:</span> <span class="token string">"bar"</span><span class="token punctuation">]</span>

<span class="token builtin">Alamofire</span><span class="token punctuation">.</span><span class="token function">download</span><span class="token punctuation">(</span>urlString<span class="token punctuation">,</span> method<span class="token punctuation">:</span> <span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">,</span> parameters<span class="token punctuation">:</span> parameters<span class="token punctuation">,</span> encoding<span class="token punctuation">:</span> <span class="token builtin">JSONEncoding</span><span class="token punctuation">.</span><span class="token keyword">default</span><span class="token punctuation">,</span> to<span class="token punctuation">:</span> destination<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">downloadProgress</span><span class="token punctuation">(</span>queue<span class="token punctuation">:</span> <span class="token builtin">DispatchQueue</span><span class="token punctuation">.</span><span class="token function">global</span><span class="token punctuation">(</span>qos<span class="token punctuation">:</span> <span class="token punctuation">.</span>utility<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> progress <span class="token keyword">in</span>
        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Progress: <span class="token interpolation"><span class="token delimiter variable">\(</span>progress<span class="token punctuation">.</span>fractionCompleted<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span>validate <span class="token punctuation">{</span> request<span class="token punctuation">,</span> response<span class="token punctuation">,</span> temporaryURL<span class="token punctuation">,</span> destinationURL <span class="token keyword">in</span>
        <span class="token comment" spellcheck="true">// Custom evaluation closure now includes file URLs (allows you to parse out error messages if necessary)</span>
        <span class="token keyword">return</span> <span class="token punctuation">.</span>success
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span>responseJSON <span class="token punctuation">{</span> response <span class="token keyword">in</span>
        <span class="token function">debugPrint</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span>
        <span class="token function">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>temporaryURL<span class="token punctuation">)</span>
        <span class="token function">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>destinationURL<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
</code></pre>
<h4 id="Upload-Request-Simple-with-URL-string"><a href="#Upload-Request-Simple-with-URL-string" class="headerlink" title="Upload Request - Simple with URL string"></a>Upload Request - Simple with URL string</h4><pre class=" language-swift"><code class="language-swift"><span class="token comment" spellcheck="true">// Alamofire 3</span>
<span class="token builtin">Alamofire</span><span class="token punctuation">.</span><span class="token function">upload</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token constant">POST</span><span class="token punctuation">,</span> urlString<span class="token punctuation">,</span> data<span class="token punctuation">:</span> data<span class="token punctuation">)</span><span class="token punctuation">.</span>response <span class="token punctuation">{</span> request<span class="token punctuation">,</span> response<span class="token punctuation">,</span> data<span class="token punctuation">,</span> error <span class="token keyword">in</span>
    <span class="token function">print</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span>
    <span class="token function">print</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span>
    <span class="token function">print</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
    <span class="token function">print</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// Alamofire 4</span>
<span class="token builtin">Alamofire</span><span class="token punctuation">.</span><span class="token function">upload</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> to<span class="token punctuation">:</span> urlString<span class="token punctuation">)</span><span class="token punctuation">.</span>response <span class="token punctuation">{</span> response <span class="token keyword">in</span> <span class="token comment" spellcheck="true">// method defaults to `.post`</span>
    <span class="token function">debugPrint</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<h4 id="Upload-Request-Simple-with-URL-request"><a href="#Upload-Request-Simple-with-URL-request" class="headerlink" title="Upload Request - Simple with URL request"></a>Upload Request - Simple with URL request</h4><pre class=" language-swift"><code class="language-swift"><span class="token comment" spellcheck="true">// Alamofire 3</span>
<span class="token builtin">Alamofire</span><span class="token punctuation">.</span><span class="token function">upload</span><span class="token punctuation">(</span>urlRequest<span class="token punctuation">,</span> file<span class="token punctuation">:</span> fileURL<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">validate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>responseData <span class="token punctuation">{</span> response <span class="token keyword">in</span>
    <span class="token function">debugPrint</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// Alamofire 4</span>
<span class="token builtin">Alamofire</span><span class="token punctuation">.</span><span class="token function">upload</span><span class="token punctuation">(</span>fileURL<span class="token punctuation">,</span> with<span class="token punctuation">:</span> urlRequest<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">validate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>responseData <span class="token punctuation">{</span> response <span class="token keyword">in</span>
    <span class="token function">debugPrint</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<h4 id="Upload-Request-Complex-with-URL-string"><a href="#Upload-Request-Complex-with-URL-string" class="headerlink" title="Upload Request - Complex with URL string"></a>Upload Request - Complex with URL string</h4><pre class=" language-swift"><code class="language-swift"><span class="token comment" spellcheck="true">// Alamofire 3</span>
<span class="token builtin">Alamofire</span><span class="token punctuation">.</span><span class="token function">upload</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token constant">PUT</span><span class="token punctuation">,</span> urlString<span class="token punctuation">,</span> file<span class="token punctuation">:</span> fileURL<span class="token punctuation">)</span>
    <span class="token punctuation">.</span>progress <span class="token punctuation">{</span> bytes<span class="token punctuation">,</span> totalBytes<span class="token punctuation">,</span> totalBytesExpected <span class="token keyword">in</span>
        <span class="token comment" spellcheck="true">// Are these for upload or for downloading the response?</span>
        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Bytes: <span class="token interpolation"><span class="token delimiter variable">\(</span>bytesRead<span class="token delimiter variable">)</span></span>, Total Bytes: <span class="token interpolation"><span class="token delimiter variable">\(</span>totalBytesRead<span class="token delimiter variable">)</span></span>, Total Bytes Expected: <span class="token interpolation"><span class="token delimiter variable">\(</span>totalBytesExpectedToRead<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span>validate <span class="token punctuation">{</span> request<span class="token punctuation">,</span> response <span class="token keyword">in</span>
        <span class="token comment" spellcheck="true">// Custom evaluation implementation (no access to server data)</span>
        <span class="token keyword">return</span> <span class="token punctuation">.</span>success
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span>responseJSON <span class="token punctuation">{</span> response <span class="token keyword">in</span>
        <span class="token function">debugPrint</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// Alamofire 4</span>
<span class="token builtin">Alamofire</span><span class="token punctuation">.</span><span class="token function">upload</span><span class="token punctuation">(</span>fileURL<span class="token punctuation">,</span> to<span class="token punctuation">:</span> urlString<span class="token punctuation">,</span> method<span class="token punctuation">:</span> <span class="token punctuation">.</span>put<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">uploadProgress</span><span class="token punctuation">(</span>queue<span class="token punctuation">:</span> <span class="token builtin">DispatchQueue</span><span class="token punctuation">.</span><span class="token function">global</span><span class="token punctuation">(</span>qos<span class="token punctuation">:</span> <span class="token punctuation">.</span>utility<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> progress <span class="token keyword">in</span>
        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Upload Progress: <span class="token interpolation"><span class="token delimiter variable">\(</span>progress<span class="token punctuation">.</span>fractionCompleted<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span>downloadProgress <span class="token punctuation">{</span> progress <span class="token keyword">in</span> <span class="token comment" spellcheck="true">// called on main queue by default</span>
        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Download Progress: <span class="token interpolation"><span class="token delimiter variable">\(</span>progress<span class="token punctuation">.</span>fractionCompleted<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span>validate <span class="token punctuation">{</span> request<span class="token punctuation">,</span> response<span class="token punctuation">,</span> data <span class="token keyword">in</span>
        <span class="token comment" spellcheck="true">// Custom evaluation closure now includes data (allows you to parse data to dig out error messages if necessary)</span>
        <span class="token keyword">return</span> <span class="token punctuation">.</span>success
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span>responseJSON <span class="token punctuation">{</span> response <span class="token keyword">in</span>
        <span class="token function">debugPrint</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
</code></pre>
<p>As you can see, there are many breaking API changes, but the common APIs still adhere to the original design goals of being able to make complex requests through a single line of code in a concise, well defined manner.</p>
<h3 id="URLStringConvertible"><a href="#URLStringConvertible" class="headerlink" title="URLStringConvertible"></a>URLStringConvertible</h3><p>There are two changes to the <code>URLStringConvertible</code> protocol that are worth noting.</p>
<h4 id="URLConvertible"><a href="#URLConvertible" class="headerlink" title="URLConvertible"></a>URLConvertible</h4><p>The first MAJOR change worth noting on the <code>URLStringConvertible</code> is that it has been renamed to <code>URLConvertible</code>. In Alamofire 3.x, the <code>URLStringConvertible</code> was defined as:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">public</span> protocol <span class="token builtin">URLStringConvertible</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> <span class="token builtin">URLString</span><span class="token punctuation">:</span> <span class="token builtin">String</span> <span class="token punctuation">{</span> <span class="token keyword">get</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Now in Alamofire 4, the <code>URLConvertible</code> protocol is defined as:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">public</span> protocol <span class="token builtin">URLConvertible</span> <span class="token punctuation">{</span>
    <span class="token keyword">func</span> <span class="token function">asURL</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token constant">URL</span>
<span class="token punctuation">}</span>
</code></pre>
<p>As you can see, the <code>URLString</code> property is completely gone and replaced by a new <code>asURL</code> method that throws. To explain, let’s first backup.</p>
<p>A VERY common problem in Alamofire is that users forget to percent escape their URL strings and Alamofire will crash. Up until now, we (the Alamofire team) have taken the stance that this is how Alamofire is designed and your URLs need to conform to <a href="https://tools.ietf.org/html/rfc2396" target="_blank" rel="external">RFC 2396</a>. This is certainly not ideal for the community because we all would rather have Alamofire tell us that our URL was invalid rather than having it crash.</p>
<p>Now, back to the new <code>URLConvertible</code> protocol. The reason Alamofire was not previously able to safely handle invalid URL strings was, in fact, due to the lack of safety on <code>URLStringConvertible</code>. It’s not possible for Alamofire to know how to intelligently make an invalid URL string valid. Therefore, if the <code>URL</code> is unable to be created from the <code>URLConvertible</code>, an <code>AFError.invalidURL</code> error is thrown.</p>
<p>This change (along with many others) allows Alamofire to safely handle invalid URLs and report the error back in the response handlers.</p>
<h4 id="URLRequest-Conformance"><a href="#URLRequest-Conformance" class="headerlink" title="URLRequest Conformance"></a>URLRequest Conformance</h4><p>The <code>URLRequest</code> no longer conforms to the <code>URLStringConvertible</code>, now <code>URLConvertible</code> protocol. This was always a bit of a stretch in the previous versions of Alamofire and wasn’t really necessary. It also had a high potential to introduce ambiguity into many Alamofire APIs. Because of these reasons, <code>URLRequest</code> no longer conforms to <code>URLStringConvertible</code> (now <code>URLConvertible</code>).</p>
<p>What this means in code is that you can no longer do the following:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> urlRequest <span class="token operator">=</span> <span class="token function">URLRequest</span><span class="token punctuation">(</span>url<span class="token punctuation">:</span> <span class="token function">URL</span><span class="token punctuation">(</span>string<span class="token punctuation">:</span> <span class="token string">"https://httpbin.org/get"</span><span class="token punctuation">)</span><span class="token operator">!</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> urlString <span class="token operator">=</span> urlRequest<span class="token punctuation">.</span>urlString
</code></pre>
<p>Instead, in Alamofire 4, you now have to do the following:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> urlRequest <span class="token operator">=</span> <span class="token function">URLRequest</span><span class="token punctuation">(</span>url<span class="token punctuation">:</span> <span class="token function">URL</span><span class="token punctuation">(</span>string<span class="token punctuation">:</span> <span class="token string">"https://httpbin.org/get"</span><span class="token punctuation">)</span><span class="token operator">!</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> urlString <span class="token operator">=</span> urlRequest<span class="token punctuation">.</span>url<span class="token operator">?</span><span class="token punctuation">.</span>absoluteString
</code></pre>
<blockquote>
<p>See <a href="https://github.com/Alamofire/Alamofire/pull/1505" target="_blank" rel="external">PR-1505</a> for more info.</p>
</blockquote>
<h3 id="URLRequestConvertible"><a href="#URLRequestConvertible" class="headerlink" title="URLRequestConvertible"></a>URLRequestConvertible</h3><p>The <code>URLRequestConvertible</code> was susceptible to the same safety issues concerns as the <code>URLStringConvertible</code> in Alamofire 3.x. In Alamofire 3, the <code>URLRequestConvertible</code> was:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">public</span> protocol <span class="token builtin">URLRequestConvertible</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> <span class="token builtin">URLRequest</span><span class="token punctuation">:</span> <span class="token builtin">URLRequest</span> <span class="token punctuation">{</span> <span class="token keyword">get</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Now, in Alamofire 4, it is:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">public</span> protocol <span class="token builtin">URLRequestConvertible</span> <span class="token punctuation">{</span>
    <span class="token keyword">func</span> <span class="token function">asURLRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">URLRequest</span>
<span class="token punctuation">}</span>
</code></pre>
<p>As you can see, the <code>URLRequest</code> property has been replaced by an <code>asURLRequest</code> method that throws when encountering an error generating the <code>URLRequest</code>.</p>
<p>The most likely place this will affect your code is in the <code>Router</code> design pattern. If you have a <code>Router</code>, it’s going to have to change, but for the better! You will now implement the <code>asURLRequest</code> method instead of the property which gives you the ability to throw an error if necessary. You no longer have to force unwrap unsafe data or parameters or wrap <code>ParameterEncoding</code> in a do-catch. Any error encountered in a <code>Router</code> can now be automatically handled by Alamofire.</p>
<blockquote>
<p>See <a href="https://github.com/Alamofire/Alamofire/pull/1505" target="_blank" rel="external">PR-1505</a> for more info.</p>
</blockquote>
<hr>
<h2 id="New-Features"><a href="#New-Features" class="headerlink" title="New Features"></a>New Features</h2><h3 id="Request-Adapter"><a href="#Request-Adapter" class="headerlink" title="Request Adapter"></a>Request Adapter</h3><p>The <code>RequestAdapter</code> protocol is a completely new feature in Alamofire 4. </p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">public</span> protocol <span class="token builtin">RequestAdapter</span> <span class="token punctuation">{</span>
    <span class="token keyword">func</span> <span class="token function">adapt</span><span class="token punctuation">(</span><span class="token number">_</span> urlRequest<span class="token punctuation">:</span> <span class="token builtin">URLRequest</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">URLRequest</span>
<span class="token punctuation">}</span>
</code></pre>
<p>It allows each <code>Request</code> made on a <code>SessionManager</code> to be inspected and adapted before being created. One very specific way to use an adapter is to append an <code>Authorization</code> header to requests behind a certain type of authentication.</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">class</span> <span class="token class-name">AccessTokenAdapter</span><span class="token punctuation">:</span> <span class="token builtin">RequestAdapter</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">let</span> accessToken<span class="token punctuation">:</span> <span class="token builtin">String</span>

    <span class="token keyword">init</span><span class="token punctuation">(</span>accessToken<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>accessToken <span class="token operator">=</span> accessToken
    <span class="token punctuation">}</span>

    <span class="token keyword">func</span> <span class="token function">adapt</span><span class="token punctuation">(</span><span class="token number">_</span> urlRequest<span class="token punctuation">:</span> <span class="token builtin">URLRequest</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">URLRequest</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> urlRequest <span class="token operator">=</span> urlRequest

        <span class="token keyword">if</span> urlRequest<span class="token punctuation">.</span>urlString<span class="token punctuation">.</span><span class="token function">hasPrefix</span><span class="token punctuation">(</span><span class="token string">"https://httpbin.org"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            urlRequest<span class="token punctuation">.</span><span class="token function">setValue</span><span class="token punctuation">(</span><span class="token string">"Bearer "</span> <span class="token operator">+</span> accessToken<span class="token punctuation">,</span> forHTTPHeaderField<span class="token punctuation">:</span> <span class="token string">"Authorization"</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">return</span> urlRequest
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> sessionManager <span class="token operator">=</span> <span class="token function">SessionManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
sessionManager<span class="token punctuation">.</span>adapter <span class="token operator">=</span> <span class="token function">AccessTokenAdapter</span><span class="token punctuation">(</span>accessToken<span class="token punctuation">:</span> <span class="token string">"1234"</span><span class="token punctuation">)</span>

sessionManager<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token string">"https://httpbin.org/get"</span><span class="token punctuation">)</span>
</code></pre>
<p>If an <code>Error</code> occurs during the adaptation process, it should be thrown and will be delivered in the response handler of the <code>Request</code>.</p>
<blockquote>
<p>See <a href="https://github.com/Alamofire/Alamofire/pull/1450" target="_blank" rel="external">PR-1450</a> for more info.</p>
</blockquote>
<h3 id="Request-Retrier"><a href="#Request-Retrier" class="headerlink" title="Request Retrier"></a>Request Retrier</h3><p>The <code>RequestRetrier</code> is another brand new Alamofire 4 protocol. </p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">public</span> <span class="token keyword">typealias</span> <span class="token builtin">RequestRetryCompletion</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">_</span> shouldRetry<span class="token punctuation">:</span> <span class="token builtin">Bool</span><span class="token punctuation">,</span> <span class="token number">_</span> timeDelay<span class="token punctuation">:</span> <span class="token builtin">TimeInterval</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Void</span>

<span class="token keyword">public</span> protocol <span class="token builtin">RequestRetrier</span> <span class="token punctuation">{</span>
    <span class="token keyword">func</span> <span class="token function">should</span><span class="token punctuation">(</span><span class="token number">_</span> manager<span class="token punctuation">:</span> <span class="token builtin">SessionManager</span><span class="token punctuation">,</span> retry request<span class="token punctuation">:</span> <span class="token builtin">Request</span><span class="token punctuation">,</span> with error<span class="token punctuation">:</span> <span class="token builtin">Error</span><span class="token punctuation">,</span> completion<span class="token punctuation">:</span> @escaping <span class="token builtin">RequestRetryCompletion</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<p>It allows a <code>Request</code> that encountered an <code>Error</code> while being executed to be retried with an optional delay if specified.</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">class</span> <span class="token class-name">OAuth2Handler</span><span class="token punctuation">:</span> <span class="token builtin">RequestAdapter</span><span class="token punctuation">,</span> <span class="token builtin">RequestRetrier</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">func</span> <span class="token function">should</span><span class="token punctuation">(</span><span class="token number">_</span> manager<span class="token punctuation">:</span> <span class="token builtin">SessionManager</span><span class="token punctuation">,</span> retry request<span class="token punctuation">:</span> <span class="token builtin">Request</span><span class="token punctuation">,</span> with error<span class="token punctuation">:</span> <span class="token builtin">Error</span><span class="token punctuation">,</span> completion<span class="token punctuation">:</span> <span class="token builtin">RequestRetryCompletion</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token keyword">let</span> response <span class="token operator">=</span> request<span class="token punctuation">.</span>task<span class="token punctuation">.</span>response <span class="token keyword">as</span><span class="token operator">?</span> <span class="token builtin">HTTPURLResponse</span><span class="token punctuation">,</span> response<span class="token punctuation">.</span>statusCode <span class="token operator">==</span> <span class="token number">401</span> <span class="token punctuation">{</span>
            <span class="token function">completion</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// retry after 1 second</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token function">completion</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// don't retry</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> sessionManager <span class="token operator">=</span> <span class="token function">SessionManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
sessionManager<span class="token punctuation">.</span>retrier <span class="token operator">=</span> <span class="token function">OAuth2Handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

sessionManager<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span>urlString<span class="token punctuation">)</span><span class="token punctuation">.</span>responseJSON <span class="token punctuation">{</span> response <span class="token keyword">in</span>
    <span class="token function">debugPrint</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<p>The retrier allows you to inspect the <code>Request</code> after it has completed and run all <code>Validation</code> closures to determine whether it should be retried. When using both the <code>RequestAdapter</code> and <code>RequestRetrier</code> protocols together, you can create credential refresh systems for OAuth1, OAuth2, Basic Auth and even exponential backoff retry policies. The possibilities are endless. For more information and examples on this topic, please refer to the README.</p>
<blockquote>
<p>See <a href="https://github.com/Alamofire/Alamofire/pull/1391" target="_blank" rel="external">PR-1391</a> and <a href="https://github.com/Alamofire/Alamofire/pull/1450" target="_blank" rel="external">PR-1450</a> for more info.</p>
</blockquote>
<h3 id="Task-Metrics"><a href="#Task-Metrics" class="headerlink" title="Task Metrics"></a>Task Metrics</h3><p>In iOS and tvOS 10 and macOS 10.12, Apple introduced the new <a href="https://developer.apple.com/reference/foundation/urlsessiontaskmetrics" target="_blank" rel="external">URLSessionTaskMetrics</a> APIs. The task metrics encapsulate some fantastic statistical information about the request and response execution. The API is very similar to Alamofire’s <code>Timeline</code>, but provide many more statistics that Alamofire was unable to compute. We’re really excited about these APIs and have exposed them on each <code>Response</code> type meaning they couldn’t be easier to use.</p>
<pre class=" language-swift"><code class="language-swift"><span class="token builtin">Alamofire</span><span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span>urlString<span class="token punctuation">)</span><span class="token punctuation">.</span>response <span class="token punctuation">{</span> response <span class="token keyword">in</span>
    <span class="token function">debugPrint</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>metrics<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<p>It’s important to note that these APIs are only available on iOS and tvOS 10+ and macOS 10.12+. Therefore, depending on your deployment target, you may need to use these inside availability checks:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token builtin">Alamofire</span><span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span>urlString<span class="token punctuation">)</span><span class="token punctuation">.</span>response <span class="token punctuation">{</span> response <span class="token keyword">in</span>
    <span class="token keyword">if</span> #<span class="token function">available</span><span class="token punctuation">(</span>iOS <span class="token number">10.0</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">debugPrint</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>metrics<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>See <a href="https://github.com/Alamofire/Alamofire/pull/1492" target="_blank" rel="external">PR-1492</a> for more info.</p>
</blockquote>
<hr>
<h2 id="Updated-Features"><a href="#Updated-Features" class="headerlink" title="Updated Features"></a>Updated Features</h2><p>Alamofire 4 contains many new features and enhancements on existing ones. This section is designed to give a brief overview of the features and demonstrate their uses. For more information on each each, please refer to the linked pull request.</p>
<h3 id="Errors"><a href="#Errors" class="headerlink" title="Errors"></a>Errors</h3><p>Alamofire 4 contains a completely new error system that adopts the new pattern proposed in <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0112-nserror-bridging.md" target="_blank" rel="external">SE-0112</a>. At the heart of the new error system is <code>AFError</code>, a new <code>Error</code> type enumeration backed by five main cases.</p>
<ul>
<li><code>.invalidURL(url: URLConvertible)</code> - Returned when a <code>URLConvertible</code> type fails to create a valid <code>URL</code>.</li>
<li><code>.parameterEncodingFailed(reason: ParameterEncodingFailureReason)</code> - Returned when a parameter encoding object throws an error during the encoding process.</li>
<li><code>.multipartEncodingFailed(reason: MultipartEncodingFailureReason)</code> - Returned when some step in the multipart encoding process fails. </li>
<li><code>.responseValidationFailed(reason: ResponseValidationFailureReason)</code> - Returned when a <code>validate()</code> call fails.</li>
<li><code>.responseSerializationFailed(reason: ResponseSerializationFailureReason)</code> - Returned when a response serializer encounters an error in the serialization process.</li>
</ul>
<p>Each case contains a specific failure reason which is another nested enumeration with multiple cases that contain additional information about the exact type of error that occurred. What this ultimately means is that is is much easier in Alamofire to identify where an error came from and what to do about it.</p>
<pre class=" language-swift"><code class="language-swift"><span class="token builtin">Alamofire</span><span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span>urlString<span class="token punctuation">)</span><span class="token punctuation">.</span>responseJSON <span class="token punctuation">{</span> response <span class="token keyword">in</span>
    <span class="token keyword">guard</span> <span class="token keyword">case</span> <span class="token keyword">let</span> <span class="token punctuation">.</span><span class="token function">failure</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token operator">=</span> response<span class="token punctuation">.</span>result <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token keyword">let</span> error <span class="token operator">=</span> error <span class="token keyword">as</span><span class="token operator">?</span> <span class="token builtin">AFError</span> <span class="token punctuation">{</span>
        <span class="token keyword">switch</span> error <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token punctuation">.</span><span class="token function">invalidURL</span><span class="token punctuation">(</span><span class="token keyword">let</span> url<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Invalid URL: <span class="token interpolation"><span class="token delimiter variable">\(</span>url<span class="token delimiter variable">)</span></span> - <span class="token interpolation"><span class="token delimiter variable">\(</span>error<span class="token punctuation">.</span>localizedDescription<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span>
        <span class="token keyword">case</span> <span class="token punctuation">.</span><span class="token function">parameterEncodingFailed</span><span class="token punctuation">(</span><span class="token keyword">let</span> reason<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Parameter encoding failed: <span class="token interpolation"><span class="token delimiter variable">\(</span>error<span class="token punctuation">.</span>localizedDescription<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span>
            <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Failure Reason: <span class="token interpolation"><span class="token delimiter variable">\(</span>reason<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span>
        <span class="token keyword">case</span> <span class="token punctuation">.</span><span class="token function">multipartEncodingFailed</span><span class="token punctuation">(</span><span class="token keyword">let</span> reason<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Multipart encoding failed: <span class="token interpolation"><span class="token delimiter variable">\(</span>error<span class="token punctuation">.</span>localizedDescription<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span>
            <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Failure Reason: <span class="token interpolation"><span class="token delimiter variable">\(</span>reason<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span>
        <span class="token keyword">case</span> <span class="token punctuation">.</span><span class="token function">responseValidationFailed</span><span class="token punctuation">(</span><span class="token keyword">let</span> reason<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Response validation failed: <span class="token interpolation"><span class="token delimiter variable">\(</span>error<span class="token punctuation">.</span>localizedDescription<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span>
            <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Failure Reason: <span class="token interpolation"><span class="token delimiter variable">\(</span>reason<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span>

            <span class="token keyword">switch</span> reason <span class="token punctuation">{</span>
            <span class="token keyword">case</span> <span class="token punctuation">.</span>dataFileNil<span class="token punctuation">,</span> <span class="token punctuation">.</span>dataFileReadFailed<span class="token punctuation">:</span>
                <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Downloaded file could not be read"</span><span class="token punctuation">)</span>
            <span class="token keyword">case</span> <span class="token punctuation">.</span><span class="token function">missingContentType</span><span class="token punctuation">(</span><span class="token keyword">let</span> acceptableContentTypes<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Content Type Missing: <span class="token interpolation"><span class="token delimiter variable">\(</span>acceptableContentTypes<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span>
            <span class="token keyword">case</span> <span class="token punctuation">.</span><span class="token function">unacceptableContentType</span><span class="token punctuation">(</span><span class="token keyword">let</span> acceptableContentTypes<span class="token punctuation">,</span> <span class="token keyword">let</span> responseContentType<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Response content type: <span class="token interpolation"><span class="token delimiter variable">\(</span>responseContentType<span class="token delimiter variable">)</span></span> was unacceptable: <span class="token interpolation"><span class="token delimiter variable">\(</span>acceptableContentTypes<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span>
            <span class="token keyword">case</span> <span class="token punctuation">.</span><span class="token function">unacceptableStatusCode</span><span class="token punctuation">(</span><span class="token keyword">let</span> code<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Response status code was unacceptable: <span class="token interpolation"><span class="token delimiter variable">\(</span>code<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
        <span class="token keyword">case</span> <span class="token punctuation">.</span><span class="token function">responseSerializationFailed</span><span class="token punctuation">(</span><span class="token keyword">let</span> reason<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Response serialization failed: <span class="token interpolation"><span class="token delimiter variable">\(</span>error<span class="token punctuation">.</span>localizedDescription<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span>
            <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Failure Reason: <span class="token interpolation"><span class="token delimiter variable">\(</span>reason<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>

        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Underlying error: <span class="token interpolation"><span class="token delimiter variable">\(</span>error<span class="token punctuation">.</span>underlyingError<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token keyword">let</span> error <span class="token operator">=</span> error <span class="token keyword">as</span><span class="token operator">?</span> <span class="token builtin">URLError</span> <span class="token punctuation">{</span>
        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"URLError occurred: <span class="token interpolation"><span class="token delimiter variable">\(</span>error<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Unknown error: <span class="token interpolation"><span class="token delimiter variable">\(</span>error<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>This new design allows you to drill down into errors as deep as you may need to in order to figure out the best way to proceed. It also frees developers from the burden of having to deal with <code>NSError</code> types everywhere. By switching to our own custom <code>Error</code> type in Alamofire, we’ve been able to simplify the <code>Result</code> and <code>Response</code> generic types to only require a single generic parameter. This simplifies the response serialization logic.</p>
<blockquote>
<p>See <a href="https://github.com/Alamofire/Alamofire/pull/1419" target="_blank" rel="external">PR-1419</a> for more info.</p>
</blockquote>
<h3 id="Parameter-Encoding-Protocol"><a href="#Parameter-Encoding-Protocol" class="headerlink" title="Parameter Encoding Protocol"></a>Parameter Encoding Protocol</h3><p>The <code>ParameterEncoding</code> enumeration has served us well for over two years at this point. However, it had some limitations that we wanted to address in Alamofire 4.</p>
<ul>
<li>The <code>.url</code> case has always been a bit confusing since it selects a destination based on the HTTP method.</li>
<li>The <code>.urlEncodedInURL</code> case has always been an eye sore to work around the behavior of the <code>.url</code> case.</li>
<li><code>.JSON</code> and <code>.PropertyList</code> encoding could not accept formatting or writing options.</li>
<li>The <code>.Custom</code> encoding was a bit difficult for users to get the hang of.</li>
</ul>
<p>Because of these reasons, we decided to eliminate the enumeration altogether in Alamofire 4! Now, <code>ParameterEncoding</code> is a protocol backed by three concrete <code>URLEncoding</code>, <code>JSONEncoding</code> and <code>PropertyList</code> encoding structs with a new <code>Parameters</code> typealias for creating your parameter dictionaries.</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">public</span> <span class="token keyword">typealias</span> <span class="token builtin">Parameters</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">:</span> <span class="token builtin">Any</span><span class="token punctuation">]</span>

<span class="token keyword">public</span> protocol <span class="token builtin">ParameterEncoding</span> <span class="token punctuation">{</span>
    <span class="token keyword">func</span> <span class="token function">encode</span><span class="token punctuation">(</span><span class="token number">_</span> urlRequest<span class="token punctuation">:</span> <span class="token builtin">URLRequestConvertible</span><span class="token punctuation">,</span> with parameters<span class="token punctuation">:</span> <span class="token builtin">Parameters</span><span class="token operator">?</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">URLRequest</span>
<span class="token punctuation">}</span>
</code></pre>
<h4 id="URL-Encoding"><a href="#URL-Encoding" class="headerlink" title="URL Encoding"></a>URL Encoding</h4><p>The new <code>URLEncoding</code> struct contains a <code>Destination</code> enumeration supporting three types of destinations:</p>
<ul>
<li><code>.methodDependent</code> - Applies encoded query string result to existing query string for <code>GET</code>, <code>HEAD</code> and <code>DELETE</code> requests and sets as the HTTP body for requests with any other HTTP method.</li>
<li><code>.queryString</code> - Sets or appends encoded query string result to existing query string.</li>
<li><code>.httpBody</code> - Sets encoded query string result as the HTTP body of the URL request.</li>
</ul>
<p>These destinations make it much easier to control where the parameters are encoded onto the <code>URLRequest</code>. Creating requests still uses the same signature as before in regards to parameter encoding and also has the same default behavior.</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> parameters<span class="token punctuation">:</span> <span class="token builtin">Parameters</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"foo"</span><span class="token punctuation">:</span> <span class="token string">"bar"</span><span class="token punctuation">]</span>

<span class="token builtin">Alamofire</span><span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span>urlString<span class="token punctuation">,</span> parameters<span class="token punctuation">:</span> parameters<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// Encoding => URLEncoding(destination: .methodDependent)</span>
<span class="token builtin">Alamofire</span><span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span>urlString<span class="token punctuation">,</span> parameters<span class="token punctuation">:</span> parameters<span class="token punctuation">,</span> encoding<span class="token punctuation">:</span> <span class="token function">URLEncoding</span><span class="token punctuation">(</span>destination<span class="token punctuation">:</span> <span class="token punctuation">.</span>queryString<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token builtin">Alamofire</span><span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span>urlString<span class="token punctuation">,</span> parameters<span class="token punctuation">:</span> parameters<span class="token punctuation">,</span> encoding<span class="token punctuation">:</span> <span class="token function">URLEncoding</span><span class="token punctuation">(</span>destination<span class="token punctuation">:</span> <span class="token punctuation">.</span>httpBody<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">// Static convenience properties (we'd like to encourage everyone to use this more concise form)</span>
<span class="token builtin">Alamofire</span><span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span>urlString<span class="token punctuation">,</span> parameters<span class="token punctuation">:</span> parameters<span class="token punctuation">,</span> encoding<span class="token punctuation">:</span> <span class="token builtin">URLEncoding</span><span class="token punctuation">.</span><span class="token keyword">default</span><span class="token punctuation">)</span>
<span class="token builtin">Alamofire</span><span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span>urlString<span class="token punctuation">,</span> parameters<span class="token punctuation">:</span> parameters<span class="token punctuation">,</span> encoding<span class="token punctuation">:</span> <span class="token builtin">URLEncoding</span><span class="token punctuation">.</span>queryString<span class="token punctuation">)</span>
<span class="token builtin">Alamofire</span><span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span>urlString<span class="token punctuation">,</span> parameters<span class="token punctuation">:</span> parameters<span class="token punctuation">,</span> encoding<span class="token punctuation">:</span> <span class="token builtin">URLEncoding</span><span class="token punctuation">.</span>httpBody<span class="token punctuation">)</span>
</code></pre>
<h4 id="JSON-Encoding"><a href="#JSON-Encoding" class="headerlink" title="JSON Encoding"></a>JSON Encoding</h4><p>The new <code>JSONEncoding</code> struct exposes the ability to customize the JSON writing options.</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> parameters<span class="token punctuation">:</span> <span class="token builtin">Parameters</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"foo"</span><span class="token punctuation">:</span> <span class="token string">"bar"</span><span class="token punctuation">]</span>

<span class="token builtin">Alamofire</span><span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span>urlString<span class="token punctuation">,</span> parameters<span class="token punctuation">:</span> parameters<span class="token punctuation">,</span> encoding<span class="token punctuation">:</span> <span class="token function">JSONEncoding</span><span class="token punctuation">(</span>options<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token builtin">Alamofire</span><span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span>urlString<span class="token punctuation">,</span> parameters<span class="token punctuation">:</span> parameters<span class="token punctuation">,</span> encoding<span class="token punctuation">:</span> <span class="token function">JSONEncoding</span><span class="token punctuation">(</span>options<span class="token punctuation">:</span> <span class="token punctuation">.</span>prettyPrinted<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">// Static convenience properties (we'd like to encourage everyone to use this more concise form)</span>
<span class="token builtin">Alamofire</span><span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span>urlString<span class="token punctuation">,</span> parameters<span class="token punctuation">:</span> parameters<span class="token punctuation">,</span> encoding<span class="token punctuation">:</span> <span class="token builtin">JSONEncoding</span><span class="token punctuation">.</span><span class="token keyword">default</span><span class="token punctuation">)</span>
<span class="token builtin">Alamofire</span><span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span>urlString<span class="token punctuation">,</span> parameters<span class="token punctuation">:</span> parameters<span class="token punctuation">,</span> encoding<span class="token punctuation">:</span> <span class="token builtin">JSONEncoding</span><span class="token punctuation">.</span>prettyPrinted<span class="token punctuation">)</span>
</code></pre>
<h4 id="Property-List-Encoding"><a href="#Property-List-Encoding" class="headerlink" title="Property List Encoding"></a>Property List Encoding</h4><p>The new <code>PropertyListEncoding</code> struct allows customizing the plist format and write options.</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> parameters<span class="token punctuation">:</span> <span class="token builtin">Parameters</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"foo"</span><span class="token punctuation">:</span> <span class="token string">"bar"</span><span class="token punctuation">]</span>

<span class="token builtin">Alamofire</span><span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span>urlString<span class="token punctuation">,</span> parameters<span class="token punctuation">:</span> parameters<span class="token punctuation">,</span> encoding<span class="token punctuation">:</span> <span class="token function">PropertyListEncoding</span><span class="token punctuation">(</span>format<span class="token punctuation">:</span> <span class="token punctuation">.</span>xml<span class="token punctuation">,</span> options<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token builtin">Alamofire</span><span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span>urlString<span class="token punctuation">,</span> parameters<span class="token punctuation">:</span> parameters<span class="token punctuation">,</span> encoding<span class="token punctuation">:</span> <span class="token function">PropertyListEncoding</span><span class="token punctuation">(</span>format<span class="token punctuation">:</span> <span class="token punctuation">.</span>binary<span class="token punctuation">,</span> options<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">// Static convenience properties (we'd like to encourage everyone to use this more concise form)</span>
<span class="token builtin">Alamofire</span><span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span>urlString<span class="token punctuation">,</span> parameters<span class="token punctuation">:</span> parameters<span class="token punctuation">,</span> encoding<span class="token punctuation">:</span> <span class="token builtin">PropertyListEncoding</span><span class="token punctuation">.</span>xml<span class="token punctuation">)</span>
<span class="token builtin">Alamofire</span><span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span>urlString<span class="token punctuation">,</span> parameters<span class="token punctuation">:</span> parameters<span class="token punctuation">,</span> encoding<span class="token punctuation">:</span> <span class="token builtin">PropertyListEncoding</span><span class="token punctuation">.</span>binary<span class="token punctuation">)</span>
</code></pre>
<h4 id="Custom-Encoding"><a href="#Custom-Encoding" class="headerlink" title="Custom Encoding"></a>Custom Encoding</h4><p>Creating a custom custom <code>ParameterEncoding</code> is now as simple as implementing the protocol. For more examples on how to do this, please refer to the README.</p>
<blockquote>
<p>See <a href="https://github.com/Alamofire/Alamofire/pull/1465" target="_blank" rel="external">PR-1465</a> for more info.</p>
</blockquote>
<h3 id="Request-Subclasses"><a href="#Request-Subclasses" class="headerlink" title="Request Subclasses"></a>Request Subclasses</h3><p>In Alamofire 4, the <code>request</code>, <code>download</code>, <code>upload</code> and <code>stream</code> APIs no longer return a <code>Request</code>. Instead, they return a specific type of <code>Request</code> subclass. There were several motivating factors and community questions that led us to making this change:</p>
<ul>
<li><strong>Progress:</strong> The behavior of the <code>progress</code> method was confusing for upload requests.<ul>
<li>What does <code>progress</code> report on an upload <code>Request</code>? The progress of the upload? The progress of the response download?</li>
<li>If it reports both, how do you know if or when it switches?</li>
</ul>
</li>
<li><strong>Response Serializers:</strong> The response serializers were designed for data and upload requests, not download or stream requests.<ul>
<li>How do you access the fileURL when a download is complete?</li>
<li>What would <code>responseData</code>, <code>responseString</code> or <code>responseJSON</code> do for a download request? Stream request?</li>
</ul>
</li>
</ul>
<p>At a high level, Alamofire 4 now has four <code>Request</code> subclasses that each support their own custom chained APIs. This allows each subclass to create extensions tailored to that specific type of request.</p>
<pre class=" language-swift"><code class="language-swift">open <span class="token keyword">class</span> <span class="token class-name">Request</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// Contains common properties, authentication and state methods as well as</span>
    <span class="token comment" spellcheck="true">// CustomStringConvertible and CustomDebugStringConvertible conformance</span>
<span class="token punctuation">}</span>

open <span class="token keyword">class</span> <span class="token class-name">DataRequest</span><span class="token punctuation">:</span> <span class="token builtin">Request</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// Contains stream (not to be confused with StreamRequest) and download progress methods.</span>
<span class="token punctuation">}</span>

open <span class="token keyword">class</span> <span class="token class-name">DownloadRequest</span><span class="token punctuation">:</span> <span class="token builtin">Request</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// Contains download destination and options, resume data and download progress methods.</span>
<span class="token punctuation">}</span>

open <span class="token keyword">class</span> <span class="token class-name">UploadRequest</span><span class="token punctuation">:</span> <span class="token builtin">DataRequest</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// Inherits all DataRequest APIs and also contains upload progress methods.</span>
<span class="token punctuation">}</span>

open <span class="token keyword">class</span> <span class="token class-name">StreamRequest</span><span class="token punctuation">:</span> <span class="token builtin">Request</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// Only inherits Request APIs, there are no other custom APIs at this time.</span>
<span class="token punctuation">}</span>
</code></pre>
<p>By making this split, Alamofire 4 was able to create customized chaining APIs for each type of <code>Request</code>. This opened up all sorts of possibilities, but let’s take a moment to focus on what this change means in terms of progress reporting and download destinations.</p>
<blockquote>
<p>See <a href="https://github.com/Alamofire/Alamofire/pull/1455" target="_blank" rel="external">PR-1455</a> for more info.</p>
</blockquote>
<h4 id="Download-and-Upload-Progress"><a href="#Download-and-Upload-Progress" class="headerlink" title="Download and Upload Progress"></a>Download and Upload Progress</h4><p>The progress reporting system for data, download and upload requests has been completely redesigned. Each request type contains progress APIs for executing a closure during each progress update by returning the underlying <code>Progress</code> instance. The closure will be called on the specified queue that defaults to main.</p>
<p><strong>Data Request Progress</strong></p>
<pre class=" language-swift"><code class="language-swift"><span class="token builtin">Alamofire</span><span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span>urlString<span class="token punctuation">)</span>
    <span class="token punctuation">.</span>downloadProgress <span class="token punctuation">{</span> progress <span class="token keyword">in</span>
        <span class="token comment" spellcheck="true">// Called on main dispatch queue by default</span>
        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Download progress: <span class="token interpolation"><span class="token delimiter variable">\(</span>progress<span class="token punctuation">.</span>fractionCompleted<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span>responseJSON <span class="token punctuation">{</span> response <span class="token keyword">in</span>
        <span class="token function">debugPrint</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
</code></pre>
<p><strong>Download Request Progress</strong></p>
<pre class=" language-swift"><code class="language-swift"><span class="token builtin">Alamofire</span><span class="token punctuation">.</span><span class="token function">download</span><span class="token punctuation">(</span>urlString<span class="token punctuation">,</span> to<span class="token punctuation">:</span> destination<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">downloadProgress</span><span class="token punctuation">(</span>queue<span class="token punctuation">:</span> <span class="token builtin">DispatchQueue</span><span class="token punctuation">.</span><span class="token function">global</span><span class="token punctuation">(</span>qos<span class="token punctuation">:</span> <span class="token punctuation">.</span>utility<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> progress <span class="token keyword">in</span>
        <span class="token comment" spellcheck="true">// Called on utility dispatch queue</span>
        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Download progress: <span class="token interpolation"><span class="token delimiter variable">\(</span>progress<span class="token punctuation">.</span>fractionCompleted<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span>responseJSON <span class="token punctuation">{</span> response <span class="token keyword">in</span>
        <span class="token function">debugPrint</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
</code></pre>
<p><strong>Upload Request Progress</strong></p>
<pre class=" language-swift"><code class="language-swift"><span class="token builtin">Alamofire</span><span class="token punctuation">.</span><span class="token function">upload</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> to<span class="token punctuation">:</span> urlString<span class="token punctuation">,</span> withMethod<span class="token punctuation">:</span> <span class="token punctuation">.</span>post<span class="token punctuation">)</span>
    <span class="token punctuation">.</span>uploadProgress <span class="token punctuation">{</span> progress <span class="token keyword">in</span>
        <span class="token comment" spellcheck="true">// Called on main dispatch queue by default</span>
        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Upload progress: <span class="token interpolation"><span class="token delimiter variable">\(</span>progress<span class="token punctuation">.</span>fractionCompleted<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span>downloadProgress <span class="token punctuation">{</span> progress <span class="token keyword">in</span>
        <span class="token comment" spellcheck="true">// Called on main dispatch queue by default</span>
        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Download progress: <span class="token interpolation"><span class="token delimiter variable">\(</span>progress<span class="token punctuation">.</span>fractionCompleted<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span>responseData <span class="token punctuation">{</span> response <span class="token keyword">in</span>
        <span class="token function">debugPrint</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
</code></pre>
<p>It’s now easy to differentiate between upload and download progress for upload requests.</p>
<blockquote>
<p>See <a href="https://github.com/Alamofire/Alamofire/pull/1455" target="_blank" rel="external">PR-1455</a> for more info.</p>
</blockquote>
<h4 id="Download-File-Destinations"><a href="#Download-File-Destinations" class="headerlink" title="Download File Destinations"></a>Download File Destinations</h4><p>In Alamofire 3.x, successful download requests would always move the temporary file to a final destination URL provided by the <code>destination</code> closure. While this was a nice convenience, it had several limitations:</p>
<ul>
<li><code>Forced</code> - The API forces you to provide a destination closure to move the file even if you have a valid use case for not moving it.</li>
<li><code>Limiting</code> - There was no way to adjust the file system prior to moving the file.<ul>
<li>What if you need to delete a pre-existing file at the destination URL before moving the temporary file?</li>
<li>What if you need to create intermediate directories to the destination URL before moving the temporary file?</li>
</ul>
</li>
</ul>
<p>These limitations led to several enhancements in Alamofire 4. The first of which is the optionality of the destination closure. Now, by default, the <code>destination</code> closure is <code>nil</code> which means the file is not moved anywhere on the file system and the temporary URL is returned.</p>
<pre class=" language-swift"><code class="language-swift"><span class="token builtin">Alamofire</span><span class="token punctuation">.</span><span class="token function">download</span><span class="token punctuation">(</span>urlString<span class="token punctuation">)</span><span class="token punctuation">.</span>responseData <span class="token punctuation">{</span> response <span class="token keyword">in</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Temporary URL: <span class="token interpolation"><span class="token delimiter variable">\(</span>response<span class="token punctuation">.</span>temporaryURL<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>We’ll cover the <code>DownloadResponse</code> type in more detail in the <a href="#response-serializers">Response Serializers</a> section.</p>
</blockquote>
<h4 id="Download-Options"><a href="#Download-Options" class="headerlink" title="Download Options"></a>Download Options</h4><p>The other major change made was to add download options to the destination closure allowing more file system control over the move operation. To accomplish this, the <code>DownloadOptions</code> type was created and added to the <code>DownloadFileDestination</code> closure.</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">public</span> <span class="token keyword">typealias</span> <span class="token builtin">DownloadFileDestination</span> <span class="token operator">=</span> <span class="token punctuation">(</span>
    <span class="token number">_</span> temporaryURL<span class="token punctuation">:</span> <span class="token constant">URL</span><span class="token punctuation">,</span>
    <span class="token number">_</span> response<span class="token punctuation">:</span> <span class="token builtin">HTTPURLResponse</span><span class="token punctuation">)</span>
    <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">(</span>destinationURL<span class="token punctuation">:</span> <span class="token constant">URL</span><span class="token punctuation">,</span> options<span class="token punctuation">:</span> <span class="token builtin">DownloadOptions</span><span class="token punctuation">)</span>
</code></pre>
<p>The two currently supported <code>DownloadOptions</code> are:</p>
<ul>
<li><code>.createIntermediateDirectories</code> - Creates intermediate directories for the destination URL if specified.</li>
<li><code>.removePreviousFile</code> - Removes a previous file from the destination URL if specified.</li>
</ul>
<p>They can then be used as follows:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> destination<span class="token punctuation">:</span> <span class="token builtin">DownloadRequest</span><span class="token punctuation">.</span><span class="token builtin">DownloadFileDestination</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">_</span><span class="token punctuation">,</span> <span class="token number">_</span> <span class="token keyword">in</span> 
    <span class="token keyword">return</span> <span class="token punctuation">(</span>fileURL<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">.</span>removePreviousFile<span class="token punctuation">,</span> <span class="token punctuation">.</span>createIntermediateDirectories<span class="token punctuation">]</span><span class="token punctuation">)</span> 
<span class="token punctuation">}</span>

<span class="token builtin">Alamofire</span><span class="token punctuation">.</span><span class="token function">download</span><span class="token punctuation">(</span>urlString<span class="token punctuation">,</span> to<span class="token punctuation">:</span> destination<span class="token punctuation">)</span><span class="token punctuation">.</span>response <span class="token punctuation">{</span> response <span class="token keyword">in</span>
    <span class="token function">debugPrint</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<p>If an error occurs during the file system operations, the <code>error</code> on the <code>DownloadResponse</code> will be of type <code>URLError</code>.</p>
<blockquote>
<p>See <a href="https://github.com/Alamofire/Alamofire/pull/1462" target="_blank" rel="external">PR-1462</a> for more info.</p>
</blockquote>
<h3 id="Response-Validation"><a href="#Response-Validation" class="headerlink" title="Response Validation"></a>Response Validation</h3><p>There were several opportunity areas for improving the response validation system in Alamofire 4. These areas included:</p>
<ul>
<li>Exposing the underlying <code>data</code> to the <code>Validation</code> closure.</li>
<li>Custom validation between different <code>Request</code> subclasses types allowing <code>temporaryURL</code> and <code>destinationURL</code> to be exposed for download requests.</li>
</ul>
<p>By creating <code>Request</code> subclasses, the validation closure typealias and request APIs were able to be tailored to each request type.</p>
<h4 id="Data-Request"><a href="#Data-Request" class="headerlink" title="Data Request"></a>Data Request</h4><p>The <code>Validation</code> closure exposed on the <code>DataRequest</code> (inherited by <code>UploadRequest</code>) is now as follows:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">extension</span> <span class="token builtin">DataRequest</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">typealias</span> <span class="token builtin">Validation</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">URLRequest</span><span class="token operator">?</span><span class="token punctuation">,</span> <span class="token builtin">HTTPURLResponse</span><span class="token punctuation">,</span> <span class="token builtin">Data</span><span class="token operator">?</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">ValidationResult</span>
<span class="token punctuation">}</span>
</code></pre>
<p>By exposing the <code>Data?</code> property directly in the closure, you no longer have to write an extension on <code>Request</code> to access it. Now you can do something like this:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token builtin">Alamofire</span><span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span>urlString<span class="token punctuation">)</span>
    <span class="token punctuation">.</span>validate <span class="token punctuation">{</span> request<span class="token punctuation">,</span> response<span class="token punctuation">,</span> data <span class="token keyword">in</span>
        <span class="token keyword">guard</span> <span class="token keyword">let</span> data <span class="token operator">=</span> data <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">.</span><span class="token function">failure</span><span class="token punctuation">(</span>customError<span class="token punctuation">)</span> <span class="token punctuation">}</span>

        <span class="token comment" spellcheck="true">// 1) Validate the response to make sure everything looks good</span>
        <span class="token comment" spellcheck="true">// 2) If validation fails, you can now parse the error message out of the</span>
        <span class="token comment" spellcheck="true">//    data if necessary and add that to your custom error if you wish.</span>

        <span class="token keyword">return</span> <span class="token punctuation">.</span>success
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span>response <span class="token punctuation">{</span> response <span class="token keyword">in</span>
        <span class="token function">debugPrint</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
</code></pre>
<h4 id="Download-Request"><a href="#Download-Request" class="headerlink" title="Download Request"></a>Download Request</h4><p>The <code>Validation</code> closure on the <code>DownloadRequest</code> is very similar to the <code>DataRequest</code> API, but tailored more to downloads.</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">extension</span> <span class="token builtin">DownloadRequest</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">typealias</span> <span class="token builtin">Validation</span> <span class="token operator">=</span> <span class="token punctuation">(</span>
        <span class="token number">_</span> request<span class="token punctuation">:</span> <span class="token builtin">URLRequest</span><span class="token operator">?</span><span class="token punctuation">,</span> 
        <span class="token number">_</span> response<span class="token punctuation">:</span> <span class="token builtin">HTTPURLResponse</span><span class="token punctuation">,</span> 
        <span class="token number">_</span> temporaryURL<span class="token punctuation">:</span> <span class="token constant">URL</span><span class="token operator">?</span><span class="token punctuation">,</span> 
        <span class="token number">_</span> destinationURL<span class="token punctuation">:</span> <span class="token constant">URL</span><span class="token operator">?</span><span class="token punctuation">)</span> 
        <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">ValidationResult</span>
<span class="token punctuation">}</span>
</code></pre>
<p>The <code>temporaryURL</code> and <code>destinationURL</code> parameters now allow you access the data returned by the server directly in an inline closure. This allows you to inspect the data inside the file if you’ve determined you need to in order to create a custom error.</p>
<pre class=" language-swift"><code class="language-swift"><span class="token builtin">Alamofire</span><span class="token punctuation">.</span><span class="token function">download</span><span class="token punctuation">(</span>urlString<span class="token punctuation">)</span>
    <span class="token punctuation">.</span>validate <span class="token punctuation">{</span> request<span class="token punctuation">,</span> response<span class="token punctuation">,</span> temporaryURL<span class="token punctuation">,</span> destinationURL <span class="token keyword">in</span>
        <span class="token keyword">guard</span> <span class="token keyword">let</span> fileURL <span class="token operator">=</span> temporaryURL <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">.</span><span class="token function">failure</span><span class="token punctuation">(</span>customError<span class="token punctuation">)</span> <span class="token punctuation">}</span>

        <span class="token keyword">do</span> <span class="token punctuation">{</span>
            <span class="token keyword">let</span> <span class="token number">_</span> <span class="token operator">=</span> <span class="token keyword">try</span> <span class="token function">Data</span><span class="token punctuation">(</span>contentsOf<span class="token punctuation">:</span> fileURL<span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token punctuation">.</span>success
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token punctuation">.</span><span class="token function">failure</span><span class="token punctuation">(</span>customError<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span>response <span class="token punctuation">{</span> response <span class="token keyword">in</span>
        <span class="token function">debugPrint</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
</code></pre>
<p>By exposing the underlying server data directly to the inline closures, error messages embedded in those responses can be parsed out inside the <code>Validation</code> closure to create a custom error including the server error message. If the payload is the same schema as used in a response serializer closure, the response serializer could be called to parse out the error message rather than duplicating the logic. For an example of how to do this, please refer to the README.</p>
<blockquote>
<p>See <a href="https://github.com/Alamofire/Alamofire/pull/1461" target="_blank" rel="external">PR-1461</a> for more info.</p>
</blockquote>
<h3 id="Response-Serializers"><a href="#Response-Serializers" class="headerlink" title="Response Serializers"></a>Response Serializers</h3><p>The response serialization system in Alamofire 3.x had several pretty severe limitations:</p>
<ul>
<li>Response serialization APIs could be applied to download and stream requests but resulted in undefined behavior.<ul>
<li>How do you access the fileURL when a download is complete?</li>
<li>What would <code>responseData</code>, <code>responseString</code> or <code>responseJSON</code> do when chained onto a download request? A stream request?</li>
</ul>
</li>
<li>The <code>response</code> API returned 4 parameters instead of an encapsulating <code>Response</code> type.<ul>
<li>The biggest issue here is that any change to that API could not be done in a backwards compatible manner.</li>
<li>Created confusion when switching between the serialized and unserialized APIs which led to difficult to debug compiler errors.</li>
</ul>
</li>
</ul>
<p>As you can see, there were some very strong limitations to this system in Alamofire 3.x. Therefore, in Alamofire 4, the <code>Request</code> type was first broken down into subclasses, which opened up the opportunity to create customized response serializers and APIs for specific types of requests. Before getting to far into response serializers, we should first walk through the new <code>Response</code> types.</p>
<h4 id="Default-Data-Response"><a href="#Default-Data-Response" class="headerlink" title="Default Data Response"></a>Default Data Response</h4><p>The <code>DefaultDataResponse</code> represents an unserialized server response. There’s no Alamofire processing that happens, it just collects all the response information from the <code>SessionDelegate</code> APIs and returns it in a simple struct.</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">public</span> <span class="token keyword">struct</span> <span class="token builtin">DefaultDataResponse</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">let</span> request<span class="token punctuation">:</span> <span class="token builtin">URLRequest</span><span class="token operator">?</span>
    <span class="token keyword">public</span> <span class="token keyword">let</span> response<span class="token punctuation">:</span> <span class="token builtin">HTTPURLResponse</span><span class="token operator">?</span>
    <span class="token keyword">public</span> <span class="token keyword">let</span> data<span class="token punctuation">:</span> <span class="token builtin">Data</span><span class="token operator">?</span>
    <span class="token keyword">public</span> <span class="token keyword">let</span> error<span class="token punctuation">:</span> <span class="token builtin">Error</span><span class="token operator">?</span>
    <span class="token keyword">public</span> <span class="token keyword">var</span> metrics<span class="token punctuation">:</span> <span class="token builtin">URLSessionTaskMetrics</span><span class="token operator">?</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> _metrics <span class="token keyword">as</span><span class="token operator">?</span> <span class="token builtin">URLSessionTaskMetrics</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>This is the type of response you will get back from the <code>DataRequest.response</code> API.</p>
<pre class=" language-swift"><code class="language-swift"><span class="token builtin">Alamofire</span><span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span>urlString<span class="token punctuation">)</span><span class="token punctuation">.</span>response <span class="token punctuation">{</span> response <span class="token keyword">in</span>
    <span class="token function">debugPrint</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token builtin">Alamofire</span><span class="token punctuation">.</span><span class="token function">upload</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> to<span class="token punctuation">:</span> urlString<span class="token punctuation">)</span><span class="token punctuation">.</span>response <span class="token punctuation">{</span> response <span class="token keyword">in</span>
    <span class="token function">debugPrint</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<h4 id="Data-Response"><a href="#Data-Response" class="headerlink" title="Data Response"></a>Data Response</h4><p>The generic <code>DataResponse</code> type is the same as the generic <code>Response</code> in Alamofire 3.x, but refactored and contains the new <code>metrics</code> property.</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">public</span> <span class="token keyword">struct</span> <span class="token builtin">DataResponse</span><span class="token operator">&lt;</span><span class="token builtin">Value</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">let</span> request<span class="token punctuation">:</span> <span class="token builtin">URLRequest</span><span class="token operator">?</span>
    <span class="token keyword">public</span> <span class="token keyword">let</span> response<span class="token punctuation">:</span> <span class="token builtin">HTTPURLResponse</span><span class="token operator">?</span>
    <span class="token keyword">public</span> <span class="token keyword">let</span> data<span class="token punctuation">:</span> <span class="token builtin">Data</span><span class="token operator">?</span>
    <span class="token keyword">public</span> <span class="token keyword">let</span> result<span class="token punctuation">:</span> <span class="token builtin">Result</span><span class="token operator">&lt;</span><span class="token builtin">Value</span><span class="token operator">></span>
    <span class="token keyword">public</span> <span class="token keyword">let</span> timeline<span class="token punctuation">:</span> <span class="token builtin">Timeline</span>
    <span class="token keyword">public</span> <span class="token keyword">var</span> metrics<span class="token punctuation">:</span> <span class="token builtin">URLSessionTaskMetrics</span><span class="token operator">?</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> _metrics <span class="token keyword">as</span><span class="token operator">?</span> <span class="token builtin">URLSessionTaskMetrics</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>You still have access to the same response serialization APIs as before on the <code>DataRequest</code> and <code>UploadRequest</code> types.</p>
<pre class=" language-swift"><code class="language-swift"><span class="token builtin">Alamofire</span><span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span>urlString<span class="token punctuation">)</span><span class="token punctuation">.</span>responseJSON <span class="token punctuation">{</span> response <span class="token keyword">in</span>
    <span class="token function">debugPrint</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span>
    <span class="token function">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>result<span class="token punctuation">.</span>isSuccess<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token builtin">Alamofire</span><span class="token punctuation">.</span><span class="token function">upload</span><span class="token punctuation">(</span>fileURL<span class="token punctuation">,</span> to<span class="token punctuation">:</span> urlString<span class="token punctuation">)</span><span class="token punctuation">.</span>responseData <span class="token punctuation">{</span> response <span class="token keyword">in</span>
    <span class="token function">debugPrint</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span>
    <span class="token function">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>result<span class="token punctuation">.</span>isSuccess<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<h4 id="Default-Download-Response"><a href="#Default-Download-Response" class="headerlink" title="Default Download Response"></a>Default Download Response</h4><p>Since downloads work differently than data and upload requests, Alamofire 4 contains custom download <code>Response</code> types tailored to their behavior. The <code>DefaultDownloadResponse</code> type represents an unserialized server response for a <code>DownloadRequest</code> that collects all the <code>SessionDelegate</code> information into a simple struct.</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">public</span> <span class="token keyword">struct</span> <span class="token builtin">DefaultDownloadResponse</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">let</span> request<span class="token punctuation">:</span> <span class="token builtin">URLRequest</span><span class="token operator">?</span>
    <span class="token keyword">public</span> <span class="token keyword">let</span> response<span class="token punctuation">:</span> <span class="token builtin">HTTPURLResponse</span><span class="token operator">?</span>
    <span class="token keyword">public</span> <span class="token keyword">let</span> temporaryURL<span class="token punctuation">:</span> <span class="token constant">URL</span><span class="token operator">?</span>
    <span class="token keyword">public</span> <span class="token keyword">let</span> destinationURL<span class="token punctuation">:</span> <span class="token constant">URL</span><span class="token operator">?</span>
    <span class="token keyword">public</span> <span class="token keyword">let</span> resumeData<span class="token punctuation">:</span> <span class="token builtin">Data</span><span class="token operator">?</span>
    <span class="token keyword">public</span> <span class="token keyword">let</span> error<span class="token punctuation">:</span> <span class="token builtin">Error</span><span class="token operator">?</span>
    <span class="token keyword">public</span> <span class="token keyword">var</span> metrics<span class="token punctuation">:</span> <span class="token builtin">URLSessionTaskMetrics</span><span class="token operator">?</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> _metrics <span class="token keyword">as</span><span class="token operator">?</span> <span class="token builtin">URLSessionTaskMetrics</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>The <code>DefaultDownloadResponse</code> type is returned when using the new <code>DownloadRequest.response</code> API.</p>
<pre class=" language-swift"><code class="language-swift"><span class="token builtin">Alamofire</span><span class="token punctuation">.</span><span class="token function">download</span><span class="token punctuation">(</span>urlString<span class="token punctuation">)</span><span class="token punctuation">.</span>response <span class="token punctuation">{</span> response <span class="token keyword">in</span>
    <span class="token function">debugPrint</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span>
    <span class="token function">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>temporaryURL<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<h4 id="Download-Response"><a href="#Download-Response" class="headerlink" title="Download Response"></a>Download Response</h4><p>The new generic <code>DownloadResponse</code> type is similar to the generic <code>DataResponse</code> type, but contains information tailored to download requests. The <code>DownloadResponse</code> type is returned when one of four new APIs exposed on the <code>DownloadRequest</code> type. These new APIs match the <code>DataRequest</code> ones, and provide the same functionality by loading the data from the underlying temporary or destination URL.</p>
<pre class=" language-swift"><code class="language-swift"><span class="token builtin">Alamofire</span><span class="token punctuation">.</span><span class="token function">download</span><span class="token punctuation">(</span>urlString<span class="token punctuation">,</span> to<span class="token punctuation">:</span> destination<span class="token punctuation">)</span>
    <span class="token punctuation">.</span>responseData <span class="token punctuation">{</span> response <span class="token keyword">in</span>
        <span class="token function">debugPrint</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span>responseString <span class="token punctuation">{</span> response <span class="token keyword">in</span>
        <span class="token function">debugPrint</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span>responseJSON <span class="token punctuation">{</span> response <span class="token keyword">in</span>
        <span class="token function">debugPrint</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span>responsePropertyList <span class="token punctuation">{</span> response <span class="token keyword">in</span>
        <span class="token function">debugPrint</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
</code></pre>
<p>These new response serialization APIs make it MUCH easier to download a request to a file and serialize the response all in a single call.</p>
<h4 id="Custom-Response-Serializers"><a href="#Custom-Response-Serializers" class="headerlink" title="Custom Response Serializers"></a>Custom Response Serializers</h4><p>If you have created your own custom response serializers, you may want to extend support across both data and download requests similar to what we’ve done with the Alamofire response serializers. If you do decide to do this, take a close look at how Alamofire shares the response serializer implementation between both request types by moving the implementation to the <code>Request</code>. This allowed us to DRY up our logic to avoid duplication between types.</p>
<blockquote>
<p>See <a href="https://github.com/Alamofire/Alamofire/pull/1457" target="_blank" rel="external">PR-1457</a> for more info.</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Alamofire </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS动画中的枚举UIViewAnimationOptions]]></title>
      <url>/2017/06/11/iOS/UIViewAnimationOptions/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><a id="more"></a>
<p>首先这个枚举属于UIViewAnimation。我们经常使用的函数是 <code>[UIView animateWithDuration: animations:^{} completion:^(BOOL finished) {}];</code><br>和<code>[UIView animateWithDuration: animations:^{}];</code>如果动画稍微复杂点，例如需要组合等等就可能用到这个函数：<code>[UIView animateWithDuration: delay: options: animations: completion:^(BOOL finished) {}];</code>刚开始接触的朋友看到一堆枚举可能就觉得烦，尤其是苹果那混乱的动画框架东一坨，西一坨。又是Quartz2D，又是核心动画跟臭袜子一样……没关系，捡回来接着穿。</p>
<p>　　以上方法中的options一项需要传入一个枚举，这个枚举大概控制的是这几个要素：当前动画嵌套中的动画执行随时间的快慢种类（先快后慢等..）。动画要一直重复吗。如果我使用转场动画那么我用哪种转场效果。还有子动画嵌套在父动画中时我们如何对待父动画中的相同选项等等..</p>
<p>　正文：</p>
<pre><code>UIViewAnimationOptionLayoutSubviews            //提交动画的时候布局子控件，表示子控件将和父控件一同动画。

UIViewAnimationOptionAllowUserInteraction      //动画时允许用户交流，比如触摸

UIViewAnimationOptionBeginFromCurrentState     //从当前状态开始动画

UIViewAnimationOptionRepeat                    //动画无限重复

UIViewAnimationOptionAutoreverse               //执行动画回路,前提是设置动画无限重复

UIViewAnimationOptionOverrideInheritedDuration //忽略外层动画嵌套的执行时间

UIViewAnimationOptionOverrideInheritedCurve    //忽略外层动画嵌套的时间变化曲线

UIViewAnimationOptionAllowAnimatedContent      //通过改变属性和重绘实现动画效果，如果key没有提交动画将使用快照

UIViewAnimationOptionShowHideTransitionViews   //用显隐的方式替代添加移除图层的动画效果

UIViewAnimationOptionOverrideInheritedOptions  //忽略嵌套继承的选项
</code></pre><p>   //时间函数曲线相关</p>
<pre><code>UIViewAnimationOptionCurveEaseInOut            //时间曲线函数，由慢到快

UIViewAnimationOptionCurveEaseIn               //时间曲线函数，由慢到特别快

UIViewAnimationOptionCurveEaseOut              //时间曲线函数，由快到慢

UIViewAnimationOptionCurveLinear               //时间曲线函数，匀速
</code></pre><p>   //转场动画相关的</p>
<pre><code>UIViewAnimationOptionTransitionNone            //无转场动画

UIViewAnimationOptionTransitionFlipFromLeft    //转场从左翻转

UIViewAnimationOptionTransitionFlipFromRight   //转场从右翻转

UIViewAnimationOptionTransitionCurlUp          //上卷转场

UIViewAnimationOptionTransitionCurlDown        //下卷转场

UIViewAnimationOptionTransitionCrossDissolve   //转场交叉消失

UIViewAnimationOptionTransitionFlipFromTop     //转场从上翻转

UIViewAnimationOptionTransitionFlipFromBottom  //转场从下翻转
</code></pre><p>　 浅略理解，待友人的指正。</p>
<p>　补充：关于最后一组转场动画它一般是用在这个方法中的：</p>
<p>　　　　<code>[UIView transitionFromView: toView: duration: options: completion:^(BOOL finished) {}];</code></p>
<p>　该方法效果是插入一面视图移除一面视图，期间可以使用一些转场动画效果。</p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> UIViewAnimationOptions </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LDA Algorithm]]></title>
      <url>/2017/05/26/machine-learning/LDA/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h3 id="线性判别分析LDA原理总结"><a href="#线性判别分析LDA原理总结" class="headerlink" title="线性判别分析LDA原理总结"></a><center>线性判别分析LDA原理总结</center></h3><p>　　　　线性判别分析（Linear Discriminant Analysis, 以下简称LDA）,一种经典的降维方法。LDA在模式识别领域（比如人脸识别，舰艇识别等图形图像识别领域）中有非常广泛的应用，因此我们有必要了解下它的算法原理。</p>
<p>　　　　在学习LDA之前，有必要将其自然语言处理领域的LDA区别开来，在自然语言处理领域， LDA是隐含狄利克雷分布（Latent Dirichlet Allocation，简称LDA），他是一种处理文档的主题模型。我们本文只讨论线性判别分析，因此后面所有的LDA均指线性判别分析。</p>
<ol>
<li>LDA的思想</li>
</ol>
<p>　　　　LDA是一种监督学习的降维技术，也就是说它的数据集的每个样本是有类别输出的。这点和PCA不同。PCA是不考虑样本类别输出的无监督降维技术。LDA的思想可以用一句话概括，就是“投影后类内方差最小，类间方差最大”。什么意思呢？ 我们要将数据在低维度上进行投影，投影后希望每一种类别数据的投影点尽可能的接近，而不同类别的数据的类别中心之间的距离尽可能的大。</p>
<center><br><img src="http://oq5d32gij.bkt.clouddn.com/14958087329231.jpg" alt=""><br></center>

<p>　　　　可能还是有点抽象，我们先看看最简单的情况。假设我们有两类数据 分别为红色和蓝色，如下图所示，这些数据特征是二维的，我们希望将这些数据投影到一维的一条直线，让每一种类别数据的投影点尽可能的接近，而红色和蓝色数据中心之间的距离尽可能的大。</p>
<p>　　　　上图中提供了两种投影方式，哪一种能更好的满足我们的标准呢？从直观上可以看出，右图要比左图的投影效果好，因为右图的黑色数据和蓝色数据各个较为集中，且类别之间的距离明显。左图则在边界处数据混杂。以上就是LDA的主要思想了，当然在实际应用中，我们的数据是多个类别的，我们的原始数据一般也是超过二维的，投影后的也一般不是直线，而是一个低维的超平面。</p>
<p>　　　　在我们将上面直观的内容转化为可以度量的问题之前，我们先了解些必要的数学基础知识，这些在后面讲解具体LDA原理时会用到。</p>
<ol>
<li>瑞利商（Rayleigh quotient）与广义瑞利商（genralized Rayleigh quotient）<br>   我们首先来看看瑞利商的定义。瑞利商是指这样的函数$R(A,x)$:<br>$$R(A,x)=\frac{x^HAx}{x^Hx}$$<br>　　　　其中x为非零向量，而A为n×n的Hermitan矩阵。所谓的Hermitan矩阵就是满足共轭转置矩阵和自己相等的矩阵，即$A^H=A$。如果我们的矩阵A是实矩阵，则满足$A^H=A$的矩阵即为Hermitan矩阵。</li>
</ol>
<p>　　　　瑞利商$R(A,x)$有一个非常重要的性质，即它的最大值等于矩阵A最大的特征值，而最小值等于矩阵A的最小的特征值，也就是满足<br>$$\lambda_{min}≤\frac{x^HAx}{x^Hx}≤\lambda_{max}$$<br>　　　　具体的证明这里就不给出了。当向量x是标准正交基时，即满足$x^Hx=1$时，瑞利商退化为：$R(A,x)=x^HAx$，这个形式在谱聚类和PCA中都有出现。</p>
<p>　　　　以上就是瑞利商的内容，现在我们再看看广义瑞利商。广义瑞利商是指这样的函数$R(A,B,x)$:<br>$$R(A,x)=\frac{x^HAx}{x^HBx}$$<br>　　　　其中x为非零向量，而A,B为n×n的Hermitan矩阵。B为正定矩阵。它的最大值和最小值是什么呢？其实我们只要通过将其通过标准化就可以转化为瑞利商的格式。我们令$x′=B^{−1/2}x$,则分母转化为：<br>$$x^HBx=x′^H(B^{−1/2})^HBB^{−1/2}x′=x′^HB^{−1/2}BB^{−1/2}x′=x′^Hx′$$<br>　　　　而分子转化为：<br>$$x^HAx=x′^HB^{−1/2}AB^{−1/2}x′$$<br>　　　　此时我们的$R(A,B,x)$转化为$R(A,B,x′)$:<br>$$R(A,B,x′)=\frac{x′^HB^{−1/2}AB^{−1/2}x′}{x′^Hx′}$$<br>　　　　利用前面的瑞利商的性质，我们可以很快的知道，$R(A,B,x)$的最大值为矩阵$B^{−1/2}AB^{−1/2}$的最大特征值，或者说矩阵$B^{−1}A$的最大特征值，而最小值为矩阵$B^{−1}A$的最小特征值。这里使用了一个的技巧，即对矩阵进行标准化。</p>
<ol>
<li>二类LDA原理</li>
</ol>
<p>　　　　现在我们回到LDA的原理上，我们在第一节说讲到了LDA希望投影后希望同一种类别数据的投影点尽可能的接近，而不同类别的数据的类别中心之间的距离尽可能的大，但是这只是一个感官的度量。现在我们首先从比较简单的二类LDA入手，严谨的分析LDA的原理。</p>
<p>　　　　假设我们的数据集$D={(x_1,y_1),(x_2,y_2),\cdots,((x_m,y_m))}$,其中任意样本$x_i$为n维向量，$y_i\in{0,1}$。我们定义$N_j(j=0,1)$为第j类样本的个数，$X_j(j=0,1)$为第j类样本的集合，而$μ_j(j=0,1)$为第j类样本的均值向量，定义$Σ_j(j=0,1)$为第j类样本的协方差矩阵。</p>
<p>　　　　$μ_j$的表达式为：<br>$$μ_j=\frac{1}{N_j}\sum_{x\in{X_j}}x(j=0,1)$$<br>　　　　$∑_j$的表达式为：<br>$$∑_j=\sum_{x\in{Xj}}(x−μ_j)(x−μ_j)^T(j=0,1)$$<br>　　　　由于是两类数据，因此我们只需要将数据投影到一条直线上即可。假设我们的投影直线是向量w,则对任意一个样本本$x_i$,它在直线w的投影为$w^Tx_i$,对于我们的两个类别的中心点$μ_0,μ_1$,在在直线w的投影为$w^Tμ_0$和$w^Tμ_1$。由于LDA需要让不同类别的数据的类别中心之间的距离尽可能的大，也就是我们要最大化$||w^Tμ_0−w^Tμ_1||^2_2$,同时我们希望同一种类别数据的投影点尽可能的接近，也就是要同类样本投影点的协方差$w^T\sum_0w$和$w^T\sum_1w$尽可能的小，即最小化$w^T\sum_0w+w^T\sum_1w$。综上所述，我们的优化目标为：<br>$$\underbrace{arg\ max}_w\ J(w)=\frac{||w^Tμ_0−w^Tμ_1||^2_2}{w^T\sum_0w+w^T\sum_1w}=\frac{w^T(μ_0−μ_1)(μ_0−μ_1)^Tw}{w^T(\sum_0+\sum_1)w}$$<br>　　　　我们一般定义类内散度矩阵$S_w$为：<br>$$S_w=∑_0+∑_1=\sum_{x\in{X0}}(x−μ0)(x−μ0)^T+\sum_{x\in{X1}}(x−μ1)(x−μ1)^T$$<br>　　　　同时定义类间散度矩阵$S_b$为：<br>$$S_b=(μ_0−μ_1)(μ_0−μ_1)^T$$<br>　　　　这样我们的优化目标重写为：<br>$$\underbrace{arg\ max}_w\ J(w)=\frac{w^TS_bw}{w^TS_ww}$$<br>　　　　仔细一看上式，这不就是我们的广义瑞利商嘛！这就简单了，利用我们第二节讲到的广义瑞利商的性质，我们知道我们的$J(w)$最大值为矩阵$S^{−1}_wS_b$的最大特征值，而对应的$w$为$S^{−1}_wS_b$的最大特征值对应的特征向量!</p>
<p>　　　　注意到对于二类的时候，$S_bw$的方向恒为$μ_0−μ_1$,不妨令$S_bw=\lambda (μ_0−μ_1)$，将其带入：$(S^{−1}_wS_b)w=λw$，可以得到$w=S^{−1}_w(μ_0−μ_1)$， 也就是说我们只要求出原始二类样本的均值和方差就可以确定最佳的投影方向$w$了。</p>
<ol>
<li>多类LDA原理</li>
</ol>
<p>　　　　有了二类LDA的基础，我们再来看看多类别LDA的原理。</p>
<p>　　　　假设我们的数据集$D={(x_1,y_1),(x_2,y_2),\cdots,((x_m,y_m))}$,其中任意样本$x_i$为n维向量，$y_i\in{C_1,C_2,\cdots,C_k}$。我们定义$N_j(j=1,2\cdots k)$为第j类样本的个数，$X_j(j=1,2\cdots k)$为第j类样本的集合，而$μ_j(j=1,2\cdots k)$为第j类样本的均值向量，定义$Σ_j(j=1,2\cdots k)$为第j类样本的协方差矩阵。在二类LDA里面定义的公式可以很容易的类推到多类LDA。</p>
<p>　　　　由于我们是多类向低维投影，则此时投影到的低维空间就不是一条直线，而是一个超平面了。假设我们投影到的低维空间的维度为d，对应的基向量为$(w_1,w_2,\cdots w_d)$，基向量组成的矩阵为$W$, 它是一个$m×d$的矩阵。</p>
<p>　　　　此时我们的优化目标应该可以变成为:<br>$$\frac{W^TS_bW}{W^TS_wW}$$<br>　　　　其中$Sb=\sum_{j=1}^kN_j(μ_j−μ)(μ_j−μ)^T$,μ为所有样本均值向量。$S_w=\sum_{j=1}^kS_{wj}=\sum_{j=1}^k\sum_{x\in{X_j}}(x−μ_j)(x−μ_j)^T$<br>　　　　但是有一个问题，就是$W^TS_bW$和$W^TS_wW$都是矩阵，不是标量，无法作为一个标量函数来优化！也就是说，我们无法直接用二类LDA的优化方法，怎么办呢？一般来说，我们可以用其他的一些替代优化目标来实现。</p>
<p>　　　　常见的一个LDA多类优化目标函数定义为：<br>$$\underbrace{arg\ max}_W\ J(W)=\frac{\prod_{diag}W^TS_bW}{\prod_{diag}W^TS_wW}$$<br>　　　　其中$\prod_{diag}A$为A的主对角线元素的乘积，$W$为$m×d$的矩阵。</p>
<p> 　　　　$J(W)$的优化过程可以转化为：<br>$$J(W)=\frac{\prod_{i=1}^dw^T_iS_bw_i}{\prod_{i=1}^dw^T_iS_ww_i}=\prod_{i=1}^d\frac{w^T_iS_bw_i}{w^T_iS_ww_i}$$<br>　　　　仔细观察上式最右边，这不就是广义瑞利商嘛！最大值是矩阵$S^{−1}_wS_b$的最大特征值,最大的d个值的乘积就是矩阵$S^{−1}_wS_b$的最大的d个特征值的乘积,此时对应的矩阵$W$为这最大的d个特征值对应的特征向量张成的矩阵。</p>
<p>　　　　由于W是一个利用了样本的类别得到的投影矩阵，因此它的降维到的维度d最大值为k-1。为什么最大维度不是类别数k呢？因为$S_b$中每个$μ_j−μ$的秩为1，因此协方差矩阵相加后最大的秩为k(矩阵的秩小于等于各个相加矩阵的秩的和)，但是由于如果我们知道前k-1个$μ_j$后，最后一个$μ_k$可以由前k-1个$μ_j$线性表示，因此$S_b$的秩最大为k-1，即特征向量最多有k-1个。</p>
<ol>
<li>LDA算法流程</li>
</ol>
<p>　　　　在第三节和第四节我们讲述了LDA的原理，现在我们对LDA降维的流程做一个总结。</p>
<p>　　　　输入：数据集$D={(x_1,y_1),(x_2,y_2),\cdots,((x_m,y_m))}$,其中任意样本$x_i$为n维向量，$y_i\in{C_1,C_2,\cdots,C_k}$，降维到的维度d。</p>
<p>　　　　输出：降维后的样本集 $D′$</p>
<p>　　　　1) 计算类内散度矩阵$S_w$</p>
<p>　　　　2) 计算类间散度矩阵$S_b$</p>
<p>　　　　3) 计算矩阵$S^{−1}_wS_b$</p>
<p>　　　　4）计算$S^{−1}_wS_b$的最大的d个特征值和对应的d个特征向量$(w_1,w_2,\cdots w_d)$,得到投影矩阵$W$</p>
<p>　　　　5) 对样本集中的每一个样本特征$x_i$,转化为新的样本$z_i=W^Tx_i$<br>　　　　6) 得到输出样本集$D′={(z_1,y_1),(z_2,y_2),\cdots,((z_m,y_m))}$</p>
<p>　　　　以上就是使用LDA进行降维的算法流程。实际上LDA除了可以用于降维以外，还可以用于分类。一个常见的LDA分类基本思想是假设各个类别的样本数据符合高斯分布，这样利用LDA进行投影后，可以利用极大似然估计计算各个类别投影数据的均值和方差，进而得到该类别高斯分布的概率密度函数。当一个新的样本到来后，我们可以将它投影，然后将投影后的样本特征分别带入各个类别的高斯分布概率密度函数，计算它属于这个类别的概率，最大的概率对应的类别即为预测类别。</p>
<p>　　　　由于LDA应用于分类现在似乎也不是那么流行，这里我就不多讲了。</p>
<ol>
<li>LDA vs PCA</li>
</ol>
<p>　　　　LDA用于降维，和PCA有很多相同，也有很多不同的地方，因此值得好好的比较一下两者的降维异同点。</p>
<p>　　　　首先我们看看相同点：</p>
<p>　　　　1）两者均可以对数据进行降维。</p>
<p>　　　　2）两者在降维时均使用了矩阵特征分解的思想。</p>
<p>　　　　3）两者都假设数据符合高斯分布。</p>
<p>　　　　我们接着看看不同点：</p>
<p>　　　　1）LDA是有监督的降维方法，而PCA是无监督的降维方法</p>
<p>　　　　2）LDA降维最多降到类别数k-1的维数，而PCA没有这个限制。</p>
<p>　　　　3）LDA除了可以用于降维，还可以用于分类。</p>
<p>　　　　4）LDA选择分类性能最好的投影方向，而PCA选择样本点投影具有最大方差的方向。</p>
<p>　　　　这点可以从下图形象的看出，在某些数据分布下LDA比PCA降维较优。
　　　　</p>
<center><br><img src="http://oq5d32gij.bkt.clouddn.com/14958087681939.jpg" alt=""><br></center>

<p>　　　　当然，某些某些数据分布下PCA比LDA降维较优，如下图所示：
　　　　</p>
<center><br><img src="http://oq5d32gij.bkt.clouddn.com/14958087756706.jpg" alt=""><br></center>

<ol>
<li>LDA算法小结</li>
</ol>
<p>　　　　LDA算法既可以用来降维，又可以用来分类，但是目前来说，主要还是用于降维。在我们进行图像识别图像识别相关的数据分析时，LDA是一个有力的工具。下面总结下LDA算法的优缺点。</p>
<p>　　　　LDA算法的主要优点有：</p>
<p>　　　　1）在降维过程中可以使用类别的先验知识经验，而像PCA这样的无监督学习则无法使用类别先验知识。</p>
<p>　　　　2）LDA在样本分类信息依赖均值而不是方差的时候，比PCA之类的算法较优。</p>
<p>　　　　LDA算法的主要缺点有：</p>
<p>　　　　1）LDA不适合对非高斯分布样本进行降维，PCA也有这个问题。</p>
<p>　　　　2）LDA降维最多降到类别数k-1的维数，如果我们降维的维度大于k-1，则不能使用LDA。当然目前有一些LDA的进化版算法可以绕过这个问题。</p>
<p>　　　　3）LDA在样本分类信息依赖方差而不是均值的时候，降维效果不好。</p>
<p>　　　　4）LDA可能过度拟合数据。</p>
]]></content>
      
        <categories>
            
            <category> machine learning </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LDA </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS UICollectionView自定义cell]]></title>
      <url>/2017/05/19/iOS/uicell/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p>自定义的UITableCell<br><a id="more"></a></p>
<pre class=" language-mm"><code class="language-mm">//
//  jokeCell.m
//  MyLaugh
//
//  Created by wangyu on 14/05/2017.
//  Copyright © 2017 wangyu. All rights reserved.
//

#import "jokeCell.h"
#define SCREEN_WIDTH [UIScreen mainScreen].bounds.size.width

@implementation jokeCell
{
    UILabel *_titleLabel;
    UILabel *_contentLabel;
    UILabel *_updatetimeLabel;
}

-(instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier
{
    self = [super initWithStyle:style reuseIdentifier:reuseIdentifier];
    _titleLabel = [[UILabel alloc]initWithFrame:CGRectMake(0,5,SCREEN_WIDTH,21)];
    _titleLabel.backgroundColor = [UIColor clearColor];
    _titleLabel.textAlignment = NSTextAlignmentCenter;
    _titleLabel.textColor = [UIColor purpleColor];
    _titleLabel.font = [UIFont italicSystemFontOfSize:17];
    _contentLabel = [[UILabel alloc]initWithFrame:CGRectMake(0, 30, SCREEN_WIDTH, 21)];
    _contentLabel.backgroundColor = [UIColor clearColor];
    _contentLabel.numberOfLines = 0;
    _updatetimeLabel = [[UILabel alloc]initWithFrame:CGRectMake(0, 30, SCREEN_WIDTH, 21)];
    _updatetimeLabel.textAlignment = NSTextAlignmentRight;
    self.selectionStyle = UITableViewCellSelectionStyleNone;
    return self;
}


- (void)layoutSubviews{
    [super layoutSubviews];
    [self.contentView addSubview:_titleLabel];
    [self.contentView addSubview:_contentLabel];
    [self.contentView addSubview:_updatetimeLabel];
}

-(void) setTitle:(NSString *)title
{
    _title = title;
    _titleLabel.text = title;
}

-(void) setContent:(NSString *)content
{
    _content = content;
    _contentLabel.text = content;
}

-(void)setUpdatetime:(NSString *)updatetime
{
    _updatetime = updatetime;
    _updatetimeLabel.text = updatetime;
}

-(void) setContentLabelHeight:(CGFloat)height
{
    _contentLabel.frame = CGRectMake(0, 30, _contentLabel.frame.size.width, height);
    _updatetimeLabel.frame = CGRectMake(0, 35+height, _updatetimeLabel.frame.size.width, 21);
}

-(CGFloat) getHeight
{
    //计算文字高度
    NSDictionary *attribute = @{NSFontAttributeName: _contentLabel.font};
    CGSize retSize = [_contentLabel.text boundingRectWithSize:CGSizeMake(SCREEN_WIDTH, MAXFLOAT) options:NSStringDrawingTruncatesLastVisibleLine|NSStringDrawingUsesLineFragmentOrigin|NSStringDrawingUsesFontLeading attributes:attribute context:nil].size;
    _contentLabel.frame = CGRectMake(0, 30, _contentLabel.frame.size.width, retSize.height);
    _updatetimeLabel.frame = CGRectMake(0, 35+_contentLabel.frame.size.height, _updatetimeLabel.frame.size.width, 21);
    return 30+_contentLabel.frame.size.height+10+21+5;
}

- (void)awakeFromNib {
    [super awakeFromNib];
    // Initialization code
}

- (void)setSelected:(BOOL)selected animated:(BOOL)animated {
    [super setSelected:selected animated:animated];

    // Configure the view for the selected state
}

@end
</code></pre>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ios </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MathJax]]></title>
      <url>/2017/05/18/machine-learning/math/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p>对LaTex基本用法的学习<br><a id="more"></a><br>$$T = \{(\vec{x_1},y_1),((\vec{x_2},y_2),\cdots,(\vec{x_N},y_N)\},\vec{x_i} $$</p>
<h2 id="常用数学符号的-LaTeX-表示方法"><a href="#常用数学符号的-LaTeX-表示方法" class="headerlink" title="常用数学符号的 LaTeX 表示方法"></a>常用数学符号的 LaTeX 表示方法</h2><p>１、指数和下标可以用 ^ 和 _ 后加相应字符来实现。比如：</p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/foot.gif" alt="foot"></p>
<p>2、平方根（square root）的输入命令为：\sqrt，n 次方根相应地为: \sqrt[n]。方根符号的大小由LATEX自动加以调整。也可用\surd 仅给出<br>符号。比如：</p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/sqrt.gif" alt="sqrt"></p>
<p>3、命令\overline 和\underline 在表达式的上、下方画出水平线。比如：</p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/overline.gif" alt="overline"></p>
<p>4、命令\overbrace 和\underbrace 在表达式的上、下方给出一水平的大括号。</p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/brace.gif" alt="brace"></p>
<p>5、向量（Vectors）通常用上方有小箭头（arrow symbols）的变量表示。这可由\vec 得到。另两个命令\overrightarrow 和\overleftarrow在定义从A 到B 的向量时非常有用。</p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/vec.gif" alt="ve"></p>
<p>6、分数（fraction）使用\frac{…}{…} 排版。一般来说，1/2 这种形式更受欢迎，因为对于少量的分式，它看起来更好些。</p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/frac.gif" alt="fra"></p>
<p>7、积分运算符（integral operator）用\int 来生成。求和运算符（sum operator）由\sum 生成。乘积运算符（product operator）由\prod 生成。上限和下限用^ 和_来生成，类似于上标和下标。</p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/int.gif" alt="int"></p>
<p>###以下提供一些常用符号的表示方法</p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/1.gif" alt="1"></p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/2.gif" alt="2"></p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/3.gif" alt="3"></p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/4.gif" alt="4"></p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/5.gif" alt="5"></p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/6.gif" alt="6"></p>
<p><img src="http://oq5d32gij.bkt.clouddn.com/7.gif" alt="7"></p>
<p>大家都喜欢用 $E=mc^2$ 举例子，但是我不是很理解。  </p>
<p>这个公式 $\cos 2\theta = \cos^2 \theta - \sin^2 \theta =  2 \cos^2 \theta - 1$ 少年可还记得？</p>
<p>插入方程组（注意多行公式结尾\\\需要打成\\\，可能是因为markdown会自动转义第一个\\）：</p>
<p>\begin{aligned}<br>\dot{x} &amp; = \sigma(y-x) \\\<br>\dot{y} &amp; = \rho x - y - xz \\\<br>\dot{z} &amp; = -\beta z + xy<br>\end{aligned}</p>
<p>插入矩阵（同上）：</p>
<p>\begin{bmatrix}<br>1 &amp; 2\\\<br>3 &amp; 4<br>\end{bmatrix}</p>
<p>来个复杂点的（注意有的公式开头不会自动识别，用$ $包围）：</p>
<p>$$\frac{\partial u}{\partial t}= h^2\left( \frac{\partial^2u}{\partial x^2}+ \frac{\partial^2 u}{\partial y^2}+\frac{\partial^2 u}{\partial z^2}\right)$$</p>
<p>最后来个牛逼的吧，薛定谔方程，大学物理就记得这个了：</p>
<p>$$ i\hbar\frac{\partial \psi}{\partial t}= \frac{-\hbar^2}{2m} \left(\frac{\partial^2}{\partial x^2}+ \frac{\partial^2}{\partial y^2}+ \frac{\partial^2}{\partial z^2}\right) \psi + V \psi.$$</p>
<p>$$\begin{cases}\int\Omega \nabla \mathbf{F}&amp;=\int\Gamma \mathbf{F}\cdot d\mathbf{S} \<br>u&amp;=g_0,\quad \Gamma_D \<br>\partial_n u&amp;=g_1 ,\quad \Gamma_N<br>\end{cases} $$</p>
<p>$$\underbrace{a+b+\cdots+z}_{26}$$</p>
]]></content>
      
        <categories>
            
            <category> machine learning </category>
            
        </categories>
        
        
        <tags>
            
            <tag> math </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
